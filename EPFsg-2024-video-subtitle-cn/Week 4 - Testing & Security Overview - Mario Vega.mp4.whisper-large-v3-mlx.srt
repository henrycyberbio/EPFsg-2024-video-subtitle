1
00:01:30,000 --> 00:01:59,980
©BF-Watch TV 2021

2
00:02:00,000 --> 00:02:29,979
©BF-Watch TV 2021

3
00:03:30,000 --> 00:03:59,979
谢谢。

4
00:04:00,000 --> 00:04:29,980
谢谢。

5
00:04:30,000 --> 00:04:59,980
谢谢。

6
00:05:00,000 --> 00:05:29,980
谢谢。

7
00:05:30,000 --> 00:05:34,000
大家好。希望你能听到我的声音。

8
00:05:34,000 --> 00:05:38,000
我是...

9
00:05:38,000 --> 00:05:42,000
我今天没有相机，所以

10
00:05:42,000 --> 00:05:46,000
让我知道是否仍然...是的，谢谢。所以，

11
00:05:46,000 --> 00:05:50,000
欢迎来到我们EPF的第四周

12
00:05:50,000 --> 00:05:54,000
研究小组。之后

13
00:05:54,000 --> 00:05:58,000
涵盖介绍，执行，共识层，

14
00:05:58,000 --> 00:06:04,000
现在，我们将深入研究我们讨论的所有这些实际测试和确保。

15
00:06:04,699 --> 00:06:06,540
这很重要。

16
00:06:07,100 --> 00:06:11,199
对于许多人来说，测试听起来像是奇怪的。

17
00:06:11,480 --> 00:06:13,339
就像，我们为什么要关心它？

18
00:06:13,360 --> 00:06:14,660
就像发展的一部分一样。

19
00:06:14,879 --> 00:06:17,540
但这实际上是整个以太坊中最重要的部分之一。

20
00:06:17,959 --> 00:06:20,699
我会说，就像我们之前讨论的主题一样重要。

21
00:06:20,819 --> 00:06:25,899
因为，正如我们所说，这是阻止整个网络腹部浮出水的原因。

22
00:06:25,899 --> 00:06:33,159
在本周的谈判中，我们获得了讨论此主题的最佳人选。

23
00:06:33,339 --> 00:06:45,399
我相信，是EF测试和安全团队的我们的同事Mario Vega，我相信自2021年秋天以来一直在努力进行测试。

24
00:06:46,039 --> 00:06:47,779
合并前一年。

25
00:06:47,779 --> 00:06:56,500
在第一年，他对许多测试基础设施进行了大修，这有助于合并实际发生。

26
00:06:57,079 --> 00:07:04,259
直到今天，他还是所有升级和努力工作等所有测试的主要力量之一。

27
00:07:04,759 --> 00:07:08,619
所以，是的，我今天很高兴今天在这里有Mario。

28
00:07:09,000 --> 00:07:10,519
你能听到我吗？

29
00:07:14,699 --> 00:07:15,919
好吧，你们能听到我的声音吗？

30
00:07:16,359 --> 00:07:17,139
是啊是啊。

31
00:07:17,339 --> 00:07:17,759
一切都很好。

32
00:07:17,779 --> 00:07:23,179
是的。非常感谢您加入。您可以在Harrison按钮中共享幻灯片。

33
00:07:23,179 --> 00:07:25,899
只给我一秒钟。

34
00:07:25,899 --> 00:07:36,299
是的，对于每个人都在听，现在加入的每个人，请使用研究组的第四周

35
00:07:36,299 --> 00:07:44,399
不和谐。我们刚刚为本周的演讲打开了线程。因此，您可以在那里提出问题。

36
00:07:44,399 --> 00:07:50,799
在谈话期间随时询问任何事情，我们将尝试将其回答

37
00:07:50,799 --> 00:07:57,519
在线程中，否则我们将直接询问Mario。是的。

38
00:08:02,719 --> 00:08:07,519
我们得到了幻灯片。惊人的。那起作用吗？看起来不错吗？

39
00:08:07,519 --> 00:08:11,759
是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。是的。

40
00:08:11,759 --> 00:08:15,539
您只需单击幻灯片，如果您要寻找的话。

41
00:08:15,779 --> 00:08:16,159
在右侧。

42
00:08:16,899 --> 00:08:18,519
你去。

43
00:08:18,519 --> 00:08:19,180
是的，那个。

44
00:08:19,279 --> 00:08:19,680
你去。

45
00:08:20,120 --> 00:08:21,019
太感谢了。

46
00:08:21,639 --> 00:08:22,379
这是你的。

47
00:08:22,639 --> 00:08:22,959
前进。

48
00:08:23,159 --> 00:08:23,519
完美的。

49
00:08:24,219 --> 00:08:25,019
所以，是的。

50
00:08:25,060 --> 00:08:26,060
感谢您的演讲。

51
00:08:26,920 --> 00:08:27,899
我叫马里奥。

52
00:08:28,219 --> 00:08:28,639
马里奥·维加（Mario Vega）。

53
00:08:28,800 --> 00:08:29,899
我来自EF。

54
00:08:30,060 --> 00:08:33,419
我在EF测试团队中工作。

55
00:08:33,419 --> 00:08:45,879
我主要专注于开发测试和功能，主要是以太坊用来实际工作正常工作的整个测试设置的功能测试部分。

56
00:08:47,000 --> 00:08:55,199
因此，我将在EF中的某些同伴做的事情上进行一些挖掘。

57
00:08:55,899 --> 00:09:01,599
还主要测试安全性，还可以限制其中的一点点。

58
00:09:01,600 --> 00:09:11,399
是的，让我们开始。因此，今天的主题我将介绍如何完成执行层测试？

59
00:09:12,120 --> 00:09:18,540
主要是EVM测试，这是链条共识的非常重要的部分。

60
00:09:18,879 --> 00:09:27,779
我们有两个主要存储库。一个是以太坊测试，另一个是我们刚开始进行的新测试。

61
00:09:27,779 --> 00:09:30,220
称为以太坊执行规格测试。

62
00:09:31,360 --> 00:09:33,100
我们将涵盖其中的一点点。

63
00:09:33,199 --> 00:09:35,459
我也会做一些演示

64
00:09:35,459 --> 00:09:37,939
关于如何运行这些测试，

65
00:09:38,159 --> 00:09:40,500
他们的工作方式和内在工作。

66
00:09:42,179 --> 00:09:43,919
这将是非常非常好的。

67
00:09:45,120 --> 00:09:47,079
我要掩盖一点

68
00:09:47,079 --> 00:09:48,139
共识层测试，

69
00:09:48,620 --> 00:09:51,539
主要是以太坊共识规范，

70
00:09:51,759 --> 00:09:54,220
这是基本上所有事情的回购。

71
00:09:54,220 --> 00:10:01,259
这是用于此规范的一种解决方案，测试都在一个内部覆盖

72
00:10:01,259 --> 00:10:07,100
这个存储库我将要仔细研究一下，不是最细节，因为

73
00:10:07,100 --> 00:10:15,060
这不是我们目前工作的主要领域，我的意思是EF团队和测试团队

74
00:10:15,060 --> 00:10:21,519
我将要进行一些跨层中断测试，这是一个非常

75
00:10:21,519 --> 00:10:26,319
现在重要的部分是我们有两个层，即执行层和共识层部分。

76
00:10:27,699 --> 00:10:34,559
和团队，测试团队主要在Hive上工作。但是我们也有

77
00:10:34,559 --> 00:10:40,939
Devnet，ChildWorks和Testnet，这是DevOps团队的工作。我们要去

78
00:10:40,939 --> 00:10:45,439
覆盖其中的一点。但是我们将在Hive上更深入一些，这是

79
00:10:45,440 --> 00:10:50,080
我最合作的那个。

80
00:10:50,260 --> 00:10:53,560
而且我们也将在其中做一些演示

81
00:10:53,620 --> 00:10:55,780
如何运行测试，如何工作，

82
00:10:55,860 --> 00:10:57,140
内在的工作和所有这些东西。

83
00:10:57,200 --> 00:11:00,080
最后，一点点安全，

84
00:11:01,100 --> 00:11:03,260
潜在的问题是什么，

85
00:11:03,820 --> 00:11:06,020
什么是奖励。

86
00:11:06,280 --> 00:11:10,500
如果你们正在寻找安全问题，

87
00:11:10,500 --> 00:11:19,700
如果您正确披露并发现任何与安全有关的问题，您可以赚钱。

88
00:11:19,700 --> 00:11:22,779
那将是我们今天所涵盖的。

89
00:11:23,500 --> 00:11:31,440
以及在解决任何安全实例后如何公开披露您的测试。

90
00:11:33,500 --> 00:11:38,139
所以，是的，我们将从EVM测试开始，

91
00:11:38,139 --> 00:11:42,759
这是，我不会说最简单。

92
00:11:42,960 --> 00:11:48,319
它非常复杂，但是设置最直接。

93
00:11:49,899 --> 00:11:56,059
EVM测试，主要目的基本上只是为了验证

94
00:11:56,059 --> 00:11:59,879
每个以太坊执行客户端都遵守此规范。

95
00:12:00,460 --> 00:12:04,460
这非常重要，因为不遵守规范

96
00:12:04,460 --> 00:12:07,060
意味着积极的叉子

97
00:12:07,060 --> 00:12:08,280
在链中

98
00:12:08,280 --> 00:12:09,860
如果没有共识

99
00:12:09,860 --> 00:12:13,220
关于执行的内容

100
00:12:13,220 --> 00:12:14,660
通过所有交易。

101
00:12:17,560 --> 00:12:19,639
设置超级简单

102
00:12:19,639 --> 00:12:20,680
用于事件测试。

103
00:12:20,780 --> 00:12:21,420
基本上，你有

104
00:12:21,420 --> 00:12:23,379
相同的输入

105
00:12:23,379 --> 00:12:25,100
对于每个客户

106
00:12:25,100 --> 00:12:26,639
而且您必须注册

107
00:12:26,639 --> 00:12:28,100
每个客户

108
00:12:28,100 --> 00:12:30,180
获得相同的确切输出

109
00:12:30,180 --> 00:12:32,200
给定相同的环境

110
00:12:32,379 --> 00:12:32,700
预状态，

111
00:12:32,900 --> 00:12:34,400
和硬叉激活。

112
00:12:34,460 --> 00:12:38,120
我们将在一点上进行。

113
00:12:42,820 --> 00:12:46,220
是的，我想掩盖这个重要的

114
00:12:46,220 --> 00:12:47,780
测试的特征，

115
00:12:47,780 --> 00:12:49,940
因为这些就像最大的

116
00:12:49,940 --> 00:12:53,639
我们最关注的事情

117
00:12:53,639 --> 00:12:56,420
在为ABM编写测试时。

118
00:12:56,420 --> 00:12:59,759
第一个是预状态。

119
00:13:01,820 --> 00:13:03,580
我会回去一点。

120
00:13:03,580 --> 00:13:07,259
因此，只需解释一下这是如何组成的即可。

121
00:13:07,460 --> 00:13:12,180
因此，以太坊区块链包含状态。

122
00:13:12,379 --> 00:13:16,060
总的来说，这就是一切生活的地方。

123
00:13:16,259 --> 00:13:18,420
包括以太坊区块链的所有内容。

124
00:13:18,620 --> 00:13:20,460
它生活在州。

125
00:13:20,660 --> 00:13:25,139
其中包含智能合约，余额，nonce，

126
00:13:25,340 --> 00:13:30,259
智能合约的代码，最重要的是

127
00:13:30,259 --> 00:13:31,900
智能合约的存储。

128
00:13:31,900 --> 00:13:33,540
因此，每个智能合约。

129
00:13:33,580 --> 00:13:36,900
至少包含代码和存储。

130
00:13:36,900 --> 00:13:40,660
这是一个非常重要的部分，因为当您撰写智能合约时

131
00:13:41,100 --> 00:13:47,520
通常，您想保存一些将保留的信息。

132
00:13:48,280 --> 00:13:52,520
即使在您启动智能合约的第一个交易之后，

133
00:13:52,940 --> 00:13:57,520
在下一个交易中，您将需要访问上一份的信息。

134
00:13:57,840 --> 00:13:58,580
所以这是存储。

135
00:13:58,700 --> 00:14:00,900
这是区块链的非常重要的部分。

136
00:14:00,899 --> 00:14:11,519
当我们设置EVM测试时，这就像测试中最关键的部分。

137
00:14:11,759 --> 00:14:17,259
例如，因为我们没有测试整个主网，因为它很大。

138
00:14:17,779 --> 00:14:23,220
您现在在Mainnet中拥有的东西，您拥有具有疯狂存储空间的合同。

139
00:14:23,220 --> 00:14:27,720
他们将使用的大量关键值。

140
00:14:27,720 --> 00:14:36,700
例如，uniswap，他们使用大量存储存储每个用户的存储

141
00:14:36,800 --> 00:14:39,340
每个令牌的平衡等等。

142
00:14:39,899 --> 00:14:47,920
但是对于最简单的测试，因此通常，当我们编写EVM测试时，我们通常只是

143
00:14:47,920 --> 00:14:52,840
想专注于EVM执行的一小部分。

144
00:14:53,360 --> 00:14:55,399
因此，我们生成了一个预状态。

145
00:14:55,399 --> 00:15:01,659
在执行任何交易之前，我们肯定会知道的是预期的。

146
00:15:03,120 --> 00:15:04,399
这很重要。

147
00:15:04,699 --> 00:15:08,879
我将在以下幻灯片中进一步解释。

148
00:15:10,819 --> 00:15:11,480
但这是肯定的。

149
00:15:11,899 --> 00:15:12,759
是的。

150
00:15:13,939 --> 00:15:17,899
另一个重要的部分是环境。

151
00:15:17,899 --> 00:15:21,899
因此，当您运行交易时，

152
00:15:21,899 --> 00:15:31,679
首先，您在区块链中的交易被更多的交易所包围，但也是一个块。

153
00:15:32,100 --> 00:15:37,579
该块包含许多可能影响交易结果的信息。

154
00:15:38,360 --> 00:15:44,000
例如，您可以阅读您当前执行的块的时间戳。

155
00:15:44,000 --> 00:15:51,200
或者是来自共识层的偏好，并给您一些

156
00:15:51,200 --> 00:15:58,340
伪随机性作为您合同的输入也是块号，例如非常重要

157
00:15:58,340 --> 00:16:05,960
您还可以获取以前的块缓存，例如，如果您想，总的气体限制

158
00:16:05,960 --> 00:16:12,519
您的测试执行多少，您将设置一个越来越多的气体限制，我们有一些测试

159
00:16:12,519 --> 00:16:16,919
我们将这种气体撞到很大的地方

160
00:16:16,919 --> 00:16:19,120
只是因为我们想检查

161
00:16:19,120 --> 00:16:23,679
例如，如果任何合同需要太长执行。

162
00:16:24,279 --> 00:16:25,679
以及基本费用，

163
00:16:25,879 --> 00:16:28,019
因为基本费用非常重要

164
00:16:28,019 --> 00:16:32,139
因为即使您不执行某件事

165
00:16:32,139 --> 00:16:37,360
需要大量交易费用，

166
00:16:37,639 --> 00:16:38,819
您仍然想确保

167
00:16:38,820 --> 00:16:42,920
每个客户都需要基本费用

168
00:16:42,920 --> 00:16:46,340
并计算每笔交易的正确费用

169
00:16:46,340 --> 00:16:47,800
您正在测试。

170
00:16:48,680 --> 00:16:50,080
另外，硬叉激活时间。

171
00:16:50,240 --> 00:16:52,900
这也非常重要，因为当我们进行测试时

172
00:16:52,900 --> 00:16:58,040
对于新叉，最常见的设置方案

173
00:16:58,040 --> 00:17:01,420
是我们建立了一个环境

174
00:17:01,420 --> 00:17:03,800
叉将被激活的地方

175
00:17:03,800 --> 00:17:07,180
将来在某些最终区块。

176
00:17:08,819 --> 00:17:12,119
这在其中，我将举一个非常非常具体的例子。

177
00:17:12,279 --> 00:17:17,460
例如，对于斑点，您不应该运行Blob Transactions

178
00:17:17,460 --> 00:17:20,939
在激活坎昆叉之前。

179
00:17:21,279 --> 00:17:28,200
因此，在此特定测试的环境中，我们将来设置了一个叉子激活时间。

180
00:17:28,359 --> 00:17:30,279
然后我们发送交易，例如。

181
00:17:30,379 --> 00:17:35,279
然后我们验证包含此交易的块正确拒绝

182
00:17:35,279 --> 00:17:37,259
执行客户端。

183
00:17:38,819 --> 00:17:50,159
这只是一个小例子，但是有很多方法可以通过这些变量测试许多有趣的组合和激活方案。

184
00:17:50,579 --> 00:17:57,119
这就是为什么环境对于准备测试非常重要的原因。

185
00:17:58,720 --> 00:18:01,000
第三个是交易。

186
00:18:01,299 --> 00:18:04,000
这基本上是最重要的。

187
00:18:04,000 --> 00:18:09,240
而且，如果您没有正在测试的交易，那么基本上您将不会执行任何操作。

188
00:18:09,660 --> 00:18:14,779
智能合约的每个执行都始于交易。

189
00:18:15,259 --> 00:18:20,039
因此，这是我们编写的测试中非常重要的部分。

190
00:18:20,880 --> 00:18:31,839
最有可能的是，当您撰写测试时，您将交易发送到智能合约，您知道它将执行一些重要的代码。

191
00:18:31,839 --> 00:18:37,899
您永远不会像交易一样发送只是为了将以太从一个帐户发送到另一个帐户

192
00:18:37,899 --> 00:18:44,159
因为没有什么有趣的事情发生了，但是是的，您将在

193
00:18:44,159 --> 00:18:48,980
预状态和您将要建立一项有趣的交易的环境

194
00:18:48,980 --> 00:18:53,359
您执行此交易将在区块链中引起有趣的东西

195
00:18:53,359 --> 00:19:00,539
这就是您的测试的工作方式，我说交易和交易，因为我们有

196
00:19:00,539 --> 00:19:05,339
不同种类的测试。我要详细介绍一些细节，但基本上我们可以拥有

197
00:19:07,259 --> 00:19:12,779
测试只有一笔交易对我们来说很有趣，这是测试非常具体的EVM

198
00:19:12,779 --> 00:19:21,659
链中的执行。而且我们还进行了多项交易的测试，等于

199
00:19:21,659 --> 00:19:27,259
块充满了许多交易。这是我们要测试完整区块链的时候

200
00:19:27,259 --> 00:19:36,460
功能。最后但重要的是邮政状态。当我们设计测试时

201
00:19:37,180 --> 00:19:43,819
非常重要的是，在您设置了预定的环境交易之后，您也很重要

202
00:19:43,819 --> 00:19:50,220
想确切地知道您期望在区块链帐户中发生什么。

203
00:19:50,779 --> 00:19:54,619
因此，例如，如果您设置了智能合约，并且该智能合约应

204
00:19:54,619 --> 00:20:00,399
将一些内容写入智能合约的存储中，您期望从零到一个零，

205
00:20:00,699 --> 00:20:05,819
然后，这是您将其放入邮政的地方。帖子包含

206
00:20:05,819 --> 00:20:09,799
您正在使用交易来调用的有趣帐户的所有列表。

207
00:20:10,359 --> 00:20:16,719
以及交易后，您要检查的所有有趣的存储值

208
00:20:16,719 --> 00:20:22,939
执行。非常重要。确切地知道要寻找什么也很重要。

209
00:20:22,940 --> 00:20:25,500
当您编写测试时，您不是

210
00:20:25,500 --> 00:20:27,500
编写良好的测试，除非

211
00:20:27,500 --> 00:20:29,640
您真的知道结果应该是什么。

212
00:20:31,539 --> 00:20:32,019
和

213
00:20:32,019 --> 00:20:33,720
这是

214
00:20:33,720 --> 00:20:34,900
设置和

215
00:20:34,900 --> 00:20:37,779
基本上，验证在

216
00:20:37,779 --> 00:20:38,799
执行测试。

217
00:20:39,700 --> 00:20:41,539
我会进一步

218
00:20:41,539 --> 00:20:43,059
有关如何的详细信息

219
00:20:43,059 --> 00:20:45,799
我们使用所有这些输入

220
00:20:45,799 --> 00:20:47,620
生成测试

221
00:20:47,620 --> 00:20:49,580
以及我们如何验证

222
00:20:49,580 --> 00:20:50,700
客户有一点。

223
00:20:52,940 --> 00:20:56,259
我不知道，马里奥，如果您到目前为止有任何疑问。

224
00:20:57,759 --> 00:21:00,019
如果没有，我可以继续。

225
00:21:04,900 --> 00:21:05,420
是的。

226
00:21:05,660 --> 00:21:05,940
好的。

227
00:21:06,900 --> 00:21:12,559
因此，所有这些输入我们都在EVM测试中，

228
00:21:12,840 --> 00:21:16,600
除非我们有什么可以执行它们，否则它们是毫无意义的。

229
00:21:17,340 --> 00:21:19,820
因此，这是一个称为测试填充的过程。

230
00:21:20,100 --> 00:21:22,640
因此，一旦我们写了所有的意见，

231
00:21:22,640 --> 00:21:25,960
我们有要执行的状态。

232
00:21:26,540 --> 00:21:31,340
我们拥有具有正确代码和要执行的所有内容的智能合约。

233
00:21:31,460 --> 00:21:40,980
我们仍然必须以某种方式应用状态过渡，这是您将预状态和交易转换为邮政的时刻。

234
00:21:41,820 --> 00:21:46,240
这是一个以许多不同方式完成的过程。

235
00:21:46,240 --> 00:21:49,480
但这很重要，因为

236
00:21:49,480 --> 00:21:53,640
当我们有测试时

237
00:21:53,640 --> 00:21:55,079
我们有测试源代码

238
00:21:55,079 --> 00:21:58,000
用json或python写的

239
00:21:58,000 --> 00:22:00,759
取决于您正在使用的存储库

240
00:22:00,759 --> 00:22:05,220
但是输出将永远是

241
00:22:05,220 --> 00:22:06,440
JSON输出

242
00:22:06,440 --> 00:22:07,799
那就是我们使用的

243
00:22:07,799 --> 00:22:11,779
每个客户都将消耗

244
00:22:11,779 --> 00:22:15,599
这是一个称为测试填充的过程

245
00:22:15,599 --> 00:22:24,899
将测试设计定义转换为每个客户中实际消耗和可验证的东西的过程。

246
00:22:25,980 --> 00:22:27,359
非常重要的过程。

247
00:22:27,779 --> 00:22:34,199
我将在以下幻灯片中解释一下它的专门完成方式，我们如何做。

248
00:22:34,539 --> 00:22:35,119
是的。

249
00:22:36,019 --> 00:22:36,740
是的。

250
00:22:36,899 --> 00:22:38,839
另外，更重要。

251
00:22:38,839 --> 00:22:49,539
而且，填充过程与所有客户执行的单元测试非常不同。

252
00:22:49,899 --> 00:22:54,000
每个代码都可以进行自己的单元测试。

253
00:22:54,819 --> 00:22:58,139
当您开发软件时，这是一种非常普遍的做法。

254
00:22:58,959 --> 00:23:06,439
以太坊客户确实使用单元测试来测试执行客户端和共识客户。

255
00:23:06,440 --> 00:23:15,500
但是，我们填充的测试固定装置的重要质量是，这可以由

256
00:23:15,500 --> 00:23:20,720
任何客户。因此，我们一次生成一个测试，然后可以在所有客户端执行它

257
00:23:20,720 --> 00:23:27,580
并验证它们之间没有任何差异。这很重要

258
00:23:27,580 --> 00:23:34,160
共识运行。如果我们依靠每个客户的编写单元测试，

259
00:23:34,160 --> 00:23:36,620
单位测试肯定会有所不同。

260
00:23:37,340 --> 00:23:39,940
因此，当我们填写测试并创建固定装置时，

261
00:23:40,580 --> 00:23:45,140
这也意味着我们确定执行客户端

262
00:23:45,140 --> 00:23:46,880
正在消耗完全相同的测试。

263
00:23:47,660 --> 00:23:48,900
这对于共识非常重要。

264
00:23:53,100 --> 00:23:53,660
好的。

265
00:23:55,420 --> 00:23:58,620
所以，是的，让我看看。

266
00:23:59,759 --> 00:24:00,019
是的。

267
00:24:00,660 --> 00:24:01,300
好的。

268
00:24:01,299 --> 00:24:13,779
因此，这是一个小图，它仅显示了我们如何进行单州测试的要点

269
00:24:17,059 --> 00:24:23,299
用于EVM测试。我们从我已经描述的是预状态开始。

270
00:24:23,299 --> 00:24:28,019
您拥有所有智能合约，所有余额，代码和所需的存储

271
00:24:28,019 --> 00:24:30,920
为了测试。

272
00:24:30,920 --> 00:24:33,759
您将其与一次交易结合在一起，

273
00:24:34,480 --> 00:24:36,940
有帐户源，

274
00:24:38,059 --> 00:24:39,359
帐户目的地，

275
00:24:39,980 --> 00:24:43,579
某些值可能为零或其他值

276
00:24:44,220 --> 00:24:45,680
一些气体和一些数据。

277
00:24:46,960 --> 00:24:48,139
当您结合在一起时，

278
00:24:48,440 --> 00:24:50,440
您将获得发布日期，

279
00:24:50,740 --> 00:24:54,240
这可能是创建新的智能合约，

280
00:24:54,859 --> 00:24:55,859
一些修改的余额，

281
00:24:55,859 --> 00:24:57,619
如此新的或修改后。

282
00:24:58,019 --> 00:24:59,439
好吧，不是修改的代码。

283
00:24:59,539 --> 00:25:01,259
新代码或修改。

284
00:25:02,939 --> 00:25:04,099
是的，这是不正确的。

285
00:25:04,459 --> 00:25:05,379
未修改的代码。

286
00:25:05,479 --> 00:25:05,839
这是不可能的。

287
00:25:06,439 --> 00:25:08,479
新代码或修改的存储。

288
00:25:08,579 --> 00:25:09,119
是的，就是这样。

289
00:25:11,839 --> 00:25:14,259
和自我毁灭以及所有这些东西。

290
00:25:14,579 --> 00:25:16,519
您可以拥有一切。

291
00:25:16,659 --> 00:25:19,500
重要的是，在预状态下，

292
00:25:20,459 --> 00:25:24,299
您必须建立智能合同

293
00:25:24,299 --> 00:25:27,319
这会执行一些有趣的事情。

294
00:25:28,899 --> 00:25:31,000
那将是目的地

295
00:25:31,000 --> 00:25:31,859
您的交易。

296
00:25:32,019 --> 00:25:33,879
否则，它不会执行任何有意义的事情

297
00:25:33,879 --> 00:25:35,359
而且您并没有真正测试任何东西。

298
00:25:36,519 --> 00:25:38,200
另外，交易，例如

299
00:25:38,379 --> 00:25:43,079
如果可能的目的地

300
00:25:43,079 --> 00:25:46,000
交易不是明智的合同

301
00:25:46,180 --> 00:25:47,680
但是创建智能合约，

302
00:25:47,759 --> 00:25:48,599
这也是可能的。

303
00:25:49,240 --> 00:25:52,440
然后您投入此交易的数据

304
00:25:52,440 --> 00:25:55,680
以初始代码的方式执行。

305
00:25:56,000 --> 00:25:56,940
所以这也很有趣。

306
00:25:57,140 --> 00:26:02,019
因此，如果您可以放一些有趣的初始代码，

307
00:26:02,559 --> 00:26:04,720
这是另一种测试方式

308
00:26:04,720 --> 00:26:07,480
您的智能合约是以正确的方式创建的。

309
00:26:08,140 --> 00:26:10,440
还有修改的余额，

310
00:26:10,660 --> 00:26:13,019
新创建的代码在这里也非常重要，

311
00:26:13,240 --> 00:26:14,759
以及必要时修改的存储。

312
00:26:15,940 --> 00:26:20,039
最重要的是，我们使用所谓的舞台路线

313
00:26:20,039 --> 00:26:20,980
进行此验证。

314
00:26:20,980 --> 00:26:28,700
正如我们之前解释的那样，状态根是包含智能合约的国家。

315
00:26:29,579 --> 00:26:38,019
但是根类似于这种加密计算，该计算将状态的所有内容提交并牢固地归入一个数字。

316
00:26:38,259 --> 00:26:41,960
这是一个很大的数字，基本上是32个字节。

317
00:26:42,240 --> 00:26:49,400
这两个不同的状态很难将其投入相同的数字。

318
00:26:49,400 --> 00:26:51,800
这就是使区块链安全的原因。

319
00:26:52,880 --> 00:27:04,240
因此，鉴于此前提条件，我们可以假设，如果两个执行客户端，您给他们相同的预状态，相同的交易，

320
00:27:04,820 --> 00:27:10,960
您还可以知道，您期望结束时有相同的状态根差。

321
00:27:10,960 --> 00:27:19,100
因此，如果您比较两个执行客户端，并且它们为您提供了两个不同的状态根，则意味着其中一个或一个测试，也可能是不正确的。

322
00:27:19,400 --> 00:27:29,180
这就是这是最简单的测试方式。

323
00:27:29,180 --> 00:27:33,920
我们也有一个模糊的差分测试。

324
00:27:33,920 --> 00:27:35,220
非常相似。

325
00:27:35,220 --> 00:27:43,100
主要区别在于，我们有一个称为fuzzyevm的工具

326
00:27:43,100 --> 00:27:46,759
由Goethereum客户的开发人员之一。

327
00:27:46,759 --> 00:28:08,779
而且，这种工作的方式是，我们设计的智能合约不是我们旨在按执行客户端达到某些特定代码路径的已知智能合约，而是在这种情况下，烦恼却妨碍了代码所包含的内容。

328
00:28:08,779 --> 00:28:18,339
因此，您将代码插入锁中，进入链条的预设。

329
00:28:18,559 --> 00:28:26,899
然后，您创建了一个特别是目的地的交易，是该代码，是固定的智能合约。

330
00:28:28,200 --> 00:28:35,799
然后，由于我们不知道该合同的结果是什么，因为它已被弄脏，所以

331
00:28:35,799 --> 00:28:40,720
它将具有非常随机或随机的行为。

332
00:28:41,099 --> 00:28:44,039
您可能会设置您不希望设置的存储空间。

333
00:28:44,440 --> 00:28:48,519
我们验证这种测试的方式是我们通过州路线

334
00:28:48,519 --> 00:28:52,539
我们将其比较不同的客户。

335
00:28:53,339 --> 00:28:57,319
因此，如果我们有相同的智能合约，则相同的交易，

336
00:28:57,319 --> 00:29:01,099
同一预状态，我们得到了不同的州路线

337
00:29:01,099 --> 00:29:04,619
在两个不同的EVM客户端

338
00:29:04,619 --> 00:29:06,599
这意味着有一个错误。

339
00:29:06,599 --> 00:29:07,979
有问题。

340
00:29:07,979 --> 00:29:10,379
然后您可以验证并确切查看

341
00:29:11,759 --> 00:29:15,199
通过检查执行的痕迹

342
00:29:15,199 --> 00:29:17,199
确切知道发生了什么。

343
00:29:17,199 --> 00:29:20,500
然后您可以这样找到一个盒子。

344
00:29:25,139 --> 00:29:25,979
是的。

345
00:29:25,979 --> 00:29:29,579
而且我们还进行了区块链测试。

346
00:29:29,579 --> 00:29:33,899
所以以前的是基于

347
00:29:33,900 --> 00:29:39,980
我们有一个预状态，我们有一项交易，并且我们有一个非常具体的执行将要发生。

348
00:29:41,040 --> 00:29:47,920
但是我们也可以进行完整的块测试，这意味着您也有预状态，

349
00:29:48,240 --> 00:29:50,700
这是智能合约，平衡，代码和存储等等。

350
00:29:51,180 --> 00:29:57,280
然后，您将它们置于将要实例化区块链实例化的创世纪。

351
00:29:57,780 --> 00:30:03,480
然后，您开始喂食块，每个块都有交易，也是标题值。

352
00:30:03,480 --> 00:30:06,460
还有更多可以压缩一个块的信息。

353
00:30:06,819 --> 00:30:09,200
然后您开始喂食整个块

354
00:30:09,200 --> 00:30:10,740
进入执行客户端。

355
00:30:11,680 --> 00:30:15,360
然后，您希望在一个或两个或多个块之后，

356
00:30:15,980 --> 00:30:17,460
您期望客户，

357
00:30:18,680 --> 00:30:21,539
如果您的验证结果

358
00:30:21,539 --> 00:30:25,860
是您进食测试的每个块，

359
00:30:25,860 --> 00:30:28,779
您在测试中设计的应该是正确的，

360
00:30:29,079 --> 00:30:32,200
那么期望是执行客户端

361
00:30:32,200 --> 00:30:34,600
消耗所有这些块

362
00:30:34,600 --> 00:30:39,299
然后您检查链头

363
00:30:39,299 --> 00:30:40,400
执行客户端

364
00:30:40,740 --> 00:30:43,019
您必须在这里找到块

365
00:30:43,019 --> 00:30:44,340
您期望的是。

366
00:30:45,100 --> 00:30:46,500
如果出于某种原因，

367
00:30:47,039 --> 00:30:48,920
假设在此图中，

368
00:30:50,000 --> 00:30:52,480
第二块被认为是无效的

369
00:30:52,480 --> 00:30:54,519
由一个执行客户之一

370
00:30:54,519 --> 00:30:57,100
因为他们在某处的检查有故障。

371
00:30:57,799 --> 00:30:59,519
这意味着连锁头

372
00:30:59,519 --> 00:31:01,140
不会对应于第二个块。

373
00:31:01,140 --> 00:31:02,840
然后您会遇到错误。

374
00:31:04,980 --> 00:31:12,720
这非常重要，因为并非我们检查执行客户端的所有内容都是EVM执行的一部分。

375
00:31:13,100 --> 00:31:18,880
我们还检查了执行先前块的其他值。

376
00:31:19,140 --> 00:31:22,900
例如，1559年，这是基本费用。

377
00:31:23,320 --> 00:31:25,860
您有块的基本费用。

378
00:31:25,860 --> 00:31:31,100
这是根据上一个块的先前交易来计算的。

379
00:31:31,140 --> 00:31:43,480
因此，如果某些客户计算为50-59，则基本费用，例如，您将在此处的某个地方获得拒绝。

380
00:31:43,700 --> 00:31:49,000
然后，您的链头将与测试的最后一个块不匹配。

381
00:31:49,360 --> 00:31:52,660
然后，您会发现一个错误。

382
00:31:53,740 --> 00:31:59,920
然后，您还可以检查球状态，新的智能合约，修改后的余额，新代码，修改后的存储以及所有内容。

383
00:31:59,920 --> 00:32:01,720
您检查一切都到位

384
00:32:01,720 --> 00:32:06,640
因为即使在正确消耗所有块之后

385
00:32:06,640 --> 00:32:09,120
到末端块

386
00:32:09,120 --> 00:32:11,600
您仍然可以在某个地方有一些错误

387
00:32:11,600 --> 00:32:14,759
出于某种原因存储的地方

388
00:32:14,759 --> 00:32:19,140
无法从执行行正确响应

389
00:32:19,140 --> 00:32:21,440
那是非常...

390
00:32:21,440 --> 00:32:24,600
这不是很常见

391
00:32:24,600 --> 00:32:26,779
因为通常在检查链头时

392
00:32:26,779 --> 00:32:28,860
您还检查了状态根

393
00:32:28,859 --> 00:32:31,959
这意味着描述性承诺

394
00:32:31,959 --> 00:32:33,139
我们之前谈到了。

395
00:32:34,000 --> 00:32:36,299
这意味着您的存储空间正确。

396
00:32:36,459 --> 00:32:40,199
因此，这些检查只是理智检查，额外的检查。

397
00:32:40,819 --> 00:32:44,419
但是，是的，基本要旨是所有块被消耗了

398
00:32:44,419 --> 00:32:45,639
因为客户是正确的。

399
00:32:50,119 --> 00:32:50,679
是的。

400
00:32:50,680 --> 00:32:59,640
而且我们还有其他检查方式，

401
00:32:59,799 --> 00:33:06,120
这是您在某个时候使用一个无效的块设计测试。

402
00:33:07,440 --> 00:33:11,440
例如，让我们再次以1559的例子为例

403
00:33:11,440 --> 00:33:17,900
假设您故意提出了无效的价值

404
00:33:17,900 --> 00:33:20,560
进入一个块的基本费用。

405
00:33:21,019 --> 00:33:24,200
然后，将该块馈送给客户。

406
00:33:24,600 --> 00:33:28,680
然后，您希望客户拒绝此块。

407
00:33:29,480 --> 00:33:32,540
因此，将会发生的是块被拒绝。

408
00:33:32,880 --> 00:33:33,480
那是一张支票。

409
00:33:33,980 --> 00:33:36,780
然后，您回到客户，然后说，

410
00:33:36,880 --> 00:33:40,680
好吧，我给你的最后一个区块是什么？

411
00:33:41,500 --> 00:33:42,560
那是正确的。

412
00:33:43,019 --> 00:33:44,320
然后，您再次检查

413
00:33:44,400 --> 00:33:45,820
因为在这种情况下，它是第二个块。

414
00:33:45,940 --> 00:33:46,920
那是最后一个街区。

415
00:33:46,920 --> 00:33:49,700
然后，您检查帖子和所有内容。

416
00:33:51,380 --> 00:33:57,680
帖子变得很重要，因为如果您喂养一个无效的块，

417
00:33:57,779 --> 00:34:06,400
您希望邮政或居住在客户中的合同不属于无效块。

418
00:34:06,539 --> 00:34:09,740
因此，在这种情况下，此检查实际上更为重要。

419
00:34:09,739 --> 00:34:17,139
确切了解客户是如何失败也是非常重要的。

420
00:34:18,339 --> 00:34:27,859
当您设计这些负面测试之一时，这是非常重要的

421
00:34:27,859 --> 00:34:31,439
当然，没有其他方法可以失败。

422
00:34:31,440 --> 00:34:56,000
因此，例如，再次，如果您要设计1559的测试，并且想在基本费用中放置一个无效的值，但是您忘记了使用此修改后的值更新块舱口，这意味着客户仍将继续使用正确拒绝您的块。

423
00:34:56,000 --> 00:35:00,139
但不是因为您修改了基本费用价值

424
00:35:00,139 --> 00:35:02,300
而是由于块哈希。

425
00:35:02,699 --> 00:35:04,360
这是一个无效的测试

426
00:35:04,360 --> 00:35:07,500
因为您没有确定其他每个领域

427
00:35:07,500 --> 00:35:10,519
您正在测试的是正确的。

428
00:35:11,280 --> 00:35:15,300
因此，这在说考试时非常重要

429
00:35:15,300 --> 00:35:17,480
而且您必须始终确保。

430
00:35:17,480 --> 00:35:22,440
这很容易在这里滑入

431
00:35:22,440 --> 00:35:24,599
写测试

432
00:35:24,599 --> 00:35:27,699
然后，您认为自己正确编写了测试。

433
00:35:27,839 --> 00:35:31,860
然后稍后意识到，好吧，我没有更改。

434
00:35:32,059 --> 00:35:34,339
客户正在通过测试。

435
00:35:34,579 --> 00:35:38,619
但是我没有发现的地方有一个错误。

436
00:35:38,960 --> 00:35:41,179
因为客户仍然拒绝了块。

437
00:35:41,319 --> 00:35:44,259
因为我的块没有正确设计。

438
00:35:44,500 --> 00:35:45,980
我的测试未正确设计。

439
00:35:49,119 --> 00:35:49,639
是的。

440
00:35:49,639 --> 00:35:52,799
好的。

441
00:35:52,799 --> 00:35:56,779
到目前为止有任何问题吗？

442
00:35:56,779 --> 00:36:00,739
正在进行讨论。

443
00:36:00,739 --> 00:36:05,079
伙计们，如果您想问一个问题，我会给您一秒钟。

444
00:36:05,079 --> 00:36:06,920
但是否则很清楚。

445
00:36:06,920 --> 00:36:07,920
非常感谢，马里奥。

446
00:36:07,920 --> 00:36:08,920
这很棒。

447
00:36:08,920 --> 00:36:17,000
人们只是在讨论我能回答的一些事情。

448
00:36:17,000 --> 00:36:19,480
是的，我想我们稍后会提出问题。

449
00:36:21,019 --> 00:36:21,460
好吧。

450
00:36:22,139 --> 00:36:22,340
好吧。

451
00:36:23,179 --> 00:36:23,500
凉爽的。

452
00:36:27,340 --> 00:36:27,940
好的。

453
00:36:28,420 --> 00:36:32,699
因此，现在要进行测试的实际测试填充部分。

454
00:36:33,360 --> 00:36:38,519
我们将从拥有的第一个存储库开始。

455
00:36:39,179 --> 00:36:44,159
这是自以太坊成立以来就已经存在的以太坊测试库。

456
00:36:45,539 --> 00:36:46,840
大约九年前。

457
00:36:47,000 --> 00:36:56,820
这是以太坊社区生产的第一个测试框架。

458
00:36:57,380 --> 00:37:07,179
基本上，测试的源文件是简单的JSON文件或YAML，这是源代码。

459
00:37:07,179 --> 00:37:13,940
这是您设计预状态的部分

460
00:37:14,159 --> 00:37:16,159
您的存储，代码，智能合约，

461
00:37:16,259 --> 00:37:17,219
你放在那里的一切。

462
00:37:17,219 --> 00:37:22,940
这一切都进入了JSON文件或YAML文件。

463
00:37:23,839 --> 00:37:26,440
它提供非常简单的参数化

464
00:37:26,440 --> 00:37:30,639
从某种意义上说，您可以设置多个交易

465
00:37:30,639 --> 00:37:33,179
在同一预状态的顶部进行操作。

466
00:37:33,679 --> 00:37:36,500
然后您期望有不同的结果

467
00:37:36,500 --> 00:37:44,340
取决于交易。然后，您还可以以紧凑的JSON格式检查所有内容。

468
00:37:45,380 --> 00:37:53,940
这些测试以C ++编写。对不起。测试填充剂称为重新测试。

469
00:37:53,940 --> 00:38:05,539
它用C ++编写。重新测试基本上是您的JSON输入。你有

470
00:38:05,539 --> 00:38:13,779
对其进行重新测试，然后将其调用重新测试，然后消耗json，它实际上会通过

471
00:38:13,779 --> 00:38:19,119
要填写测试，然后在最后您有一个固定装置，每个客户都可以消费

472
00:38:19,119 --> 00:38:25,019
然后，您可以在任何一个客户中检查UH是否无效

473
00:38:25,019 --> 00:38:33,719
我们有更新的执行规范测试。

474
00:38:33,800 --> 00:38:37,860
这是在去年刚刚开发的

475
00:38:37,860 --> 00:38:40,280
还有前一年。

476
00:38:41,159 --> 00:38:44,199
主要区别在于我们具有Python源代码。

477
00:38:44,759 --> 00:38:47,400
因此，测试的来源，

478
00:38:47,639 --> 00:38:49,900
这是您定义预状态和所有内容的地方。

479
00:38:50,380 --> 00:38:51,300
这一切都在Python中。

480
00:38:51,300 --> 00:38:55,900
它提供了简单至复杂的参数化

481
00:38:55,900 --> 00:38:57,760
因为它是由pytest驱动的。

482
00:38:58,440 --> 00:39:00,500
因此，我们拥有所有的pytest工具

483
00:39:00,500 --> 00:39:04,000
为进行不同的参数化

484
00:39:04,000 --> 00:39:04,800
不同的测试。

485
00:39:05,820 --> 00:39:08,380
这允许很大的灵活性

486
00:39:08,380 --> 00:39:14,580
而且仅写单个输入非常有效

487
00:39:14,580 --> 00:39:17,300
然后，您只需传递很多参数，

488
00:39:17,980 --> 00:39:20,240
参数化的许多值。

489
00:39:20,239 --> 00:39:27,119
它将为您产生大量测试。真的很方便。它真的可以得到

490
00:39:27,119 --> 00:39:34,079
复杂的。因此，我们仍在定义。我们仍在定义多少复杂性

491
00:39:34,079 --> 00:39:46,239
我们希望测试是吗？因此，这是一个非常不错的框架。不利的一面是，

492
00:39:46,239 --> 00:39:57,099
还进行了重新测试，由于过渡功能，这也需要实际的客户端实现能够填写测试。

493
00:39:57,099 --> 00:39:59,699
这只是

494
00:39:59,699 --> 00:40:01,619
因为我们没有过渡功能

495
00:40:01,619 --> 00:40:03,860
到目前为止在Python实施

496
00:40:03,860 --> 00:40:05,559
但是有一个

497
00:40:05,559 --> 00:40:06,799
正在进行的工作

498
00:40:06,799 --> 00:40:09,819
整个Python

499
00:40:09,819 --> 00:40:11,619
规格

500
00:40:12,159 --> 00:40:13,860
书面

501
00:40:13,860 --> 00:40:15,719
在脚本中

502
00:40:15,719 --> 00:40:17,460
所谓的收益率是定理执行

503
00:40:17,460 --> 00:40:19,619
执行

504
00:40:19,619 --> 00:40:20,139
以后规格

505
00:40:20,139 --> 00:40:23,059
这将来会

506
00:40:23,059 --> 00:40:25,500
被用来服务

507
00:40:25,500 --> 00:40:26,900
作为实际客户实施

508
00:40:26,900 --> 00:40:28,920
但不是今天。

509
00:40:32,880 --> 00:40:33,440
好的。

510
00:40:33,800 --> 00:40:37,000
这些是内在的工作

511
00:40:37,000 --> 00:40:39,119
执行规格测试的方式。

512
00:40:39,180 --> 00:40:40,059
这很相似

513
00:40:40,059 --> 00:40:43,700
在重新测试和执行规格测试中。

514
00:40:44,180 --> 00:40:47,700
所以我要去这一点

515
00:40:47,700 --> 00:40:49,800
关于它在内部的工作方式。

516
00:40:49,980 --> 00:40:51,400
实际上很简单。

517
00:40:52,019 --> 00:40:53,400
这是框架。

518
00:40:53,660 --> 00:40:55,500
正如我之前说的

519
00:40:55,500 --> 00:40:58,539
它从一些Python测试开始。

520
00:41:00,480 --> 00:41:04,059
此测试，您可以为每个EIP创建一个

521
00:41:04,059 --> 00:41:06,980
或几个EIP。

522
00:41:07,079 --> 00:41:10,960
例如，您也可以为许多叉子写许多。

523
00:41:12,380 --> 00:41:14,039
我们现在的工作方式

524
00:41:14,039 --> 00:41:16,380
是我们有不同的文件夹

525
00:41:16,380 --> 00:41:20,860
我们的Python测试居住的地方，每个叉子都一个。

526
00:41:21,019 --> 00:41:22,800
因此，例如，我们从Frontier开始

527
00:41:22,800 --> 00:41:25,239
然后我们一直到坎昆。

528
00:41:25,500 --> 00:41:30,500
目前，Cancun包含所有4844个测试，

529
00:41:31,159 --> 00:41:34,139
所有信标根合同测试和所有内容。

530
00:41:34,139 --> 00:41:36,920
所有这些都组织得很好。

531
00:41:36,920 --> 00:41:40,260
这是我真正喜欢的新存储库。

532
00:41:40,260 --> 00:41:42,780
然后您就开始了。

533
00:41:42,780 --> 00:41:45,119
您从Python测试开始

534
00:41:45,119 --> 00:41:48,340
您写所有的预期，交易的地方。

535
00:41:48,340 --> 00:41:51,099
你实际上喜欢

536
00:41:51,099 --> 00:41:55,920
因此，我已经写了参数化和所有内容。

537
00:41:55,920 --> 00:42:01,920
然后，当您执行此操作时，执行此操作，使用的是填充命令

538
00:42:01,920 --> 00:42:05,400
我们有这个存储库。

539
00:42:05,400 --> 00:42:09,920
您将填充命令指定为目前要执行的测试。

540
00:42:09,920 --> 00:42:13,699
然后它将进入，执行Python代码。

541
00:42:13,699 --> 00:42:16,699
重要的是它具有两个依赖性。

542
00:42:16,699 --> 00:42:17,699
好吧，三个。

543
00:42:17,699 --> 00:42:19,500
底部有点不重要，

544
00:42:19,599 --> 00:42:21,219
但是顶部的两个是

545
00:42:21,899 --> 00:42:23,699
尤其是最重要的非常重要。

546
00:42:24,199 --> 00:42:25,439
因此，当您填写测试时

547
00:42:25,439 --> 00:42:28,500
然后你要指出

548
00:42:28,500 --> 00:42:30,259
您想执行交易的地方，

549
00:42:30,619 --> 00:42:32,219
但是你不知道该怎么做

550
00:42:32,219 --> 00:42:33,159
因为您正在运行Python。

551
00:42:33,259 --> 00:42:35,119
您没有实际的逻辑

552
00:42:35,119 --> 00:42:37,079
执行客户端。

553
00:42:37,239 --> 00:42:39,779
你要做的是产卵

554
00:42:39,779 --> 00:42:42,079
这个Goethereum子命令，

555
00:42:42,819 --> 00:42:43,759
这就是EVM。

556
00:42:44,199 --> 00:42:47,299
然后EVM过渡实际上是

557
00:42:47,300 --> 00:42:54,500
EVM TA 10。您给出的命令只是所有预州和交易

558
00:42:54,500 --> 00:43:00,900
和环境。然后它将吐出执行的结果，

559
00:43:01,539 --> 00:43:04,740
包括执行您提供的每笔交易。

560
00:43:06,660 --> 00:43:12,820
这很重要，因为这是一个来回的过程，填充测试。如果有

561
00:43:12,820 --> 00:43:20,340
一个执行10个块的单个测试，您将10次调用此EVM过渡工具。

562
00:43:24,019 --> 00:43:33,380
这非常有效。不是...但是我们有更多的解决方案使它更加

563
00:43:33,380 --> 00:43:41,380
高效的。因为我们基本上每次测试都会致电一次，两次或三次。所以它变得很

564
00:43:41,380 --> 00:43:51,059
消耗，CPU消耗。我们拥有的第二个依赖性是坚固。这就是

565
00:43:51,619 --> 00:43:58,660
少了，因为我们在框架内的大多数测试我们都有每个操作代码

566
00:43:58,660 --> 00:44:06,900
EVM具有。因此，您实际上不需要写坚固。坚固是一种极好的

567
00:44:06,900 --> 00:44:13,840
写智能合约的语言。但是我们的问题是我们通常必须专注于

568
00:44:13,840 --> 00:44:22,840
我们正在测试的单一操作码。因此，在坚固性对我们的一切方面有一定的优化

569
00:44:22,840 --> 00:44:28,260
期望在符合智能合约的字节码中看到，这不是很好。因为

570
00:44:28,260 --> 00:44:36,420
如果它优化了一些非常重要的操作码，我们在填充时实际上正在测试

571
00:44:36,420 --> 00:44:40,440
测试将使测试不可靠。根本不去

572
00:44:40,440 --> 00:44:44,500
工作是因为您要测试的OPODE不存在。它没有执行。

573
00:44:44,840 --> 00:44:48,280
没关系。所以我们只使用

574
00:44:48,280 --> 00:44:52,400
当我们有非常复杂的代码时，坚固性

575
00:44:52,400 --> 00:44:56,300
我们不能处理字节码写作。事实并非如此

576
00:44:56,300 --> 00:45:00,300
实际上字节码写作。我将在源代码中显示一个示例

577
00:45:00,300 --> 00:45:03,780
有点让你们看看如何

578
00:45:03,780 --> 00:45:05,120
我们如何写这个。

579
00:45:05,680 --> 00:45:08,600
但是，是的，我们越来越少地使用它。

580
00:45:09,760 --> 00:45:13,460
我们也有另一个输入是EIPS，

581
00:45:14,160 --> 00:45:15,540
存储库实际上。

582
00:45:17,519 --> 00:45:21,060
这是规范的主要来源

583
00:45:21,060 --> 00:45:22,720
我们用来编写测试。

584
00:45:23,380 --> 00:45:25,640
因此，每当我们写测试时，

585
00:45:25,780 --> 00:45:28,680
我们不去Goethereum的代码。

586
00:45:28,800 --> 00:45:29,920
我们去规格。

587
00:45:30,700 --> 00:45:33,360
由此，我们取出了测试用例。

588
00:45:33,780 --> 00:45:36,380
实际上，我们从规格中写下它们。

589
00:45:36,380 --> 00:45:42,880
因此，保留EIP的想法非常重要

590
00:45:42,880 --> 00:45:48,300
在此测试的源代码中。

591
00:45:48,300 --> 00:45:52,500
我们在这里这样做的方式是我们也...

592
00:45:52,500 --> 00:45:55,220
好吧，一个是测试仪，测试作者。

593
00:45:55,220 --> 00:45:58,900
他们正在进入EIP，并且正在复制

594
00:45:58,900 --> 00:46:02,380
或带来或任何公式，

595
00:46:02,380 --> 00:46:04,539
无论在那里描述什么。

596
00:46:04,539 --> 00:46:07,500
但他们还带来了校验和

597
00:46:07,500 --> 00:46:08,940
和EIP的版本。

598
00:46:09,800 --> 00:46:10,860
这很重要

599
00:46:10,860 --> 00:46:15,220
因为在任何叉子的开发过程中，

600
00:46:15,220 --> 00:46:19,880
EIP不时改变确实很常见。

601
00:46:19,880 --> 00:46:23,039
因此，这就像我们使用的安全措施

602
00:46:23,039 --> 00:46:24,500
为了确保，好的，

603
00:46:24,500 --> 00:46:28,180
我们从EIP中汲取了这些逻辑或信息

604
00:46:28,179 --> 00:46:30,399
或来自AP的想法。

605
00:46:30,399 --> 00:46:34,339
我们确定我们正在研究这个最新版本吗？

606
00:46:34,339 --> 00:46:36,699
因为那时EIP改变了

607
00:46:36,699 --> 00:46:38,859
然后执行客户端去

608
00:46:38,859 --> 00:46:40,579
并实现较新的版本

609
00:46:40,579 --> 00:46:42,940
我们的测试开始失败

610
00:46:42,940 --> 00:46:46,079
他们来找我们说，你写了什么？

611
00:46:46,079 --> 00:46:50,639
然后，我们有一个证明我们为EIP撰写的证据，

612
00:46:50,639 --> 00:46:52,119
但是在以前的版本中。

613
00:46:52,119 --> 00:46:55,179
因此，该过程只是去更新

614
00:46:55,179 --> 00:46:56,019
对于最新版本，

615
00:46:56,019 --> 00:46:57,539
但是然后我们在这里有故障。

616
00:46:58,179 --> 00:47:01,679
只是为了确保我们正在为AP的某些版本编写。

617
00:47:03,599 --> 00:47:04,119
是的。

618
00:47:04,259 --> 00:47:08,859
执行填充命令后，我们将获得输出。

619
00:47:09,279 --> 00:47:10,899
这是重要的部分。

620
00:47:11,759 --> 00:47:12,879
这些是固定装置。

621
00:47:13,379 --> 00:47:15,059
这是一个非常简单的...

622
00:47:15,059 --> 00:47:18,139
好吧，这不是一个非常简单的JSON文件，但是非常可读。

623
00:47:20,500 --> 00:47:22,339
JSON文件中没有什么复杂的。

624
00:47:22,339 --> 00:47:24,679
基本上只是测试的输出。

625
00:47:25,539 --> 00:47:26,719
还有两种口味。

626
00:47:27,159 --> 00:47:27,839
这是...

627
00:47:27,839 --> 00:47:28,019
好吧，三个。

628
00:47:28,179 --> 00:47:35,299
三种口味是我在此处描述的第一个UM第一个状态

629
00:47:35,299 --> 00:47:42,639
我们对此有一种特定的格式，我们还有另一种特定于此的格式，第三

630
00:47:42,639 --> 00:47:48,239
格式与区块链格式相同，但我们用来在Hive中消耗的格式

631
00:47:48,239 --> 00:47:54,639
这是我将在演示文稿中进一步解释的工具，是的

632
00:47:54,639 --> 00:47:59,279
这里重要的部分是，这是对客户的实际输入。这就是我们测试的方式

633
00:47:59,279 --> 00:48:07,519
客户是因为客户去了并消耗此JSON。如果发现的东西

634
00:48:07,519 --> 00:48:12,960
无法消费，或者消耗它时，它发现了不同的结果，这意味着有

635
00:48:12,960 --> 00:48:18,639
区别。某处有一个错误。这就是我们在客户中找到老板的方式，

636
00:48:18,639 --> 00:48:21,039
至少对于测试的EVM部分。

637
00:48:23,019 --> 00:48:24,699
我会进一步解释

638
00:48:24,699 --> 00:48:28,179
在有关蜂巢的演讲中。

639
00:48:28,679 --> 00:48:31,539
但是我们为什么需要它的要旨

640
00:48:31,539 --> 00:48:34,460
是因为总有两种方法

641
00:48:34,460 --> 00:48:36,239
块的消费

642
00:48:36,239 --> 00:48:38,819
在每个执行客户端中。

643
00:48:38,940 --> 00:48:41,819
所以一种是原始格式。

644
00:48:42,019 --> 00:48:44,119
您有块，实际块，

645
00:48:44,239 --> 00:48:47,059
形成为RLP，

646
00:48:47,319 --> 00:48:48,460
这是一种编码方法。

647
00:48:48,639 --> 00:48:52,339
这是通过对等网络广播的。

648
00:48:52,500 --> 00:48:54,279
因此，当您同步时，这就是您得到的。

649
00:48:55,139 --> 00:48:58,339
但是在另一种情况下，当我们使用蜂巢时，

650
00:48:58,339 --> 00:49:03,420
我们通过引擎API喂食执行客户端，

651
00:49:03,619 --> 00:49:08,759
这是引擎API基本上只是一种通信方法

652
00:49:08,759 --> 00:49:11,839
在执行客户端和共识层之间。

653
00:49:12,940 --> 00:49:17,219
因此，当实际以太坊区块链运行时，

654
00:49:17,219 --> 00:49:19,819
我们有共识客户端正在运行

655
00:49:19,819 --> 00:49:23,419
它将指令还给执行客户端。

656
00:49:23,919 --> 00:49:26,239
因此这些说明是形式

657
00:49:26,239 --> 00:49:28,539
发动机API指令。

658
00:49:28,799 --> 00:49:30,459
这就是我们在这里测试的。

659
00:49:30,799 --> 00:49:32,399
因此，当我们填写测试时，

660
00:49:32,899 --> 00:49:37,000
高格式包含实际的发动机API指令

661
00:49:37,000 --> 00:49:39,599
这些将来自共识客户。

662
00:49:39,659 --> 00:49:46,339
因此，我们可以确定这种特定的测试方案

663
00:49:46,340 --> 00:49:50,519
将被测试，好像在运行

664
00:49:50,519 --> 00:49:51,740
在真正的区块链上。

665
00:49:54,700 --> 00:49:58,519
考虑到事实带来的区别

666
00:49:58,519 --> 00:50:01,600
就状态而言，该主网非常非常大。

667
00:50:03,100 --> 00:50:04,220
以及我们填写的所有测试，

668
00:50:04,460 --> 00:50:06,079
他们非常非常小

669
00:50:06,079 --> 00:50:08,160
因为否则它将无法管理。

670
00:50:08,920 --> 00:50:11,320
但是，是的，这或多或少是同一件事。

671
00:50:15,360 --> 00:50:15,920
好的。

672
00:50:16,340 --> 00:50:22,840
是的，我想对我们如何真正填写测试进行一些演示。

673
00:50:24,120 --> 00:50:28,860
让我首先去，让我去实际的存储库。

674
00:50:29,840 --> 00:50:31,440
顺便说一句，您还能看到我的屏幕吗？

675
00:50:35,059 --> 00:50:36,000
是的，一切都很好。

676
00:50:36,460 --> 00:50:36,860
好的。

677
00:50:37,320 --> 00:50:37,700
完美的。

678
00:50:38,440 --> 00:50:41,100
这是执行幽灵存储库。

679
00:50:41,980 --> 00:50:45,460
而且它的记录很好。

680
00:50:45,460 --> 00:50:50,260
我们在这里有这个文档页面，你们可以来看看。

681
00:50:51,360 --> 00:50:56,960
首先，我们需要三件事来运行此操作。

682
00:50:57,420 --> 00:51:00,619
好吧，以及您需要安装Python的先决条件。

683
00:51:00,740 --> 00:51:04,440
我认为您需要Python 3.10。

684
00:51:04,820 --> 00:51:06,340
3.10，是3.10。

685
00:51:07,019 --> 00:51:11,900
而且我们还需要汇编EVM和坚固性。

686
00:51:11,900 --> 00:51:18,559
因此，我不会介绍如何编译，以太坊或坚固性。

687
00:51:19,000 --> 00:51:20,860
您可以假设它非常...

688
00:51:20,860 --> 00:51:24,320
如果您转到Readme并在Go Ethereum存储库中，则可以对此进行编译。

689
00:51:24,800 --> 00:51:28,780
但是，是的，第一种方法是您来到这个存储库，

690
00:51:29,180 --> 00:51:31,760
然后，您可以克隆整个存储库。

691
00:51:32,579 --> 00:51:38,200
只需git克隆，您就可以在PC中获得此副本。

692
00:51:38,199 --> 00:51:44,899
让我向您展示存储库的样子。

693
00:51:44,899 --> 00:51:49,960
是的，这是...

694
00:51:49,960 --> 00:51:51,460
这包括...

695
00:51:51,460 --> 00:51:53,759
存储库由两个...组成

696
00:51:53,759 --> 00:51:55,419
让我...

697
00:51:55,419 --> 00:51:56,099
你去。

698
00:51:57,619 --> 00:51:58,919
存储库...

699
00:51:58,919 --> 00:52:00,119
让我删除这个。

700
00:52:01,359 --> 00:52:05,000
我们有两个部分的部分。

701
00:52:05,000 --> 00:52:08,019
第一个是源代码。

702
00:52:08,199 --> 00:52:15,879
框架。因此，您在来源内部发现的所有内容都属于代码

703
00:52:15,879 --> 00:52:21,719
我们用来填写测试。这里没有针对以太坊区块链的测试。

704
00:52:22,439 --> 00:52:28,359
然后第二部分也是根目录中的测试。您可以在这里开始看到

705
00:52:28,359 --> 00:52:34,839
您实际上开始看到一些硬叉。因此，我们拥有每一个硬叉，直到坎昆是

706
00:52:34,840 --> 00:52:40,920
在这里。我们从Frontier开始。然后宅基地，拜占庭，伊斯坦布尔，

707
00:52:42,360 --> 00:52:50,600
巴黎，巴黎的婚姻和上海。我跳过了伦敦和柏林。但是，是的。

708
00:52:50,600 --> 00:52:57,720
你明白了。因此，如果您进入这些文件夹中的任何一个，则可以看到每个测试

709
00:52:57,719 --> 00:52:58,759
我们已经实施了。

710
00:52:59,379 --> 00:53:03,619
只需考虑到这个存储库

711
00:53:03,619 --> 00:53:07,899
自上海以来开始活跃。

712
00:53:08,099 --> 00:53:10,559
因此，对于上海，是的，您将看到每个AIP。

713
00:53:11,079 --> 00:53:13,079
但是例如，对于柏林，您不会看到很多

714
00:53:13,079 --> 00:53:17,559
因为当柏林来到时，这并不活跃。

715
00:53:17,980 --> 00:53:20,859
因此，您将看不到所有完整的测试。

716
00:53:21,279 --> 00:53:24,059
您可以在以太坊测试存储库中找到它们。

717
00:53:25,079 --> 00:53:27,699
是的，让我们看看简单性

718
00:53:27,699 --> 00:53:39,779
测试我能想到的。让我们去参加其中一项测试。是的。让我们从顶部开始。

719
00:53:40,739 --> 00:53:47,899
我们在这里编写的每个测试都使用pytest。这是我们用来填写测试的框架。

720
00:53:48,119 --> 00:53:54,899
我们使用Pytest为我们提供的许多功能。然后您可以看到我们

721
00:53:54,900 --> 00:53:59,760
需要为我们要提供的每个测试编写功能。在这个

722
00:53:59,760 --> 00:54:06,860
情况我们有一个非常简单的测试，称为TestDup。它的目的是

723
00:54:06,860 --> 00:54:13,019
这里说的是测试最简单的dup opcodes之一

724
00:54:13,019 --> 00:54:20,860
EVM中存在的Opcodes。它测试DUP 1至16。因此，它将生成一个测试

725
00:54:20,860 --> 00:54:23,120
对于每个DOP升级。

726
00:54:23,760 --> 00:54:26,920
是的，您可以在这里很好地看到如何...

727
00:54:26,920 --> 00:54:27,940
你有...

728
00:54:27,940 --> 00:54:33,360
您可以看到每个...的实际含义

729
00:54:33,360 --> 00:54:34,120
的...

730
00:54:34,120 --> 00:54:35,960
升级。

731
00:54:36,760 --> 00:54:36,980
但是，是的。

732
00:54:37,519 --> 00:54:40,760
此测试功能，它会生成一个状态，

733
00:54:41,099 --> 00:54:43,680
我们之前谈论的那个，第一个。

734
00:54:44,320 --> 00:54:48,780
原因是这纯粹是EVM测试。

735
00:54:48,780 --> 00:54:52,700
因此，您可以将街区上的所有内容抽象。

736
00:54:52,800 --> 00:54:57,620
您只能使用Opcodes和ABM执行。

737
00:54:57,820 --> 00:54:58,700
然后您将获得此测试。

738
00:54:58,820 --> 00:54:59,600
因为这是最简单的。

739
00:54:59,960 --> 00:55:03,940
您不需要外面的任何东西来测试配音命令。

740
00:55:05,320 --> 00:55:12,240
当您确定要测试的格式时，这是要牢记的主要事情。

741
00:55:13,340 --> 00:55:13,820
是的。

742
00:55:13,980 --> 00:55:15,120
你有一个环境。

743
00:55:15,980 --> 00:55:17,060
而且您得到了预先。

744
00:55:17,059 --> 00:55:21,860
这是我们一直在谈论的前提。因此，您要做的第一件事是

745
00:55:21,860 --> 00:55:27,380
到...您有一个常见的测试地址，这是我们写的所有交易的来源。

746
00:55:28,019 --> 00:55:34,739
而且，它还将包含所有代码，但在这里没有填写。所以在这一点上我们只

747
00:55:34,739 --> 00:55:40,340
设置一个是交易来源的测试地址，我们将有一个无限的金额

748
00:55:40,340 --> 00:55:44,659
平衡。因为这是...这将是我们发送的所有交易的来源。

749
00:55:44,659 --> 00:55:50,420
所以它必须有东西。然后我们定义帐户。

750
00:55:52,179 --> 00:55:59,779
我们将要使用要使用的代码的帐户。这是主要的

751
00:55:59,779 --> 00:56:07,299
交易将发送到的帐户。然后它将...我们将开始

752
00:56:07,300 --> 00:56:13,700
在其中创建代码。让我看看还有其他。好的。是的。

753
00:56:14,340 --> 00:56:19,060
是的。如您所见，它是...生成此代码的三个部分。

754
00:56:19,700 --> 00:56:31,539
因此，第一部分是我们要创建一个10。因此，从0到10。到...不。 0x10是16。

755
00:56:31,539 --> 00:56:54,519
并推送命令。所以这很容易。只是推动命令基本上只是将某些东西推入EVM堆栈中。是的，EVM是一台堆栈计算机。然后，您将堆栈用于很多事情。因此，您将要使用的主要EVM OPODE至少是一些推送命令。

756
00:56:54,519 --> 00:57:03,300
因此，在这种情况下，我们使用的是最简单的，它只是将一个字节推入堆栈。

757
00:57:04,559 --> 00:57:09,719
该堆栈由32个字节元素组成。

758
00:57:10,039 --> 00:57:11,759
但是在这种情况下，我们只是在推动一个字节。

759
00:57:11,860 --> 00:57:19,639
因此，它将为31个零字节，然后是一个字节，这是由此定义的。

760
00:57:19,639 --> 00:57:25,259
而且，如果您知道Python，您现在就知道我们将收集所有这些。

761
00:57:26,139 --> 00:57:32,739
我们将将此数组或列表收集到要去此处的字节代码中。

762
00:57:33,519 --> 00:57:43,099
之后，我们将进行测试的操作码，这是定义的

763
00:57:43,099 --> 00:57:43,400
多变的。

764
00:57:43,519 --> 00:57:48,879
这个变量很特别，因为我们将其定义为测试的参数，

765
00:57:48,879 --> 00:57:49,199
请参阅此处。

766
00:57:49,199 --> 00:57:54,019
而且这很重要，因为这是被参数化的。

767
00:57:54,599 --> 00:57:59,460
这是我们在Bytest中使用的最重要的装饰器之一。

768
00:58:00,879 --> 00:58:06,219
基本上只需在此处使用此参数

769
00:58:06,219 --> 00:58:10,419
然后每次为此运行此功能。

770
00:58:11,219 --> 00:58:16,159
因此，此变量的价值将在每个迭代中都会改变

771
00:58:16,159 --> 00:58:18,219
执行此功能。

772
00:58:19,199 --> 00:58:24,199
因此，第一次迭代将使用配音

773
00:58:24,199 --> 00:58:26,799
第二个配音二，依此类推。

774
00:58:26,799 --> 00:58:29,980
这将改变哪个价值，

775
00:58:31,079 --> 00:58:33,899
执行字节码的哪个值。

776
00:58:33,899 --> 00:58:36,199
因此，它将改变结果

777
00:58:36,199 --> 00:58:38,819
测试。

778
00:58:40,139 --> 00:58:44,139
最后，我们将使用另一个

779
00:58:44,139 --> 00:58:48,619
我们使用的最重要的OP代码

780
00:58:48,619 --> 00:58:50,719
这是SSStore。

781
00:58:50,719 --> 00:58:55,659
而SSStore基本上是我们使用的代码最多

782
00:58:55,659 --> 00:58:59,199
因为这是我们保存东西的方式

783
00:58:59,199 --> 00:59:01,880
进入我们正在执行的合同的存储。

784
00:59:03,319 --> 00:59:06,119
如果我们在测试中的任何地方都不使用此操作码，

785
00:59:06,960 --> 00:59:10,179
这意味着我们要测试其他东西

786
00:59:10,179 --> 00:59:11,819
像错误之类的东西

787
00:59:11,819 --> 00:59:16,500
或者我们基本上已经写了一个无效的测试。

788
00:59:16,500 --> 00:59:19,400
在这种情况下，我们正在做的就是

789
00:59:19,400 --> 00:59:22,519
我们已经把所有这些东西都放在堆栈中了，

790
00:59:22,519 --> 00:59:25,699
在我们的EVM执行的堆栈中。

791
00:59:25,699 --> 00:59:28,440
然后，最后一步只是为了保存它们。

792
00:59:28,440 --> 00:59:29,539
这就是我们在这里做的。

793
00:59:29,539 --> 00:59:34,539
我们只将一个字节推入堆栈，

794
00:59:35,119 --> 00:59:37,940
我们将在这里保存此值

795
00:59:37,940 --> 00:59:40,559
我们以前推了。

796
00:59:41,579 --> 00:59:43,860
显然，然后存储它。

797
00:59:43,860 --> 00:59:46,079
我们将为每个堆栈项目做到这一点

798
00:59:46,079 --> 00:59:48,199
我们还有又一个。

799
00:59:48,199 --> 00:59:50,019
不，是一样的。

800
00:59:50,019 --> 00:59:50,860
是的。

801
00:59:50,860 --> 00:59:54,279
当我们执行代码时，这将被存储。

802
00:59:55,940 --> 01:00:00,579
最后，我们设置了具有其代码的帐户，

803
01:00:00,579 --> 01:00:01,980
它的地址和一切。

804
01:00:01,980 --> 01:00:04,199
因此，我们准备将其放入预状态

805
01:00:04,199 --> 01:00:08,400
这意味着当我们执行此测试时

806
01:00:08,400 --> 01:00:11,360
客户会消耗此测试，

807
01:00:11,360 --> 01:00:14,139
它会找到一个包含帐户的预状态。

808
01:00:14,139 --> 01:00:15,059
所以这很重要

809
01:00:15,059 --> 01:00:18,179
因为这是要执行交易的方式

810
01:00:18,179 --> 01:00:20,119
这是交易的目的地

811
01:00:20,119 --> 01:00:21,400
正如您在这里看到的。

812
01:00:21,400 --> 01:00:22,559
是的，到底是。

813
01:00:22,559 --> 01:00:25,679
因此，我们在此测试中进行的交易

814
01:00:25,679 --> 01:00:27,239
是单个交易。

815
01:00:27,239 --> 01:00:29,699
这在这里唯一重要

816
01:00:29,699 --> 01:00:33,079
是我们将其发送到帐户

817
01:00:33,079 --> 01:00:35,420
我们放入所写的代码。

818
01:00:39,119 --> 01:00:42,179
再加上我们的信息，但这是无关紧要的。

819
01:00:42,179 --> 01:00:43,019
是的，基本上。

820
01:00:43,019 --> 01:00:44,360
还有。

821
01:00:44,360 --> 01:00:47,480
最后，我们要设定的最后一件事

822
01:00:48,500 --> 01:00:52,760
是发布日期，这是我们要检查的

823
01:00:52,760 --> 01:00:55,780
那是在...之后发生的

824
01:00:57,940 --> 01:01:00,240
发生在执行交易之后。

825
01:01:01,160 --> 01:01:04,980
基本上只是期望堆栈项目

826
01:01:04,980 --> 01:01:08,400
我们在这里说的是正确的位置。

827
01:01:08,400 --> 01:01:09,240
如果您阅读了描述，

828
01:01:09,240 --> 01:01:11,720
您会发现它是如何工作的。

829
01:01:11,719 --> 01:01:14,799
但是，是的，这基本上是最后一步。

830
01:01:14,799 --> 01:01:16,539
下一步只是填充测试。

831
01:01:17,539 --> 01:01:21,500
这里会发生什么，我们将填补状态

832
01:01:21,500 --> 01:01:25,459
使用我们之前设置的所有成分。

833
01:01:25,459 --> 01:01:28,039
这将为我们提供一个固定装置。

834
01:01:28,039 --> 01:01:32,359
因此，最简单的方法就是这样

835
01:01:32,359 --> 01:01:34,959
我们运行填充命令。

836
01:01:34,959 --> 01:01:36,959
因此，我们在哪里很重要。

837
01:01:36,959 --> 01:01:40,759
因此，测试前沿，UP代码测试下划线Dub.py。

838
01:01:40,760 --> 01:01:41,940
让我们这样做。

839
01:01:41,940 --> 01:01:46,680
填充叉子坎昆。

840
01:01:46,680 --> 01:01:51,680
并测试带有UP代码的边界

841
01:01:53,040 --> 01:01:54,880
并测试下划线配音。

842
01:01:57,640 --> 01:01:58,480
你去。

843
01:02:00,500 --> 01:02:01,340
你去。

844
01:02:01,340 --> 01:02:06,160
因此，如您所见，我们产生了大量的测试。

845
01:02:06,160 --> 01:02:10,020
48是，我会一点点解释。

846
01:02:10,019 --> 01:02:13,780
因此，这意味着我们在这里进行的每个测试，

847
01:02:14,800 --> 01:02:18,280
在这种情况下，执行客户端

848
01:02:18,280 --> 01:02:21,659
因为我们正在用Geth填充此过渡工具，所以

849
01:02:21,659 --> 01:02:23,380
我们在这里没有测试任何其他客户。

850
01:02:23,380 --> 01:02:25,300
我们只是在使用Geth

851
01:02:25,300 --> 01:02:27,739
告诉我们结果应该是什么。

852
01:02:27,739 --> 01:02:29,179
但是我们在这里有一个安全的措施。

853
01:02:29,179 --> 01:02:31,360
因此，如果我们正确设计或测试，

854
01:02:31,360 --> 01:02:35,619
这意味着我们放在这里，这是有道理的。

855
01:02:35,619 --> 01:02:37,659
因此，如果我们修改了此事，

856
01:02:37,659 --> 01:02:43,279
让我们将其保存到其他方面，

857
01:02:43,500 --> 01:02:44,440
像20岁。

858
01:02:45,859 --> 01:02:48,039
让我们再次运行它，看看会发生什么。

859
01:02:49,619 --> 01:02:50,239
你去。

860
01:02:50,699 --> 01:02:50,920
是的。

861
01:02:51,399 --> 01:02:54,159
所以不是...

862
01:02:54,159 --> 01:02:56,019
是的，我把这个非常非常大。

863
01:02:56,379 --> 01:02:58,179
所以这里就是

864
01:02:58,179 --> 01:03:00,559
我们在帖子中放置的一切

865
01:03:00,559 --> 01:03:02,599
对我们来说真的很重要

866
01:03:02,599 --> 01:03:04,819
执行客户端

867
01:03:04,819 --> 01:03:06,159
我们正在用

868
01:03:06,159 --> 01:03:07,440
实际上是理智的。

869
01:03:07,659 --> 01:03:19,619
否则，它将继续并生成我们的客户消费的测试，但不会失败，因为我们用来填写测试的执行客户端是错误的。

870
01:03:19,619 --> 01:03:24,940
因此，让我们回到原始内容，以确保我们再次填写。

871
01:03:24,940 --> 01:03:26,379
然后你去。

872
01:03:26,379 --> 01:03:27,920
好的。

873
01:03:27,920 --> 01:03:30,399
这是什么结果？

874
01:03:30,399 --> 01:03:33,199
因此，我们现在有了一个新的A新文件夹。

875
01:03:33,199 --> 01:03:35,019
让我们来看看。

876
01:03:35,019 --> 01:03:37,639
是的。你去。

877
01:03:37,659 --> 01:03:39,899
因此，我们有一个称为的文件夹，

878
01:03:39,899 --> 01:03:40,779
这是输出。

879
01:03:40,779 --> 01:03:42,679
这是固定装置的输出。

880
01:03:42,679 --> 01:03:47,099
您会看到这是三种格式

881
01:03:47,099 --> 01:03:49,980
我们期望在这里。

882
01:03:49,980 --> 01:03:51,579
因此，第一个是区块链测试。

883
01:03:51,579 --> 01:03:54,539
这是我们由客户消费的。

884
01:03:54,539 --> 01:03:56,119
高格式和状态格式。

885
01:03:56,119 --> 01:03:59,319
让我们打开其中一个只是为了看看它们的外观。

886
01:04:07,659 --> 01:04:14,599
你去。是的，一切都在这里。这是JSON输出。在这里真的很好

887
01:04:14,739 --> 01:04:20,420
我们有测试的名称，正是我们执行的。这是一个州测试。这意味着

888
01:04:20,420 --> 01:04:26,059
在此测试中，我们只有一项交易。您可以在这里看到它。我们有交易

889
01:04:26,059 --> 01:04:30,139
这里。您拥有交易的所有属性。你也有预状态

890
01:04:30,139 --> 01:04:34,579
和环境。因此，在这种情况下，您可以看到环境包含的简单信息

891
01:04:34,579 --> 01:04:42,420
包括块，环境将是什么，即块。您可以看到数字，

892
01:04:42,420 --> 01:04:46,500
时间步骤，所有这些东西以及基本费用。您还可以看到，更重要的是

893
01:04:47,940 --> 01:04:55,139
你们还记得我们将代码保存到的地址吗？就在这里。所以我们有地址

894
01:04:55,139 --> 01:05:03,219
编号100。我们在这里有代码，这是我们在此处使用此花式代码生成的。

895
01:05:04,579 --> 01:05:09,579
这就是执行的原因，因为两个目的地，

896
01:05:09,719 --> 01:05:14,019
所有交易都是完全相同的地址。

897
01:05:14,019 --> 01:05:17,619
然后，交易转到这里，执行所有这些。

898
01:05:17,619 --> 01:05:21,340
然后，我们验证此文件中也是如此。

899
01:05:21,340 --> 01:05:23,400
您可以看到一个重要的事情是

900
01:05:23,400 --> 01:05:26,139
以状态格式，我们不验证

901
01:05:26,139 --> 01:05:30,119
完全具体具体，存储的每个键

902
01:05:30,119 --> 01:05:33,199
但是我们验证了Hash，Stateroot。

903
01:05:33,199 --> 01:05:38,859
这就是使我们通过交易测试的通过或失败的原因，

904
01:05:39,139 --> 01:05:46,639
对不起，当执行客户端消耗时，对不起。

905
01:05:47,319 --> 01:05:48,799
这只是一个测试。

906
01:05:49,699 --> 01:05:52,679
但是您可以看到我们在同一文件中有许多测试，

907
01:05:52,679 --> 01:05:55,939
是.1，.2，.3，等等。

908
01:05:56,699 --> 01:06:00,059
我认为总的来说，它应该像16次测试。

909
01:06:00,559 --> 01:06:00,699
是的。

910
01:06:01,419 --> 01:06:01,939
你去。

911
01:06:02,399 --> 01:06:02,699
是的。

912
01:06:03,199 --> 01:06:08,339
因此，这基本上就是这个框架工作原理的要旨。

913
01:06:08,339 --> 01:06:10,539
我鼓励每个人都去看看。

914
01:06:11,799 --> 01:06:13,679
编写这些测试真的很有趣。

915
01:06:13,980 --> 01:06:14,759
它在Python。

916
01:06:15,460 --> 01:06:17,419
如果您以前知道Python，则可以使用此功能。

917
01:06:17,599 --> 01:06:18,439
这很简单。

918
01:06:19,399 --> 01:06:20,339
是的。

919
01:06:21,419 --> 01:06:25,539
让我回到演讲。

920
01:06:28,319 --> 01:06:28,799
是的。

921
01:06:29,259 --> 01:06:29,659
好的。

922
01:06:29,659 --> 01:06:34,920
因此，我们还有另外两个非常重要的工具。

923
01:06:35,119 --> 01:06:36,980
这是FOSSI EVM。

924
01:06:37,519 --> 01:06:40,719
当前在执行检查员中，我们没有生成FOSS测试。

925
01:06:41,000 --> 01:06:44,559
这是由此工具完成的，该工具由GO团队的Marius撰写。

926
01:06:45,079 --> 01:06:45,980
他写了这个工具。

927
01:06:46,420 --> 01:06:51,299
这是该工具生成FOSS代码的另一个工具的陪伴。

928
01:06:51,679 --> 01:06:56,859
然后，您使用GO EVM Lab，这是您用于一个输入的工具

929
01:06:56,860 --> 01:07:01,880
然后，您可以与许多不同的客户一起运行此输入。

930
01:07:02,160 --> 01:07:03,740
然后，您检查差异。

931
01:07:06,160 --> 01:07:07,820
它产生了很多错误。

932
01:07:08,120 --> 01:07:11,940
这真的很有用，因为当您编写功能测试时，

933
01:07:12,059 --> 01:07:16,160
真的很难想到您可以想到的每种边缘情况。

934
01:07:16,420 --> 01:07:21,599
因此，此工具是我们使用执行规格测试编写的非常好的陪伴。

935
01:07:21,599 --> 01:07:28,679
另一个重要的部分是执行AP测试。

936
01:07:28,679 --> 01:07:32,219
这是在此存储库中完成的。

937
01:07:32,219 --> 01:07:36,000
这是...让我快速告诉你。

938
01:07:36,000 --> 01:07:43,559
基本上，您用来查询执行客户端的所有执行AP，

939
01:07:43,559 --> 01:07:46,019
例如，获取一个块，获取交易，发送交易，

940
01:07:46,019 --> 01:07:49,440
所有这些内容都在此存储库中。

941
01:07:49,440 --> 01:07:53,320
让我快速告诉您它的外观。

942
01:07:53,320 --> 01:07:56,320
因此，我们有此存储库，然后您进行测试。

943
01:07:56,320 --> 01:08:04,720
然后，您可以看到每个RPC指令都有一两个测试。

944
01:08:04,720 --> 01:08:06,320
因此，例如，它强调了调用。

945
01:08:06,320 --> 01:08:07,659
然后，您可以去这里看看。

946
01:08:07,659 --> 01:08:11,360
而且，其中的每一个都像输入和预期输出。

947
01:08:11,360 --> 01:08:13,960
这很简单。

948
01:08:13,960 --> 01:08:17,380
他们所有人都喜欢这种链条的先决条件。

949
01:08:17,380 --> 01:08:24,420
如果您期望固定的结果，则必须拥有一个链条链

950
01:08:24,420 --> 01:08:30,380
必须拥有一个创世纪链等等

951
01:08:32,140 --> 01:08:40,980
在那里，您要进行共识层测试这一切都在

952
01:08:40,980 --> 01:08:46,980
一致的规格存储库，并且是用于测试的A

953
01:08:46,979 --> 01:08:55,119
类似于executionspectest的想法，即您具有输出。这是一个固定装置

954
01:08:55,119 --> 01:09:03,059
客户可以消费。主要区别之一是，因为您有

955
01:09:03,059 --> 01:09:08,759
同一存储库中包含的实际规范，您没有任何依赖项。

956
01:09:08,979 --> 01:09:16,059
您不依赖任何共识层客户端。因此，这很有帮助，因为您有测试，

957
01:09:16,060 --> 01:09:21,740
您有规格，在同一存储库中都有所有内容。这很花哨。

958
01:09:21,740 --> 01:09:26,140
让我向您展示这部分。

959
01:09:32,940 --> 01:09:39,100
是的。如果您进入控制台。Specs，您可以参加测试，可以进入这里，看看

960
01:09:39,100 --> 01:09:44,560
所有可以从此存储库中输出的格式。

961
01:09:44,560 --> 01:09:46,900
这些是许多不同的格式

962
01:09:46,900 --> 01:09:49,620
那测试了共识层的不同事物。

963
01:09:49,880 --> 01:09:52,380
这比我们产生的要多。

964
01:09:52,860 --> 01:09:54,860
对于执行规格，

965
01:09:55,079 --> 01:09:57,579
我们仅生成区块链测试格式和状态，

966
01:09:57,760 --> 01:09:58,920
预计会改变。

967
01:09:59,079 --> 01:10:01,980
我们将根据需要介绍更多格式。

968
01:10:02,660 --> 01:10:04,960
但是，是的，您可以看到大量格式

969
01:10:04,960 --> 01:10:06,700
您可以使用此测试生成。

970
01:10:06,699 --> 01:10:13,119
非常有用，因为您可以非常细粒度测试每个小层。

971
01:10:13,119 --> 01:10:17,659
基本上，就像单位测试共识层的每个方面一样。

972
01:10:17,760 --> 01:10:19,279
而且这也非常有效。

973
01:10:21,220 --> 01:10:26,139
我建议进入这里，进入这个存储库，

974
01:10:26,699 --> 01:10:31,599
并给阅读本

975
01:10:31,819 --> 01:10:36,119
但是了解如何填充这些测试是非常有益的。

976
01:10:36,699 --> 01:10:39,300
是的。

977
01:10:39,300 --> 01:10:41,840
让我看看。

978
01:10:41,840 --> 01:10:42,840
是的。

979
01:10:42,840 --> 01:10:43,840
好吧。

980
01:10:43,840 --> 01:10:46,739
所以进入...的最后一部分

981
01:10:46,739 --> 01:10:50,159
演讲的后期。

982
01:10:50,159 --> 01:10:53,979
我们对执行层进行测试。

983
01:10:53,979 --> 01:10:56,639
和概念层分别。

984
01:10:56,639 --> 01:11:01,779
但是我们也进行了一些跨层测试的测试。

985
01:11:01,779 --> 01:11:05,000
知道一切都融合在一起非常重要。

986
01:11:05,000 --> 01:11:05,840
它称为端到端测试。

987
01:11:06,659 --> 01:11:09,100
基本上只是建造链条

988
01:11:09,100 --> 01:11:11,899
从创世纪到某个点

989
01:11:11,899 --> 01:11:13,640
然后验证一切，

990
01:11:14,260 --> 01:11:15,859
所有互动都正确地发生了

991
01:11:15,859 --> 01:11:17,699
在执行和共识客户端之间。

992
01:11:18,000 --> 01:11:19,739
我们为此进行了不同的测试，

993
01:11:20,199 --> 01:11:21,119
测试套件。

994
01:11:21,659 --> 01:11:23,640
我只会提到其中一些

995
01:11:23,640 --> 01:11:26,659
因为否则它将是一个非常非常长的演示文稿。

996
01:11:27,180 --> 01:11:27,979
所以我们有蜂巢，

997
01:11:28,159 --> 01:11:30,960
我个人专注于哪个主要工具

998
01:11:30,960 --> 01:11:33,319
房间测试团队的重点是。

999
01:11:33,319 --> 01:11:37,259
但是我们还有更多由DevOps Scene开发的工具

1000
01:11:37,259 --> 01:11:41,259
并与其他公司结合。

1001
01:11:41,920 --> 01:11:45,340
因此，我们有断言，这基本上只是一个工具

1002
01:11:45,340 --> 01:11:50,340
我们可以用来给它输入

1003
01:11:50,340 --> 01:11:53,579
然后期望一些预期的输出

1004
01:11:53,579 --> 01:11:57,539
并断言输出在任何链中都是正确的。

1005
01:11:57,539 --> 01:12:03,460
让它是一个蜂巢链，一个Devnet，一个测试网，甚至是一个主网。

1006
01:12:03,460 --> 01:12:09,140
这很重要。您可以用主张来完成所有操作。这是一个非常好的工具。

1007
01:12:09,140 --> 01:12:13,619
我们还拥有由峰度小组开发的峰度软件包。

1008
01:12:14,340 --> 01:12:22,340
这是一个非常非常好的工具，可以从自己的产卵中做简单的事情

1009
01:12:22,340 --> 01:12:27,380
由执行客户端和共识客户端组成的本地以太链链。

1010
01:12:27,380 --> 01:12:32,520
一直到启动Shadowforks，这是我会的

1011
01:12:32,520 --> 01:12:38,159
一点点解释。这是一个非常非常好的包装，如果您

1012
01:12:38,159 --> 01:12:45,079
想快速运行一些东西。这是要使用的工具之一。我是

1013
01:12:45,079 --> 01:12:50,659
要多一点地进入Hive，因为这也是我的工具之一

1014
01:12:50,659 --> 01:13:02,239
与之合作。是的。基本上，Hive是一个为您提供测试仪产卵方式的框架

1015
01:13:02,239 --> 01:13:09,139
测试和产卵客户在测试中。即执行客户和共识客户。

1016
01:13:09,599 --> 01:13:15,680
因此，您可以创建仅是您的测试的测试。而且您有一些非常具体的事情。

1017
01:13:15,680 --> 01:13:21,140
例如，您想测试共识误差链中的存款。

1018
01:13:21,579 --> 01:13:22,960
因此，您开始测试。

1019
01:13:23,800 --> 01:13:26,060
然后您启动一个执行客户端。

1020
01:13:26,260 --> 01:13:26,480
对不起。

1021
01:13:26,740 --> 01:13:29,500
您首先开始共识客户端。

1022
01:13:29,800 --> 01:13:31,700
然后，您启动执行客户端。

1023
01:13:32,180 --> 01:13:33,020
你把它们放在一起。

1024
01:13:33,480 --> 01:13:36,539
您向共识客户发起一些存款。

1025
01:13:36,820 --> 01:13:38,060
然后您期待一些东西。

1026
01:13:38,579 --> 01:13:40,920
在测试结束时，如果一切都正确，

1027
01:13:41,220 --> 01:13:45,039
您指示测试正确完成并通过。

1028
01:13:45,680 --> 01:13:46,520
然后你总结。

1029
01:13:47,800 --> 01:13:54,980
这是一个非常好的框架，用于进行非常非常功能和特定的测试。

1030
01:13:55,720 --> 01:14:00,880
您必须牢记滚动和编写模拟器时要测试的内容。

1031
01:14:01,820 --> 01:14:02,960
它的工作方式是...

1032
01:14:02,960 --> 01:14:03,980
让我看看我是否有幻灯片。

1033
01:14:04,060 --> 01:14:04,159
是的。

1034
01:14:04,159 --> 01:14:10,760
它的工作方式是我们拥有Hive Server，它是所有事物的主要编排

1035
01:14:10,760 --> 01:14:11,780
我们在这个中运行。

1036
01:14:12,420 --> 01:14:13,780
但是您也有模拟器。

1037
01:14:13,779 --> 01:14:25,380
模拟器的工作是知道在何时开始测试，何时结束测试，何时启动客户端，何时结束客户端等方面该怎么办。

1038
01:14:25,739 --> 01:14:28,479
因此，第一步是您构建Hive服务器。

1039
01:14:29,340 --> 01:14:31,019
我会稍微展示。

1040
01:14:31,059 --> 01:14:31,779
我有一个演示。

1041
01:14:32,099 --> 01:14:33,319
真的很快。

1042
01:14:34,039 --> 01:14:36,259
然后您启动Hive Server。

1043
01:14:36,719 --> 01:14:41,039
然后，您告诉Hive服务器启动给定的模拟器。

1044
01:14:41,039 --> 01:14:45,140
它将继续并启动一个Docker容器

1045
01:14:45,140 --> 01:14:45,960
使用模拟器。

1046
01:14:46,640 --> 01:14:48,600
基本上模拟器只是另一个程序

1047
01:14:48,600 --> 01:14:50,039
其中包含所有说明

1048
01:14:50,039 --> 01:14:51,420
关于如何运行此测试。

1049
01:14:51,819 --> 01:14:53,359
因此，模拟器开始，

1050
01:14:53,760 --> 01:14:55,159
模拟器知道它正在运行，

1051
01:14:55,159 --> 01:14:56,420
它是由蜂巢经营的。

1052
01:14:56,979 --> 01:14:59,659
然后它继续做它。

1053
01:15:00,159 --> 01:15:01,399
它开始测试。

1054
01:15:01,600 --> 01:15:02,519
它开始客户

1055
01:15:02,519 --> 01:15:05,439
然后执行一些计算和事情。

1056
01:15:05,939 --> 01:15:08,060
然后结束客户或结束测试

1057
01:15:08,060 --> 01:15:11,060
或中止测试或失败或通过测试。

1058
01:15:11,460 --> 01:15:13,539
然后基本上就是这样。

1059
01:15:13,539 --> 01:15:18,780
单个模拟器可以立即启动许多测试，

1060
01:15:19,020 --> 01:15:21,580
也可以并行启动许多客户，

1061
01:15:22,100 --> 01:15:25,400
它可以协调许多不同的情况

1062
01:15:25,400 --> 01:15:30,020
为了执行和一致的客户执行。

1063
01:15:31,620 --> 01:15:34,780
好事是您不必担心

1064
01:15:34,779 --> 01:15:38,679
在模拟器中有关您的启动方式。

1065
01:15:39,039 --> 01:15:40,199
例如，假设

1066
01:15:40,319 --> 01:15:42,159
好吧，我想启动一个执行客户端，

1067
01:15:42,559 --> 01:15:43,679
但是我不知道该如何开始

1068
01:15:43,679 --> 01:15:45,639
因为去以太坊和nethermine

1069
01:15:45,639 --> 01:15:47,099
以不同的方式开始。

1070
01:15:48,359 --> 01:15:49,420
例如，我们有

1071
01:15:49,519 --> 01:15:52,059
我们每个都有Docker图像，

1072
01:15:52,059 --> 01:15:55,500
但是即使这样，您也有喜欢参数。

1073
01:15:55,979 --> 01:15:58,179
例如，GO以太坊具有不同的参数

1074
01:15:58,179 --> 01:16:01,739
有关如何指定Genesis文件或其他

1075
01:16:01,739 --> 01:16:03,819
与Nethermine相比。

1076
01:16:03,819 --> 01:16:08,199
因此，Hive服务器的目标之一是抽象所有这些。

1077
01:16:08,639 --> 01:16:10,859
因此，您开始模拟器。

1078
01:16:11,539 --> 01:16:14,460
Hive告诉您，好吧，您有Goethereum，Nettermine，

1079
01:16:14,739 --> 01:16:15,479
VISU，等等。

1080
01:16:15,939 --> 01:16:20,699
模拟器走了说，好吧，让我们开始使用Goethereum。

1081
01:16:21,099 --> 01:16:24,239
然后它已经开始使用所有参数

1082
01:16:24,239 --> 01:16:24,819
为您设置。

1083
01:16:25,079 --> 01:16:27,799
然后您可以专注于测试

1084
01:16:27,799 --> 01:16:31,799
对于该特定的执行客户端。

1085
01:16:31,800 --> 01:16:36,720
Hive Server将为您启动执行或共识客户端。

1086
01:16:37,039 --> 01:16:42,739
但是好事是，从仿真来看，您可以与Hive Server进行通信以启动更多客户端。

1087
01:16:42,860 --> 01:16:47,400
或者，您可以直接与执行客户端或共识客户端进行通信。

1088
01:16:48,060 --> 01:16:52,220
因此，这是一种非常好的方法，可以将很多东西抽象出来。

1089
01:16:52,940 --> 01:16:59,760
测试作者只专注于测试客户利基市场中的实际内容。

1090
01:17:01,800 --> 01:17:07,000
我们有许多用于蜂巢的模拟器。

1091
01:17:07,400 --> 01:17:09,820
他们都在戈兰，

1092
01:17:10,000 --> 01:17:13,180
它们都包含在Hive存储库中。

1093
01:17:13,380 --> 01:17:16,320
但是可以写任何模拟器

1094
01:17:16,320 --> 01:17:20,360
用您需要的任何语言。

1095
01:17:22,159 --> 01:17:25,800
我们还有一个python的图书馆，

1096
01:17:25,940 --> 01:17:29,159
尚未出去

1097
01:17:29,159 --> 01:17:31,440
并且仍然有一些工作要做。

1098
01:17:31,800 --> 01:17:34,199
还有一些工作要做。

1099
01:17:34,199 --> 01:17:37,340
但是，是的，暂时仅在Golang上。

1100
01:17:37,340 --> 01:17:39,579
如您所见，这是所有模拟器

1101
01:17:39,579 --> 01:17:43,119
至少在大师蜂座分支上

1102
01:17:43,119 --> 01:17:45,020
被包含在蜂巢中。

1103
01:17:45,020 --> 01:17:46,320
我们有不同的东西。

1104
01:17:46,320 --> 01:17:48,220
例如，我们有点对点，

1105
01:17:48,220 --> 01:17:50,460
就像交流方式

1106
01:17:50,460 --> 01:17:51,739
他们之间的执行客户端。

1107
01:17:51,739 --> 01:17:55,000
因此，此模拟器与测试有关

1108
01:17:55,000 --> 01:17:57,860
交流的这一部分。

1109
01:17:57,860 --> 01:18:00,720
只需启动客户，彼此交流

1110
01:18:00,720 --> 01:18:02,800
并验证这是一次交流

1111
01:18:02,800 --> 01:18:05,020
这是正确和成功的。

1112
01:18:05,020 --> 01:18:07,180
我们也有以太坊的正常

1113
01:18:07,180 --> 01:18:10,619
这包含许多不同的东西。

1114
01:18:11,800 --> 01:18:12,880
即RPC。

1115
01:18:12,880 --> 01:18:14,980
这是RPC Compa，

1116
01:18:15,980 --> 01:18:19,659
如果你们记得我们看到的另一页，

1117
01:18:19,659 --> 01:18:21,600
这是执行应用程序。

1118
01:18:21,600 --> 01:18:24,780
在这里，它进入了该存储库

1119
01:18:24,780 --> 01:18:28,079
并收集此文件的每一个

1120
01:18:28,079 --> 01:18:30,680
然后通过RPC执行它们

1121
01:18:30,680 --> 01:18:31,880
在运行的客户端

1122
01:18:31,880 --> 01:18:35,340
使用我们刚刚看到的方法。

1123
01:18:35,939 --> 01:18:36,840
所以这真的很重要

1124
01:18:36,840 --> 01:18:41,399
用于消费这些测试

1125
01:18:41,399 --> 01:18:44,220
仅将蜂巢用于RPC Comp。

1126
01:18:45,220 --> 01:18:47,340
但是我们还有更多的东西。

1127
01:18:47,500 --> 01:18:49,979
例如，我们有共识。

1128
01:18:50,300 --> 01:18:53,239
这是通过以太坊测试加载测试

1129
01:18:53,239 --> 01:18:55,699
然后将它们传递到客户中，

1130
01:18:55,920 --> 01:18:56,439
验证它们。

1131
01:18:56,439 --> 01:18:58,099
我们也有引擎API。

1132
01:18:58,319 --> 01:19:09,000
这很重要，因为它通过引擎API测试了共识客户端的通信到执行客户端，该引擎API在执行API中的此处定义。

1133
01:19:09,919 --> 01:19:15,519
此模拟器的重要部分是它不使用共识客户端。

1134
01:19:15,519 --> 01:19:25,479
原因是它希望测试一些非常特定的发动机API命令和一些非常特定的创世纪属性。

1135
01:19:25,479 --> 01:19:29,859
所以原因，我们这样做的方式

1136
01:19:29,859 --> 01:19:33,839
没有共识客户的中断，

1137
01:19:33,839 --> 01:19:38,839
是通过生成模拟共识客户端，

1138
01:19:39,199 --> 01:19:42,459
基本上只是引擎API调用

1139
01:19:42,459 --> 01:19:43,939
我们完全需要。

1140
01:19:44,799 --> 01:19:47,959
我们还具有测试GraphQL的GraphQL。

1141
01:19:47,959 --> 01:19:50,879
PYSPEC基本上是执行规格测试。

1142
01:19:50,879 --> 01:19:53,739
它们都在这里被消耗掉了，还进行了一些同步测试。

1143
01:19:53,739 --> 01:20:01,939
F2也非常重要。这是一个遗产名称。不要介意。

1144
01:20:01,939 --> 01:20:12,679
这包含共识层和执行层之间的所有中断测试。

1145
01:20:12,679 --> 01:20:21,099
因此，实际上，这个模拟器在此处确实会同时产生共识客户端和执行客户端。

1146
01:20:21,100 --> 01:20:26,220
时间。这个目的只是测试一些正在发生的特定情况。例如，

1147
01:20:26,220 --> 01:20:33,579
在Dancun，您有斑点，发送斑点并做斑点的事情并验证共识是否

1148
01:20:33,579 --> 01:20:39,180
客户端和执行客户的行为会以预期的方式行驶。

1149
01:20:39,820 --> 01:20:44,860
而且非常好，因为它协调了执行客户端和共识

1150
01:20:44,859 --> 01:20:49,679
客户同时，很高兴看到它的工作原理

1151
01:20:49,679 --> 01:20:55,719
是的，缺少最多的小型组件更多的模拟器不同

1152
01:20:55,719 --> 01:20:59,799
实现这是使用不同定理的不同限制

1153
01:20:59,799 --> 01:21:05,420
客户，但这是同一想法是的

1154
01:21:05,899 --> 01:21:11,859
是的，好吧，所以让我快速我只想展示一下它的方式

1155
01:21:11,859 --> 01:21:20,019
它运行。这真的非常简单。重要部分之一是您首先必须克隆

1156
01:21:20,019 --> 01:21:29,139
存储库一如既往。只需进入这里进入以太坊，Git克隆即可。你克隆它

1157
01:21:30,739 --> 01:21:39,219
您的本地主持人。然后，假设您安装了目标线，则只需构建它即可。

1158
01:21:39,220 --> 01:21:42,420
您将在这里建立蜂巢，这是可执行的。

1159
01:21:44,100 --> 01:21:50,980
那在那里。因此，此可执行文件与此服务器有关。服务器

1160
01:21:50,980 --> 01:21:59,140
我们...精心策划了一切。基本上，这是一个非常高档的码头容器实例化器，

1161
01:21:59,140 --> 01:22:06,900
管弦乐队。那就是它的作用。因此，让我们进行简单的测试。我想我在...

1162
01:22:06,899 --> 01:22:14,579
你去。是的。好的。让我们进行一个简单的测试。那只是测试网

1163
01:22:14,579 --> 01:22:19,939
测试执行客户端和控制台客户端。让我...

1164
01:22:23,139 --> 01:22:27,779
哦，我希望这还不错。好的。因此，我们将使用Hive命令。

1165
01:22:32,179 --> 01:22:35,219
我们将使用Hive命令，我们将指示它使用

1166
01:22:35,220 --> 01:22:38,400
使用三个不同的客户。

1167
01:22:38,400 --> 01:22:40,699
因此，第一个客户是Netlerman客户端

1168
01:22:40,699 --> 01:22:43,420
这是我们要使用的执行客户端。

1169
01:22:43,420 --> 01:22:47,980
第二和第三个客户都是

1170
01:22:47,980 --> 01:22:52,980
共识层，但他们有

1171
01:22:53,079 --> 01:22:54,640
两个不同的责任。

1172
01:22:55,940 --> 01:22:59,740
Hive需要一个信标节点和验证器客户端

1173
01:22:59,740 --> 01:23:01,980
要为共识层部分运行。

1174
01:23:01,980 --> 01:23:03,820
这就是我们在这里指定的地方。

1175
01:23:03,819 --> 01:23:08,960
在这种情况下

1176
01:23:08,960 --> 01:23:14,699
棱镜然后价值被倾斜了棱镜的价值倾斜部分。然后我们

1177
01:23:14,699 --> 01:23:20,359
将指定一个模拟器，这是此标志在这里，然后我们是

1178
01:23:20,359 --> 01:23:25,380
将其用于Tenkun，这是我们拥有的最新模拟器

1179
01:23:25,380 --> 01:23:33,239
将其限制为单个...让我看看...

1180
01:23:33,239 --> 01:23:39,900
好的，如果您想知道我们正在运行的实际测试的名称

1181
01:23:39,900 --> 01:23:44,319
您可以进入模拟器，然后得到...例如，让我们去ET2和

1182
01:23:44,319 --> 01:23:49,680
让我们去丹康，让我们看套房。你实际上可以看

1183
01:23:49,680 --> 01:23:54,779
在这里。它将列出当前的所有测试

1184
01:23:54,779 --> 01:23:56,939
在此模拟器上运行。

1185
01:23:56,939 --> 01:24:04,819
然后，让我们去最简单的一个，即Denkun Testnet。

1186
01:24:04,819 --> 01:24:07,659
您可以看到这里的每个测试案例

1187
01:24:07,659 --> 01:24:10,979
将有一条特定的通用行，您可以复制糊状。

1188
01:24:10,979 --> 01:24:14,519
让我这样做。

1189
01:24:14,519 --> 01:24:15,819
这个破折号并不重要。

1190
01:24:15,819 --> 01:24:17,199
这可以删除。

1191
01:24:17,199 --> 01:24:20,920
让我们在这里复制粘贴。

1192
01:24:20,920 --> 01:24:23,359
让我们点击Enter以查看会发生什么。

1193
01:24:23,359 --> 01:24:26,039
发生的第一件事是蜂巢开始

1194
01:24:26,039 --> 01:24:29,139
它构建了一种称为蜂巢代理的东西。

1195
01:24:29,859 --> 01:24:30,619
这并不重要。

1196
01:24:30,759 --> 01:24:32,619
基本上就像一个中介

1197
01:24:32,619 --> 01:24:35,420
在执行客户和共识客户之间

1198
01:24:35,420 --> 01:24:36,779
和蜂巢服务器。

1199
01:24:37,619 --> 01:24:39,799
这里建立的第二件事，

1200
01:24:40,019 --> 01:24:41,479
我不能停下来。

1201
01:24:41,479 --> 01:24:45,239
构建的第二件事是执行客户端。

1202
01:24:45,380 --> 01:24:47,039
您可以在这里看到Nethermind正在建造

1203
01:24:47,039 --> 01:24:48,219
它正确构建了。

1204
01:24:50,719 --> 01:24:52,479
建立客户很重要

1205
01:24:52,479 --> 01:24:57,679
客户，因为您可以知道建筑物将为您提供我们的最新版本

1206
01:24:58,319 --> 01:25:03,759
试图测试。因此，在这种情况下，我们正在努力，不要介意最新的大师。所以也可能

1207
01:25:03,759 --> 01:25:08,799
包含错误，因为这不是版本，这是主人。所以显然有东西

1208
01:25:08,799 --> 01:25:16,239
每个客户的主分支可以包含错误，但这是蜂巢的目的

1209
01:25:16,239 --> 01:25:23,039
这些错误，因此这里重要的是使用最新的大师

1210
01:25:23,039 --> 01:25:29,119
共识客户共识层对不起，我们正在使用Prism，构建是同一件事吗

1211
01:25:29,119 --> 01:25:34,559
信标节点棱镜的价值要求我们使用的最新主人是

1212
01:25:34,559 --> 01:25:40,960
没有一个释放假设是更新的东西，它基本上只是一个更好的版本，所以

1213
01:25:40,960 --> 01:25:47,279
可能是块。最后，我们将构建此模拟器。所以在这里的模拟器

1214
01:25:47,279 --> 01:25:55,039
是我们指定的一个，但是我们在这里使用的标志是极限是一个标志

1215
01:25:55,039 --> 01:26:00,880
进入模拟器。因此，我们将该标志传递到模拟器中，以告诉它请不要

1216
01:26:00,880 --> 01:26:06,560
除了此特定测试外，还要运行其他任何内容。因此，它不会运行整个模拟器。

1217
01:26:06,560 --> 01:26:10,140
以及该模拟测试的直接能力

1218
01:26:10,140 --> 01:26:12,320
只是要运行这个单个测试。

1219
01:26:13,260 --> 01:26:14,160
现在它正在运行。

1220
01:26:14,420 --> 01:26:17,039
您会看到它开始了几件事。

1221
01:26:17,980 --> 01:26:19,980
目前正在运行

1222
01:26:19,980 --> 01:26:22,120
因为它在后台做事。

1223
01:26:22,539 --> 01:26:25,080
但是我们现在可以看到的，这很愚蠢，

1224
01:26:25,680 --> 01:26:28,900
是我们所有这些东西都在Docker中运行。

1225
01:26:29,560 --> 01:26:32,260
因此您可以看到我们已经产生了

1226
01:26:32,260 --> 01:26:34,039
两个不同的执行客户端

1227
01:26:34,039 --> 01:26:38,380
以及两个不同的验证者和培根客户

1228
01:26:38,380 --> 01:26:39,239
对于共识层。

1229
01:26:39,779 --> 01:26:42,640
原因是因为这是一个完整的测试网

1230
01:26:42,640 --> 01:26:43,619
我们正在使用的

1231
01:26:44,220 --> 01:26:47,260
通常，共识客户至少需要一个同行

1232
01:26:47,260 --> 01:26:49,539
知道一切都是理智的。

1233
01:26:50,699 --> 01:26:51,680
因为否则，

1234
01:26:52,579 --> 01:26:55,819
如果您没有任何单个对等点可以连接到

1235
01:26:55,819 --> 01:26:59,300
这意味着正在发生错误的事情。

1236
01:26:59,739 --> 01:27:02,960
因此，在这种情况下，我们实例化了两双所有内容

1237
01:27:02,960 --> 01:27:06,079
并让模拟器做事。

1238
01:27:06,520 --> 01:27:09,880
然后我们实际上可以进入文件。

1239
01:27:10,220 --> 01:27:13,460
我们可以使用一个模拟器日志文件来查看。

1240
01:27:14,159 --> 01:27:21,020
其中的主要输出是工作区中的日志。

1241
01:27:21,020 --> 01:27:25,560
因此，在您的本地主机中，在您拥有的高文件夹中

1242
01:27:25,819 --> 01:27:30,060
运行工作区时，您将看到此日志目录。

1243
01:27:30,279 --> 01:27:31,600
如果你来这里，

1244
01:27:31,600 --> 01:27:36,579
您将看到实际模拟器的输出。所以你会看到一切

1245
01:27:36,579 --> 01:27:42,020
发生在模拟器中。正在运行什么，正在做什么，要求什么。你一切

1246
01:27:42,020 --> 01:27:46,900
会在这里看到它。这只是一个创世纪文件。但是然后您可以在这里看到链条是

1247
01:27:46,900 --> 01:27:55,120
进展。因此，您可以看到模拟器，它做的工作之一就是保持

1248
01:27:55,120 --> 01:27:58,520
跟踪正在发生的一切。因此，它保持跟踪的第一件事是

1249
01:27:58,520 --> 01:27:59,800
链实际上正在发展。

1250
01:28:00,500 --> 01:28:04,140
因此，您可以看到我们正在从一个插槽跳到下一个插槽。

1251
01:28:04,520 --> 01:28:08,260
因此，四个，五个，头链正在变化。

1252
01:28:08,560 --> 01:28:10,500
这意味着正在生产块。

1253
01:28:11,280 --> 01:28:14,660
同时，背景中也有很多测试

1254
01:28:14,660 --> 01:28:16,380
这是发送块交易，

1255
01:28:16,980 --> 01:28:19,560
验证那些进入内部的块交易，

1256
01:28:19,860 --> 01:28:20,980
一切都很好。

1257
01:28:22,560 --> 01:28:25,680
我认为这是一个漫长的测试，因为它是最终确定的浪费。

1258
01:28:25,680 --> 01:28:29,079
因此，我们将把它包装在演示中。

1259
01:28:29,579 --> 01:28:30,700
否则将花费太长时间。

1260
01:28:32,820 --> 01:28:36,520
但是，是的，这基本上是如何的要点。

1261
01:28:36,600 --> 01:28:37,640
让我取消这个。

1262
01:28:39,800 --> 01:28:41,720
我认为还剩五分钟。

1263
01:28:44,340 --> 01:28:47,700
那么有任何问题吗？

1264
01:28:47,860 --> 01:28:49,480
还是我应该继续前进？

1265
01:28:50,200 --> 01:28:53,440
是的，让我们稍作疑问，我想。

1266
01:28:53,520 --> 01:28:55,200
因为很多，马里奥。

1267
01:28:55,199 --> 01:28:55,939
太感谢了。

1268
01:28:56,000 --> 01:28:57,319
顺便说一句，这太神奇了。

1269
01:28:57,800 --> 01:29:00,260
我喜欢现场会议和一切。

1270
01:29:00,399 --> 01:29:00,819
真的很棒。

1271
01:29:01,699 --> 01:29:03,139
是的，实际上回到了。

1272
01:29:03,260 --> 01:29:04,979
我想问一个有趣的问题。

1273
01:29:05,779 --> 01:29:12,739
因为执行规格测试具有依赖关系，获得了执行环境。

1274
01:29:13,319 --> 01:29:18,019
因此，问题就像，您对此进行了一些介绍，但是也许如果您可以详细说明。

1275
01:29:18,479 --> 01:29:23,599
因此，就像，如何，像我们一样，我想我们不认为GET没有错误。

1276
01:29:23,600 --> 01:29:27,180
那么，我们如何确定依赖性实际上是否存在错误？

1277
01:29:27,500 --> 01:29:28,660
我们如何处理？

1278
01:29:29,740 --> 01:29:34,100
是的，理想情况下，理想的情况是我们不依靠获得。

1279
01:29:34,180 --> 01:29:35,220
这就是事实。

1280
01:29:36,600 --> 01:29:43,760
因此，作为解决方法，我们正在努力拥有另一个执行客户端，

1281
01:29:43,860 --> 01:29:46,680
这只是面向规格的，称为ILTS。

1282
01:29:46,840 --> 01:29:48,720
这是执行规格回购。

1283
01:29:50,220 --> 01:29:51,660
理想情况下，我们不应该使用Get。

1284
01:29:51,659 --> 01:29:54,399
但是截至目前，我们确实取决于获得。

1285
01:29:54,960 --> 01:29:59,920
这没什么大不了的原因

1286
01:29:59,920 --> 01:30:05,159
是因为我们还验证了日期的结果。

1287
01:30:05,399 --> 01:30:07,479
因此，当我们编写测试时，我们必须非常小心

1288
01:30:07,479 --> 01:30:10,439
我们实际上验证了我们期望的一切。

1289
01:30:11,139 --> 01:30:12,840
我们唯一不详细介绍的事情

1290
01:30:12,840 --> 01:30:13,859
是气体消耗吗

1291
01:30:13,859 --> 01:30:16,000
因为在测试中正确进行真的很棘手。

1292
01:30:16,420 --> 01:30:19,300
它可以得到误报

1293
01:30:19,300 --> 01:30:20,899
而且它会产生很多噪音。

1294
01:30:20,899 --> 01:30:26,619
但是其他东西是存储的钥匙，我们实际上所有的值

1295
01:30:26,619 --> 01:30:35,779
当我们从Geth得到回应时，请验证它们，因此影响我们的虫子没有太多余地

1296
01:30:35,779 --> 01:30:41,339
在Geth中，我们不时获得我们在填写测试时确实在Geth中找到错误，然后我们

1297
01:30:41,339 --> 01:30:47,460
我们去报告它必须等到Geth主题修复这些主题以便我们能够生成

1298
01:30:47,460 --> 01:30:50,060
测试。还有其他

1299
01:30:50,060 --> 01:30:51,380
极少数情况，我们也

1300
01:30:51,380 --> 01:30:53,539
已经产生了完整

1301
01:30:53,539 --> 01:30:56,060
测试。我们有

1302
01:30:56,060 --> 01:30:58,180
固定装置，然后我们去

1303
01:30:58,180 --> 01:30:59,720
在其他客户端运行

1304
01:30:59,939 --> 01:31:01,199
然后我们有一个错误。

1305
01:31:02,159 --> 01:31:03,260
然后有时，

1306
01:31:04,000 --> 01:31:06,020
大多数情况下，这是一个错误

1307
01:31:06,020 --> 01:31:08,100
其他客户，但有时有

1308
01:31:08,100 --> 01:31:10,100
过去发生在过去，我们发现了一个错误

1309
01:31:10,100 --> 01:31:12,180
Geth另一个客户

1310
01:31:12,180 --> 01:31:15,140
成立。就是这样

1311
01:31:15,140 --> 01:31:16,000
一个阶梯式过程

1312
01:31:16,000 --> 01:31:20,560
截至目前。将来会变得更好，但是到目前为止，有些地方

1313
01:31:20,560 --> 01:31:22,779
我们必须非常小心。

1314
01:31:23,779 --> 01:31:28,479
我们验证的，我们让我们通过了什么。

1315
01:31:29,380 --> 01:31:31,840
例如，气体极限非常棘手。正如我说的，

1316
01:31:32,319 --> 01:31:35,840
这是我们让其他客户为我们验证的东西。

1317
01:31:38,739 --> 01:31:39,279
惊人的。

1318
01:31:40,039 --> 01:31:42,020
非常感谢您的解释。

1319
01:31:42,020 --> 01:31:53,640
例如，另一个问题是像EIP作者那样的建议，例如，对RPC方法进行了一些更改，而RPC方法不需要像状态过渡或其他任何更改。

1320
01:31:53,780 --> 01:31:57,440
例如，在RPC响应中添加一些额外的数据。

1321
01:31:57,440 --> 01:32:02,340
要比较不同实现的输出的方法是什么？

1322
01:32:02,520 --> 01:32:07,500
例如，哪些东西没有太多的开销？

1323
01:32:07,500 --> 01:32:11,159
因此，如果我正确理解，

1324
01:32:12,800 --> 01:32:17,720
因此，您可以测试RPC

1325
01:32:17,720 --> 01:32:21,539
而无需写我们刚才描述的测试。

1326
01:32:21,960 --> 01:32:23,579
因此，对于这种情况，

1327
01:32:24,000 --> 01:32:25,880
您将进入执行应用程序是存储库，

1328
01:32:26,619 --> 01:32:31,340
这是我刚刚瞥了一眼的一部分，

1329
01:32:31,600 --> 01:32:36,100
这是RPC测试的所在地。

1330
01:32:36,100 --> 01:32:43,180
那些RPC测试，它们非常非常独立，非常易于编写。

1331
01:32:44,300 --> 01:32:54,400
对于那些特定类型的VIP，我建议您进入执行APS存储库，只是给它看一看，看看测试，我们在这里测试的内容。

1332
01:32:54,820 --> 01:33:02,280
因此，如果您有一些内容可以介绍以太坊客户端的RPC，那么我认为这是一个起点，是执行APS存储库。

1333
01:33:03,460 --> 01:33:04,780
好吧，很棒。太感谢了。

1334
01:33:06,100 --> 01:33:24,480
是的。一个问题。回到您的示例，您进行的演示，有针对Opcodes的测试，即48个测试用例，就像每个OpCode三个。那么，我们在那里喜欢48例测试用例的情况是什么呢？

1335
01:33:24,479 --> 01:33:31,919
因此，我们有16个Opcodes，但是对于其中一个，我们生成了三种测试格式。

1336
01:33:32,399 --> 01:33:37,559
因此，状态测试格式，区块链测试格式和区块链测试蜂巢格式。

1337
01:33:38,199 --> 01:33:41,019
因此，每种格式都有自己的目的。

1338
01:33:41,019 --> 01:33:42,519
州测试非常独立。

1339
01:33:42,859 --> 01:33:48,279
在预状态中，只有一笔交易，即淘汰国家路线，检查。

1340
01:33:48,539 --> 01:33:48,939
就是这样。

1341
01:33:49,419 --> 01:33:53,079
客户可以消费的区块链测试，这是客户消费的。

1342
01:33:53,079 --> 01:33:58,119
只需检查块标头，一切都会过去。最后，包含所有内容的蜂巢测试。

1343
01:33:58,119 --> 01:34:03,479
就像所有内容一样来自共识层。这就是为什么我们有

1344
01:34:03,479 --> 01:34:10,680
三种不同的测试格式要消费并生成。我得到它。我得到它。和所有格式

1345
01:34:10,680 --> 01:34:19,800
很酷。惊人的。是的。还有一个问题。也许我们可以将这些结合起来。就像，什么是...

1346
01:34:19,800 --> 01:34:26,440
您发现在EL或CL中测试的最复杂的是什么是最重的，多少时间

1347
01:34:26,440 --> 01:34:34,199
实际上需要运行所有这些测试，例如测试反叉um我会说

1348
01:34:34,199 --> 01:34:38,739
这确实取决于第一个问题的so是什么是最复杂的

1349
01:34:38,739 --> 01:34:46,199
我认为互操作性尚未解决，这就是

1350
01:34:46,199 --> 01:34:47,539
在我看来，最复杂的部分。

1351
01:34:48,800 --> 01:34:51,619
EVM部分也很复杂，

1352
01:34:51,619 --> 01:34:53,079
但是以自己的方式。

1353
01:34:53,340 --> 01:34:54,559
有很多细微差别

1354
01:34:54,559 --> 01:34:55,679
您必须注意。

1355
01:34:56,019 --> 01:34:57,559
当您编写EVM测试时，

1356
01:34:57,699 --> 01:34:58,840
总是会发生，

1357
01:34:59,159 --> 01:35:01,319
哦，我忘记了EVM的这件事，

1358
01:35:01,619 --> 01:35:04,420
EVM在其他地方的这种副作用。

1359
01:35:04,739 --> 01:35:06,019
这影响了我的测试。

1360
01:35:06,559 --> 01:35:07,939
所以，您确实必须

1361
01:35:08,979 --> 01:35:11,179
好吧，您知道EVM的一切，

1362
01:35:11,420 --> 01:35:12,819
但这就像来回

1363
01:35:12,819 --> 01:35:14,739
然后去检查和规格，

1364
01:35:14,739 --> 01:35:16,319
黄纸和一切。

1365
01:35:16,460 --> 01:35:18,460
因此，这是一个非常非常漫长的过程。

1366
01:35:19,119 --> 01:35:21,199
真的很好，因为它很有意义。

1367
01:35:21,380 --> 01:35:23,819
一旦您完成EVM测试并完成了

1368
01:35:23,819 --> 01:35:25,300
而且它有效，真的很好

1369
01:35:25,300 --> 01:35:26,920
因为您知道一切都是正确的。

1370
01:35:27,659 --> 01:35:28,679
但这确实很复杂。

1371
01:35:29,139 --> 01:35:30,380
这很耗时。

1372
01:35:32,079 --> 01:35:35,019
另一部分，它需要多少？

1373
01:35:35,059 --> 01:35:35,719
这需要很多。

1374
01:35:36,079 --> 01:35:39,979
因此，取决于我们正在运行的硬件，

1375
01:35:41,239 --> 01:35:43,059
共识测试的问题，

1376
01:35:43,060 --> 01:35:47,080
EVM测试是每个测试实例化了一个完整的客户端。

1377
01:35:47,440 --> 01:35:48,900
然后您将其输入。

1378
01:35:49,140 --> 01:35:50,480
然后您指定输出。

1379
01:35:50,780 --> 01:35:51,760
所以这很耗时。

1380
01:35:52,260 --> 01:35:56,600
因此，我认为以太坊测试存储库中最多有10,000个测试。

1381
01:35:57,200 --> 01:35:59,860
在新的执行规范中，只有5,000个。

1382
01:36:00,920 --> 01:36:02,440
因此，要少得多。

1383
01:36:02,500 --> 01:36:03,700
我们可以平行这些。

1384
01:36:04,360 --> 01:36:06,100
所以我没有这个数字。

1385
01:36:06,240 --> 01:36:08,420
但是上次我测试时，还没有太长时间了。

1386
01:36:08,420 --> 01:36:11,420
也许五分钟到10分钟或其他

1387
01:36:11,420 --> 01:36:13,220
对于并行的执行幽灵

1388
01:36:13,220 --> 01:36:14,980
如果您的硬件肥胖。

1389
01:36:15,279 --> 01:36:16,619
否则，这将需要很长时间。

1390
01:36:17,380 --> 01:36:17,619
是的。

1391
01:36:19,680 --> 01:36:20,779
好吧，非常感谢。

1392
01:36:21,039 --> 01:36:21,760
那很有趣。

1393
01:36:22,880 --> 01:36:24,859
是的，下一个问题是关于

1394
01:36:24,859 --> 01:36:28,380
您如何将错误传达给客户团队？

1395
01:36:28,840 --> 01:36:30,600
我想从你的角度有所不同

1396
01:36:30,600 --> 01:36:32,140
作为一个测试团队，

1397
01:36:32,140 --> 01:36:34,880
但您也提到我们会得到

1398
01:36:34,880 --> 01:36:36,300
到Bug Bounties部分。

1399
01:36:36,460 --> 01:36:37,880
所以也许我会让你

1400
01:36:37,880 --> 01:36:38,720
进入这一点。

1401
01:36:39,539 --> 01:36:40,699
这很重要。

1402
01:36:40,940 --> 01:36:41,060
是的。

1403
01:36:41,119 --> 01:36:41,619
这取决于。

1404
01:36:41,739 --> 01:36:45,380
这实际上取决于错误的严重性。

1405
01:36:45,739 --> 01:36:50,960
如果我们找到影响任何实时网络的东西，那将是

1406
01:36:50,960 --> 01:36:52,720
非常，我们必须非常谨慎。

1407
01:36:53,539 --> 01:36:59,680
例如，通常当我们开发新的叉子时，我们正处于坎昆的开始。

1408
01:37:00,579 --> 01:37:01,720
这真的很容易。

1409
01:37:01,859 --> 01:37:06,560
就像提交问题和其他内容一样，因为没有坎昆的实时网络

1410
01:37:06,560 --> 01:37:07,440
那时。

1411
01:37:07,439 --> 01:37:08,699
所以这并不重要。

1412
01:37:08,979 --> 01:37:15,799
但是，我们越接近在任何现场网络中发布的坎昆，

1413
01:37:15,899 --> 01:37:19,979
提交问题时，我们必须越谨慎。

1414
01:37:20,479 --> 01:37:23,839
它到达我们仅将其传达给特定开发人员的地步

1415
01:37:23,839 --> 01:37:27,139
我们进行了特定的沟通。

1416
01:37:27,579 --> 01:37:31,500
而且有特殊的处理，您必须照顾

1417
01:37:31,500 --> 01:37:34,799
当我们提交可能有害的东西

1418
01:37:34,799 --> 01:37:35,659
用于实时网络。

1419
01:37:36,559 --> 01:37:37,159
是的。

1420
01:37:37,439 --> 01:37:49,119
酷酷酷嗯，太棒了，非常感谢您，我认为如果呃，我们就没有问题

1421
01:37:49,119 --> 01:37:54,319
没有人仍然可以随意问我们是随着时间的流逝，是的，我们应该

1422
01:37:54,319 --> 01:38:02,479
是的，我实际上还有几个幻灯片，我可以飞过你知道我们我们

1423
01:38:02,479 --> 01:38:05,379
我们都很高兴追随。

1424
01:38:05,379 --> 01:38:06,379
每个人都很兴奋。

1425
01:38:06,379 --> 01:38:08,079
因此，请随时使用我们的时间。

1426
01:38:08,079 --> 01:38:09,619
请注意自己的时间。

1427
01:38:09,619 --> 01:38:10,839
那么多少...

1428
01:38:10,839 --> 01:38:12,519
没问题。

1429
01:38:12,519 --> 01:38:14,239
前进。

1430
01:38:14,239 --> 01:38:15,239
让我们继续吧。

1431
01:38:15,239 --> 01:38:18,459
我将飞过幻灯片。

1432
01:38:18,459 --> 01:38:20,819
是的。

1433
01:38:20,819 --> 01:38:28,859
在我之前解释过的其他所有内容之后，我们仍然还有另一种测试方法

1434
01:38:28,859 --> 01:38:32,459
使用是实时测试网。

1435
01:38:32,460 --> 01:38:40,560
我们有Devnets，Shadowrub Forks和公共DEVNET，它们都发生在Mainnet版本之前。

1436
01:38:41,720 --> 01:38:44,399
因此，对于坎昆来说，主网将在三天内出现。

1437
01:38:44,420 --> 01:38:45,939
因此，所有这些已经过去了。

1438
01:38:46,199 --> 01:38:50,539
而且我们有许多不同的测试网的迭代。

1439
01:38:50,680 --> 01:38:52,199
第一个是Devnet。

1440
01:38:52,420 --> 01:38:59,480
就像我们经营着一条小链，并与客户的所有组合一起运行。

1441
01:38:59,479 --> 01:39:03,799
但这是一个非常有限的客户。

1442
01:39:03,899 --> 01:39:06,939
因此，我们每个链节点很少。

1443
01:39:07,339 --> 01:39:16,059
这样做的目的是测试新的概念证明。

1444
01:39:16,759 --> 01:39:19,219
例如，在斑点的一开始，

1445
01:39:19,219 --> 01:39:21,239
我认为这差不多两年前

1446
01:39:22,179 --> 01:39:23,859
DEVNets是第一个方法。

1447
01:39:24,139 --> 01:39:27,059
您启动，最低实施，

1448
01:39:27,060 --> 01:39:30,180
每个客户的出生概念中的功能。

1449
01:39:30,280 --> 01:39:32,440
然后，您启动一​​个带有测试网的测试网。

1450
01:39:32,900 --> 01:39:35,880
然后您看到，将东西发送到链条

1451
01:39:35,880 --> 01:39:38,820
并查看其行为方式，并验证其行为。

1452
01:39:39,520 --> 01:39:42,120
显然，这就是

1453
01:39:42,120 --> 01:39:45,120
当软件还没有准备好生产时。

1454
01:39:45,840 --> 01:39:47,320
所以这些都是非常短暂的

1455
01:39:47,320 --> 01:39:51,620
通常他们会掉下来，然后退出同步

1456
01:39:51,620 --> 01:39:53,200
发生了很多坏事。

1457
01:39:53,560 --> 01:39:55,120
但这就是他们的目的。

1458
01:39:55,119 --> 01:39:58,159
我们使用的另一件事是阴影叉。

1459
01:39:58,159 --> 01:40:02,019
这是DevOps团队提出的非常聪明的实施。

1460
01:40:02,260 --> 01:40:09,319
基本上，您有一个主网的克隆，但是在有限的节点上，

1461
01:40:09,479 --> 01:40:13,099
您可以配置它们以尽早激活即将到来的叉子。

1462
01:40:13,680 --> 01:40:17,039
因此，例如，在坎昆（Cancun）的情况下，我们同步一切。

1463
01:40:17,859 --> 01:40:24,699
但是，我认为，这种阴影叉从去年年初开始发生。

1464
01:40:24,699 --> 01:40:33,340
因此，我们正在运行的客户配置了，例如2023年6月20日，继续使用坎昆。

1465
01:40:33,659 --> 01:40:36,639
然后您同步，然后等待叉子发生。

1466
01:40:37,059 --> 01:40:37,880
您验证事情。

1467
01:40:38,279 --> 01:40:44,699
而且，这是您仍然可以与现有节点进行交流的好处。

1468
01:40:45,539 --> 01:40:47,699
因此，您可以从实时网络中获得交易。

1469
01:40:47,699 --> 01:40:56,380
因此，当您测试新功能时，您仍将获取一些信息，其中一些来自Mainnet中实际活动的交易。

1470
01:40:57,939 --> 01:41:00,420
因此，主要用斑点测试的一种非常好的方法。

1471
01:41:00,559 --> 01:41:01,699
这被很多使用了。

1472
01:41:02,619 --> 01:41:08,479
最后，已经被淘汰的公共测试网已经被淘汰了。

1473
01:41:09,340 --> 01:41:11,199
我们有Sepolia和Holesky。

1474
01:41:11,199 --> 01:41:16,079
他们都有不同的目的。

1475
01:41:17,279 --> 01:41:21,699
是的，大多数情况下是为了使应用程序

1476
01:41:21,979 --> 01:41:24,199
让他们能够测试他们的实现

1477
01:41:24,899 --> 01:41:29,819
关于叉子的新功能。

1478
01:41:30,559 --> 01:41:30,659
是的。

1479
01:41:32,760 --> 01:41:34,760
是的，我要快得很快

1480
01:41:34,760 --> 01:41:35,819
通过以太坊安全。

1481
01:41:36,979 --> 01:41:40,199
有一个以太坊安全组

1482
01:41:41,199 --> 01:41:42,960
在以太坊基金会。

1483
01:41:43,119 --> 01:41:46,119
他们非常致力于所有这些特定问题。

1484
01:41:47,500 --> 01:41:48,460
他们主要测试。

1485
01:41:48,880 --> 01:41:52,659
他们还执行测试，例如

1486
01:41:52,960 --> 01:41:55,119
拒绝服务攻击和所有这些东西，

1487
01:41:55,319 --> 01:41:58,079
那个复杂的东西成为安全问题。

1488
01:41:58,079 --> 01:42:03,079
他们是最适合回应的人

1489
01:42:03,079 --> 01:42:05,500
对于您对安全性的大多数问题。

1490
01:42:05,899 --> 01:42:08,159
但是我要仔细研究一下。

1491
01:42:08,159 --> 01:42:25,380
例如，在执行层侧中可能出错的主要因素是，当客户确实喜欢使一个完全符合以太坊规范的块无效时。

1492
01:42:26,099 --> 01:42:29,079
这意味着我有一个正确的块。

1493
01:42:29,460 --> 01:42:32,399
然后，由于某种原因，我的客户决定这是不正确的。

1494
01:42:32,559 --> 01:42:33,800
然后它只是拒绝它。

1495
01:42:33,800 --> 01:42:37,079
这意味着所有运行该客户的人，

1496
01:42:37,199 --> 01:42:37,720
那个特定的客户，

1497
01:42:37,820 --> 01:42:39,820
将与网络不同步

1498
01:42:39,820 --> 01:42:41,260
并进入叉子。

1499
01:42:42,900 --> 01:42:44,039
有很多变量

1500
01:42:44,039 --> 01:42:45,980
很多事情会发生

1501
01:42:45,980 --> 01:42:49,880
取决于分布的重量

1502
01:42:49,880 --> 01:42:53,320
关于有多少人经营那个实际客户。

1503
01:42:54,440 --> 01:42:55,800
我不会详细介绍，

1504
01:42:55,800 --> 01:42:58,739
但这是可能的事情之一。

1505
01:43:00,140 --> 01:43:01,800
另外，发生的另一件事，

1506
01:43:01,800 --> 01:43:04,199
因此，您有一个有效的...

1507
01:43:04,199 --> 01:43:05,840
老实说，这有点糟糕。

1508
01:43:06,440 --> 01:43:10,100
这是您的客户收到无效的球锁的时候

1509
01:43:10,100 --> 01:43:12,640
您将其传递给有效。

1510
01:43:12,779 --> 01:43:16,039
这更糟，因为您正在验证某些东西

1511
01:43:16,039 --> 01:43:17,360
那是不合规的。

1512
01:43:17,360 --> 01:43:18,340
这很冒险。

1513
01:43:19,400 --> 01:43:22,520
这是我们特别注意的

1514
01:43:22,520 --> 01:43:26,440
当我们在测试存储库中设计测试时。

1515
01:43:27,400 --> 01:43:30,119
另外，另一个例子是拒绝服务

1516
01:43:30,119 --> 01:43:31,500
在执行球期间。

1517
01:43:31,800 --> 01:43:34,400
因此，如果客户只需进行交易或块

1518
01:43:34,400 --> 01:43:36,880
而且执行需要很多时间，

1519
01:43:37,220 --> 01:43:39,579
这也可以被视为拒绝服务。

1520
01:43:40,560 --> 01:43:43,600
这是我们可能存在的另一个可能的安全问题。

1521
01:43:44,699 --> 01:43:46,079
在共识层侧，

1522
01:43:46,640 --> 01:43:51,880
不同的是，取决于故障节点，

1523
01:43:52,400 --> 01:43:53,500
您拥有的故障节点，

1524
01:43:53,539 --> 01:43:56,579
例如，您的客户不到32％

1525
01:43:57,239 --> 01:43:58,640
这是不当行为的

1526
01:43:58,640 --> 01:44:03,560
而且由于任何原因，他们都没有遵循定理共识规范。

1527
01:44:05,619 --> 01:44:10,740
少于33％的方案最少。

1528
01:44:11,140 --> 01:44:16,360
因此，您可能会错过老虎机，而您的连锁店会错过一些证明。

1529
01:44:16,700 --> 01:44:20,200
您会看到一些打ic，但是什么都不会发生。

1530
01:44:20,200 --> 01:44:21,880
链条仍将最终确定。

1531
01:44:22,020 --> 01:44:24,160
因此，一切都好像什么都没发生。

1532
01:44:24,159 --> 01:44:28,439
如果您有33％或以上的大多数百分比，

1533
01:44:29,180 --> 01:44:31,439
如果客户失败，您可能会导致

1534
01:44:31,680 --> 01:44:33,059
您可能会导致延迟最终性。

1535
01:44:33,279 --> 01:44:35,019
所以发生的是链，

1536
01:44:35,220 --> 01:44:38,960
如果有分裂和33％的客户

1537
01:44:38,960 --> 01:44:39,880
穿过这条路线，

1538
01:44:40,359 --> 01:44:43,460
这意味着主链不会最终确定。

1539
01:44:44,300 --> 01:44:47,720
所以这很糟糕，但这是非常可恢复的。

1540
01:44:47,720 --> 01:44:50,539
它不如其他人那么糟糕。

1541
01:44:51,519 --> 01:44:53,579
50％或以上，您可以破坏叉子的选择。

1542
01:44:53,579 --> 01:44:56,720
这意味着您有50-50％的节点，

1543
01:44:56,979 --> 01:45:01,100
那么您将破坏客户的行为

1544
01:45:01,100 --> 01:45:03,840
以及客户如何选择要遵循的链条，

1545
01:45:04,359 --> 01:45:07,640
取决于大多数客户是什么。

1546
01:45:08,680 --> 01:45:10,600
而且您拥有最后一个也是最重要的

1547
01:45:10,600 --> 01:45:14,600
是66％或以上的默认客户端。

1548
01:45:15,500 --> 01:45:18,199
这意味着您拥有较高的客户

1549
01:45:18,199 --> 01:45:19,720
由于同样的事情而失败，

1550
01:45:19,920 --> 01:45:21,920
这意味着他们可以最终确定链条。

1551
01:45:21,920 --> 01:45:28,960
这是我们在与安全有关的问题中可以找到的最风险的行为。这很糟糕。

1552
01:45:29,920 --> 01:45:38,000
它可能需要某种干预。目前我认为我没有能力

1553
01:45:38,000 --> 01:45:43,199
解释在这种情况下会发生什么，但这是我们将要发生的事情之一

1554
01:45:43,199 --> 01:45:51,039
总是必须考虑。这就是为什么我们在考虑启动之前进行大量测试

1555
01:45:51,039 --> 01:45:57,699
域名，如果您喜欢这样，我们就会有后卫团队

1556
01:45:57,699 --> 01:46:05,920
像安全性一样，您有意在软件中找到安全问题

1557
01:46:05,920 --> 01:46:10,600
这是一个可以发光的地方，您可以进入赏金赏金定理

1558
01:46:10,600 --> 01:46:15,560
然后，如果您发现可以清楚的东西，并且可以得到一个不错的赏金

1559
01:46:15,560 --> 01:46:20,200
确实可以破坏实时网络。

1560
01:46:21,640 --> 01:46:26,039
并获取所有以前的公开披露的例子

1561
01:46:26,039 --> 01:46:27,160
过去发生的

1562
01:46:27,420 --> 01:46:28,680
您可以进入此存储库，

1563
01:46:29,140 --> 01:46:34,039
其中包含实际记录的安全问题

1564
01:46:34,039 --> 01:46:37,080
发生的那是，对不起，

1565
01:46:37,700 --> 01:46:41,020
过去，你打的可能不是因为有赏金

1566
01:46:41,020 --> 01:46:43,840
他们被私下披露。

1567
01:46:43,840 --> 01:46:49,319
这张幻灯片的主要鼓励是不要试图...如果您找到了东西

1568
01:46:49,319 --> 01:46:55,600
您认为被干扰了，进入这里。您会收到赏金，您将

1569
01:46:55,600 --> 01:47:01,600
不要以任何方式损害网络。所以这是一个...就像白帽

1570
01:47:01,600 --> 01:47:08,360
情况。基本上就是这样。那是我的演讲。如果你有

1571
01:47:08,359 --> 01:47:10,159
有问题吗？

1572
01:47:10,159 --> 01:47:11,960
这些是我的手柄。

1573
01:47:11,960 --> 01:47:14,539
Twitter，github。

1574
01:47:14,539 --> 01:47:17,979
如果你们有兴趣测试，那就打我。

1575
01:47:17,979 --> 01:47:19,939
如果您有问题，我会回答更多问题。

1576
01:47:25,639 --> 01:47:27,659
再次非常感谢，马里奥。

1577
01:47:27,659 --> 01:47:29,159
很棒的东西。

1578
01:47:29,159 --> 01:47:29,920
是的。

1579
01:47:29,920 --> 01:47:35,460
让我检查我们是否有一些结束问题。

1580
01:47:35,460 --> 01:47:37,000
但是我认为我们很好，伙计。

1581
01:47:37,000 --> 01:47:41,439
因为我们大约15分钟了，所以您为我们度过了很多美好的时光。

1582
01:47:41,979 --> 01:47:43,500
你给了我们很多，伙计。

1583
01:47:43,659 --> 01:47:48,560
我认为人们还必须再次查看演示文稿，以获取那里的所有细节。

1584
01:47:49,460 --> 01:47:51,399
伙计，这很激烈。

1585
01:47:51,520 --> 01:47:51,939
很长。

1586
01:47:52,039 --> 01:47:53,359
所以我真的很感谢你的时间。

1587
01:47:53,880 --> 01:47:54,699
真的很棒。

1588
01:47:56,119 --> 01:47:56,560
是的。

1589
01:47:57,619 --> 01:47:58,060
是的。

1590
01:47:58,060 --> 01:47:58,720
太感谢了。

1591
01:47:58,880 --> 01:48:00,000
我也学到了很多。

1592
01:48:00,000 --> 01:48:01,859
是的。

1593
01:48:01,859 --> 01:48:13,679
是的。也许，如果您可以指出想要学习并开始以某种有意义的方式贡献的人，那么您指出的地方是什么？

1594
01:48:15,359 --> 01:48:20,719
我们需要在您在本演示文稿中看到的任何存储库中的帮助。

1595
01:48:20,939 --> 01:48:24,659
无论您最能激发您的兴趣，我认为这是您可以开始的最好的地方。

1596
01:48:25,639 --> 01:48:26,519
欢迎一切。

1597
01:48:26,979 --> 01:48:28,579
您也可以开始...

1598
01:48:28,579 --> 01:48:30,239
所有存储库都有

1599
01:48:31,260 --> 01:48:35,519
通常，发布问题是第一个好问题。

1600
01:48:35,519 --> 01:48:38,559
这是每个存储库中开始的地方。

1601
01:48:38,559 --> 01:48:39,399
我会确保

1602
01:48:39,399 --> 01:48:44,079
因为我们拥有我们维护的执行幽灵。

1603
01:48:44,079 --> 01:48:45,960
我将确保此后

1604
01:48:45,960 --> 01:48:49,279
我们将尝试考虑许多第一个好的新问题

1605
01:48:49,279 --> 01:48:50,760
将它们设置在执行幽灵中

1606
01:48:50,760 --> 01:48:51,699
如果你想去那里。

1607
01:48:51,699 --> 01:48:53,000
或者你也有。

1608
01:48:53,000 --> 01:48:55,939
我将确保新的东西弹出。

1609
01:48:55,939 --> 01:49:02,639
惊人的。是的。是的。再次非常感谢。像马里奥一样真是太好了

1610
01:49:02,639 --> 01:49:09,299
在APSG中串联。所以，这很有趣。我想，是的，我们会的，我们会包裹

1611
01:49:09,299 --> 01:49:18,460
起来。是的。就像您在Discord服务器中一样。所以，如果人们在那里打扰你

1612
01:49:18,460 --> 01:49:24,219
借口，但我想他们可能有一些确切的问题。是的。再次非常感谢。和

1613
01:49:24,220 --> 01:49:28,060
是的，非常感谢您所有一直关注的人问问题。

1614
01:49:28,060 --> 01:49:30,400
这是一个激烈的人。

1615
01:49:30,400 --> 01:49:34,260
所以下周我会见大家。

1616
01:49:34,260 --> 01:49:35,260
是的。

1617
01:49:35,260 --> 01:49:36,260
Ciao。

1618
01:49:36,260 --> 01:49:37,260
谢谢。

1619
01:49:37,260 --> 01:49:38,260
是的。

1620
01:49:38,260 --> 01:49:39,260
祝你有美好的一天。

1621
01:49:39,260 --> 01:49:40,260
再次非常感谢。

1622
01:49:40,260 --> 01:49:40,260
1623年

1623
01:50:24,220 --> 01:50:26,220
所以

