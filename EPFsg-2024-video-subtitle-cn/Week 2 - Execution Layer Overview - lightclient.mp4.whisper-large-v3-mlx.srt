1
00:00:00,000 --> 00:00:13,400
好的，大家。感谢您加入我们。欢迎回到以太坊协议研究小组。

2
00:00:13,939 --> 00:00:24,780
这是10周的第二周。今天，我们将与Core Developer Lightclient谈论执行层。

3
00:00:24,780 --> 00:00:31,440
因此，我将继续前进，让Mario为我们介绍Matt，我们将在这里滚动。

4
00:00:32,980 --> 00:00:36,579
嘿，大家。嘿，马特。非常感谢您加入。非常感谢您的到来。

5
00:00:37,340 --> 00:00:39,620
你能听到我吗？

6
00:00:40,240 --> 00:00:41,400
我听到你的声音。

7
00:00:42,320 --> 00:00:45,100
是的。非常感谢您在这里，伙计。真的很感激。

8
00:00:45,460 --> 00:00:50,900
对于任何不认识Matt或Lightclan的人来说，他不仅是核心开发人员。

9
00:00:50,899 --> 00:00:55,140
他是Goethereum团队的一员，不仅仅是Goethereum。

10
00:00:55,939 --> 00:00:59,379
还有一些测试，EIP编辑。

11
00:00:59,379 --> 00:01:18,259
通常，

12
00:01:18,260 --> 00:01:20,100
就像多年的常见障碍一样。

13
00:01:20,500 --> 00:01:25,520
今天将使我们深入研究执行层理论

14
00:01:25,520 --> 00:01:28,219
在与定理中一起使用并实施的。

15
00:01:29,660 --> 00:01:33,859
如果您有任何疑问，您想

16
00:01:34,160 --> 00:01:37,600
我喜欢澄清一下我们已经拥有的东西

17
00:01:37,600 --> 00:01:40,060
过去一周中提出了一些问题。

18
00:01:40,900 --> 00:01:45,020
因此，如果您准备好了，请随时将它们发布到相应的

19
00:01:45,019 --> 00:01:52,219
不和谐线程，当有一个空间时，我们会问它，我们会问马特

20
00:01:52,219 --> 00:01:56,439
再次感谢你在这里，我真的很感激，地板是你的

21
00:01:56,439 --> 00:02:07,159
很酷，你们能听到我的声音吗？

22
00:02:07,159 --> 00:02:10,240
就通过不和谐而向您求助于您，您会问他们

23
00:02:10,240 --> 00:02:17,760
酷了，非常感谢我让我我很高兴与所有人谈论执行

24
00:02:17,760 --> 00:02:25,400
层我会通过不和谐吧，是的，所以我有一些笔记准备遍历

25
00:02:25,400 --> 00:02:32,719
执行层的概述以某种简单的术语，但是如果您有疑问，请

26
00:02:32,719 --> 00:02:37,939
随意将它们发布在Discord Josh和Mario上，随时可以打扰我，我想要

27
00:02:37,939 --> 00:02:45,439
为了确保我们都在同一页面上。这样，让我分享我的屏幕。

28
00:02:46,139 --> 00:02:58,060
我们可以继续前进。所以我想出了一些轮廓

29
00:02:58,060 --> 00:03:04,620
讨论有一点结构。我想做的第一件事就是

30
00:03:04,620 --> 00:03:10,860
我看到执行层具有的主要作品的概述。然后我们可以潜水

31
00:03:10,860 --> 00:03:17,659
深入到这些特定元素中的每个元素中。因此，让我们开始。假设这是

32
00:03:17,659 --> 00:03:28,060
第二周讲座。我想谈论的第一件事是我想谈谈

33
00:03:28,060 --> 00:03:31,240
执行层的块验证方面。

34
00:03:34,120 --> 00:03:38,180
通过合并，我们已经改变了角色

35
00:03:38,180 --> 00:03:39,960
执行层在以太坊中

36
00:03:39,960 --> 00:03:42,640
在一切都包含之前。

37
00:03:42,740 --> 00:03:45,580
它正在达成链条的共识。

38
00:03:45,699 --> 00:03:48,280
它正在确保链的完整性。

39
00:03:48,420 --> 00:03:51,340
它确保块

40
00:03:51,340 --> 00:03:53,080
以正确的方式订购

41
00:03:53,259 --> 00:03:55,159
那个重新发生的正确发生了

42
00:03:55,420 --> 00:03:57,180
以及所有这些类型的事物。

43
00:03:57,180 --> 00:04:01,280
合并后，所有这些都被外包到了共识层。

44
00:04:01,580 --> 00:04:06,819
在这一点上，执行层的作用变得更加简化。

45
00:04:07,219 --> 00:04:11,300
因此，我喜欢将其视为执行状态过渡功能。

46
00:04:11,879 --> 00:04:14,080
我们将讨论它的外观。

47
00:04:14,460 --> 00:04:26,620
但是，只是为了具体说明，我们实际上可以在共识规格中看到共识层如何对执行层的思考。

48
00:04:26,620 --> 00:04:34,379
因此，如果我们去共识规范，并且看Deneb Beacon链，我们实际上可以

49
00:04:34,379 --> 00:04:40,199
直接进一步看一下，我认为它已验证并通知有效载荷。

50
00:04:42,439 --> 00:04:44,319
实际执行有效载荷。

51
00:04:45,280 --> 00:04:48,180
因此，有一个称为过程执行有效载荷的函数

52
00:04:48,180 --> 00:04:53,980
这是由信标连续进行的

53
00:04:53,980 --> 00:04:57,379
所有其他验证都需要做的

54
00:04:57,379 --> 00:04:59,319
验证块是有效的

55
00:04:59,319 --> 00:05:01,120
并向前移动共识层。

56
00:05:01,840 --> 00:05:06,040
因此，执行层实际上已经体现了

57
00:05:06,040 --> 00:05:08,379
通过此功能就在这里。

58
00:05:08,379 --> 00:05:13,280
而且有很多不同的复杂性

59
00:05:13,280 --> 00:05:15,300
如何交流这些东西。

60
00:05:15,360 --> 00:05:16,319
你可以看到这个

61
00:05:16,319 --> 00:05:18,020
使用此执行引擎概念。

62
00:05:18,020 --> 00:05:20,160
这就是我们交流的方式

63
00:05:20,160 --> 00:05:23,700
从共识层执行层。

64
00:05:23,699 --> 00:05:27,439
但实际上您能想到的是我们进行一些高级检查，

65
00:05:27,479 --> 00:05:29,939
确保某些事情之类的东西是正确的。

66
00:05:30,060 --> 00:05:31,699
这是链的下一个块。

67
00:05:32,459 --> 00:05:35,980
验证一些事情，例如时间戳，其他一些东西，您知道，

68
00:05:35,980 --> 00:05:37,240
轻量级验证。

69
00:05:38,039 --> 00:05:43,560
然后我们将有效载荷发送到执行层，并验证

70
00:05:43,560 --> 00:05:43,899
堵塞。

71
00:05:44,219 --> 00:05:51,120
我们实际上可以看到信标链中最低的功能

72
00:05:51,120 --> 00:05:53,399
与通知新有效载荷与执行层进行交互。

73
00:05:53,699 --> 00:06:07,019
因此，通知新有效载荷。共识层的规格中没有实现，因为它的作用只是将执行有效载荷发送给执行引擎，即执行client。

74
00:06:07,639 --> 00:06:11,039
然后执行客户端执行状态过渡功能。

75
00:06:11,039 --> 00:06:20,719
它验证了块标头的校正，验证交易是否正确地应用于状态，并将返回真或错误。

76
00:06:20,720 --> 00:06:26,640
因此，就共识层如何看待执行层而言，这确实很简单。

77
00:06:28,060 --> 00:06:33,500
因此，从共识层的角度来看，这就是块验证。

78
00:06:33,900 --> 00:06:40,380
让我们看一下从实际执行层高级别的块验证的外观。

79
00:06:40,980 --> 00:06:42,160
所以我要在旅途中写这篇文章。

80
00:06:42,340 --> 00:06:44,000
这将是超级直接的。

81
00:06:44,440 --> 00:06:46,720
真的没有特别的事情。

82
00:06:46,720 --> 00:06:52,180
但是，如果您对某些语法的含义有疑问，请随时跳入，但基本上您可以

83
00:06:52,180 --> 00:06:58,180
考虑一下阶段过渡功能，我将将其简化为STF，以获取一些参数

84
00:06:58,180 --> 00:07:05,340
对于执行层所采用的确切而言，这并不是完美的，而是说明性的

85
00:07:05,340 --> 00:07:10,340
目的我认为这是考虑它的最简单方法，以便我们占据父母。

86
00:07:10,340 --> 00:07:15,840
因为我们将不得不验证从父母到那的一些过渡逻辑

87
00:07:15,839 --> 00:07:23,519
到当前块。然后，我们将接收当前的块。我们将接受状态数据库。

88
00:07:24,799 --> 00:07:32,719
因此，状态数据库基本上是在目前存储所有状态数据的原因，

89
00:07:32,719 --> 00:07:37,759
或者我猜在父母块中。这是最后一个已知的有效状态。以及我们会的

90
00:07:37,759 --> 00:07:45,120
返回是我们将返回另一个状态数据库，因为这将是更新的状态和错误。所以

91
00:07:45,120 --> 00:07:50,100
因此，如果此功能失败，我们希望返回错误，而不是更新状态

92
00:07:50,100 --> 00:07:52,980
DB。

93
00:07:52,980 --> 00:07:57,540
好的。

94
00:07:57,540 --> 00:08:01,439
因此，我们要做的第一件事是我们必须验证标题。

95
00:08:01,439 --> 00:08:05,379
当我们实际进行实施并进行定理时，我们会更近一点。

96
00:08:05,379 --> 00:08:13,000
但是我只是在这里说，如果我们在验证标题时出现错误

97
00:08:13,000 --> 00:08:19,459
然后，我们通过父母和街区。

98
00:08:19,459 --> 00:08:24,879
然后，我们只想返回不更新的状态，我们将返回错误。

99
00:08:24,879 --> 00:08:33,840
基本上，这意味着检测到标题错误。

100
00:08:33,840 --> 00:08:39,340
因此，相对于标题失败的一个例子。

101
00:08:39,340 --> 00:08:44,200
我猜一个有趣的例子是有很多历史相关性的是气体限制。

102
00:08:44,480 --> 00:08:47,320
因此，今天我们的气体限额约为3000万。

103
00:08:47,700 --> 00:08:52,820
气体限制实际上是在执行中并不硬编码的东西

104
00:08:52,820 --> 00:08:53,379
在任何地方。

105
00:08:53,800 --> 00:08:57,340
有一种机制可以阻止生产商来改变气体限制。

106
00:08:57,340 --> 00:09:02,620
因此，他们实际上有能力将气体限制更改约一个10，一个10

107
00:09:03,100 --> 00:09:04,740
一个10 24。

108
00:09:04,740 --> 00:09:09,700
因此，如果气体限制为3000万，您可以将其增加一小部分。

109
00:09:10,379 --> 00:09:15,320
因此，如果您将气体限制从3000万块增加到4000万，您知道，

110
00:09:15,360 --> 00:09:20,440
在一个单个块的过程中，标题验证将失败，因为您会

111
00:09:20,440 --> 00:09:24,159
超过了1024次分数更新。

112
00:09:25,259 --> 00:09:29,779
出现问题的另一个可能性是您可以拥有块

113
00:09:29,779 --> 00:09:32,919
数字不是顺序的。

114
00:09:32,919 --> 00:09:35,819
这可能应该被抓住在信标链上

115
00:09:35,819 --> 00:09:40,019
也可以在验证标头中发生，但也可能发生。

116
00:09:41,120 --> 00:09:45,860
1559的基本费用需要根据上次正确更新

117
00:09:45,860 --> 00:09:47,620
使用气体与气体极限。

118
00:09:47,979 --> 00:09:50,139
因此，其中有很多类型的事情正在发生。

119
00:09:51,719 --> 00:09:52,299
坚持，稍等。

120
00:09:52,339 --> 00:09:54,139
我的猫现在正在吃脚。

121
00:09:54,939 --> 00:09:55,419
不。

122
00:09:58,279 --> 00:09:58,879
嘿，马特。

123
00:09:58,879 --> 00:09:59,059
好的。

124
00:09:59,480 --> 00:09:59,639
是的。

125
00:10:00,279 --> 00:10:01,099
只是一秒钟。

126
00:10:01,100 --> 00:10:04,659
您可以放大IDE，以便我们在屏幕上更清楚地看到吗？

127
00:10:05,000 --> 00:10:05,180
是的。

128
00:10:06,820 --> 00:10:07,500
那怎么样？

129
00:10:08,440 --> 00:10:09,159
更好。

130
00:10:09,300 --> 00:10:09,460
谢谢。

131
00:10:10,200 --> 00:10:10,480
好的。

132
00:10:11,960 --> 00:10:13,460
这就是验证标题。

133
00:10:13,659 --> 00:10:18,820
一旦我们验证了标头，我们将假设标题是正确的，并且环境

134
00:10:18,820 --> 00:10:24,840
标题指定是交易应运行的环境。

135
00:10:25,220 --> 00:10:28,460
因此，从那里，您实际上只需应用交易即可。

136
00:10:28,460 --> 00:10:35,800
因此，我想在这里做的是在块交易上说范围。

137
00:10:40,420 --> 00:10:45,519
因此，这只会使我们对块中的每笔交易进行循环。

138
00:10:45,740 --> 00:10:48,120
对于每次交易，我们需要执行它。

139
00:10:48,200 --> 00:10:55,220
因此，我们会说我们将通过虚拟机（即EVM）运行。

140
00:10:58,460 --> 00:11:03,879
因此，我要给它一个块标头，因为在EVM中，您需要知道

141
00:11:03,879 --> 00:11:11,940
该块之所以出现，是因为有指令，例如Coinbase，燃气限制或时间戳。

142
00:11:11,940 --> 00:11:15,740
而且，您需要在执行该交易时需要知道这些值是什么。

143
00:11:16,100 --> 00:11:19,280
因此，我们将通过标头传递，然后将其提供给交易，然后

144
00:11:19,280 --> 00:11:20,019
我们会给它国家。

145
00:11:20,019 --> 00:11:30,699
我们会说，如果此功能失败，我们只需要再次返回错误即可。在这种情况下，

146
00:11:30,759 --> 00:11:38,399
问题是交易实际上是无效的。因此，块无效。

147
00:11:41,139 --> 00:11:47,639
在执行层中，不可能在块内实现无效的事务。

148
00:11:47,639 --> 00:11:49,759
如果块内有无效的东西

149
00:11:49,759 --> 00:11:52,000
整个块的毒药

150
00:11:52,000 --> 00:11:53,480
并使它无效。

151
00:11:55,500 --> 00:11:57,759
如果该交易正确，

152
00:11:57,840 --> 00:12:00,519
我们将通过结果Res更新状态。

153
00:12:01,620 --> 00:12:05,019
这几乎就是这样

154
00:12:05,019 --> 00:12:07,179
就状态过渡函数而言。

155
00:12:07,419 --> 00:12:12,059
如果我们实际上通过整个交易列表来完成

156
00:12:12,059 --> 00:12:15,240
我们可以返回最终的累积状态，

157
00:12:15,279 --> 00:12:17,600
所有交易都适用于其。

158
00:12:17,639 --> 00:12:31,480
然后是信标链，您可能会围绕此包装功能。

159
00:12:31,480 --> 00:12:40,299
该执行有效载荷。

160
00:12:40,299 --> 00:12:43,960
这将归还我们的布尔。

161
00:12:43,960 --> 00:12:45,560
因此，我们将布尔归还给信标连锁店

162
00:12:45,560 --> 00:12:48,759
它将调用其中的状态过渡功能。

163
00:12:49,100 --> 00:12:50,540
所以我不会把整个事情写出来。

164
00:12:50,660 --> 00:12:52,360
但我基本上会说，

165
00:12:53,259 --> 00:12:58,360
如果没有错误，

166
00:12:59,379 --> 00:13:00,460
抱歉，如果有错误，

167
00:13:01,240 --> 00:13:03,480
返回false，否则返回true。

168
00:13:09,080 --> 00:13:09,560
好的。

169
00:13:09,560 --> 00:13:12,980
因此，信标链本质上是在呼唤

170
00:13:12,980 --> 00:13:21,539
一些功能新的有效载荷。然后我们呼吁执行方我们的状态过渡功能

171
00:13:21,539 --> 00:13:27,379
使用执行有效载荷中的信息。如果状态过渡函数没有错误，

172
00:13:27,379 --> 00:13:37,460
我们将返回真实。如果确实错误，我们返回false。有关此块验证的任何问题

173
00:13:37,460 --> 00:13:37,940
概述。

174
00:13:42,940 --> 00:13:45,480
我们有几个问题。

175
00:13:48,040 --> 00:13:48,240
是的。

176
00:13:48,240 --> 00:13:50,240
发生了什么...

177
00:13:51,980 --> 00:13:54,259
你为什么通过

178
00:13:54,259 --> 00:13:56,360
块标题进入VM.RUN？

179
00:13:58,019 --> 00:14:00,200
所以在内部

180
00:14:00,200 --> 00:14:01,960
块标头是所有信息。

181
00:14:02,360 --> 00:14:04,180
所以我的意思是，有两个

182
00:14:04,180 --> 00:14:06,420
执行交易时需要的上下文。

183
00:14:06,419 --> 00:14:17,259
第一个显然是状态，因为该州具有您要执行的合同代码之类的东西，该帐户中可能正在操纵或阅读的存储。

184
00:14:17,519 --> 00:14:23,559
但是您还需要上下文，即交易正在执行的块上下文。

185
00:14:24,219 --> 00:14:27,659
因此，我提到了几个例子，但还有一些例子。

186
00:14:28,299 --> 00:14:33,319
您可能需要访问以前的randow值或块哈希。

187
00:14:33,320 --> 00:14:36,400
这是为了给你某种随机性

188
00:14:36,400 --> 00:14:37,560
在虚拟机中

189
00:14:37,560 --> 00:14:42,620
您可能想获得基本费用

190
00:14:42,620 --> 00:14:44,379
基本费用在块标题内

191
00:14:44,379 --> 00:14:46,580
在交易执行中

192
00:14:46,580 --> 00:14:48,160
您可以致电基本费用opcode

193
00:14:48,160 --> 00:14:50,960
因此，该价值将需要以某种方式填充

194
00:14:50,960 --> 00:14:52,640
因此，我的原因是我通过标题

195
00:14:52,640 --> 00:14:54,840
是填充这些环境价值观

196
00:14:54,840 --> 00:14:57,440
是的，谢谢

197
00:14:57,440 --> 00:15:07,700
因此，说话过渡功能由共识层调用，无论其有效是否有效。

198
00:15:08,500 --> 00:15:11,960
如果无效，CL会发生什么？

199
00:15:14,420 --> 00:15:18,680
因此，如果它在CL上无效，则该块将被拒绝。

200
00:15:19,620 --> 00:15:22,720
我们也许可以非常迅速地看待这一点。

201
00:15:27,440 --> 00:15:32,740
嗯，这是过程执行有效载荷。

202
00:15:47,520 --> 00:15:55,620
因此，在这里，信标规格的作品的方式是使用断言来验证

203
00:15:55,620 --> 00:16:02,700
某些属性是他们所期望的。而且因为我们说此功能验证并通知新功能

204
00:16:02,700 --> 00:16:10,139
有效载荷回报布尔值，它试图断言该价值将是真实的，意思是

205
00:16:10,139 --> 00:16:16,240
我们在状态过渡功能中正确验证了该块。如果是错误的，你失败了

206
00:16:16,240 --> 00:16:20,960
并断言信标规范，这基本上意味着拒绝块。不是真的

207
00:16:20,960 --> 00:16:26,100
也许不清楚该机械如何从规格中起作用，但这通常就是这样

208
00:16:26,100 --> 00:16:36,320
在这种情况下，使用断言真棒，谢谢，是的，我想我们可以继续前进

209
00:16:36,320 --> 00:16:45,240
有些问题慢慢出现，但可以随意变得冷静，所以这是另一个验证

210
00:16:45,240 --> 00:16:51,700
我想提及的有关执行客户端的高级主题，另一个主要主题

211
00:16:51,700 --> 00:16:58,960
它在生态系统中扮演的角色是构建执行有效载荷，建立块

212
00:16:58,960 --> 00:17:04,980
包含状态转换，所有有用的事务的交易。

213
00:17:04,980 --> 00:17:12,599
因此，我们可以快速查看它的外观，从

214
00:17:12,599 --> 00:17:20,000
执行客户端。当我们到达点对点部分时，我将更多地谈论这一点，但从本质上讲

215
00:17:20,000 --> 00:17:26,519
节点是在此点对点方案上闲聊交易，而这些是交易

216
00:17:26,519 --> 00:17:32,459
在一个块中尚不有效。不后悔尚未有效包含在一个块中，但是他们自己

217
00:17:32,459 --> 00:17:38,559
有效的。因此，这意味着nonce是该帐户的下一个有效nonce。该帐户足够

218
00:17:38,559 --> 00:17:43,799
支付交易的价值，等等。

219
00:17:44,279 --> 00:17:48,220
因此，有时节点会成为创建块的任务

220
00:17:48,220 --> 00:17:51,619
这取决于共识层。

221
00:17:51,619 --> 00:17:54,679
共识层随机确定每个时期

222
00:17:54,679 --> 00:17:57,139
哪些验证者将构建一个块。

223
00:17:57,539 --> 00:18:00,419
如果碰巧选择了验证器来构建该块，

224
00:18:00,579 --> 00:18:02,599
您会告诉您的共识客户，

225
00:18:03,159 --> 00:18:04,339
嘿，您应该建立一个块。

226
00:18:04,519 --> 00:18:08,019
这是一些障碍的背景

227
00:18:08,019 --> 00:18:13,539
应该建造。因此，我们可以像上面一样再次嘲笑它作为一个函数，

228
00:18:13,559 --> 00:18:22,299
然后去。这看起来有点像我们称为build的函数。而且要去

229
00:18:22,299 --> 00:18:29,079
要采用一个我无法完全定义的环境。我们将稍后再定义一下。

230
00:18:29,579 --> 00:18:34,460
但是环境将拥有所有信息，就像标题一样，

231
00:18:34,519 --> 00:18:37,980
它会有信息，例如时间戳是什么？什么是块号？

232
00:18:38,019 --> 00:18:40,460
以前的基本费用是多少，

233
00:18:41,259 --> 00:18:43,900
所有需要发生在街区中的提款，

234
00:18:44,099 --> 00:18:46,059
来自共识层的事物。

235
00:18:46,139 --> 00:18:49,440
在这种情况下，共识层是大脑。

236
00:18:49,440 --> 00:18:52,200
这就是说，这是信息，

237
00:18:52,539 --> 00:18:54,339
您应该构建块的上下文。

238
00:18:54,339 --> 00:18:57,259
因此，只需在此上下文中构建块即可。

239
00:18:57,559 --> 00:18:59,240
这就是环境。

240
00:18:59,539 --> 00:19:02,579
我们将进入一个池，这是一个交易池。

241
00:19:02,579 --> 00:19:08,179
该池正在维护交易列表。

242
00:19:09,279 --> 00:19:11,839
我们只是为了简单而假设

243
00:19:11,839 --> 00:19:12,919
它会假设...

244
00:19:13,500 --> 00:19:15,299
抱歉，它将维持

245
00:19:15,299 --> 00:19:17,279
有序交易列表

246
00:19:17,279 --> 00:19:19,299
按其价值订购。

247
00:19:20,000 --> 00:19:22,679
所以这将帮助我们建立

248
00:19:22,679 --> 00:19:26,519
执行客户端最有利可图的块

249
00:19:26,519 --> 00:19:31,299
考虑到我们在网络上看到的交易。

250
00:19:31,299 --> 00:19:34,079
而且我们还将在

251
00:19:34,079 --> 00:19:36,839
因为我们必须更新

252
00:19:36,839 --> 00:19:40,019
我们需要返回的是一个块

253
00:19:40,019 --> 00:19:42,159
州DB

254
00:19:42,159 --> 00:19:46,619
因为我们已经通过累积交易对其进行了更新

255
00:19:46,619 --> 00:19:49,940
在该块中，可能是一个错误

256
00:19:49,940 --> 00:19:53,319
好的

257
00:19:53,319 --> 00:19:59,259
内部构建

258
00:19:59,259 --> 00:20:03,640
我们会跟踪几件事。

259
00:20:04,720 --> 00:20:06,759
我们应该跟踪所用的气体

260
00:20:06,759 --> 00:20:13,779
因为我们只能使用有限的气体。

261
00:20:15,519 --> 00:20:20,039
我将不考虑事实

262
00:20:20,039 --> 00:20:21,740
我们实际上可以更改气体限制。

263
00:20:21,859 --> 00:20:23,980
我只是说这将是一些固定价值。

264
00:20:24,379 --> 00:20:25,819
因此，这是一个简单的例子。

265
00:20:26,619 --> 00:20:28,299
但是通常在建造街区时

266
00:20:28,299 --> 00:20:33,319
您需要观看使用多少汽油，并在您停止建造块

267
00:20:33,319 --> 00:20:41,000
达到可以包括的交易的限制，我们也将

268
00:20:41,000 --> 00:20:44,399
存储所有将要进入块的交易

269
00:20:44,399 --> 00:20:52,720
因此，让我们确保我们继续添加交易，直到使用的气体更大

270
00:20:52,720 --> 00:20:58,759
超过3000万。这大约是当今主网上的气体限制。

271
00:21:01,079 --> 00:21:06,240
因此，要获得我们的第一笔交易或进行任何交易，我们必须询问交易池，

272
00:21:06,480 --> 00:21:12,980
再说一次，黑拳击说它将保留有序的交易列表

273
00:21:12,980 --> 00:21:18,680
对于我们来说，我们总是得到最好的下一笔交易。我们可以说的只是

274
00:21:18,680 --> 00:21:19,880
弹出交易。

275
00:21:20,080 --> 00:21:22,980
我们将其视为某种列表

276
00:21:22,980 --> 00:21:24,100
这使我们能够弹出。

277
00:21:24,660 --> 00:21:26,019
我们将启动该交易。

278
00:21:27,039 --> 00:21:29,680
然后我们将执行它。

279
00:21:31,180 --> 00:21:32,340
我们称这种气为。

280
00:21:32,720 --> 00:21:33,759
不，我已经命名了。

281
00:21:36,519 --> 00:21:37,720
我们称之为气体。

282
00:21:38,720 --> 00:21:39,640
和错误。

283
00:21:40,440 --> 00:21:42,560
我们将再次进行交易，

284
00:21:42,560 --> 00:21:43,799
就像我们上面所做的那样。

285
00:21:48,680 --> 00:21:55,380
因此，我将在环境中通过它。

286
00:21:55,380 --> 00:22:00,259
您知道，我们可以假设运行需要一些接口

287
00:22:00,259 --> 00:22:02,420
封锁和环境都满足。

288
00:22:02,799 --> 00:22:04,500
因此，我们将在环境中通过。

289
00:22:04,660 --> 00:22:07,220
我们将通过该交易，然后将通过该州。

290
00:22:07,340 --> 00:22:11,720
因此，它将再次在这种情况下运行交易

291
00:22:11,720 --> 00:22:13,519
环境正在定义。

292
00:22:13,519 --> 00:22:16,440
它将返回我们一个更新的状态

293
00:22:16,440 --> 00:22:20,680
实际积累交易。

294
00:22:21,259 --> 00:22:23,160
因此，如果那不成功，

295
00:22:23,160 --> 00:22:25,740
这意味着运行返回错误，

296
00:22:26,779 --> 00:22:29,019
实际上，我们只是要继续这里。

297
00:22:30,019 --> 00:22:32,759
因此，这意味着交易无效。

298
00:22:33,720 --> 00:22:40,460
而且因为我们仍然有更多的气体

299
00:22:40,460 --> 00:22:42,019
要在块中消费，

300
00:22:42,400 --> 00:22:44,539
我们不想返回一个区域

301
00:22:44,539 --> 00:22:55,319
因为块中确实没有发生任何错误。

302
00:22:55,599 --> 00:22:58,920
由于某种原因，我们有可能进行无效的交易

303
00:22:58,920 --> 00:23:02,539
因为它在执行时做了不好的事情。

304
00:23:03,960 --> 00:23:07,920
也许交易池略有过时。

305
00:23:09,659 --> 00:23:12,720
我们在这里要做的就是让自己继续下去。

306
00:23:12,720 --> 00:23:19,000
并尝试将下一个从池中的交易进入此块。

307
00:23:19,420 --> 00:23:23,380
因此，一旦我们验证了运行该事务的错误，

308
00:23:23,380 --> 00:23:27,740
实际上，我们可以将气体添加到我们的气体使用中。

309
00:23:27,980 --> 00:23:30,380
因此，我们只会添加。

310
00:23:30,579 --> 00:23:32,940
因此，现在，您知道我们有一项交易，

311
00:23:33,059 --> 00:23:34,279
这是一个简单的转移。

312
00:23:34,539 --> 00:23:37,240
简单的传输仅为2100万天气。

313
00:23:37,839 --> 00:23:39,180
对不起，21,000天气。

314
00:23:39,180 --> 00:23:45,160
现在，我们的汽油从0到21,000。

315
00:23:45,160 --> 00:23:47,380
因此，我们将继续这样做

316
00:23:47,380 --> 00:23:52,220
直到我们达到3000万，我可能会说。

317
00:23:52,380 --> 00:23:54,480
或游泳池是空的。

318
00:23:58,120 --> 00:23:59,519
游泳池不是空的。

319
00:24:01,100 --> 00:24:04,539
所以我们要么完全填充块

320
00:24:04,539 --> 00:24:07,620
或者我们用完了潜在的交易。

321
00:24:07,619 --> 00:24:27,159
一旦这样做，我们需要做的就是我们需要完成整个过渡，并返回我们的块，状态数据库和错误。我只会将其外包给我们在Goethereum中具有的另一个功能，这是这样最终确定的。

322
00:24:27,160 --> 00:24:44,540
最终确定的工作是需要大量的交易和有关该块的一些信息，并且会产生一个完全组装的块。我们这样做的原因是，在块末尾需要进行一些计算。

323
00:24:44,539 --> 00:24:47,740
我在这里有点掩饰

324
00:24:47,740 --> 00:24:49,740
我们将查看何时查看过程功能

325
00:24:49,740 --> 00:24:51,899
但基本上是在标题中

326
00:24:51,899 --> 00:24:53,399
你有类似的东西

327
00:24:53,399 --> 00:24:55,960
交易路线

328
00:24:55,960 --> 00:24:57,319
收据路线

329
00:24:57,319 --> 00:24:59,339
提款路线

330
00:24:59,339 --> 00:25:01,920
这些是您需要计算的值

331
00:25:01,920 --> 00:25:03,480
通过默克尔尺寸清单

332
00:25:03,480 --> 00:25:05,819
所以我们能想象的是

333
00:25:05,819 --> 00:25:07,539
最终的功能将做到这一点

334
00:25:07,539 --> 00:25:08,159
所以我们可以

335
00:25:08,159 --> 00:25:10,940
我忘了实际上附加这些交易

336
00:25:10,940 --> 00:25:12,460
所以我们不得不说

337
00:25:12,460 --> 00:25:15,059
附加。

338
00:25:16,840 --> 00:25:18,980
因此，现在我们有了交易列表。

339
00:25:20,319 --> 00:25:20,559
糟糕。

340
00:25:22,079 --> 00:25:24,319
所以我要确定这个

341
00:25:24,319 --> 00:25:28,019
我们正在与环境建立的街区，

342
00:25:28,019 --> 00:25:30,360
交易和国家。

343
00:25:31,539 --> 00:25:34,100
我只是说最终确定将会

344
00:25:34,100 --> 00:25:37,220
还返回这三个值。所以它会去

345
00:25:37,220 --> 00:25:39,440
组装块。它将返回国家

346
00:25:39,440 --> 00:25:42,980
正确更新后，

347
00:25:43,100 --> 00:25:45,480
也许有一些提款或其他东西。

348
00:25:45,860 --> 00:25:48,480
如果在最终确定期间出现问题，

349
00:25:48,940 --> 00:25:50,279
它将返回错误。

350
00:25:51,400 --> 00:25:56,620
因此，这是一种超级简化的方式

351
00:25:56,620 --> 00:25:57,519
建造一个街区。

352
00:25:58,860 --> 00:26:01,680
希望这种向您传达

353
00:26:01,680 --> 00:26:05,240
执行层如何考虑构建块。

354
00:26:06,059 --> 00:26:09,259
我不知道这是否有任何疑问。

355
00:26:09,440 --> 00:26:10,779
此示例在这里。

356
00:26:18,039 --> 00:26:19,700
是的，看来我们有一对，

357
00:26:19,960 --> 00:26:21,940
聊天中的一些问题。

358
00:26:25,640 --> 00:26:26,660
让我们来看看。

359
00:26:29,640 --> 00:26:32,960
保罗问，交易池是否以任何方式订购？

360
00:26:32,960 --> 00:26:35,259
如果没有，我们如何确保最大利润

361
00:26:35,259 --> 00:26:36,680
使用poop.pop时？

362
00:26:37,660 --> 00:26:38,140
是的，到底是。

363
00:26:38,140 --> 00:26:47,920
因此，交易池是，我们假设在这种情况下，它基本上是通过汽油价格订购的。

364
00:26:48,480 --> 00:26:52,440
有了1559年，它有些复杂，因为我们有这个小费的概念。

365
00:26:52,700 --> 00:26:56,060
但从本质上讲，它是由向建筑商的最高付款交易订购的。

366
00:26:56,460 --> 00:27:02,800
因此，每次打电话给POP时，您都会获得为您提供最大价值的交易。

367
00:27:05,500 --> 00:27:06,460
伟大的。谢谢。

368
00:27:08,140 --> 00:27:27,320
因此，您唯一拒绝交易的时间是由于某种原因是否无效。

369
00:27:27,320 --> 00:27:32,400
在这种情况下，您可以在这里看到这一点。

370
00:27:32,400 --> 00:27:38,960
交易池本身正在进行一些验证。因此，我们或多或少验证

371
00:27:38,960 --> 00:27:43,860
交易的有效。有时可能会有一些种族条件

372
00:27:43,860 --> 00:27:48,540
尚未完全更新，但是块头已经更新，或者可能是一笔交易。

373
00:27:52,920 --> 00:27:57,380
总的来说，我的意思是，总的来说，交易池应该真的应该

374
00:27:57,380 --> 00:28:03,440
验证交易是有效的。因此，这并没有发生太多。但是你不会去

375
00:28:03,440 --> 00:28:08,900
查看交易并出于任何其他原因拒绝，然后无法付款。因为如果交易

376
00:28:08,900 --> 00:28:15,380
可以付款，然后在执行过程中的报价无价交易确实是一项恢复的交易，

377
00:28:15,600 --> 00:28:21,140
从共识的角度来看，这是有效的。它可能没有有效更改

378
00:28:21,140 --> 00:28:24,740
不仅为其使用的汽油支付的国家。

379
00:28:27,380 --> 00:28:33,280
另一个问题是，有一些关于加密的备忘录的讨论。

380
00:28:33,280 --> 00:28:35,580
一，那有多可行？

381
00:28:35,580 --> 00:28:41,900
两个，由于块交易是通过气体订购的，在这种设计中是否没有加密气体？

382
00:28:41,900 --> 00:28:42,900
是的。

383
00:28:42,900 --> 00:28:45,280
我的意思是，这是一个非常具有挑战性的问题。

384
00:28:45,280 --> 00:28:51,440
我认为很多人都对此进行了看法，并且关于如何进行的想法不同

385
00:28:51,440 --> 00:28:52,440
做到。

386
00:28:52,440 --> 00:29:01,340
因此，我看到的建议主要是在其他连锁店上，我认为加密的Mempools的宇宙已经有了诸如无加密的汽油之类的东西。

387
00:29:01,860 --> 00:29:06,559
因为当您构建块时，您不知道该交易是什么。

388
00:29:06,640 --> 00:29:10,700
您有点致力于一个块的有序列表。

389
00:29:10,900 --> 00:29:15,440
因此，您需要了解该阻滞使用多少气体。

390
00:29:15,440 --> 00:29:18,460
我也看过一些

391
00:29:18,460 --> 00:29:20,840
发件人的建议

392
00:29:20,840 --> 00:29:22,539
也没有加密

393
00:29:22,539 --> 00:29:23,900
只是

394
00:29:23,900 --> 00:29:26,740
目标和数据

395
00:29:26,740 --> 00:29:28,160
他们正在做的是加密的

396
00:29:28,160 --> 00:29:31,100
这样他们就可以以某种方式验证

397
00:29:31,100 --> 00:29:32,779
我想他们可以做一个

398
00:29:32,779 --> 00:29:34,779
简单验证

399
00:29:34,779 --> 00:29:36,920
发件人可以为未加密的天然气付费

400
00:29:36,920 --> 00:29:40,980
这些显然是

401
00:29:40,980 --> 00:29:42,860
与

402
00:29:42,860 --> 00:29:44,779
缺点，因为如果您正在尝试

403
00:29:44,779 --> 00:29:51,319
要拥有一个加密的茶池，并且您正在尝试拥有私人交易流，您正在泄漏

404
00:29:51,319 --> 00:29:58,420
即使只是说使用uh的气体，还有很多信息，甚至还有发件人

405
00:29:58,420 --> 00:30:06,379
地址，所以从以太坊的角度来看，我认为这可能是什么

406
00:30:06,379 --> 00:30:11,559
将来要越来越远，我们可能想要一个完整的解决方案，而不是想要一个完整的解决方案

407
00:30:11,559 --> 00:30:19,639
只做大多数事情正确的事情。我可以在这里有点。这不是

408
00:30:19,639 --> 00:30:24,879
我一段时间以来都看过的东西。但这通常是我的理解。似乎没有

409
00:30:24,879 --> 00:30:31,200
就像我们想出的一种方法可以完全有效地进行加密的MIM池。所以我们

410
00:30:31,200 --> 00:30:37,159
等待破裂。惊人的。谢谢。

411
00:30:37,160 --> 00:30:43,300
因此，您使用的气体少于3000万，但您也提到

412
00:30:43,300 --> 00:30:44,300
这不是硬编码。

413
00:30:44,300 --> 00:30:48,540
因此，这只是通过或通过类似参数的一个示例。

414
00:30:49,120 --> 00:30:49,640
是的。

415
00:30:49,800 --> 00:30:51,800
我的意思是，我们可以说气体限制。

416
00:30:51,940 --> 00:30:54,160
我的意思是，真的，我认为我们拥有的功能。

417
00:30:56,740 --> 00:31:00,160
我的意思是，实际上，我们可以说的是我们可以说它在环境中。

418
00:31:00,160 --> 00:31:10,980
但是基本上，呃，每当您建立一个块时，您的节点都具有我所说的能力

419
00:31:10,980 --> 00:31:22,880
控制气体限制超过1024，这样我就可以在任一端进行操作

420
00:31:22,880 --> 00:31:29,820
或减去该价值，因此您在客户上说的话，您可能会经过诸如汽油之类的东西

421
00:31:29,819 --> 00:31:34,460
目标。我忘了。我忘了这个标志叫什么。这是气体限制目标或类似的目标

422
00:31:34,460 --> 00:31:47,460
那。您可能会说4000万。因此，如果您的气体限制目标在父块上方

423
00:31:47,460 --> 00:31:53,519
气体限制，然后是环境。glet气体限制将在某个时候尝试

424
00:31:53,519 --> 00:32:00,379
并弄清楚我们能够靠近目标。基本上只是拿走

425
00:32:01,099 --> 00:32:08,559
它正在尝试看到一个超过1024的目标，是目标吗？我们超越了目标吗？

426
00:32:09,079 --> 00:32:14,339
如果不是目标或对不起，如果它超出了目标，那么我们可以减少它并成为

427
00:32:14,339 --> 00:32:20,460
少于1024多个三角洲，您知道，我们的目标完全相等。因此，在这种情况下，

428
00:32:20,460 --> 00:32:24,740
如果我们的目标是4000万，最后一个价值是3000万，

429
00:32:24,840 --> 00:32:28,579
那将是3000万次，

430
00:32:28,819 --> 00:32:29,759
我是说，

431
00:32:29,819 --> 00:32:31,340
1025超过1024，

432
00:32:32,220 --> 00:32:32,620
本质上。

433
00:32:36,600 --> 00:32:37,480
所以你，

434
00:32:37,740 --> 00:32:40,579
您的节点对气体限制的控制权有所控制。

435
00:32:40,579 --> 00:32:41,440
对于此示例，

436
00:32:41,440 --> 00:32:44,519
我并不是真的很深入地计算出来，

437
00:32:45,019 --> 00:32:47,259
但是我们可以在短短一秒钟内

438
00:32:47,380 --> 00:32:48,299
除非还有更多问题。

439
00:32:50,460 --> 00:33:00,840
是的，他们有点不断进来，但我只是想做一些更重要的事情

440
00:33:00,840 --> 00:33:02,220
我猜一个。

441
00:33:02,220 --> 00:33:07,740
是的，有趣的问题是这里是否有任何种族条件要担心。

442
00:33:07,740 --> 00:33:14,579
就像来自孟买的交易被堵塞在街区中，必须在之前删除它们

443
00:33:14,579 --> 00:33:15,579
您建立另一个块。

444
00:33:15,579 --> 00:33:22,439
是的。我们试图避免比赛条件。我的意思是，这只是一个玩具的例子。就是这样

445
00:33:22,439 --> 00:33:27,539
并没有真正解决这些问题。但这就是诚信可能会丢失的地方。

446
00:33:27,539 --> 00:33:31,899
交易池应该做很多交易验证。一般来说，

447
00:33:31,899 --> 00:33:38,059
一旦达到这一点，该交易应该有效。但是有时候游泳池是

448
00:33:38,059 --> 00:33:45,519
并非总是完美的同步，它可能正在更新或通过其交易列表

449
00:33:45,519 --> 00:33:49,460
并尝试更新有效的交易。

450
00:33:49,559 --> 00:33:50,579
所以你可能会得到一些东西

451
00:33:50,579 --> 00:33:52,879
目前的头部尚未更新。

452
00:33:53,299 --> 00:33:55,259
因此，交易可能无效。

453
00:33:56,099 --> 00:33:57,200
这是一个很好的例子。

454
00:33:59,259 --> 00:34:02,440
但是我们的交易，

455
00:34:03,059 --> 00:34:05,000
我们的街区建筑要复杂得多

456
00:34:05,000 --> 00:34:09,639
而且有些事情必须避免。

457
00:34:12,880 --> 00:34:13,480
惊人的。

458
00:34:13,480 --> 00:34:18,219
人们不确定RES变量的含义。

459
00:34:18,219 --> 00:34:20,179
是否是新状态。

460
00:34:20,179 --> 00:34:21,179
对不起。

461
00:34:21,179 --> 00:34:22,179
这是新状态。

462
00:34:22,179 --> 00:34:24,260
我想我忘了...

463
00:34:24,260 --> 00:34:25,260
是的。

464
00:34:25,260 --> 00:34:28,240
我忘了积累它。

465
00:34:28,240 --> 00:34:33,760
因此，基本上，RES是将交易应用于其的状态。

466
00:34:33,760 --> 00:34:38,780
因此，我正在做的是，如果该交易有效，那么我只是更新状态变量

467
00:34:38,780 --> 00:34:41,179
res。

468
00:34:41,179 --> 00:34:45,779
因此，状态将成为将交易应用于其的下一个状态。

469
00:34:46,779 --> 00:34:47,219
正确的。

470
00:34:48,519 --> 00:34:48,960
好的。

471
00:34:49,000 --> 00:34:49,259
惊人的。

472
00:34:49,539 --> 00:34:49,699
是的。

473
00:34:49,779 --> 00:34:50,480
非常感谢，马特。

474
00:34:50,579 --> 00:34:52,000
我认为我们可以前进。

475
00:34:52,940 --> 00:34:53,179
甜的。

476
00:34:54,239 --> 00:34:58,839
因此，您知道，我们已经结束了一半，但是现在我们已经完成了概述。

477
00:34:59,659 --> 00:35:04,259
因此，让我们跳进去，看看状态过渡功能。

478
00:35:04,260 --> 00:35:12,280
因此，我给了您关于状态过渡功能的非常高级的概述

479
00:35:12,280 --> 00:35:16,520
但是我想真正带我们穿越

480
00:35:16,520 --> 00:35:24,820
Goethereum发生了什么。这可能有点困难，因为你们不能取消静音

481
00:35:24,820 --> 00:35:31,040
提出问题，但我只是要经历这个问题，希望这是您分类的一种方式

482
00:35:31,039 --> 00:35:36,659
查看此代码在哪里？这些东西的形状是什么？也许是在自己的时间

483
00:35:37,019 --> 00:35:42,920
更深入地浏览它，并尝试真正了解流程和每一行

484
00:35:42,920 --> 00:35:47,279
那正在发生。但是，我们将在这里很快进行。因为我确实有一对

485
00:35:47,279 --> 00:35:57,259
其他要谈论的事情。好的。因此，如果我进入以太坊，我们实际上可以查看该功能，

486
00:35:57,260 --> 00:36:02,600
通知新有效载荷功能，信标链正在调用

487
00:36:02,600 --> 00:36:04,720
与执行层交互。

488
00:36:05,620 --> 00:36:08,680
为此，我们会去催化剂，

489
00:36:09,020 --> 00:36:13,860
这是我们的引擎API的名字。

490
00:36:14,180 --> 00:36:18,780
引擎API是连接信标的接口，

491
00:36:19,020 --> 00:36:20,800
执行层的共识层。

492
00:36:21,360 --> 00:36:23,140
我们将前往API.GO。

493
00:36:23,139 --> 00:36:27,179
因此，有一个称为新有效载荷的功能。

494
00:36:30,579 --> 00:36:36,559
因此，新的有效载荷是信标连锁店所呼唤的。

495
00:36:37,079 --> 00:36:39,799
因此，它吸收了很多价值。

496
00:36:40,019 --> 00:36:42,259
主要是我在谈论的价值观，

497
00:36:42,559 --> 00:36:45,480
块数据在此可执行数据中。

498
00:36:45,859 --> 00:36:48,819
这看起来很像一个街区。

499
00:36:49,099 --> 00:36:52,420
它有父母哈希，状态根，收据root，

500
00:36:52,420 --> 00:36:58,639
数量，气体限制，汽油使用，您的交易，提款，其他一堆其他东西。

501
00:36:58,780 --> 00:37:04,180
我不会太深入4844件事，因为那使事情变得更加复杂。

502
00:37:05,460 --> 00:37:08,920
但是发生的是共识层有一个块。

503
00:37:09,139 --> 00:37:13,420
它想询问执行层，该块有效吗？

504
00:37:14,599 --> 00:37:20,139
执行层对该块信息进行了大量验证。

505
00:37:20,139 --> 00:37:23,179
因此，这将执行一些完整性检查。

506
00:37:23,960 --> 00:37:27,699
像这样，如果我哈希给我所有数据，

507
00:37:27,799 --> 00:37:30,319
它会等于您也给我的块哈希吗？

508
00:37:30,519 --> 00:37:32,639
这是被抓住的东西

509
00:37:32,759 --> 00:37:35,259
经常会捕捉到客户中的小错误。

510
00:37:37,779 --> 00:37:39,940
最终，您知道，它只是经历了

511
00:37:39,940 --> 00:37:41,839
并验证一些

512
00:37:41,900 --> 00:37:43,379
只是进行一堆完整性检查，

513
00:37:43,980 --> 00:37:46,519
关于

514
00:37:46,519 --> 00:37:51,480
信标链和共识层之间的通信。

515
00:37:51,659 --> 00:37:56,480
但是最终，我们到达此功能插入块而无需设置头。

516
00:37:56,559 --> 00:38:02,300
因此，在这里，我们实际上开始尝试将该障碍物放入我们的链条中。

517
00:38:02,500 --> 00:38:08,340
我们验证了一群我们想要存在的不变性，然后才开始提出

518
00:38:08,340 --> 00:38:09,119
阻止链条。

519
00:38:09,259 --> 00:38:11,559
然后我们必须跳进去，然后继续做。

520
00:38:12,059 --> 00:38:14,780
因此，这些功能非常复杂。

521
00:38:14,780 --> 00:38:27,580
而且，他们知道，他们有很多东西，我认为我们可能会考虑删除，因为信标连锁店正在为我们做很多重组和连锁管理。

522
00:38:27,880 --> 00:38:35,420
但这是一个事实，即我们曾经必须在我们的股份证明之前自己做这个事实。

523
00:38:35,840 --> 00:38:38,860
因此，插入链将调用我们谈论的一些事情。

524
00:38:39,180 --> 00:38:41,019
有一个称为验证标头的函数。

525
00:38:41,019 --> 00:38:44,980
验证标头是接口上的函数。

526
00:38:45,980 --> 00:38:50,840
该界面在共识中定义，这是我们所在的地方。

527
00:38:51,000 --> 00:38:55,079
但是，标准链有一个共识引擎。

528
00:38:55,219 --> 00:38:57,699
它具有其功能验证标头。

529
00:38:58,360 --> 00:39:08,000
它可以做的是它将执行与此类共识相关的标头验证。

530
00:39:11,019 --> 00:39:15,900
它要做的第一件事是检查查看的是终端总难度。

531
00:39:15,900 --> 00:39:23,659
这就是我们确定链条是否是工作证明或股份证明的方式。

532
00:39:23,940 --> 00:39:30,880
在这一点上，您知道，这总是引用了引用的报价，因为难度不再有更新。

533
00:39:31,739 --> 00:39:35,119
合并发生了。

534
00:39:35,280 --> 00:39:40,340
因此，我们一直在跳过ETH1标头验证。

535
00:39:40,340 --> 00:39:43,780
而且我们只是在进行Beacon标头验证。

536
00:39:44,120 --> 00:39:49,480
因此，信标头部验证在很多方面都是相同的。

537
00:39:49,840 --> 00:39:57,880
您可以通过非常个人的约束。

538
00:39:58,620 --> 00:40:00,280
我会提到一些有趣的。

539
00:40:01,019 --> 00:40:05,039
首先，为了证明股份，没有更多的叔叔概念。

540
00:40:05,700 --> 00:40:09,300
叔叔是相同块高度的重复块。

541
00:40:09,300 --> 00:40:21,519
我们有工作证明，因为有时，如果您在世界各地有很多分布式矿工，那么两个矿工可能会在大约同一时间找到一个街区，然后他们与另一个发现了一个街区。

542
00:40:22,019 --> 00:40:24,360
因此，现在您在同一块号上有两个块。

543
00:40:25,060 --> 00:40:30,980
而且您仍然想奖励这两个矿工，因为他们将作品放进去，并找到了一个障碍。

544
00:40:31,120 --> 00:40:39,000
但是，其中只有一个可以成为规范化的块，这意味着它是规范链的一部分。

545
00:40:39,000 --> 00:40:43,380
为了证明股份，我们不再有这个概念了。

546
00:40:43,380 --> 00:40:48,579
因此，在执行层中，我们强迫叔叔哈希永远成为一个空的叔叔哈希，

547
00:40:48,960 --> 00:40:51,360
这只是一个空列表的默克尔根。

548
00:40:51,920 --> 00:40:55,480
因此，如果不是这样，那么我们只需要返回错误，因为那不是有效的

549
00:40:55,480 --> 00:40:56,440
损失块的证明。

550
00:40:57,119 --> 00:40:59,659
同样，由于困难，我们没有工作证明。

551
00:41:00,079 --> 00:41:02,179
标题难度总是必须为零。

552
00:41:06,639 --> 00:41:07,320
让我们来看看。

553
00:41:07,719 --> 00:41:07,880
好的。

554
00:41:07,880 --> 00:41:12,180
因此，我们谈论了1559年，我们谈论了气体限制。

555
00:41:12,440 --> 00:41:14,240
这是此检查的地方。

556
00:41:15,320 --> 00:41:20,920
因此，我们必须验证气体限制是否停留在允许的装订范围内。

557
00:41:21,820 --> 00:41:24,019
我认为这正在这里发生。

558
00:41:24,200 --> 00:41:25,539
所以我们给它，好吧。

559
00:41:25,559 --> 00:41:27,300
母体气体限制是一定的价值。

560
00:41:27,420 --> 00:41:30,820
这是现在的当前标头的气体限制。

561
00:41:31,220 --> 00:41:37,860
而且我们必须确保它仍然属于原因，即可以接受的平衡。

562
00:41:37,880 --> 00:41:53,260
因此，基本上，我们只是计算出气体限制的分隔线，而我们只是确保差异不大于或小于限制。

563
00:41:53,860 --> 00:41:56,059
这就是1024号。

564
00:41:56,160 --> 00:42:03,119
我们只是将以前的气体限制除外，并确保差异并不大于此。

565
00:42:03,940 --> 00:42:05,900
这就是验证气体限制。

566
00:42:05,900 --> 00:42:09,880
然后是1559逻辑，我们计算基本费用。

567
00:42:10,099 --> 00:42:14,840
我们要确保标题的基本费用等于我们期望的基本费用。

568
00:42:15,119 --> 00:42:22,559
因此，我们从本质上浏览了标题中的每个字段，并确保所有这些字段都是正确的。

569
00:42:23,619 --> 00:42:26,320
因此，这主要是标题验证。

570
00:42:27,119 --> 00:42:34,039
验证标头后，我们实际上可以执行块或处理块。

571
00:42:34,039 --> 00:42:35,940
我只是跳回去

572
00:42:35,940 --> 00:42:37,699
所以现在我们又回到了该功能

573
00:42:37,699 --> 00:42:39,360
插入块

574
00:42:39,360 --> 00:42:41,059
插入没有固定头的块

575
00:42:41,059 --> 00:42:43,119
因此，如果我们继续下降

576
00:42:43,119 --> 00:42:45,300
还有很多其他逻辑

577
00:42:45,300 --> 00:42:47,039
处理重新调整

578
00:42:47,039 --> 00:42:48,559
我们已经知道的块

579
00:42:48,559 --> 00:42:50,920
我们已经知道的块

580
00:42:50,920 --> 00:42:53,340
但是最终如果我们经历

581
00:42:53,340 --> 00:42:55,400
走过去

582
00:42:55,400 --> 00:42:57,360
应该打电话给功能

583
00:42:57,360 --> 00:42:58,340
称为过程

584
00:42:58,340 --> 00:43:02,980
最终

585
00:43:02,980 --> 00:43:12,280
我通过了它，我想也许不在这里，就在这里

586
00:43:12,280 --> 00:43:21,639
好的，所以在我们经历了一大堆重要但有点无关的事情之后

587
00:43:21,639 --> 00:43:27,059
尊重插入一个块，我们最终可以进入这个功能过程，这就是我写的

588
00:43:27,059 --> 00:43:33,460
大纲最初。这是我试图为您提供的功能

589
00:43:33,460 --> 00:43:38,920
概述。因此，如您所见，它需要类似于我们所展示的东西

590
00:43:38,920 --> 00:43:45,759
概述。它占据了一个障碍，它正在使用状态数据库。我想我也通过了父母，但是

591
00:43:45,759 --> 00:43:52,179
我们可以访问它。因此，我们在这一点上真的不需要这一点，因为父母

592
00:43:52,179 --> 00:43:54,779
信息放入VM配置中。

593
00:43:54,779 --> 00:43:57,899
这就像执行的环境一样。

594
00:43:57,899 --> 00:43:59,779
因此，它调用那里的接口。

595
00:43:59,779 --> 00:44:04,779
我可以在国家处理器中访问它。

596
00:44:05,339 --> 00:44:10,339
因此，此功能的实际实现在这里。

597
00:44:10,460 --> 00:44:12,019
StateProcessor.go。

598
00:44:13,239 --> 00:44:18,000
因此，这是我们真正执行国家过渡的地方

599
00:44:18,000 --> 00:44:20,480
在以太坊中。

600
00:44:20,480 --> 00:44:25,480
这里比我们谈论的要多得多

601
00:44:28,940 --> 00:44:31,480
在示例中，但是您基本上可以看到

602
00:44:31,480 --> 00:44:34,039
就像一个非常相似的结构一样。

603
00:44:34,039 --> 00:44:36,300
所以在这里，我们只是创建一堆价值观

604
00:44:36,300 --> 00:44:37,820
我们要维护

605
00:44:37,820 --> 00:44:39,300
在整个块的执行过程中。

606
00:44:39,300 --> 00:44:40,860
这是二手气。

607
00:44:40,860 --> 00:44:43,059
最后，我们想确保我们使用的气体

608
00:44:43,059 --> 00:44:45,840
等于标题中的气体使用情况。

609
00:44:45,840 --> 00:44:48,059
这是验证的重要检查

610
00:44:48,059 --> 00:44:50,320
所有执行都正确。

611
00:44:50,320 --> 00:44:52,539
然后我们有循环。

612
00:44:52,539 --> 00:44:55,940
因此，我们只是通过块中的所有交易

613
00:44:57,700 --> 00:45:00,280
我们应用交易。

614
00:45:00,280 --> 00:45:05,280
申请交易确实像我们谈论的

615
00:45:05,519 --> 00:45:09,100
或者最终我们到达这里，我们称为VM。

616
00:45:09,100 --> 00:45:12,220
我们必须经过此功能过渡DB。

617
00:45:12,220 --> 00:45:16,559
过渡数据库有很多交易水平

618
00:45:16,559 --> 00:45:17,400
验证。

619
00:45:17,400 --> 00:45:19,039
因此它具有预检查功能。

620
00:45:19,039 --> 00:45:22,440
这在验证交易的nonce是正确的。

621
00:45:22,440 --> 00:45:25,820
交易的余额是正确的。

622
00:45:25,820 --> 00:45:30,820
可能发生的其他一些类似的溢出。

623
00:45:33,500 --> 00:45:38,500
大约1559年检查了很多费用验证。

624
00:45:38,880 --> 00:45:43,880
最终我们验证，

625
00:45:43,880 --> 00:45:49,019
因此，我们验证，您知道，必须发生很多小的验证。

626
00:45:49,019 --> 00:45:52,480
但是最终，我们到达可以执行该交易的时候。

627
00:45:55,079 --> 00:46:00,380
就是说，我通过了它。

628
00:46:06,579 --> 00:46:07,380
啊，在这里。

629
00:46:07,380 --> 00:46:07,660
好的。

630
00:46:07,760 --> 00:46:13,000
因此，我们在这里说执行的实例是两种类型。

631
00:46:13,000 --> 00:46:16,619
您要么执行合同

632
00:46:16,619 --> 00:46:18,619
或者您要执行打电话。

633
00:46:19,340 --> 00:46:24,760
我们已经做到了，以便我们可以创建和调用这些功能。

634
00:46:25,719 --> 00:46:29,820
因此，在这里您可以查看交易是否会创建某些东西，

635
00:46:29,920 --> 00:46:33,719
我们将调用创建功能，并可以执行创建。

636
00:46:34,320 --> 00:46:36,840
而且，如果我们不是创建，那么我们必须更新NONCE。

637
00:46:36,840 --> 00:46:38,840
在创建中，NONCE已经更新。

638
00:46:39,000 --> 00:46:40,840
因此，这不存在。

639
00:46:43,000 --> 00:46:51,360
在代码的这个分支中，我们更新了nonce，然后执行呼叫，所以我

640
00:46:51,360 --> 00:46:55,820
要跳过呼叫的实施

641
00:46:55,820 --> 00:47:02,780
看看EVM，但这实质上是在踢起EVM，说我想执行EVM

642
00:47:02,780 --> 00:47:08,960
作为我的消息发件人，这是目的地，因此请在该目的地加载代码

643
00:47:08,960 --> 00:47:13,039
然后将此数据作为呼叫数据传递到该目的地。

644
00:47:14,800 --> 00:47:18,320
因此，流程，我们获得了回报值。

645
00:47:18,539 --> 00:47:19,880
我们剩余的汽油，

646
00:47:20,199 --> 00:47:22,980
如果您从经过的气体中减去，

647
00:47:23,039 --> 00:47:24,760
您得到了使用的气数量

648
00:47:24,760 --> 00:47:27,400
以及执行过程中发生的任何错误。

649
00:47:28,740 --> 00:47:33,300
我们向用户退还一些汽油

650
00:47:33,300 --> 00:47:35,880
如果重置存储有一些退款。

651
00:47:35,880 --> 00:47:44,240
我们支付了Coinbase，这是向用户收取的费用以执行该交易。

652
00:47:44,240 --> 00:47:47,640
然后我们返回该执行结果。

653
00:47:47,640 --> 00:47:50,720
因此，如果我们反弹，我们会又回来应用消息。

654
00:47:50,720 --> 00:47:54,820
我们只是积累了使用的气体。

655
00:47:54,820 --> 00:47:58,880
我们将此收据累积到我们的收据列表中。

656
00:47:58,880 --> 00:48:04,420
因此，我们在那里的收据列表，日志累积了。

657
00:48:04,420 --> 00:48:08,599
最终，我们进行了所有这些交易。

658
00:48:08,599 --> 00:48:10,559
我们完成此交易循环

659
00:48:10,559 --> 00:48:11,860
然后我们进入这个功能

660
00:48:11,860 --> 00:48:13,840
我在最终确定之前提到过

661
00:48:14,039 --> 00:48:16,380
这只会适用

662
00:48:16,380 --> 00:48:18,840
一些特定的共识。

663
00:48:19,340 --> 00:48:21,960
这是一个有趣的人

664
00:48:21,960 --> 00:48:27,400
因为标准链正在完成，

665
00:48:27,460 --> 00:48:29,260
我们实际上进行了提款

666
00:48:29,260 --> 00:48:31,780
因为这是一个共识层

667
00:48:31,780 --> 00:48:39,900
我想您可以说，这确实与交易无关。

668
00:48:40,380 --> 00:48:45,060
这就是我们经营一条信标连锁店的事实，这是一种股份证明。

669
00:48:45,360 --> 00:48:50,540
单击，例如，Goethereum通常支持的另一种类型的共识，

670
00:48:50,720 --> 00:48:55,460
没有提款。因此，您需要有一个区分它的地方。那就是

671
00:48:55,460 --> 00:48:59,860
此功能最终确定起作用。它让我们区分不同的共识

672
00:48:59,860 --> 00:49:06,099
我们可能拥有的引擎。因此，最终确定将通过发生的每个提款

673
00:49:06,099 --> 00:49:10,960
从信标连锁店告诉我们将发生在这个障碍物中。只是

674
00:49:10,960 --> 00:49:18,340
执行它们。因此，它增加了稀薄的空气。基本上只是服用一些以太

675
00:49:18,340 --> 00:49:24,800
在那个信标链上，将其放在执行层上。所以一旦完成了，

676
00:49:24,800 --> 00:49:27,200
一旦完成，我们就可以退还收据。

677
00:49:28,560 --> 00:49:32,340
让我们看看我是否可以反弹回到所谓的位置。

678
00:49:36,860 --> 00:49:40,539
因此，我们正在研究此功能，应用交易。

679
00:49:41,120 --> 00:49:42,220
所有这些交易...

680
00:49:42,220 --> 00:49:42,519
哦，对不起。

681
00:49:42,700 --> 00:49:43,980
我们正在研究过程。

682
00:49:45,160 --> 00:49:48,080
因此，一旦过程完成，我们就处于区块链中。

683
00:49:48,600 --> 00:49:52,580
现在，区块链基本上是处理的。

684
00:49:52,579 --> 00:49:56,559
因此，它将做更多的事情，更新一些指标。

685
00:49:57,000 --> 00:49:59,279
最终，我们将把这个块写入状态。

686
00:49:59,400 --> 00:50:06,179
当所有内容都解决到磁盘上或内存中时，这就是一种。

687
00:50:06,699 --> 00:50:10,179
因此，在这一点上，我们正在插入块。

688
00:50:10,239 --> 00:50:11,099
块是有效的。

689
00:50:11,940 --> 00:50:19,319
而且我们还有更多的指标和小事。

690
00:50:19,320 --> 00:50:26,519
但是基本上，我们将写入的块数量归还给

691
00:50:26,519 --> 00:50:30,680
磁盘，如果有任何错误，我们会返回，因为我们没有错误

692
00:50:30,680 --> 00:50:36,360
成功地写道，在这种情况下，我们只会说一个块，如果我们走了一个块

693
00:50:36,360 --> 00:50:44,920
回到催化剂API um的路上，这实际上扔掉了块的数量

694
00:50:44,920 --> 00:50:52,119
被编写了，只需检查一下错误是否没有错误，我们会得到UH错误nil错误

695
00:50:52,119 --> 00:50:58,519
从插入块返回，而没有设置所有这一切，最终我们会

696
00:50:58,519 --> 00:51:03,960
返回有效载荷状态状态引擎有效和新的最新哈希，这是一个块

697
00:51:03,960 --> 00:51:10,280
只是插入了

698
00:51:10,280 --> 00:51:13,880
共识层获得一个块，并将其发送到执行层

699
00:51:13,880 --> 00:51:25,099
我知道那是很多。我不想挂在很多问题上，但是如果有一些高级的事情，我可以在谈论其他一些事情之前迅速回答，我会愿意。

700
00:51:29,160 --> 00:51:35,500
太感谢了。我们有一个高级。如果您可以再次解释什么是收据。

701
00:51:35,500 --> 00:51:52,840
是的。因此，收据是有关交易的信息，该信息只能在执行交易后才能验证或确定。

702
00:51:52,840 --> 00:51:59,840
因此，如果我们查看收据的共识定义，它具有类似的内容。

703
00:51:59,840 --> 00:52:03,820
因此，这些是共识领域。

704
00:52:03,860 --> 00:52:06,400
这些实际上是收据中的东西。

705
00:52:06,559 --> 00:52:09,940
其他东西是一些没有收据中的Goethereum东西。

706
00:52:10,180 --> 00:52:17,539
但是您有诸如类型之类的东西，其中说明了此收据与什么交易类型相关联。

707
00:52:18,220 --> 00:52:20,880
基本上，这被用作歧视者。

708
00:52:20,880 --> 00:52:28,340
因此，您可以解释不同类型的交易是否具有不同类型的收据，

709
00:52:28,340 --> 00:52:36,420
我认为他们目前真的没有做。后期，这是在拜占庭中贬低的，

710
00:52:36,500 --> 00:52:40,820
我认为，但是已经弃了一段时间。所以您真的是这些。你

711
00:52:40,820 --> 00:52:46,320
具有状态，这将说明交易是否恢复。你会累积

712
00:52:46,320 --> 00:52:53,940
使用的气体说，该交易使用了多少。开花过滤器，如果您不熟悉

713
00:52:53,940 --> 00:52:57,920
使用Bloom过滤器，我会在Wikipedia上检查一下。这基本上是一种快速的方法

714
00:52:57,920 --> 00:53:04,960
确定您是否可能正在寻找该交易中的日志。进而

715
00:53:04,960 --> 00:53:08,920
您只有所有日志的列表。日志是您可以从智能中写的东西

716
00:53:08,920 --> 00:53:15,320
合同。智能合约地址将在这里。您可以有帮助您的主题

717
00:53:15,320 --> 00:53:21,280
通过Bloom过滤器快速找到它。然后您有数据。因此，如果日志的一个示例可能是

718
00:53:21,280 --> 00:53:29,920
发送ERC20可能会设置一个日志的ERC20，该日志表明ERC20是从一个发送的

719
00:53:29,920 --> 00:53:35,680
地址到另一个地址，因此您可以从交易结束时从块中读取该地址

720
00:53:35,680 --> 00:53:47,120
并查看所有带有特定令牌的ERC20转移，非常感谢Matt

721
00:53:47,119 --> 00:53:55,319
另一个问题是关于多次交易的环境，这些交易导致多个交易

722
00:53:55,319 --> 00:53:58,880
其他交易，例如拨打合同等。

723
00:53:58,880 --> 00:54:03,579
您在概述中使用的上下文，最终变量的环境如何？

724
00:54:03,579 --> 00:54:07,380
这些交易如何获取？

725
00:54:07,380 --> 00:54:08,679
好的。

726
00:54:08,679 --> 00:54:12,239
让我看看我是否可以很快显示出来。

727
00:54:12,239 --> 00:54:16,619
我想去国家处理器。

728
00:54:17,379 --> 00:54:22,219
因此，我们关心两种环境。

729
00:54:22,899 --> 00:54:25,179
我认为这是正确的。

730
00:54:27,339 --> 00:54:30,179
因此，我们有EVM环境，

731
00:54:30,699 --> 00:54:36,639
它主要存储交易级别上下文和块级别上下文。

732
00:54:36,639 --> 00:54:39,039
因此，块级是我提到的。

733
00:54:39,399 --> 00:54:41,839
共插基气体限制，块数，时间，难度，

734
00:54:41,840 --> 00:54:47,380
基本费用，随机，所有这些东西。这是不会将交易转变为交易的内容。

735
00:54:47,620 --> 00:54:54,720
它固定在整个块上。然后我们有交易背景，起源，气价，

736
00:54:55,220 --> 00:55:01,960
斑点的东西。这些是整个交易中真实的事情，但可能会在

737
00:55:01,960 --> 00:55:06,960
块是因为有不同的交易。因此，这是两种类型的环境

738
00:55:06,960 --> 00:55:13,079
可以在执行过程中访问，但通常是为交易的完整执行而修复

739
00:55:13,079 --> 00:55:17,000
然后在口译员中也有

740
00:55:17,000 --> 00:55:22,860
呃，evo否是正确的

741
00:55:22,860 --> 00:55:38,200
好的。因此，在口译员内，您有一些东西。而且您有一个范围上下文，

742
00:55:38,200 --> 00:55:42,920
我们将在此处浏览一下，这与当前范围相关的事物

743
00:55:42,920 --> 00:55:47,300
因此，如果您要访问当前范围中的堆栈或当前的内存

744
00:55:47,300 --> 00:55:54,980
当前范围中的合同范围或存储这些都是所有这些都是

745
00:55:56,100 --> 00:56:01,380
每次您

746
00:56:01,380 --> 00:56:07,780
调用一些添加新的呼叫框架的东西，例如呼叫委托呼叫呼叫创建两个

747
00:56:07,780 --> 00:56:12,820
这将创建新的范围，然后合同也很有趣，因为它

748
00:56:12,820 --> 00:56:14,860
它有发件人。

749
00:56:14,860 --> 00:56:17,640
因此，呼叫者是消息。

750
00:56:17,640 --> 00:56:19,519
如果您写一些牢固性。

751
00:56:19,519 --> 00:56:21,840
所以这是环境环境

752
00:56:21,840 --> 00:56:24,300
在交易中发生了变化。

753
00:56:24,300 --> 00:56:29,140
这就是EVM，口译员将使用

754
00:56:29,140 --> 00:56:31,519
填写指令请求。

755
00:56:31,519 --> 00:56:32,900
像什么是呼叫者？

756
00:56:32,900 --> 00:56:35,380
谁称这份合同？

757
00:56:35,380 --> 00:56:40,380
或者在这里这段记忆的价值是什么？

758
00:56:40,380 --> 00:56:46,220
在这里，这些是可以通过此环境变量访问的东西，所以我有点

759
00:56:46,220 --> 00:56:51,019
简化了很多东西，但这就是您开始在实际中挖掘的样子

760
00:56:51,019 --> 00:56:53,740
我们拥有的VM中的实施

761
00:56:58,300 --> 00:57:05,019
非常感谢您在那里潜水嗯，我一直在看到新问题，但人们仍然是

762
00:57:05,019 --> 00:57:07,619
所以我仍然认为有一个尖峰的晚溪流。

763
00:57:07,619 --> 00:57:07,920
所以。

764
00:57:09,159 --> 00:57:09,420
好的。

765
00:57:10,900 --> 00:57:12,800
好吧，让我们继续前进。

766
00:57:12,940 --> 00:57:21,420
然后，在我们关闭之前，我还有其他几件事要讨论。

767
00:57:21,780 --> 00:57:23,639
这就是状态过渡函数。

768
00:57:23,960 --> 00:57:30,380
让我们更深入地研究以太坊虚拟机是什么。

769
00:57:30,380 --> 00:57:38,039
因此，为了说明这一点，我想快速图表。

770
00:57:38,039 --> 00:57:44,900
这样您就可以了解EVM内部发生的事情。

771
00:57:44,900 --> 00:57:50,340
我认为我只是在EVM中显示了很多有关不同上下文的信息。

772
00:57:50,340 --> 00:57:56,079
但是我倾向于发现，如果人们有图片可以看一下，人们会更好地理解它。

773
00:57:56,079 --> 00:57:59,500
因此，我们将其称为EVM。

774
00:57:59,500 --> 00:58:02,659
这是EVM框。

775
00:58:03,719 --> 00:58:06,820
这本质上是EVM呼叫框架。

776
00:58:07,360 --> 00:58:11,300
因此，就像我说的那样，呼叫框架在整个交易中都会发生变化。

777
00:58:12,219 --> 00:58:16,639
而且您只能访问与该呼叫框架相关的事物。

778
00:58:17,039 --> 00:58:21,019
因此，该呼叫框架中可访问的内容是代码。

779
00:58:21,679 --> 00:58:24,679
这是您当前正在执行的代码。

780
00:58:24,679 --> 00:58:30,719
除了该代码外，您还需要知道要执行的代码中的位置。

781
00:58:30,859 --> 00:58:31,759
因此，您有PC。

782
00:58:31,940 --> 00:58:33,019
那是程序计数器。

783
00:58:33,319 --> 00:58:39,339
如果您完全熟悉口译员，那么您将熟悉PC的工作原理。

784
00:58:39,659 --> 00:58:45,519
但基本上，这只是在说解释器正在处理的方式是，如果PC在0，

785
00:58:45,659 --> 00:58:51,059
它将在代码中的索引0上加载指令，然后执行它。

786
00:58:51,059 --> 00:58:58,340
然后，如果指令大于一个字节，它将更新PC或可能更多。

787
00:58:58,719 --> 00:59:00,320
但是我们的大多数指示都是一个字节。

788
00:59:01,099 --> 00:59:04,840
因此，我们还有其他一些框架级别的东西。

789
00:59:04,920 --> 00:59:05,779
我们有堆栈。

790
00:59:06,719 --> 00:59:07,940
我们有记忆。

791
00:59:13,900 --> 00:59:15,000
我们有气。

792
00:59:15,299 --> 00:59:16,279
剩余的气体。

793
00:59:21,059 --> 00:59:29,000
这些主要是我们仅针对这种执行框架所拥有的。

794
00:59:29,420 --> 00:59:32,980
我们也有像我们看到的东西。

795
00:59:33,099 --> 00:59:36,900
我们有我刚刚结束的区块上下文。

796
00:59:36,960 --> 00:59:38,340
我们有TX上下文。

797
00:59:38,340 --> 00:59:40,539
这些在框架内可访问。

798
00:59:41,320 --> 00:59:44,719
我们也有可访问的状态。

799
00:59:46,179 --> 00:59:50,340
因此，有很多操作可以访问该州的一部分。

800
00:59:51,059 --> 00:59:59,019
XCODE大小，XCode哈希，意味着外部代码大小或外部代码哈希。

801
00:59:59,420 --> 01:00:02,519
这些是可以让您阅读州的内容的说明。

802
01:00:03,519 --> 01:00:06,380
诸如Coinbase之类的说明为您提供块上下文。

803
01:00:07,039 --> 01:00:10,360
诸如Origin之类的说明为您提供交易上下文。

804
01:00:13,239 --> 01:00:18,420
好的，这主要是VM的样子。

805
01:00:18,420 --> 01:00:27,820
喜欢。要更多地了解EVM的工作原理，我们可以拥有一个快速示例程序。

806
01:00:29,039 --> 01:00:35,760
我们将在这里的操场上做。哦，他们已经有一个。是的，让我们使用这个。

807
01:00:36,360 --> 01:00:42,460
因此，堆栈机的工作方式是堆栈是您进行操作的工作场所。

808
01:00:42,460 --> 01:00:54,420
所有指令本质上都采用堆栈参数来修改该特定指令的行为。

809
01:00:55,179 --> 01:01:02,659
因此，在此示例中，从本质上讲，我们正在用Mstore写一些内容，然后我们将其返回给呼叫者。

810
01:01:03,360 --> 01:01:09,920
因此，如果我们看一下看起来，如果我们逐步逐步，我们将使用第一个指令。

811
01:01:09,920 --> 01:01:13,599
因此，如果我们在这里考虑这张照片，PC等于0。

812
01:01:13,940 --> 01:01:16,680
因此，在此示例中，我们的PC在0。

813
01:01:17,320 --> 01:01:20,420
我们的堆栈和记忆是空的。

814
01:01:20,840 --> 01:01:22,539
然后剩余的气体无关紧要。

815
01:01:22,980 --> 01:01:25,860
但是，让我们想象我们基本上还有无限的气体。

816
01:01:27,200 --> 01:01:30,800
如果我们步骤1通过，我们已经推开了一个价值。

817
01:01:30,860 --> 01:01:32,019
该值是42。

818
01:01:32,619 --> 01:01:35,180
因此，现在我们的堆栈已经成长为一个元素。

819
01:01:35,280 --> 01:01:36,960
它的值为42。

820
01:01:38,099 --> 01:01:39,820
我们运行另一个说明。

821
01:01:39,920 --> 01:01:46,880
同样，将一个推到一个将零推到堆栈上。现在我们在M商店。所以商店，

822
01:01:47,059 --> 01:01:52,200
M商店的工作方式是将堆栈上的第一个元素占用，它将其用作偏移量

823
01:01:52,200 --> 01:01:58,200
写一个值。然后它读取堆栈上的下一个项目。它写下了这一价值

824
01:01:58,200 --> 01:02:03,200
抵消。因此，当我按下下一个按钮时，会发生什么是我们要删除两个

825
01:02:03,200 --> 01:02:09,380
堆栈元素。但是随后记忆将写42个。那正是

826
01:02:09,380 --> 01:02:14,920
发生在这里。因此，现在我们要返回此值。因此，返回价值的方法是您需要

827
01:02:14,920 --> 01:02:20,099
说回报价值将有多大。您需要说从哪里开始阅读

828
01:02:20,099 --> 01:02:28,559
返回值。而这样做的方式是，我们推动十六进制值20，即十进制为32。

829
01:02:28,980 --> 01:02:34,360
然后，我们将索引从零开始。因此，我们将从这里开始。我们会通过

830
01:02:34,360 --> 01:02:35,800
在所有32个字节中。

831
01:02:36,579 --> 01:02:37,900
因此，如果我们只是看那些

832
01:02:38,079 --> 01:02:41,019
我们将20推到堆栈上，将零推到堆栈上。

833
01:02:41,280 --> 01:02:43,420
然后我们将他们俩都返回。

834
01:02:44,019 --> 01:02:46,120
因此，现在我们获得了42个回报值。

835
01:02:46,120 --> 01:02:51,820
这就像堆叠机的工作原理一样，就像

836
01:02:51,960 --> 01:02:54,820
如何思考EVM内的行为。

837
01:02:56,539 --> 01:02:58,940
我会提到，在EVM中，

838
01:02:59,019 --> 01:03:01,720
有许多不同类型的说明。

839
01:03:01,719 --> 01:03:05,619
我们看的是一些非常简单的东西。

840
01:03:08,299 --> 01:03:13,719
通常，您可以将不同的类别视为算术。

841
01:03:16,159 --> 01:03:24,480
因此，算术正在添加，减法，指数，进行模量，这种类型的东西。

842
01:03:24,719 --> 01:03:27,019
有位函数用于位弯曲。

843
01:03:27,259 --> 01:03:31,419
如果您需要执行AN，并且存在X或AN，则存在这些功能。

844
01:03:31,719 --> 01:03:39,179
有环境功能使我们像我提到的那样访问块上下文和TX上下文。

845
01:03:41,339 --> 01:03:50,039
我们还具有呼叫框架说明。

846
01:03:50,439 --> 01:03:56,839
每当我们查看过渡数据库方法时，我们都会看到一点。

847
01:03:56,840 --> 01:04:01,240
在创建时，我们称为EVM.Create。

848
01:04:01,360 --> 01:04:03,940
在打电话给我们致电evm.call。

849
01:04:04,220 --> 01:04:06,140
这些都是说明的类型

850
01:04:06,140 --> 01:04:07,780
在EVM中也存在

851
01:04:07,780 --> 01:04:09,559
如果您需要创建一个新的呼叫框架。

852
01:04:10,420 --> 01:04:11,539
有控制流。

853
01:04:12,400 --> 01:04:14,480
因此，如果您想拥有更复杂的程序，

854
01:04:15,059 --> 01:04:16,320
分支的程序。

855
01:04:17,340 --> 01:04:20,240
通过分支，也许我可以显示的一个例子是

856
01:04:20,240 --> 01:04:25,200
这是4788合同。

857
01:04:26,840 --> 01:04:36,140
因此，这是4788的合同，将在下一个硬叉中使用。

858
01:04:36,140 --> 01:04:39,640
但是您可以在这里看到一个分支的示例。

859
01:04:39,640 --> 01:04:44,120
因此，这是在做什么，它将取决于呼叫者是否等于此

860
01:04:44,120 --> 01:04:46,019
大数字。

861
01:04:46,019 --> 01:04:47,280
这个数字是一个特殊的数字。

862
01:04:47,280 --> 01:04:50,019
这是系统地址。

863
01:04:50,019 --> 01:04:51,960
这就是4788的工作方式。

864
01:04:51,960 --> 01:04:55,860
该系统将使用此地址调用此合同。

865
01:04:55,860 --> 01:04:57,940
在这种情况下，我们知道这是一个特别的电话。

866
01:04:58,460 --> 01:05:06,700
因此，我们使用跳跃i来确定呼叫者是否平等

867
01:05:06,700 --> 01:05:11,519
这个数字是正确的，我们会跳到一定的值。

868
01:05:11,660 --> 01:05:13,620
如果不是这样，我们将跳到不同的价值。

869
01:05:13,980 --> 01:05:17,960
因此，这使您可以控制程序的流程。

870
01:05:19,780 --> 01:05:21,460
然后还有堆栈操作。

871
01:05:22,099 --> 01:05:24,539
因此，我们在该示例中看到了一些堆栈操作。

872
01:05:24,539 --> 01:05:25,559
有推动。

873
01:05:25,880 --> 01:05:28,380
还有流行和交换之类的东西。

874
01:05:28,840 --> 01:05:31,800
这样一来，您就可以以不同的方式操纵堆栈。

875
01:05:34,320 --> 01:05:37,119
然后有一些系统类型的调用，

876
01:05:39,380 --> 01:05:41,539
我想我可以放...

877
01:05:42,659 --> 01:05:45,079
我们可以说呼叫是系统通话的一部分。

878
01:05:45,219 --> 01:05:46,460
因此，我们可以说呼叫创建。

879
01:05:46,860 --> 01:05:48,480
我们看到了这个回报值。

880
01:05:48,639 --> 01:05:49,900
这是一种系统调用。

881
01:05:53,659 --> 01:05:54,139
是的。

882
01:05:54,539 --> 01:05:56,940
也许商店，

883
01:05:57,440 --> 01:05:58,279
S商店。

884
01:05:58,579 --> 01:06:00,719
这写信给合同的存储。

885
01:06:01,239 --> 01:06:03,139
然后有一些内存操作。

886
01:06:03,139 --> 01:06:05,019
我们可以负载，

887
01:06:05,159 --> 01:06:05,779
商店，

888
01:06:06,500 --> 01:06:07,300
M商店八，

889
01:06:07,900 --> 01:06:09,659
存储一个单个字节。

890
01:06:10,519 --> 01:06:13,500
因此，这些是让我们操纵框架内的内存。

891
01:06:15,579 --> 01:06:16,139
好的。

892
01:06:16,179 --> 01:06:19,519
那是与EVM相关事物的超快速速成课程。

893
01:06:19,619 --> 01:06:20,940
关于EVM有什么疑问吗？

894
01:06:24,539 --> 01:06:33,659
保罗问的一个问题是如何确定各种教学成本？

895
01:06:36,300 --> 01:06:45,300
很久以前，做了一些基准测试。

896
01:06:46,099 --> 01:06:53,079
我忘记了每秒目标气体是我们大致靶向的。

897
01:06:54,539 --> 01:06:57,659
我不知道我是否能找到，我不知道我是否能很快找到。

898
01:06:57,659 --> 01:07:03,940
嗯，基本上每秒有一个气体，我们想在特定上处理

899
01:07:03,940 --> 01:07:05,400
处理器体系结构。

900
01:07:05,739 --> 01:07:10,519
这就是我们大致达到不同汽油价格的地方。

901
01:07:11,019 --> 01:07:16,159
而且我不记得我头顶上每秒的气是什么，但是我们只是

902
01:07:16,159 --> 01:07:18,059
提出一个使用指令的基准。

903
01:07:18,059 --> 01:07:21,239
我们会经常运行很多次

904
01:07:21,239 --> 01:07:24,079
看看多少次

905
01:07:24,079 --> 01:07:25,360
你可以每秒运行

906
01:07:25,360 --> 01:07:28,340
然后向后工作

907
01:07:28,340 --> 01:07:30,059
要弄清楚什么是适当的，

908
01:07:30,219 --> 01:07:30,699
就像，你知道，

909
01:07:30,739 --> 01:07:32,539
如果此指令需要这么长时间

910
01:07:32,579 --> 01:07:34,980
那我们需要什么气

911
01:07:34,980 --> 01:07:37,420
要达到每秒的气体？

912
01:07:38,579 --> 01:07:40,159
在这一点上，你知道，

913
01:07:40,759 --> 01:07:41,940
我们有很多说明

914
01:07:41,940 --> 01:07:45,559
因此，有时候我们不会非常紧密

915
01:07:45,559 --> 01:07:46,880
进行这种类型的基准测试。

916
01:07:46,880 --> 01:07:49,680
因此，伦敦硬叉带来了基本费用。

917
01:07:50,059 --> 01:07:53,840
而且在该特定指令上并没有真正的基准测试，因为我们只是

918
01:07:53,840 --> 01:08:00,619
复制了与其他块上下文类型指令相同的气体值。

919
01:08:01,280 --> 01:08:09,059
因此，今天很多这些事情都使用其他类似类型的说明的气体成本

920
01:08:09,059 --> 01:08:09,420
是。

921
01:08:09,780 --> 01:08:13,320
我们仍然要处理这种粗糙的气体。

922
01:08:13,320 --> 01:08:14,920
但是我想

923
01:08:14,920 --> 01:08:17,739
我认为事情不是完美的

924
01:08:17,739 --> 01:08:18,300
排队

925
01:08:18,300 --> 01:08:21,180
有些事情可能是

926
01:08:21,180 --> 01:08:22,739
被过多的费用

927
01:08:22,739 --> 01:08:28,300
太棒了，谢谢

928
01:08:28,300 --> 01:08:31,180
一些人现在打字，所以也许

929
01:08:31,180 --> 01:08:33,060
我们给五个

930
01:08:33,060 --> 01:08:35,100
几秒钟，如果有什么事

931
01:08:35,100 --> 01:08:37,119
我们可以继续

932
01:08:37,119 --> 01:08:39,180
是的，我很喜欢

933
01:08:39,180 --> 01:08:41,119
另外15分钟左右

934
01:08:41,119 --> 01:08:42,100
我不知道没关系

935
01:08:42,100 --> 01:08:44,700
是的，太好了

936
01:08:44,700 --> 01:08:46,240
甜的

937
01:08:46,240 --> 01:08:50,020
酷让我们

938
01:08:50,020 --> 01:08:52,220
只要继续努力，然后我们就可以做

939
01:08:52,220 --> 01:08:53,940
最后一个大问题

940
01:08:53,940 --> 01:08:54,740
好的

941
01:08:54,740 --> 01:08:57,960
好吧，我们谈论的

942
01:08:57,960 --> 01:09:00,480
我们谈论的块验证

943
01:09:00,480 --> 01:09:01,700
建筑物

944
01:09:01,700 --> 01:09:03,539
状态过渡功能

945
01:09:03,539 --> 01:09:05,860
超高级概述

946
01:09:05,860 --> 01:09:07,340
关于EVM的工作方式

947
01:09:07,340 --> 01:09:10,020
现在我想谈谈

948
01:09:10,020 --> 01:09:11,300
点对点层

949
01:09:11,300 --> 01:09:17,659
当我们谈论交易池时，我们提到了一点

950
01:09:17,659 --> 01:09:19,260
以及如何构建块。

951
01:09:19,659 --> 01:09:26,500
但是我想更多地挖掘对等层的外观？

952
01:09:26,699 --> 01:09:27,960
它的责任是什么？

953
01:09:27,960 --> 01:09:41,199
因此，执行层在称为devptp的PDP协议上运行。

954
01:09:41,300 --> 01:09:48,980
DevP2P是以太坊的定制协议。

955
01:09:49,900 --> 01:09:52,539
它从以太坊的开始就发展起来。

956
01:09:53,760 --> 01:09:57,900
我想今天关于DEVP2P的有趣的复活节彩蛋。

957
01:09:58,020 --> 01:10:04,860
如果您不熟悉，我们将调用DEVP2P协议，例如Eth68，Eth69。

958
01:10:05,680 --> 01:10:09,400
我认为我们现在正在使用Eth68，从事Eth69的工作。

959
01:10:09,399 --> 01:10:26,379
但是，我想我应该说这就像一个子功能，所以

960
01:10:26,379 --> 01:10:37,479
是DevP2P下的其他协议，我们有ETH，我们有一个是

961
01:10:37,479 --> 01:10:45,159
今天的主要收益。曾经有诸如耳语之类的东西。是

962
01:10:45,159 --> 01:10:48,879
我还有其他想法吗？我想我们可以

963
01:10:48,879 --> 01:10:49,439
看看它。

964
01:10:55,339 --> 01:11:02,459
哦，是的。莱斯。有一些证人传播的想法

965
01:11:02,500 --> 01:11:07,359
亚功能，这将使我们能够传播块

966
01:11:07,359 --> 01:11:14,079
目击者就是那些是的是，是的，是窃窃私语的见证人的事物

967
01:11:14,079 --> 01:11:19,579
今天弃用了，我们真的只关注ETH和SNAP，我要说一个有趣的复活节彩蛋

968
01:11:19,579 --> 01:11:26,699
对于ETH，您知道我们现在在ETH 68 69上我们没有68个ETH协议

969
01:11:26,699 --> 01:11:34,719
早期发生的事情是我们从ETH 1开始，然后进入ETH 2，有

970
01:11:34,720 --> 01:11:38,500
在以太坊的早期，很多非常快速的迭代。

971
01:11:38,500 --> 01:11:41,980
我们有点绕过6。

972
01:11:42,579 --> 01:11:52,000
到那时，我认为他们开始尝试用ETH 6.1，ETH 6.2进行思考。

973
01:11:53,340 --> 01:11:56,000
所有这些协议都丢失了。

974
01:11:56,100 --> 01:12:01,560
您将不再在客户端定义中真正找到这些类型的协议，因为这

975
01:12:01,560 --> 01:12:06,960
您知道，在发布前，很早发布。所以我们

976
01:12:06,960 --> 01:12:10,140
最终我不知道第一个是什么

977
01:12:10,140 --> 01:12:12,300
这里提到的是

978
01:12:20,220 --> 01:12:22,620
好的，当前版本是E 68。

979
01:12:22,619 --> 01:12:31,019
好的。

980
01:12:31,119 --> 01:12:32,239
是的，Eth 60。

981
01:12:33,619 --> 01:12:35,180
所以我们有一堆POC。

982
01:12:35,340 --> 01:12:37,460
因此，就像POC 1、2、3、4、5、6一样。

983
01:12:37,460 --> 01:12:43,279
然后终于6点在6岁时，他们说我们不能继续这样做。

984
01:12:43,340 --> 01:12:46,140
让我们只做6.0、6.1等。

985
01:12:46,279 --> 01:12:51,059
因此，2015年，我们拥有ETH 61，ETH 62，63。

986
01:12:51,060 --> 01:12:56,440
我认为64可能是您可能在客户中看到的最后一个。

987
01:12:57,300 --> 01:13:00,940
但是，是的，我们对ETH协议进行了许多不同的更改。

988
01:13:01,180 --> 01:13:03,980
因此，没有68个ETH协议。

989
01:13:04,260 --> 01:13:08,640
大约有15种ETH协议，这很有趣。

990
01:13:09,440 --> 01:13:12,700
但是好吧，回到PDP对我们有什么作用？

991
01:13:12,700 --> 01:13:16,700
所以责任...

992
01:13:16,699 --> 01:13:25,880
我们需要能够访问历史数据。

993
01:13:27,479 --> 01:13:32,399
我们还需要能够访问交易。

994
01:13:36,960 --> 01:13:38,439
我会说新交易。

995
01:13:38,619 --> 01:13:40,099
实际上，汇总交易。

996
01:13:40,619 --> 01:13:42,179
所以这些正在待处理。

997
01:13:43,039 --> 01:13:46,199
因此，这些是试图传播的交易

998
01:13:46,199 --> 01:13:47,479
进入一个街区。

999
01:13:47,579 --> 01:13:48,579
他们还没有在街区中。

1000
01:13:49,760 --> 01:13:50,760
然后说。

1001
01:13:52,099 --> 01:13:55,460
所以这是三个主要部分

1002
01:13:55,460 --> 01:13:56,979
那个ETH协议，

1003
01:13:57,300 --> 01:13:59,079
DEVP2P协议和ETH协议

1004
01:13:59,079 --> 01:14:00,000
试图提供，

1005
01:14:00,319 --> 01:14:01,579
试图给我们。

1006
01:14:02,939 --> 01:14:04,319
所以让我们看一下，

1007
01:14:05,619 --> 01:14:07,939
让我们看访问历史数据。

1008
01:14:09,199 --> 01:14:12,019
这是通过两种不同的方法完成的

1009
01:14:12,519 --> 01:14:13,559
或多或少。

1010
01:14:13,560 --> 01:14:26,039
获取标题，获取块标头并获得块尸体。如果您考虑什么是历史

1011
01:14:26,039 --> 01:14:35,300
数据，或多或少是这两件事。还有，请确保我有一个权利。

1012
01:14:35,300 --> 01:14:37,680
git块。

1013
01:14:38,199 --> 01:14:39,320
GIT收据。

1014
01:14:39,980 --> 01:14:40,119
是的。

1015
01:14:40,720 --> 01:14:42,220
因此，还有GIT收据。

1016
01:14:44,400 --> 01:14:46,680
所以这三种方法

1017
01:14:46,680 --> 01:14:48,840
这使我们能够获取所有历史数据

1018
01:14:48,840 --> 01:14:49,739
与以太坊有关。

1019
01:14:50,140 --> 01:14:52,279
如果您考虑什么是历史数据，

1020
01:14:52,360 --> 01:14:55,860
它的数据不需要

1021
01:14:55,860 --> 01:14:59,400
用于积极验证状态过渡函数。

1022
01:14:59,820 --> 01:15:01,779
如果我们回头，我们认为

1023
01:15:01,779 --> 01:15:04,020
该状态过渡功能是什么，

1024
01:15:04,020 --> 01:15:09,440
您知道它正在占用父块，我们将假设在客户端可用

1025
01:15:09,440 --> 01:15:16,240
在客户的热记忆中，这是一种可以访问的当前块

1026
01:15:16,240 --> 01:15:20,660
要验证，然后是状态，这样我就没有什么可以让我访问所有

1027
01:15:20,660 --> 01:15:25,340
以太坊的历史块，或者您在国家过渡功能中知道没有地方

1028
01:15:25,340 --> 01:15:31,280
我正在检查200个街区的一个街区的标题，所以这就是为什么我们将其称为

1029
01:15:31,279 --> 01:15:36,279
历史数据，链中发生的事情，但不一定是在活动路径中

1030
01:15:36,279 --> 01:15:44,739
用于验证。我们也有一些获得交易的方法。我们有方法

1031
01:15:44,739 --> 01:15:49,399
交易，已经存在一段时间了。然后我们有了这种较新的方法

1032
01:15:49,399 --> 01:15:58,039
新的合并交易哈希。而且这种新的池交易哈希方法出现了，

1033
01:15:58,039 --> 01:16:05,960
我认为在Eth66中。当时的理由是我们需要减少带宽的使用

1034
01:16:05,960 --> 01:16:14,300
执行客户端。即使在今天，尤其是今天，现在您的客户同步了，

1035
01:16:15,380 --> 01:16:21,880
您几乎所有的网络带宽都用于交易。

1036
01:16:21,880 --> 01:16:30,760
因此，在E66中，彼得想找出一种减少负载的方法，即执行客户端的带宽负载。

1037
01:16:30,980 --> 01:16:45,440
他想出了一个想法，即当我们获得新的交易时，与其将完整的交易发送给我们的每个同行，要么同行宣布交易给我们，要么我们在本地收到。

1038
01:16:45,800 --> 01:16:50,739
我们只会将其发送给所有同龄人，而是将其发送到同龄人的平方根。

1039
01:16:50,739 --> 01:16:55,639
我们所有的同行都将获得新的泳池交易。

1040
01:16:56,479 --> 01:16:59,639
完整的交易转到一个随机子集，

1041
01:17:00,000 --> 01:17:02,199
平方根对等的随机子集。

1042
01:17:02,699 --> 01:17:06,619
因此，这确实有助于减轻带宽的用法

1043
01:17:06,619 --> 01:17:09,739
我一遍又一遍地得到相同的交易

1044
01:17:09,739 --> 01:17:14,019
来自许多不同的节点。

1045
01:17:14,300 --> 01:17:18,340
现在，我大部分都从其他节点复制了哈希。

1046
01:17:18,340 --> 01:17:25,539
而且我只称呼这种方法，我认为这是被拉出的交易。

1047
01:17:28,119 --> 01:17:35,300
因此，如果我收到一些以前从未见过的哈希，我只会称此方法被拉出交易。

1048
01:17:37,560 --> 01:17:47,340
我们可以看的一件有趣的事情是，我们实际上可以去查看以太坊执行平方根公告的代码线。

1049
01:17:48,340 --> 01:17:50,460
那是在eth中。

1050
01:17:51,239 --> 01:17:52,579
我认为这是在处理者中。

1051
01:17:55,480 --> 01:17:56,020
是的。

1052
01:17:56,760 --> 01:17:57,239
好的。

1053
01:17:57,539 --> 01:17:59,760
因此，有一个功能广播交易。

1054
01:17:59,760 --> 01:18:05,100
只要有可以广播的交易，该方法就会称为。

1055
01:18:05,100 --> 01:18:09,520
它的作用是

1056
01:18:09,520 --> 01:18:21,840
好的，每次交易

1057
01:18:21,840 --> 01:18:28,820
我们确定该交易是否已被其他客户看到，我们也确定

1058
01:18:28,820 --> 01:18:33,539
我们有多少同龄人将直接接收到这一点

1059
01:18:33,539 --> 01:18:38,640
平方根函数是。因此，根据我们有多少同龄人，我们将其扎根。

1060
01:18:38,739 --> 01:18:51,159
这就是直接同龄人的数量。我们在哪里使用？是的，好吧。所以我认为同龄人是

1061
01:18:51,159 --> 01:19:01,399
同行的随机列表。因此，我们在这里说，好吧，一直到Num Direct。所以你

1062
01:19:01,399 --> 01:19:03,819
您可以想象这是一个很小的价值，例如两个。

1063
01:19:04,979 --> 01:19:08,879
因此，同行索引为零，一个。

1064
01:19:09,179 --> 01:19:12,460
我们将无条件发送此交易。

1065
01:19:13,199 --> 01:19:19,359
对于其他所有人来说，我们只是在这里使用列表切片。

1066
01:19:19,519 --> 01:19:23,219
我们将向所有其他同行发送公告。

1067
01:19:24,859 --> 01:19:29,939
是的，这就是使用此公告列表与TX集列表。

1068
01:19:29,939 --> 01:19:33,719
这就是在这个文件中。

1069
01:19:33,839 --> 01:19:34,139
这是什么？

1070
01:19:34,199 --> 01:19:35,719
Eth Slash Handler.go。

1071
01:19:35,819 --> 01:19:39,099
您实际上可以看到这是这种行为的地方

1072
01:19:39,099 --> 01:19:42,819
从开发人员中，P2P层即将到来。

1073
01:19:44,779 --> 01:19:48,059
因此，如果我们快速查看不同的方法，

1074
01:19:48,179 --> 01:19:49,939
让我们看一下它们。

1075
01:19:52,119 --> 01:19:53,399
GIT块标题。

1076
01:19:54,339 --> 01:19:58,479
请求，我们使用此请求ID。

1077
01:19:58,479 --> 01:20:01,519
这也许是在ETH 67中添加的。

1078
01:20:02,859 --> 01:20:06,679
并且请求ID只是让我们继续跟踪

1079
01:20:06,679 --> 01:20:07,819
我们的要求更好。

1080
01:20:08,419 --> 01:20:11,059
因此，当我们发送请求时，我们发送ID

1081
01:20:11,059 --> 01:20:12,659
然后回应又回来了

1082
01:20:12,659 --> 01:20:14,039
它为我们提供了相同的ID。

1083
01:20:14,679 --> 01:20:18,319
只是帮助跟踪飞行中的请求。

1084
01:20:18,939 --> 01:20:21,679
我们说，这是一个开始。

1085
01:20:22,139 --> 01:20:25,419
所以这将是块值

1086
01:20:25,420 --> 01:20:31,800
我们想开始从中收到。

1087
01:20:32,520 --> 01:20:34,579
我们会说我们想要多少个街区。

1088
01:20:34,960 --> 01:20:36,060
然后我们有能力

1089
01:20:36,060 --> 01:20:38,180
还可以使它们有可能相反。

1090
01:20:38,899 --> 01:20:42,480
这很重要，因为在合并之前，

1091
01:20:42,600 --> 01:20:44,859
您同步节点的方式，

1092
01:20:45,220 --> 01:20:46,980
同步历史是您将从创世纪开始

1093
01:20:46,980 --> 01:20:49,199
因为这是第一个

1094
01:20:49,199 --> 01:20:54,920
这是链的可信根。

1095
01:20:55,420 --> 01:20:57,000
我们只会同步。

1096
01:20:57,140 --> 01:20:58,699
我们将下载所有标题，

1097
01:20:59,440 --> 01:21:01,279
下载所有块尸体。

1098
01:21:01,819 --> 01:21:03,020
因此，我们将同步。

1099
01:21:03,199 --> 01:21:05,039
我们会说开始块零，

1100
01:21:06,199 --> 01:21:09,239
从零下载20个块。

1101
01:21:09,539 --> 01:21:10,859
因此，我们将达到20。

1102
01:21:11,300 --> 01:21:14,159
通过合并，我们实际上是相反的。

1103
01:21:14,359 --> 01:21:16,260
因此，我们有一个值得信赖的检查站，

1104
01:21:16,720 --> 01:21:18,300
有点像创世纪。

1105
01:21:18,699 --> 01:21:21,020
但是现在值得信赖的检查站在某个地方，

1106
01:21:21,739 --> 01:21:24,140
您知道，链的非零部分过去的创世纪，

1107
01:21:24,140 --> 01:21:31,020
我们想获取历史数据。因此，如果我们的检查站就像块，我们会说我想获得

1108
01:21:31,720 --> 01:21:36,180
启动块以大概20个限制，并将块反向使块

1109
01:21:36,180 --> 01:21:40,860
因此，我们将在减去1和Minus 2中下载到N MINUS 20

1110
01:21:40,860 --> 01:21:44,260
这样就可以让我们向后下载所有这些块

1111
01:21:45,700 --> 01:21:48,480
获得块尸体基本上是同一回事

1112
01:21:48,479 --> 01:21:55,599
一旦我们实际上不是这个

1113
01:21:55,599 --> 01:22:00,359
我们一旦获得了标题，我们就知道块哈希是什么，所以我们可以只是

1114
01:22:00,359 --> 01:22:06,599
要求与这些特定标头有关的尸体，以便我们发送所有块的列表

1115
01:22:06,599 --> 01:22:12,539
我们拥有并为那些人拥有尸体的哈希，我得到的收据与

1116
01:22:12,539 --> 01:22:13,539
是的。

1117
01:22:13,539 --> 01:22:16,920
因此，在与收据的同时，我们有链条。

1118
01:22:16,920 --> 01:22:19,619
我们已经通过GIT块标头收到了链条。

1119
01:22:19,619 --> 01:22:25,100
然后我们就走了，我们通过块哈希收据来获得所有这些收据。

1120
01:22:25,100 --> 01:22:31,460
因此，这是获取待处理交易的历史数据。

1121
01:22:31,460 --> 01:22:39,399
我们有一个方法交易。

1122
01:22:39,399 --> 01:22:44,420
因此，这可能没有任何类型的请求。

1123
01:22:44,420 --> 01:22:50,159
许多其他消息是获取块，获得交易等等。

1124
01:22:50,159 --> 01:22:53,079
这是您只会无条件发送给同伴的东西。

1125
01:22:53,079 --> 01:22:57,099
就像我们在broad.th.unction广播交易中所看到的。

1126
01:22:57,099 --> 01:23:00,960
这将直接将交易直接发送到您的同伴。

1127
01:23:00,960 --> 01:23:04,879
因此，它实际上只是发送交易列表。

1128
01:23:04,880 --> 01:23:09,819
另一个是新的池交易哈希。

1129
01:23:09,819 --> 01:23:16,460
这个更复杂，但基本上只是发送交易列表

1130
01:23:16,460 --> 01:23:21,640
类型，大小和交易的哈希。

1131
01:23:21,640 --> 01:23:27,779
因此，一旦收到了这些，您就可以查看这些是您尚未看到的交易哈希

1132
01:23:27,779 --> 01:23:29,400
前。

1133
01:23:29,400 --> 01:23:34,579
如果它们是您以前从未见过的交易哈希，则可以调用获取池交易。

1134
01:23:34,579 --> 01:23:42,399
传递交易哈希，然后对等方将以完整的交易值响应。

1135
01:23:43,300 --> 01:23:45,359
这是在泳池交易中返回的。

1136
01:23:45,840 --> 01:23:50,340
池交易看起来非常类似于交易消息。

1137
01:23:51,859 --> 01:23:55,260
好的，这是历史数据，等待数据。

1138
01:23:55,800 --> 01:24:02,279
我想在P2P上提及的最后责任是访问州。

1139
01:24:02,279 --> 01:24:06,880
因此，很多人可能听说过Snapsync。

1140
01:24:07,420 --> 01:24:10,920
我只想快速说出Snapsync的工作原理。

1141
01:24:11,579 --> 01:24:17,300
在高水平上，您可以将SnapSync视为两阶段协议。

1142
01:24:17,300 --> 01:24:24,460
第一阶段是我需要连续下载一堆数据。

1143
01:24:25,179 --> 01:24:25,559
所以如果我们...

1144
01:24:27,399 --> 01:24:28,319
糟糕。

1145
01:24:28,319 --> 01:24:32,219
如果我们考虑

1146
01:24:32,219 --> 01:24:34,779
尝试

1147
01:24:34,779 --> 01:24:37,279
作为

1148
01:24:37,279 --> 01:24:40,079
某种

1149
01:24:40,079 --> 01:24:41,679
默克树

1150
01:24:41,679 --> 01:24:46,299
该图只是一棵二进制树

1151
01:24:46,299 --> 01:24:47,399
因为那是

1152
01:24:47,399 --> 01:24:49,539
真的很难画

1153
01:24:49,539 --> 01:24:52,199
画真的很难

1154
01:24:52,199 --> 01:24:54,319
一棵十大树

1155
01:24:54,319 --> 01:24:57,179
在文字中

1156
01:24:57,180 --> 01:24:59,539
我确定它已经完成了

1157
01:24:59,539 --> 01:25:04,039
好吧，这是

1158
01:25:04,039 --> 01:25:05,539
b

1159
01:25:05,539 --> 01:25:09,140
c

1160
01:25:09,140 --> 01:25:12,020
d

1161
01:25:12,020 --> 01:25:13,740
好的，这样

1162
01:25:13,740 --> 01:25:15,800
Snapsync Works是

1163
01:25:15,800 --> 01:25:17,980
你

1164
01:25:17,980 --> 01:25:19,619
第一个请求

1165
01:25:19,619 --> 01:25:21,880
叶子的叶子

1166
01:25:21,880 --> 01:25:23,780
against

1167
01:25:23,780 --> 01:25:25,820
根，所以说这个

1168
01:25:25,820 --> 01:25:26,700
是根1

1169
01:25:26,699 --> 01:25:37,260
因此，根部正在改变是一个很小的例子，但显然您知道

1170
01:25:37,260 --> 01:25:42,899
我不知道也许我们必须访问的是数百万个不同的叶子节点

1171
01:25:42,899 --> 01:25:48,739
我们必须访问2亿个叶子节点，因此，当我们经历此过程时，我们可能会访问

1172
01:25:49,300 --> 01:25:56,579
a和b针对根，然后扎根一个变化，因为节点不节点不节点

1173
01:25:56,579 --> 01:26:02,439
保持所有历史状态。他们只保留那种热状态，即活跃状态。在去

1174
01:26:02,439 --> 01:26:09,399
以太坊和许多客户，这是最近128个州。因此，如果一路为块，

1175
01:26:09,500 --> 01:26:14,300
假设一个，现在您需要访问...现在区块链已经继续前进了。

1176
01:26:14,300 --> 01:26:28,320
区块链已经继续前进，现在在呃，你知道200这些都会完全

1177
01:26:28,320 --> 01:26:38,920
嗯，我们已经下载了我们下载的试验的这一部分，我们已经下载了

1178
01:26:38,920 --> 01:26:40,180
这是审判的一部分。

1179
01:26:40,260 --> 01:26:41,039
我们有一个和B。

1180
01:26:42,039 --> 01:26:43,359
现在我们处于200号块。

1181
01:26:43,739 --> 01:26:45,140
花了很长时间

1182
01:26:45,140 --> 01:26:46,359
让我们下载这些东西。

1183
01:26:46,640 --> 01:26:47,920
我们需要下载C和D。

1184
01:26:48,060 --> 01:26:49,480
C和D仍然没有改变。

1185
01:26:50,079 --> 01:26:51,739
我们可以下载这些。

1186
01:26:52,239 --> 01:26:53,440
所以现在像本地一样

1187
01:26:53,440 --> 01:26:56,819
我们拥有的是A，B，C，D。

1188
01:26:58,000 --> 01:27:00,579
以及我们在链上看到的

1189
01:27:00,579 --> 01:27:03,859
是A和B不匹配

1190
01:27:03,859 --> 01:27:07,460
在该街区200的路线中。

1191
01:27:07,460 --> 01:27:26,439
因此，现在我们需要去，我们需要问，例如，更新值是什么？因此，快照协议的第一部分只是我不知道如何说出这种连续的状态检索。

1192
01:27:26,439 --> 01:27:34,299
因此，我们只是在进行，我们正在访问每个叶子以获取帐户。

1193
01:27:34,299 --> 01:27:35,939
这就像超级简单。

1194
01:27:35,939 --> 01:27:37,219
显然有帐户尝试。

1195
01:27:37,219 --> 01:27:38,939
然后在它下面尝试一个存储。

1196
01:27:38,939 --> 01:27:43,979
但是您只会通过，您将启动最低的索引叶节点，下载它，

1197
01:27:43,979 --> 01:27:47,319
下载下一个，一直穿过，直到到达州的尽头。

1198
01:27:47,319 --> 01:27:49,899
一旦完成了州的尽头，您就会看到您可能有东西

1199
01:27:49,899 --> 01:27:51,099
那是陈旧的。

1200
01:27:51,099 --> 01:27:55,859
因此，C和D仍然有效，但是A和B不正确。

1201
01:27:55,859 --> 01:28:01,719
因此，现在您必须经历这个康复阶段，如果您运行Geth节点或任何

1202
01:28:01,719 --> 01:28:06,259
进行快照同步的节点可能是最令人困惑的部分。

1203
01:28:06,259 --> 01:28:12,159
因此，康复阶段实际上只是在您的树中走过并试图获得完整性

1204
01:28:12,159 --> 01:28:13,899
国家回来的。

1205
01:28:13,899 --> 01:28:16,219
因此，您将通过路径查找。

1206
01:28:16,219 --> 01:28:25,759
因此，您可能会问，好吧，让我完整的root 200节点列表。

1207
01:28:25,760 --> 01:28:35,380
在这里放1和2。因此，这个康复阶段可能就像获得R200。那会回到你身边

1208
01:28:35,380 --> 01:28:47,619
节点1和2，此处列出。下一部分是获得1。

1209
01:28:47,619 --> 01:28:56,340
R和A。现在您会注意到这条路完全相同。如果您用术语考虑

1210
01:28:56,340 --> 01:29:04,079
在二进制树中，左节点可能为索引零。左节点为索引零，零。

1211
01:29:04,500 --> 01:29:11,559
左至右节点就像索引零一个。因此，这些是零，零，零的路径。

1212
01:29:11,560 --> 01:29:15,520
您现在可以看到，对于0，0，您有A。

1213
01:29:16,160 --> 01:29:19,220
您已经有一个了，但是告诉您实际上是R。

1214
01:29:19,760 --> 01:29:26,340
因此，我们现在可以更新我们的当地状态以成为RACD。

1215
01:29:27,120 --> 01:29:29,100
您将继续这个康复过程。

1216
01:29:29,340 --> 01:29:32,120
您会看到您必须更新它，

1217
01:29:32,500 --> 01:29:34,100
但是随后您下降到2。

1218
01:29:36,180 --> 01:29:37,740
你说得到2。

1219
01:29:37,739 --> 01:29:44,399
而且您会发现您已经拥有C和D，这都是正确的。因此无需更新

1220
01:29:44,399 --> 01:29:51,739
在这一点上，就像康复一样。这可能很难概念化，因为它是

1221
01:29:51,739 --> 01:29:57,840
这样的一个很小的例子，但是如果您将其推送到数百万节点，这可能是

1222
01:29:57,840 --> 01:30:05,019
非常缓慢的过程。有趣的是，这个过程的功能很重要

1223
01:30:05,020 --> 01:30:11,580
快速您可以下载这样做，如果可以这样做，您可以多快下载下载

1224
01:30:11,580 --> 01:30:17,860
就像想象一下，您可以立即下载此连续下载，然后下载所有内容

1225
01:30:17,860 --> 01:30:23,080
R1因此，您可以在R1透视之前下载所有内容，这意味着您不必

1226
01:30:23,080 --> 01:30:29,960
进行任何康复

1227
01:30:29,960 --> 01:30:37,680
路线。每当您无法完成连续的状态检索时，才能进行康复

1228
01:30:37,680 --> 01:30:43,180
违反相同的路线。因此，您下载了一些针对R1的下载，您下载了一些R200，

1229
01:30:43,460 --> 01:30:49,039
有些反对R400，然后继续进行。因此，如果您的互联网连接非常缓慢，

1230
01:30:49,380 --> 01:30:55,020
而且，一旦您进入治愈阶段，您将需要很长时间才能进行状态检索

1231
01:30:55,020 --> 01:30:58,320
您有很多过时的节点。

1232
01:30:58,800 --> 01:31:01,200
因此，现在您必须经历这个非常缓慢的过程

1233
01:31:01,200 --> 01:31:05,400
下载数据的旁路检索。

1234
01:31:05,920 --> 01:31:07,540
这就是为什么有时人们会说的原因，

1235
01:31:07,700 --> 01:31:09,540
为什么我的节点粘在康复上？

1236
01:31:11,340 --> 01:31:14,000
这通常就是正在发生的事情。

1237
01:31:14,000 --> 01:31:21,300
他们的节点试图治愈一种非常变形的状态尝试。

1238
01:31:21,920 --> 01:31:25,000
因此，有时最好只是重新发行

1239
01:31:25,020 --> 01:31:30,200
只需删除完整的数据库，然后尝试从连续的状态检索重新开始即可。

1240
01:31:30,740 --> 01:31:32,880
如果您的互联网有问题，

1241
01:31:32,880 --> 01:31:38,000
也许您的节点很长一段时间都离线，并且具有连续状态，

1242
01:31:38,080 --> 01:31:39,420
但是它必须进行康复。

1243
01:31:39,780 --> 01:31:42,680
有时最好再次下载所有州。

1244
01:31:44,100 --> 01:31:50,140
而且我们不想深入了解不同的快照消息，但这一切都在这里。

1245
01:31:50,140 --> 01:31:52,260
我在这个存储库

1246
01:31:52,260 --> 01:31:53,579
是

1247
01:31:53,579 --> 01:31:58,539
这个存储库是

1248
01:31:58,539 --> 01:32:00,700
在以太坊组织

1249
01:32:00,700 --> 01:32:02,460
因此，如果您对其他人感到好奇

1250
01:32:02,460 --> 01:32:04,660
DEVP2P规格的一部分或想挖掘

1251
01:32:04,660 --> 01:32:05,960
对这些事情有更多的

1252
01:32:05,960 --> 01:32:08,600
有以太坊斜线devp2p

1253
01:32:08,600 --> 01:32:10,100
仓库，如果你是

1254
01:32:10,100 --> 01:32:12,539
想要有关Snapsync的更多信息，这是

1255
01:32:12,539 --> 01:32:14,579
snapspec和snapspec

1256
01:32:14,579 --> 01:32:16,680
是超级好

1257
01:32:16,680 --> 01:32:17,980
概述和描述

1258
01:32:17,979 --> 01:32:22,399
绝对是，我认为这绝对值得一读。

1259
01:32:22,539 --> 01:32:26,579
如果您仍然对Snapsync的工作方式感到困惑。

1260
01:32:28,019 --> 01:32:28,619
好的。

1261
01:32:28,979 --> 01:32:29,739
那是P2P。

1262
01:32:29,859 --> 01:32:32,819
有什么问题与P2P内容有关吗？

1263
01:32:38,239 --> 01:32:39,500
非常感谢，马特。

1264
01:32:39,539 --> 01:32:40,219
那太棒了。

1265
01:32:42,099 --> 01:32:46,579
我们已经在聊天中问了一些问题。

1266
01:32:46,579 --> 01:32:53,859
大多数人问你怎么知道你不是在下载错误的链条

1267
01:32:53,859 --> 01:32:59,939
示例连接陷阱节点的启动网络是恶意的。那会发生什么呢？

1268
01:32:59,939 --> 01:33:10,579
是的，在这种情况下，这些路线是经过身份验证的路线。所以你开始的方式

1269
01:33:10,579 --> 01:33:14,420
做snap同步看起来像这样。

1270
01:33:20,819 --> 01:33:23,539
因此，基本上，您从弱主观性检查点开始。

1271
01:33:28,579 --> 01:33:34,979
您知道，您如何获得该价值是由每个人决定的。但是大多数人做的是

1272
01:33:34,979 --> 01:33:44,179
他们从某些检查点服务器获得了一些弱主观性检查点，这使您有一个根

1273
01:33:46,739 --> 01:33:53,699
嗯，让我们看看我们只称其为r，实际上这就像一个块哈希

1274
01:33:54,500 --> 01:33:58,899
所以你去，得到与哈希相关联的块

1275
01:33:58,899 --> 01:34:11,319
与哈希相关联的块后，您就可以开始按照该块状态进行快照

1276
01:34:11,319 --> 01:34:17,619
所以我想在这里阐明的是您正在运行的状态根源

1277
01:34:17,619 --> 01:34:25,539
从您的意义上说，我们相信这种状态的根源是正确的，就像您一样

1278
01:34:25,539 --> 01:34:29,600
没有验证到达该状态根的计算是否正确。

1279
01:34:30,000 --> 01:34:34,319
您假设这是正确的，您将下载相关的状态

1280
01:34:34,319 --> 01:34:34,840
与它。

1281
01:34:35,579 --> 01:34:42,180
而且您有点喜欢继续这样做，因为我们没有验证

1282
01:34:42,180 --> 01:34:42,380
状态。

1283
01:34:42,460 --> 01:34:44,260
因此，您有点看到新块。

1284
01:34:44,380 --> 01:34:47,140
您对其进行标题验证。

1285
01:34:47,720 --> 01:34:51,039
而且，如果标题正确，您只需假设这些状态根是正确的。

1286
01:34:51,140 --> 01:34:52,859
这就是新的根源。

1287
01:34:52,859 --> 01:34:57,599
因此，您可能已经验证了一条路线，其主观性检查点较弱。

1288
01:34:57,739 --> 01:34:59,859
您花了很长时间才下载此数据。

1289
01:35:00,000 --> 01:35:02,359
您最终可以到达200号路线。

1290
01:35:03,039 --> 01:35:05,239
现在您有了不同的路线。

1291
01:35:05,779 --> 01:35:09,380
但是每次我们都相信这条路线是正确的。

1292
01:35:09,519 --> 01:35:12,939
然后，您要回来的数据将对这条路线进行见证。

1293
01:35:12,939 --> 01:35:21,519
因此，如果我要求所有帐户，所有叶子的所有叶子从零到一个，都会返回

1294
01:35:21,520 --> 01:35:26,120
证明r是根200的一部分的证据，即A是根200的一部分。

1295
01:35:27,260 --> 01:35:32,600
因此，在这种情况下，您将不会获得您下载的根本的数据。

1296
01:35:33,940 --> 01:35:40,080
确实，唯一可能发生的事情是国家计算错误

1297
01:35:40,080 --> 01:35:46,240
您正在下载该连锁店接受的一些损坏状态。

1298
01:35:46,239 --> 01:35:52,039
这种情况极有可能发生，因为您知道这就像客户一样

1299
01:35:52,039 --> 01:35:58,420
假设如果您不想依靠，我们有这种经济多数验证链

1300
01:35:58,420 --> 01:36:05,079
如果您想从创世纪验证或合并一个国家是

1301
01:36:05,079 --> 01:36:10,579
纠正您必须进行完整的同步，因此请完全捕捉您知道Snap与

1302
01:36:10,579 --> 01:36:14,899
完整的同步是一种完全独立的访问状态的方式，这就是您开始的地方

1303
01:36:14,899 --> 01:36:16,939
从一开始，您就会应用每一次

1304
01:36:16,939 --> 01:36:18,799
以太坊上发生过的交易

1305
01:36:18,799 --> 01:36:21,000
最终到达

1306
01:36:21,000 --> 01:36:22,879
最新块，并验证

1307
01:36:22,879 --> 01:36:24,839
最新区块的状态等于状态

1308
01:36:24,839 --> 01:36:27,079
所有交易

1309
01:36:27,079 --> 01:36:27,699
您申请了。

1310
01:36:33,439 --> 01:36:33,960
惊人的。

1311
01:36:35,460 --> 01:36:36,819
让我们来看看。也许有

1312
01:36:36,819 --> 01:36:38,859
还有一些问题，但我们当时正在

1313
01:36:38,859 --> 01:36:40,439
我们应该结束。它已经

1314
01:36:40,439 --> 01:36:42,059
超过90分钟。

1315
01:36:42,259 --> 01:36:43,019
我们快100。

1316
01:36:43,020 --> 01:36:45,140
但是是的，令人惊叹的火

1317
01:36:45,140 --> 01:36:47,300
男人非常感谢

1318
01:36:47,300 --> 01:36:48,400
它是

1319
01:36:48,400 --> 01:36:50,220
里面真的很棒

1320
01:36:50,220 --> 01:36:52,800
人们爱你

1321
01:36:52,800 --> 01:36:55,020
vim设置的方式已经

1322
01:36:55,020 --> 01:36:57,240
找到您的.files repo复制

1323
01:36:57,240 --> 01:36:57,460
它

1324
01:36:57,460 --> 01:37:01,180
也很好

1325
01:37:01,180 --> 01:37:01,480
是的

1326
01:37:01,480 --> 01:37:10,120
是的，非常感谢您拥有我

1327
01:37:10,119 --> 01:37:13,559
这是我想谈论的大多数事情

1328
01:37:13,559 --> 01:37:15,539
我认为我们真的没有太多时间

1329
01:37:15,539 --> 01:37:17,599
超级深入这些

1330
01:37:17,599 --> 01:37:19,340
希望您能看到

1331
01:37:19,340 --> 01:37:21,420
我是不同的存储库

1332
01:37:21,420 --> 01:37:22,340
访问

1333
01:37:22,340 --> 01:37:25,099
DEADP2P回购

1334
01:37:25,099 --> 01:37:26,760
共识规格回购

1335
01:37:26,760 --> 01:37:29,119
这些是真正好的信息的东西

1336
01:37:29,119 --> 01:37:31,539
我建议人们更深入地挖掘

1337
01:37:31,539 --> 01:37:33,399
进入以太坊的回购

1338
01:37:33,399 --> 01:37:35,479
很多好评论要阅读

1339
01:37:35,479 --> 01:37:37,039
如果你好奇

1340
01:37:37,039 --> 01:37:39,300
我所描述的一些事情如何工作

1341
01:37:39,300 --> 01:37:45,520
您可以完全浏览这些内容，并在那里查看文档。

1342
01:37:45,880 --> 01:37:50,500
我想谈论的唯一另一件事是JSON-RPC。

1343
01:37:51,060 --> 01:37:53,140
我会检查执行API库。

1344
01:37:53,420 --> 01:37:57,520
它描述了执行层的接口。

1345
01:37:58,100 --> 01:37:59,579
当人们想到什么是以太坊时

1346
01:38:00,320 --> 01:38:06,840
JSON-RPC在或多或少是绝对的术语中是一种以太坊

1347
01:38:06,840 --> 01:38:14,920
因为那是人们必须访问以太坊的界面，所以看看看看

1348
01:38:14,920 --> 01:38:21,000
执行API库，您可以查看可查询以太坊的所有数据

1349
01:38:22,600 --> 01:38:28,199
很棒的嗯，是的，非常感谢，我只想是的，我想问一件事，你能请你

1350
01:38:28,199 --> 01:38:34,199
分享您与我们一起创建的概述文档，您只需发送它

1351
01:38:34,199 --> 01:38:42,139
给我们或编辑它。是的，我可以做到。是的。再次，就像出色的工作一样。就像我学到了

1352
01:38:42,139 --> 01:38:50,340
我自己。是的，见到你。只需继续浏览所有重要部分即可。

1353
01:38:50,340 --> 01:38:56,380
太好了。是的。我认为人们有点学习，还可以观看录音

1354
01:38:56,380 --> 01:38:57,659
再次。是的。

1355
01:38:57,659 --> 01:39:01,559
多谢。我真的很感激。

1356
01:39:01,560 --> 01:39:06,120
是的。随意标记我。我在EPS不和谐中。所以标记我像客户一样。

1357
01:39:06,120 --> 01:39:09,140
如果您还有其他问题，如果可以的话，我会尽力与大家联系。

1358
01:39:11,080 --> 01:39:17,180
惊人的。非常感谢，马特。感谢它。对于那些在丹佛的人

1359
01:39:17,180 --> 01:39:26,340
丹佛本周，我们将在周四举行一次聚会。您可以检查不和谐

1360
01:39:26,340 --> 01:39:32,900
这些信息。是的。再一次，非常感谢，马特。下周我们会见到你

1361
01:39:32,900 --> 01:39:41,360
带有Alex Stokes的共识层概述。好的。谢谢大家。别紧张。再见。

