1
00:00:30,000 --> 00:00:59,980
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:59,000
¶¶

4
00:02:00,000 --> 00:02:26,439
好的。

5
00:02:26,439 --> 00:02:30,560
欢迎回到以太坊协议研究小组。

6
00:02:31,079 --> 00:02:37,020
我们在第10周的最后一周，在开发轨道上。

7
00:02:37,979 --> 00:02:44,939
这里已经有一个好几个月了，在这里学习了有关以太坊的所有知识，并在这里研究了不同的主题。

8
00:02:45,479 --> 00:02:50,400
今天，在我们的最终发展轨道谈话中，我们将与巴苏（Basu）的达诺（Dano）交谈

9
00:02:50,699 --> 00:02:53,520
他将谈论预编译。

10
00:02:53,520 --> 00:02:55,740
因此，我将继续将其传递给Mario。

11
00:02:56,200 --> 00:02:58,820
您可以给Dano提供更多适当的介绍，

12
00:02:59,060 --> 00:03:00,620
然后，您可以将其带走，Dano。

13
00:03:02,080 --> 00:03:04,280
大家好。欢迎在这里，达诺。

14
00:03:04,320 --> 00:03:05,800
非常感谢您今天加入我们。

15
00:03:06,400 --> 00:03:08,060
是的，这是我们上周，

16
00:03:08,300 --> 00:03:10,660
我们在开发轨道上的最后一个谈话，

17
00:03:10,920 --> 00:03:12,719
我们有一个非常特别的嘉宾

18
00:03:12,719 --> 00:03:16,740
因为达诺已经成为数十年的开发人员。

19
00:03:17,060 --> 00:03:21,160
他实际上是以太坊生态系统中的OG Java开发人员之一。

20
00:03:21,159 --> 00:03:25,079
当我从事小研究时

21
00:03:25,199 --> 00:03:27,079
我发现他一直在工作，

22
00:03:27,479 --> 00:03:29,719
在开始以太坊之前，他有整个职业

23
00:03:30,259 --> 00:03:32,319
在Google，Oracle工作，

24
00:03:32,659 --> 00:03:37,240
甚至出版有关Java前端的书，

25
00:03:37,500 --> 00:03:38,500
如果我正确，对吗？

26
00:03:39,340 --> 00:03:40,939
是的，您进行了研究。

27
00:03:42,180 --> 00:03:44,240
是的，我想告诉你你。

28
00:03:44,240 --> 00:03:47,120
是的，这是自2013年以来的一个项目

29
00:03:47,120 --> 00:03:49,120
然后在2018年以太坊期间

30
00:03:49,120 --> 00:03:51,659
似乎不久前

31
00:03:51,759 --> 00:03:55,439
但这就像在核心以太坊工作六年

32
00:03:55,439 --> 00:03:57,640
在HyperLeDger客户端，

33
00:03:58,080 --> 00:04:00,680
Bessu客户端，这是Java实施。

34
00:04:01,159 --> 00:04:05,099
因此，今天它专注于这个专业，

35
00:04:05,700 --> 00:04:07,920
预编译其集成客户

36
00:04:07,920 --> 00:04:12,180
以及客户如何使用它们。

37
00:04:12,659 --> 00:04:13,460
是的，非常兴奋。

38
00:04:13,460 --> 00:04:14,960
非常感谢您在这里。

39
00:04:15,719 --> 00:04:17,540
是的，舞台是你的。

40
00:04:17,540 --> 00:04:22,660
随时分享屏幕并继续开始。

41
00:04:22,660 --> 00:04:26,020
是的，我们在这里谈论前图像。只是在开玩笑，

42
00:04:26,020 --> 00:04:29,860
我们在这里谈论预编译。但这很有趣，马里奥长大了

43
00:04:30,660 --> 00:04:34,900
在我参与以太坊之前，我有一个完整的职业。实际上是

44
00:04:34,900 --> 00:04:41,620
把我带入了区块链。我曾经是Java台式机前端UI开发人员，然后再回到网络

45
00:04:41,620 --> 00:04:46,980
完全统治着一切。在某一时刻，Swing UI库是最受欢迎的库

46
00:04:46,980 --> 00:04:52,660
和企业。因此，Java桌面生命后期正在添加的一件事

47
00:04:52,660 --> 00:04:59,120
这个工具包称为javafx。他们拥有这个新的革命性布局引擎，称为A

48
00:04:59,600 --> 00:05:03,300
好吧，这对很多人来说不是革命性的，而是爪哇，它被称为场景图

49
00:05:03,300 --> 00:05:08,500
您可以将组件放在这里并在它们之间划清界限。你不必把东西放入

50
00:05:08,500 --> 00:05:14,540
网格并匹配任何东西。您可以绘制图形。所以我找到了一个图布局库，因为

51
00:05:14,540 --> 00:05:19,980
我的工作使用图形布局。我想把它放在Javafx中。我想和这个

52
00:05:19,980 --> 00:05:25,840
这些精美的图形布局。我真的需要一些有趣的数据才能变得有趣

53
00:05:25,840 --> 00:05:31,120
来自世界图。这是比特币刚刚达到了第一千美元的时间

54
00:05:31,120 --> 00:05:36,300
顶峰。因此，我一直在阅读比特币，UTXOS非常自然，

55
00:05:36,860 --> 00:05:41,860
无环向图具有非常有趣的数据。所以我已经准备好了，我真的得到了

56
00:05:41,860 --> 00:05:47,740
幸运的是，我碰巧偶然发现了戈克斯山在破产期间进行大金字塔裂口，

57
00:05:48,180 --> 00:05:51,879
做了一些YouTube视频，这只是让我直接到达深兔子洞

58
00:05:51,879 --> 00:05:58,540
做区块链。我转身全职做以太坊。我在Google呆了三年

59
00:05:58,540 --> 00:06:04,040
认为这是一个好地方。我可以从脑海中脱颖而出。不起作用。一点点工作。

60
00:06:04,780 --> 00:06:09,240
因此，当共识打电话给我并问我时，嘿，您想在Java以太坊客户端工作吗？我是

61
00:06:09,240 --> 00:06:13,780
就像，哦，是的，我绝对做。这就是你知道的，那就是你的进来，只是小事

62
00:06:13,780 --> 00:06:19,300
让您有兴趣。以太坊中有很多书呆子狙击真是太疯狂了。这么多

63
00:06:19,300 --> 00:06:23,780
正在应用的东西以及可以从较旧系统中使用的许多技术。

64
00:06:24,460 --> 00:06:28,740
所以今天，我要谈论的是预编译。那可能，

65
00:06:29,259 --> 00:06:32,939
对于很多人来说，听起来像是一个令人难以置信的主题。你知道，我们要谈谈

66
00:06:32,939 --> 00:06:38,519
关于您的执行方式，您知道，哈希功能和所有其他内容。实际上不是

67
00:06:38,519 --> 00:06:42,120
我要谈的是很多。我要谈论预编译的方式，我会看到它们

68
00:06:42,120 --> 00:06:46,419
当EVM的逃生舱口在外面做有趣的事情

69
00:06:46,419 --> 00:06:50,379
EVM的范围，但仍保持确定性和可证明的事物

70
00:06:50,379 --> 00:06:54,439
区块链上下文。我们将研究主网的方式，我们将看

71
00:06:54,439 --> 00:06:57,879
第2层如何做到的某些方式以及如何

72
00:06:57,879 --> 00:07:02,459
第1层使用它与他们的系统进行交互。而且我没有时间写

73
00:07:02,459 --> 00:07:06,199
为此幻灯片，但是在如何使用预编译方面有一个非常丰富的领域

74
00:07:06,199 --> 00:07:09,039
对于更多的异国情调，例如完全同态加密

75
00:07:09,039 --> 00:07:12,839
和AI大语言模型集成。

76
00:07:14,560 --> 00:07:17,399
因此，让我进入屏幕。

77
00:07:19,079 --> 00:07:20,360
因此，这是一个简短的议程。

78
00:07:20,420 --> 00:07:22,319
就像我说的那样，这不是密码介绍。

79
00:07:22,539 --> 00:07:23,560
我不是一个密码学家。

80
00:07:24,219 --> 00:07:26,480
我知道这些加密算法是什么。

81
00:07:26,620 --> 00:07:28,240
我知道作为开发人员如何使用它们，

82
00:07:28,620 --> 00:07:32,159
但是我不知道如何生成加洛伊斯领域

83
00:07:32,159 --> 00:07:34,639
以及如何证明ZK系统

84
00:07:34,639 --> 00:07:35,879
实际做他们声称要做的事情。

85
00:07:36,199 --> 00:07:48,839
但是我知道如何使用它们。这实际上是作为以太坊的开发人员和任何加密空间中的任何加密货币，几乎不可能知道从字面上知道一切的工作方式。

86
00:07:49,199 --> 00:07:58,500
但是，您真正需要知道的是它的作用，为什么要做，以及如果您要尝试做一些异国情调的专家，那么专家将与谁交谈。

87
00:07:59,740 --> 00:08:02,899
因此，我们将首先讨论哪些预编译和主要示例。

88
00:08:02,899 --> 00:08:07,419
表。我们将深入研究它们的工作方式。那我们要谈论外面的使用

89
00:08:07,419 --> 00:08:11,239
以太坊主要网。最后，我将总结一下未来的发展

90
00:08:11,239 --> 00:08:14,659
实际网和L2S中实际上是什么。所以，我们会去那里。

91
00:08:14,659 --> 00:08:20,159
因此，当我谈论预编译时，我真的在谈论三种不同的类型

92
00:08:20,159 --> 00:08:25,659
合同。预编译是启动整个预编译的原因。有任务

93
00:08:25,659 --> 00:08:31,000
您可以在EVM中执行，但是它们太昂贵且太慢，无法在EVM中进行。大量

94
00:08:31,000 --> 00:08:34,940
有点摇摇欲坠，就像Kachak Hash需要大量twiddling一样。你可以做

95
00:08:34,940 --> 00:08:40,559
在EVM中。我不知道，这将使您花费数百万美元。而且有很多

96
00:08:40,559 --> 00:08:45,279
使用精美编译器的Kachak更有效，更优化的实现，

97
00:08:46,639 --> 00:08:52,799
诸如SSE之类的花式处理器指令以及SSE当前的Intel芯片上的任何迭代

98
00:08:52,799 --> 00:08:58,879
无论手臂芯片上的等效物是什么。他们真的可以做Kachak哈希，

99
00:08:58,879 --> 00:09:04,100
真的很快。这就是为什么它们存在。因此，我们可以采用具有众所周知的输入a的东西，

100
00:09:04,159 --> 00:09:08,679
给出输入DB，并非常有效，非常快。现在很有趣

101
00:09:08,679 --> 00:09:13,340
卡查。没有Kachak预编译。 Kachak是加密原始的一个例子

102
00:09:13,340 --> 00:09:19,759
有一个opcode。它位于20个街区，十六进制20街区，这可能是唯一的

103
00:09:19,759 --> 00:09:24,600
十六进制20街区的东西。我预见了所有未来的加密货币。

104
00:09:24,600 --> 00:09:26,460
因为它们通常太昂贵，而对于opcodes来说。

105
00:09:27,759 --> 00:09:30,580
第二种预编译是系统合同。

106
00:09:31,040 --> 00:09:32,700
我们在以太坊主网中看不到这一点。

107
00:09:33,080 --> 00:09:34,500
我们大多在两层中看到了这一点，

108
00:09:34,740 --> 00:09:37,440
我们在Alt VM的Alt层中看到了这一点。

109
00:09:38,220 --> 00:09:40,420
这些是系统合同的种类

110
00:09:40,420 --> 00:09:42,420
在EVM中带了一些东西

111
00:09:42,420 --> 00:09:43,639
他们在不同的一层做某事

112
00:09:43,639 --> 00:09:45,460
或在区块链中的外国系统中

113
00:09:45,460 --> 00:09:47,220
这不是EVM，

114
00:09:47,519 --> 00:09:48,680
他们回来做事。

115
00:09:49,240 --> 00:09:51,360
所以你不想担心

116
00:09:51,360 --> 00:09:53,080
连接您的磁盘存储。

117
00:09:54,000 --> 00:10:03,160
您知道，您有常规的合同存储，但是您可能需要与L2存储网络通信的一些事情，您可以将其耕种到L2节点软件中运行。

118
00:10:03,480 --> 00:10:06,360
这些是通过我所说的系统合同来完成的，因为它们会破坏层。

119
00:10:06,360 --> 00:10:13,340
这就是将预编译与系统合同区别的区别在于，它们逃脱了沙箱，并做EVM不应该做的事情。

120
00:10:14,200 --> 00:10:18,320
最后，这些所谓的预部合同之间存在一些东西。

121
00:10:18,320 --> 00:10:25,920
UM前部署的合同使用技术破坏层，但在核心上，它们实际上只是EVM

122
00:10:25,920 --> 00:10:31,520
预先部署创世纪的代码或可能是叉子的一部分，它们是特定的

123
00:10:31,520 --> 00:10:37,400
地址及其存在的地址可能是您知道特殊的，这不是您

124
00:10:37,400 --> 00:10:41,740
有时可以在这些预部计划的合同中部署到密码，而这些合同

125
00:10:41,740 --> 00:10:47,960
出现并使用它们，嗯，它们是创世记文件的一部分，或者是硬叉的一部分，

126
00:10:47,960 --> 00:10:51,080
甚至还有第四个矿工案件，您刚刚部署合同并依靠

127
00:10:51,080 --> 00:10:56,480
在其中一些技术上，但我们将在演示文稿中进行稍后进行。

128
00:10:56,480 --> 00:11:05,500
因此，与今天的坎昆（Cancun）一样，以太坊主网上存在的九个预编译。

129
00:11:05,500 --> 00:11:07,120
它们的数量很少。

130
00:11:07,120 --> 00:11:10,379
我将其列为0x01。

131
00:11:10,379 --> 00:11:15,280
确实是0x3100，然后是01。

132
00:11:15,279 --> 00:11:18,519
因此，如果您在地址中调用这些，则其中会有很多零。

133
00:11:18,519 --> 00:11:23,459
当您进行EVM电话时，这很方便，因为您可以将一个人推到

134
00:11:23,459 --> 00:11:27,659
带上它，而不是用很多零来进行20次推进来引入地址。

135
00:11:27,659 --> 00:11:31,500
因此，将其称为相当有效。

136
00:11:31,500 --> 00:11:35,659
因此，前四个被引入了创世纪。

137
00:11:35,659 --> 00:11:40,100
下一个是由其中的四个带入拜占庭的。

138
00:11:40,100 --> 00:11:44,879
其中一个被带到伊斯坦布尔，其中一名被带到坎昆。

139
00:11:44,879 --> 00:11:50,320
进入创世纪的表现对于以太坊的基础确实至关重要。

140
00:11:50,759 --> 00:11:52,439
第一个被称为EC Recover。

141
00:11:53,240 --> 00:11:59,100
它的作用是，如果它太大，则需要进行哈希的承诺。

142
00:11:59,500 --> 00:12:00,919
不，它只需要32个字节的提交。

143
00:12:01,019 --> 00:12:01,840
你必须自己哈希。

144
00:12:02,759 --> 00:12:03,799
因此，它需要一条消息。

145
00:12:04,759 --> 00:12:10,139
如果它是签名，它在其上执行SECP-256-K1签名恢复。

146
00:12:10,379 --> 00:12:11,700
是的，这只是恢复。

147
00:12:12,159 --> 00:12:14,779
因此，您需要承诺，并且需要签名作品。

148
00:12:14,879 --> 00:12:19,039
这是一种承诺并创建以太坊地址的方式。

149
00:12:19,039 --> 00:12:22,159
因为它做出了额外的步骤，这就是从前12个字节上脱落的，所以

150
00:12:22,159 --> 00:12:25,279
它只为您提供以太坊地址的20个字节。

151
00:12:25,279 --> 00:12:33,679
第二次编译是SHA-2-256，它是Kachak的先驱。

152
00:12:33,679 --> 00:12:39,519
这是一个哈希，您会浏览大量数据，然后将其压缩，

153
00:12:39,519 --> 00:12:41,919
您会得到相同数量的数据。

154
00:12:41,919 --> 00:12:47,659
数据，然后将其压缩，然后将其从中获得。所以那是一种哈希算法

155
00:12:47,659 --> 00:12:54,679
用于以太坊。 RIPMD160是一种哈希算法，不在以太坊中使用，但在比特币中使用。

156
00:12:55,120 --> 00:12:59,659
它用于以太坊，并作为预编译存在。但是RIPMD在某些情况下使用

157
00:12:59,659 --> 00:13:04,259
比特币，因此，如果我们需要验证比特币特征，则将其置于兼容性。

158
00:13:05,459 --> 00:13:10,480
尽管不是零，但并没有大量使用。这是那里使用最少的人之一。

159
00:13:10,480 --> 00:13:13,279
我认为这是Mainnet上第二次最少的预编译。

160
00:13:13,720 --> 00:13:15,200
第四个是身份。

161
00:13:15,740 --> 00:13:20,259
这也是拆除的成熟，因为有更有效的方法可以做到这一点。

162
00:13:20,379 --> 00:13:22,820
身份，只需将输入复制到输出。

163
00:13:24,159 --> 00:13:28,480
因此，这是您可以将内存复制到内存的不同部分的一种方式。

164
00:13:29,080 --> 00:13:32,060
现在，我们拥有McOpyop代码，它确实有效地做到了。

165
00:13:32,820 --> 00:13:35,320
因此，不再需要身份。

166
00:13:35,320 --> 00:13:42,120
因此，随着以太坊的成长，我发现我们需要越来越多的加密原语。

167
00:13:43,560 --> 00:13:50,520
05是mod exp，模块化指数。这是我认为在很多地方使用的功能

168
00:13:50,520 --> 00:13:58,600
RSA签名，但在许多其他加密系统中也被用作原始签名。然后

169
00:13:58,600 --> 00:14:03,000
做什么，它可以进行模块化凸起。您取一个数字，将其带到一定

170
00:14:03,000 --> 00:14:07,720
指数，您采用模量，但这些数字确实很大，它们不是您的东西

171
00:14:07,720 --> 00:14:16,919
嗯，我们会说256位1024位解决方案um下三个是一组相关的

172
00:14:16,919 --> 00:14:24,440
UM预编译UM，这些用于UM不是使用的标准形式，但它是一个

173
00:14:24,440 --> 00:14:30,840
较小的BLS形式可用于这些UM，这些是UM添加乘法和配对

174
00:14:30,840 --> 00:14:38,160
在曲线中，它叫做Alt Bn 128，我听说它也称为BN 254有很多名称

175
00:14:38,160 --> 00:14:46,120
但这是BLS中使用的某些原语的256版本版本，所以很多

176
00:14:46,120 --> 00:14:51,019
人们将使用它进行汇总的签名，并且有些确实涉及不太参与

177
00:14:51,019 --> 00:14:55,280
但是在某个过程中，您可以将各种签名放在一起，您可以

178
00:14:55,280 --> 00:15:00,480
从中获得一个小签名，您可以验证这一点，我并没有真正完成很多

179
00:15:00,480 --> 00:15:04,980
关于那的数学。就像我说的那样，不是密码学的谈话，而是您的三个原始人

180
00:15:04,980 --> 00:15:17,940
需要在256位进行这样的BLS。共识层中使用的BLS签名不

181
00:15:17,940 --> 00:15:27,240
使用此。他们使用不同的曲线，BLS 12384之类的东西，但不是这个。有一个

182
00:15:27,240 --> 00:15:31,919
提议将它们带入布拉格，我想我会介绍它。我可能会在另一张幻灯片上

183
00:15:32,039 --> 00:15:39,980
但是我会在那里介绍。所以这是在拜占庭的。这是在2018年。下一个预编译

184
00:15:39,980 --> 00:15:47,779
在2020年添加的是Blake2bf功能，这是我认为是最少使用的预编译

185
00:15:47,779 --> 00:15:53,299
在那里，希望这将用于ZKCACHE和其他ZK Systems之类的东西

186
00:15:53,299 --> 00:15:55,879
因为它使用了Blake压缩算法，所以

187
00:15:56,039 --> 00:15:58,099
有人认为，仅F功能就足够了。

188
00:15:58,919 --> 00:16:04,379
这就是一个例子，我认为这是一个过程失败，

189
00:16:04,799 --> 00:16:08,259
但是很难说这是我们从中学习的必要失败。

190
00:16:08,939 --> 00:16:10,579
有一定的兴趣进入。

191
00:16:10,859 --> 00:16:13,019
冠军进来，真的将其推向前进，

192
00:16:13,719 --> 00:16:16,000
但是实际上没有任何实时需求

193
00:16:16,120 --> 00:16:17,399
需求从未真正发展

194
00:16:17,399 --> 00:16:19,559
因为它没有所有的作品

195
00:16:19,559 --> 00:16:25,339
因为还没有准备好验证一些Zcache的东西。

196
00:16:26,839 --> 00:16:30,979
因此，不幸的是，如果我们只是做了Blake2哈希算法，

197
00:16:31,059 --> 00:16:33,259
与刚刚拥有F功能相比，我们的位置要好得多。

198
00:16:33,779 --> 00:16:35,839
但是有原因为什么他们认为我们只需要F功能

199
00:16:35,839 --> 00:16:36,919
我们可以一起编译。

200
00:16:38,019 --> 00:16:41,000
如此不幸的故事。

201
00:16:42,119 --> 00:16:46,379
最后一个是几个月前添加的。

202
00:16:46,459 --> 00:16:48,619
我认为已经有几个月了。

203
00:16:48,620 --> 00:16:57,000
这就是KZD点评估，这就是它具有ZK的含义

204
00:16:57,000 --> 00:17:02,519
得到了一些向量承诺的含义，这确实是必不可少的，但是除非您

205
00:17:02,519 --> 00:17:09,059
使用斑点确实很难解释它的作用，但是简短的答案是使用

206
00:17:09,059 --> 00:17:14,940
在Blob中证明您在斑点中有某个可能存在或可能不存在的磁场元素

207
00:17:14,940 --> 00:17:18,240
它完全进入4844。

208
00:17:18,240 --> 00:17:21,700
4844的陈述可能会更深入。

209
00:17:21,700 --> 00:17:26,500
但就其作为预编译的角色而言，我认为它显示了一个很好的例子

210
00:17:26,500 --> 00:17:31,519
执行非常专业的计算的预编译非常效率非常低的计算

211
00:17:31,519 --> 00:17:36,140
EVM，但在额外的库中非常了解和实现。

212
00:17:37,700 --> 00:17:39,759
如果您想要这些摘要，则有一个网站

213
00:17:39,759 --> 00:17:44,559
EVM代码，在预编页的页面中提供了很多摘要

214
00:17:44,940 --> 00:17:49,660
在所有这些当前的预编译中，它们都有一个编写页面，但没有产品

215
00:17:49,660 --> 00:17:55,100
page但是，我不能向你展示um之后提议的人，但这让你知道

216
00:17:55,100 --> 00:18:02,460
所有细节都归入其中的许多功能，所以让我们回到

217
00:18:04,860 --> 00:18:07,500
UH K查看两个吧台

218
00:18:07,500 --> 00:18:18,700
因此，当EVM实施预编译时，这很简单。

219
00:18:21,339 --> 00:18:25,500
预编译看起来就像其他任何合同看起来完全一样，就像您在打电话

220
00:18:25,500 --> 00:18:30,299
否则，这实际上是看起来像是预编译的微妙设计天才的一部分

221
00:18:30,299 --> 00:18:34,140
您正在呼唤另一个EVM合同，但是发生了什么，您不知道您不在乎

222
00:18:34,140 --> 00:18:38,700
您将数据放入中获取数据，可能是本地的，它可能是EVM，它只是神奇地起作用

223
00:18:39,980 --> 00:18:46,540
UM和预编译的另一个基本特征是，完全计算出气体成本

224
00:18:46,540 --> 00:18:52,060
未在实际执行的气体上的输入数据，如果您选择的话，这会带来一些挑战

225
00:18:52,060 --> 00:18:56,380
预编译的一个特别糟糕的实现，您可以效率不高

226
00:18:56,380 --> 00:19:01,660
降低您的VM，但所有的班级成本都完全基于其在输入中看到的内容

227
00:19:01,660 --> 00:19:05,920
它。并将返回数据放在返回缓冲区或输出内存中，具体取决于如何

228
00:19:05,920 --> 00:19:12,259
您进行特定的电话。看起来就像其他任何合同电话一样

229
00:19:12,259 --> 00:19:17,200
在那里。但是，有几件事是目前没有提议的预编译

230
00:19:17,200 --> 00:19:24,680
做更深入的电话。他们不会产生其他EVM呼叫。那是探索设计空间的时候

231
00:19:24,680 --> 00:19:30,140
我认为，拒绝3074最初是作为预编译而开始的，他们拒绝了这一点，然后去了

232
00:19:30,140 --> 00:19:32,520
这是opcos，因为那感觉有些奇怪。

233
00:19:32,520 --> 00:19:34,300
因此，通常，预编译合同

234
00:19:34,300 --> 00:19:36,900
只会在自己内部做事

235
00:19:36,900 --> 00:19:39,259
并在自己的沙盒上玩耍并返回。

236
00:19:39,259 --> 00:19:40,640
他们很少会互动

237
00:19:40,640 --> 00:19:43,520
在现有的EVM环境中，

238
00:19:43,520 --> 00:19:45,960
并特别提出安全风险。

239
00:19:48,160 --> 00:19:50,320
那么，怎么样？

240
00:19:51,700 --> 00:19:54,560
因此，这是ECE的深刻例子

241
00:19:54,560 --> 00:19:56,680
恢复的预编译看起来像。

242
00:19:56,680 --> 00:19:59,040
因此，指定输入已固定为

243
00:20:00,140 --> 00:20:06,700
128字节。然后您得到了提交哈希，您得到了V值，R值和S值。和

244
00:20:06,700 --> 00:20:12,440
如果您对EC-DSA有所了解，那么这些对您来说很有意义。提交是它，

245
00:20:13,200 --> 00:20:19,000
EC-Recover实际上仅加密少量数据。因此，您会将其放下并加密

246
00:20:19,000 --> 00:20:25,060
该数据。 V实际上是所谓的恢复ID，它在27和28中编码

247
00:20:25,059 --> 00:20:32,919
历史原因。但是，当您逆转时，当您验证签名时，您将获得四个值之一。

248
00:20:33,039 --> 00:20:37,460
您在正无穷大的无限无限的价值中获得了价值，然后您得到了两个不同的价值

249
00:20:37,460 --> 00:20:44,419
在曲线上的各个点。此恢复ID告诉我们要恢复哪一个

250
00:20:44,419 --> 00:20:50,119
地址。当您拥有私钥并签名时，它将在这两个中结束，

251
00:20:50,159 --> 00:20:53,440
而且，直到执行签名之前，您真的不知道它将是哪一个。这就是原因

252
00:20:53,440 --> 00:20:58,880
随身携带它，因此恢复ID随签名带来

253
00:20:58,880 --> 00:21:02,720
系统只会说我们只是尝试所有这些，如果其中一个与您匹配，那么您很好，但是那是

254
00:21:02,720 --> 00:21:08,799
效率低下的UM，然后是您编码的值的R值，

255
00:21:08,799 --> 00:21:14,480
s值是一个秘密，它是通过计算值的一个部分计算的一个部分秘密

256
00:21:14,480 --> 00:21:19,600
获得以下值之一重复使用它们，您可以毁了钥匙，um um简短的答案是使用库

257
00:21:19,599 --> 00:21:24,639
提取和使用这些UM或找人是专家以验证您编写的代码

258
00:21:26,159 --> 00:21:32,879
当然，返回只是256个公钥哈希的较低220字节，因此它提取了

259
00:21:32,879 --> 00:21:39,119
地址，然后可以检查我认为的哈斯，然后返回哈希的较低的20个字节

260
00:21:39,119 --> 00:21:46,639
在哈希中，这不是真正的ECDSA密钥恢复，它以极为以太的为中心

261
00:21:46,640 --> 00:21:47,980
以以太坊的方式。

262
00:21:48,100 --> 00:21:49,280
它的服务很好，

263
00:21:49,320 --> 00:21:51,540
因为这确实专注于

264
00:21:51,759 --> 00:21:53,100
您的地址是否签署了此值？

265
00:21:53,580 --> 00:21:54,940
因此，它确实实现了其目的。

266
00:21:56,220 --> 00:21:57,980
这是3,000美元的汽油成本，

267
00:21:57,980 --> 00:21:58,920
不管你做什么。

268
00:21:59,020 --> 00:22:00,020
因此，这是固定的增加。

269
00:22:00,600 --> 00:22:03,660
但是，如果我们查看其他一些合同，

270
00:22:04,400 --> 00:22:06,120
我们可以看到其中一些具有可变数据。

271
00:22:07,300 --> 00:22:09,840
例如，MODXP是最复杂的。

272
00:22:09,920 --> 00:22:12,020
实际上，它已由另一个EVM进行了修订。

273
00:22:13,000 --> 00:22:15,480
但是一些更简单的类似于EC配对。

274
00:22:16,220 --> 00:22:17,180
几对？

275
00:22:17,299 --> 00:22:18,720
好吧，您将其乘以它。

276
00:22:18,779 --> 00:22:19,640
那就是你的成本。

277
00:22:20,420 --> 00:22:23,620
Blake 2F，您藏了多少数据？

278
00:22:24,039 --> 00:22:25,380
那就是我们要收取多少费用。

279
00:22:27,240 --> 00:22:32,279
实际上，Blake 2F是一个糟糕的例子，因为您再次做少量。

280
00:22:32,420 --> 00:22:33,860
射击256是一个更好的例子。

281
00:22:34,279 --> 00:22:35,819
您散列多少数据？

282
00:22:36,180 --> 00:22:37,420
这就是我们要收取的。

283
00:22:38,960 --> 00:22:41,539
这里的其他所有内容往往具有固定的输入尺寸。

284
00:22:41,539 --> 00:22:45,399
这涉及到一些设计考虑。

285
00:22:50,019 --> 00:22:51,659
这样就陷入了一些设计问题

286
00:22:51,659 --> 00:22:53,259
当您设计预编译时

287
00:22:53,259 --> 00:22:54,139
这些是一些事情

288
00:22:54,139 --> 00:22:56,379
以前向客户提出了问题

289
00:22:56,379 --> 00:22:59,079
并延迟了预编译的实施。

290
00:22:59,839 --> 00:23:00,899
您需要做的第一件事

291
00:23:00,899 --> 00:23:02,460
如果您要提出预编译

292
00:23:02,460 --> 00:23:03,099
您需要确保

293
00:23:03,099 --> 00:23:04,619
所有边界条件均指定。

294
00:23:06,279 --> 00:23:07,159
人们会来的

295
00:23:07,200 --> 00:23:08,079
不仅是测试人员

296
00:23:08,079 --> 00:23:09,460
那将进来并尝试打破这个。

297
00:23:09,639 --> 00:23:11,059
每个人都会进来尝试打破这个。

298
00:23:11,539 --> 00:23:18,639
因为您知道，攻击策略涉及分叉网络并在不同的叉子中引起问题。

299
00:23:19,559 --> 00:23:24,639
其中一些是数据，因此它主要是股份证明，这是工作原理攻击的证明。

300
00:23:24,920 --> 00:23:33,099
但是，即使是股份证明，它也会导致不同的客户在系统上差异。

301
00:23:33,200 --> 00:23:36,980
因此，您需要确保指定所有边界条件，并且它们具有非常具体的处理方式。

302
00:23:36,980 --> 00:23:43,200
第二个问题是，当您为气体充电时，您应该确保所有的气体尺度努力。

303
00:23:44,019 --> 00:23:52,700
这样的例子就像SHA-256，MADI-XP和配对检查一样。

304
00:23:53,660 --> 00:23:59,200
得到答案的困难越困难，您应该为此收取更多的气体。

305
00:23:59,980 --> 00:24:01,440
其中之一是执行。

306
00:24:01,799 --> 00:24:03,279
算法可以隐藏其中一些问题。

307
00:24:03,279 --> 00:24:08,079
uh moddxp um，你知道有解决方案我们发现每个人都可以确保

308
00:24:08,079 --> 00:24:11,759
在当前曲线下，但是有一些假设，就像你为什么

309
00:24:11,759 --> 00:24:17,180
曾经想做一个偶尔的模量，所以所有密码学都使用奇数模量

310
00:24:17,180 --> 00:24:21,619
嗯，除了您知道并非总是是密码学家试图引起的

311
00:24:21,619 --> 00:24:28,059
疯狂的事情发生，嗯，这也是一个问题，例如UM UH RSA签名

312
00:24:28,059 --> 00:24:32,000
但另一件事是您也想随着输入而扩展它。

313
00:24:32,539 --> 00:24:37,500
因此，如果您有固定量的数据，则要确保执行不需要解析所有数据。

314
00:24:38,279 --> 00:24:42,819
因此，如果有人通过数据兆字节，它不会炸毁预编译的执行。

315
00:24:43,759 --> 00:24:47,700
您传递的数据量，您应始终为每种字节的气体充电。

316
00:24:47,759 --> 00:24:50,440
如果是可变量，则您的气体需要可变。

317
00:24:50,440 --> 00:24:58,880
现在，我认为最后，最坏情况的最后一个例子是您应该考虑最坏的情况。

318
00:25:00,000 --> 00:25:04,600
诱人的只是为了为典型的情况而花费，以确保每个人都有合理的利用。

319
00:25:04,660 --> 00:25:10,900
就像，您知道，您只会将MODDXP用于奇数模量，而您只会在一定范围内使用它。

320
00:25:11,380 --> 00:25:17,380
但是有些人将使用荒谬的数字，他们将使用甚至模量，只是因为尝试拖链而不是其他原因。

321
00:25:17,380 --> 00:25:20,060
这发生在上海的DebCon2中。

322
00:25:20,820 --> 00:25:22,060
有些人在拖链。

323
00:25:22,420 --> 00:25:23,280
有些人是为了好玩的。

324
00:25:23,360 --> 00:25:24,200
有些人是为了钱而做的。

325
00:25:24,660 --> 00:25:28,020
但是您应该只期望在协议层中设计的任何内容中

326
00:25:28,020 --> 00:25:32,040
人们将尝试攻击它，无论他们的动力如何。

327
00:25:32,180 --> 00:25:33,580
这是您需要做好准备的东西

328
00:25:33,580 --> 00:25:35,520
以及您需要准备实施的东西。

329
00:25:37,220 --> 00:25:39,620
因此，让我们深入了解有关其实施方式的一些问题。

330
00:25:39,620 --> 00:25:45,160
我看到一些聊天室中出现的一些问题。

331
00:25:45,160 --> 00:25:52,440
因此，因此，问题之一是，实际上，这将是下一个幻灯片，实施

332
00:25:52,440 --> 00:25:53,440
策略。

333
00:25:53,440 --> 00:25:56,180
我会很快回答这个问题。

334
00:25:56,180 --> 00:25:59,840
一个问题是指Java虚拟内实施的基础或预编码代码

335
00:25:59,840 --> 00:26:00,840
机器。

336
00:26:00,840 --> 00:26:03,840
它们是在Java虚拟机正在调用的另一个过程中完成的吗？

337
00:26:03,840 --> 00:26:05,140
有点儿。

338
00:26:05,140 --> 00:26:10,080
某些预编译是在Java中完成的，如果它们就像，例如身份真的很简单。

339
00:26:10,080 --> 00:26:14,580
但是，一些更昂贵的eCDA，例如ECDSA，我们在此过程中不称呼它。

340
00:26:14,579 --> 00:26:17,659
但是我们确实将另一个图书馆带入Java。

341
00:26:18,359 --> 00:26:24,919
实际上，在巴苏，我们使用比特币D比特币D，有一个比特币D使用的库。

342
00:26:25,079 --> 00:26:33,799
它有一些，K曲线有一些非常快速的计算，您再知道，我不完全了解数学。

343
00:26:33,799 --> 00:26:34,679
我只知道它更快。

344
00:26:35,099 --> 00:26:36,519
因此，我们将该解决方案带入。

345
00:26:36,559 --> 00:26:38,919
这只是他们实施算法的方式。

346
00:26:39,399 --> 00:26:41,019
这使我们可以更快地计算它。

347
00:26:41,059 --> 00:26:42,259
我认为所有客户都使用此。

348
00:26:42,259 --> 00:26:49,559
如果他们不使用比特币D的特定软件，至少他们会使用那里的算法来更快。

349
00:26:50,599 --> 00:26:55,059
因此，这两个事情都完成了，在RAW Java中实现或使用外部库。

350
00:26:55,460 --> 00:26:58,900
我们没有进入单独的过程执行它的位置。

351
00:26:59,359 --> 00:27:02,960
我认为这是一些更奇特的设计方法。

352
00:27:07,640 --> 00:27:10,839
而且，如果在预编译中报告了这是什么行动计划？

353
00:27:10,839 --> 00:27:13,259
最后我会提出这个问题。

354
00:27:13,339 --> 00:27:14,500
这是拉胡尔的一个很好的问题。

355
00:27:14,659 --> 00:27:16,379
所以让我们为此标记

356
00:27:16,379 --> 00:27:17,759
我们参加了问答环节。

357
00:27:18,939 --> 00:27:19,959
所以让我们看一个简介

358
00:27:19,959 --> 00:27:20,659
如何实施。

359
00:27:21,079 --> 00:27:22,959
我在四个主要客户中发现

360
00:27:22,959 --> 00:27:23,579
那在那里，

361
00:27:24,519 --> 00:27:25,980
对于阿拉贡，我有点刺

362
00:27:25,980 --> 00:27:27,199
因为阿拉贡，当它到来时

363
00:27:27,199 --> 00:27:29,539
到非数据存储事物，

364
00:27:29,639 --> 00:27:31,419
目前主要是Geth的封面。

365
00:27:32,079 --> 00:27:33,079
他们正在努力引进

366
00:27:33,079 --> 00:27:33,879
所谓的蚕，

367
00:27:34,059 --> 00:27:36,079
但这还不是生产水平。

368
00:27:36,539 --> 00:27:37,879
所以，你知道，有一些有趣的

369
00:27:37,879 --> 00:27:38,919
阿拉贡发生的事情。

370
00:27:39,319 --> 00:27:40,259
但是现在，他们要去

371
00:27:40,259 --> 00:27:42,640
它主要反映了Geth的工作方式。

372
00:27:42,640 --> 00:27:44,420
从巴苏开始，

373
00:27:44,420 --> 00:27:46,279
巴苏在

374
00:27:46,279 --> 00:27:49,700
基于EVM预编译的Java软件包。

375
00:27:49,700 --> 00:27:52,640
您可以看到我们那里的所有不同的预编译。

376
00:27:52,640 --> 00:27:56,000
因此，让我们ID预编译合同非常简单。

377
00:27:56,000 --> 00:27:57,619
它具有简单的接口，

378
00:27:57,619 --> 00:27:58,940
什么是气体要求，

379
00:27:58,940 --> 00:28:00,500
以及如何计算预编译？

380
00:28:00,500 --> 00:28:02,180
这是非常简单的东西。

381
00:28:02,180 --> 00:28:04,819
在这里，这是我们那里最简单的预编译，

382
00:28:04,819 --> 00:28:07,460
您只需复制它。当然是Java，

383
00:28:07,460 --> 00:28:09,000
这是Hyperledger，那里有很多

384
00:28:09,000 --> 00:28:12,299
样板和爪哇主义，它以非常爪哇的方式完成。

385
00:28:13,160 --> 00:28:15,059
现在，如果您想以一定的方式看到它，

386
00:28:16,160 --> 00:28:20,920
我们有了它的方法，突然找不到。

387
00:28:20,960 --> 00:28:21,660
这太棒了。

388
00:28:23,839 --> 00:28:25,000
核心VM合同。

389
00:28:25,000 --> 00:28:26,279
他们只是移动了吗？

390
00:28:28,880 --> 00:28:35,119
核心VM合同。

391
00:28:35,720 --> 00:28:37,740
它一定是他们摆脱的特定分支。

392
00:28:37,740 --> 00:28:41,680
因此，核心VM合同，在这里，他们已经实施了所有预编译。

393
00:28:42,740 --> 00:28:53,620
而且，您还可以根据Geth的代码在Geth的代码中看到它们如何根据它们使用这些合同的各个世代将其分开，无论是拜占庭，伊斯坦布尔，柏林，坎昆。

394
00:28:53,720 --> 00:29:01,099
他们引入了一些前进的预编译，这些预编译也带有所需的BLS签名。

395
00:29:01,099 --> 00:29:09,019
而Go更简单，它可以使他们能够处理它的方式更像

396
00:29:09,019 --> 00:29:17,639
嗯，他们定义了一个结构，这里有一些常数，他们在结构上定义了他们的方法

397
00:29:17,639 --> 00:29:21,500
大于我要寻找的东西，它们在这种情况下实现了您知道的界面

398
00:29:21,500 --> 00:29:26,779
它是必需的气，然后实际上运行它，这是您得到的，您得到的

399
00:29:26,779 --> 00:29:32,539
气体和mod exp可能是计算您进入的气体成本的最复杂的exp

400
00:29:32,539 --> 00:29:40,299
其他需要的气体它只是返回固定值，例如BM-256添加它始终

401
00:29:40,299 --> 00:29:45,859
相同的价值，因为我们总是添加两件事，并且它可以运行有一个独立的

402
00:29:45,859 --> 00:29:52,920
他们用于BM东西的库，您知道它是在GO中实现的

403
00:29:52,920 --> 00:29:55,759
GO中的VM库足够好。

404
00:29:55,759 --> 00:30:00,759
在Java做这件事时，我们耕种到一个生锈图书馆，

405
00:30:01,039 --> 00:30:03,500
因为它更快，主要是。

406
00:30:03,500 --> 00:30:04,400
当你有点扭曲时，

407
00:30:04,400 --> 00:30:06,960
您不想在Go中做一点扭曲。

408
00:30:06,960 --> 00:30:10,200
Nethermind，他们有一个预编译CS，

409
00:30:10,200 --> 00:30:15,160
因此，让我们去看看，看看，

410
00:30:17,560 --> 00:30:19,500
EC恢复可能是一个很好的选择。

411
00:30:19,500 --> 00:30:21,080
但是，他们也有相同的方法。

412
00:30:21,079 --> 00:30:23,240
他们以非常c-sharp的方式存储它。

413
00:30:23,740 --> 00:30:25,379
他们需要将地址存储为元数据。

414
00:30:26,199 --> 00:30:28,519
您计算气体成本，基本铸造成本。

415
00:30:29,099 --> 00:30:29,779
你运行它。

416
00:30:30,039 --> 00:30:30,859
您执行数据。

417
00:30:31,579 --> 00:30:34,759
因此，在主要网络中，许多这些预编译只是有点无聊

418
00:30:34,759 --> 00:30:38,679
因为他们只是在做无聊的数学，我们需要有效地做到这一点。

419
00:30:40,539 --> 00:30:46,199
让我们在此处进行ECU恢复，以显示非常相似的情况。

420
00:30:46,619 --> 00:30:48,460
您具有可以执行此操作的实际功能。

421
00:30:51,079 --> 00:30:53,099
他们在这里有汽油成本吗？

422
00:30:55,059 --> 00:30:58,240
它们具有气体限制，气体成本量。

423
00:31:00,240 --> 00:31:02,799
是的，裁判采取了略有不同的方法。

424
00:31:02,960 --> 00:31:08,119
它们包括带有输出的气体使用情况。

425
00:31:09,000 --> 00:31:12,539
因此，他们的成本成本是多少，并且实际上输出了字节。

426
00:31:12,919 --> 00:31:13,980
所以他们一次去做。

427
00:31:14,079 --> 00:31:16,439
我们中的一些人将其分为两个步骤。

428
00:31:16,519 --> 00:31:17,679
我们中有些人一次去做。

429
00:31:18,159 --> 00:31:19,659
这具有一些设计含义。

430
00:31:19,660 --> 00:31:29,600
如果您可以从气体中告诉他们，他们甚至在尝试执行它之前没有足够的汽油来执行巨大的MODD XP，那么您只需要说，嘿，没有足够的汽油。

431
00:31:29,660 --> 00:31:32,200
我什至不会尝试。消耗所有汽油并返回。

432
00:31:32,800 --> 00:31:37,420
否则，如果您可以在没有足够的汽油时迫使人们浪费努力，那就是安全攻击。

433
00:31:37,920 --> 00:31:48,019
在一些安全审计师和研究人员中，这是一个很好的路径，他们经历了并弄脏并弄清楚了这些事情。

434
00:31:48,019 --> 00:31:53,559
因此，非常了解您在做任何昂贵的事情之前先检查汽油。

435
00:31:53,639 --> 00:31:55,960
而且有多种方法可以解决这一问题。

436
00:31:56,359 --> 00:31:57,980
这是审计师一直在看的东西。

437
00:31:58,759 --> 00:32:01,480
因此，就像我说的，实施策略，您可以使用本机代码来完成。

438
00:32:01,819 --> 00:32:06,859
如果它足够快地实现，则需要更快的代码，通常会转到自定义书面库。

439
00:32:06,859 --> 00:32:15,419
我的意思是，它们的确是256K1曲线的ECDSA代码，

440
00:32:15,740 --> 00:32:19,500
他们已经写了英特尔和手臂机代码

441
00:32:19,500 --> 00:32:22,119
尝试尽可能快地将其燃烧。

442
00:32:22,119 --> 00:32:23,819
因为在比特币中，对他们来说很有意义

443
00:32:23,819 --> 00:32:27,099
因为那是他们最长的路径

444
00:32:27,099 --> 00:32:28,259
正在验证这些哈希。

445
00:32:28,379 --> 00:32:29,919
那是比特币中最昂贵的部分。

446
00:32:30,500 --> 00:32:31,799
所以对他们来说很有意义

447
00:32:31,799 --> 00:32:35,639
只是疯狂地实施并优化它。

448
00:32:35,640 --> 00:32:37,320
而且我们只需要获得好处。

449
00:32:37,420 --> 00:32:38,180
那里很棒。

450
00:32:41,800 --> 00:32:43,060
因此来自基拉的问题。

451
00:32:43,200 --> 00:32:48,100
与在纯固体中实现相似的功能相比，您能否讨论一些特定的方法来减少燃气机？

452
00:32:48,780 --> 00:32:51,240
预编码中最常用的任何代码优化吗？

453
00:32:52,100 --> 00:33:01,860
因此，实施最大的事情可能是为什么在EVM之外完成许多这些加密事件的原因。

454
00:33:01,859 --> 00:33:07,259
是因为EVM是一台256位堆栈机。

455
00:33:08,000 --> 00:33:09,919
每个词都有256位，

456
00:33:10,000 --> 00:33:11,339
但是其中一些操作很好，

457
00:33:11,859 --> 00:33:14,659
特别是在Kachak中，使用较小的位，

458
00:33:14,740 --> 00:33:18,500
或者他们的定义确实很柔软

459
00:33:18,500 --> 00:33:22,039
到向量操作，单个输入，否，

460
00:33:24,099 --> 00:33:26,299
多个说明，单个数据，单个，

461
00:33:26,679 --> 00:33:31,500
多个数据，单个指令。

462
00:33:31,859 --> 00:33:36,919
S-I-M-D。 Got to go back to my undergrad classes to get that out.

463
00:33:37,439 --> 00:33:41,159
But they're really amenable to being put in vector optimizations.

464
00:33:42,059 --> 00:33:50,039
然后，其中一些（例如Mod Exp）需要使用一个可能会增加数字大小的可变宽度数。

465
00:33:50,899 --> 00:33:55,199
That's one class of bugs that the Geth famously found.

466
00:33:55,740 --> 00:34:01,240
当他们模糊的Geth时，如果您使用荒谬的数字，它将达到最大的数量。

467
00:34:01,240 --> 00:34:06,779
我的意思是，甚至比您认为的某些库中荒谬的数字还要大，您可以使用Segfault。

468
00:34:08,119 --> 00:34:12,579
而且我认为他们发现的一个特殊的错误是他们能够利用这一点。

469
00:34:13,000 --> 00:34:24,659
然后，如果他们可以放置RSA签名证书，他们声称他们的一个领域很大，并且将数字放在那样大，那将是将其弄清楚。

470
00:34:24,659 --> 00:34:27,779
因此，从其中一些，您知道的努力，

471
00:34:27,899 --> 00:34:31,420
他们想出了一种方法来删除SSL服务器，只是因为他们试图

472
00:34:31,420 --> 00:34:32,960
他们的Geth实施。所以有

473
00:34:33,339 --> 00:34:36,000
这是Geth的巨大胜利。

474
00:34:39,500 --> 00:34:43,539
因此，是的，就是这样，为预编译合同。

475
00:34:43,659 --> 00:34:48,920
我是出于，效率的目的，

476
00:34:48,920 --> 00:34:51,980
但是您不想在EVM代码中这样做的最大原因是因为

477
00:34:51,980 --> 00:34:54,079
本地进行操作要快得多。

478
00:34:54,079 --> 00:35:02,880
当您建立障碍物以及尝试找到MEV解决方案时，您希望绝对快速执行此操作。

479
00:35:03,579 --> 00:35:05,679
因此，它不仅更快，而且气体也更便宜。

480
00:35:05,679 --> 00:35:09,039
这些预编译中的几乎每个都定义了。

481
00:35:09,960 --> 00:35:14,420
它们在EVM中的效率非常高，非常难以达成的天然气成本。

482
00:35:14,539 --> 00:35:19,860
我认为这些都不是，您可以编码这些EVM版本，以超过此处计划的气体成本。

483
00:35:19,860 --> 00:35:24,940
气体成本旨在反映出执行这些的实际机器执行成本。

484
00:35:27,420 --> 00:35:30,860
因此，我要谈论的下一件事是系统合同。

485
00:35:33,240 --> 00:35:37,660
我想以这个《星球大战》的报价并扭曲它，因为它是真的。

486
00:35:38,280 --> 00:35:42,780
系统合同是某些人认为不一致的许多功能的途径。

487
00:35:43,400 --> 00:35:48,200
在系统合同中完成的其中一些事情将永远不会在主网中看到一天的光芒，因为它不够纯净。

488
00:35:49,119 --> 00:35:50,319
纯正可能是错误的词。

489
00:35:50,939 --> 00:35:53,099
但这是在做主网不需要做的事情

490
00:35:53,099 --> 00:35:54,339
主网不想做。

491
00:35:54,639 --> 00:35:56,739
但这是在做这些第2层中的一些

492
00:35:56,739 --> 00:35:58,519
所有第1层都必须做。

493
00:35:58,599 --> 00:36:00,299
没有其他有效的方法可以做到。

494
00:36:02,159 --> 00:36:03,500
那么什么是系统合同？

495
00:36:03,599 --> 00:36:04,299
这些在哪里使用？

496
00:36:04,859 --> 00:36:06,219
这些典型用途

497
00:36:06,219 --> 00:36:07,980
用于访问L1和L2桥接。

498
00:36:08,899 --> 00:36:10,960
仲裁，乐观和各种ZK链

499
00:36:10,960 --> 00:36:12,480
use these system contracts.

500
00:36:12,619 --> 00:36:15,239
Some of them use a hybrid pre-deployed contract

501
00:36:15,239 --> 00:36:16,119
or deployed contract,

502
00:36:16,119 --> 00:36:19,139
and they use events to signal into it.

503
00:36:20,279 --> 00:36:21,059
But these contracts,

504
00:36:21,199 --> 00:36:23,400
仲裁使用直接实施

505
00:36:23,400 --> 00:36:25,239
在这些合同中，甚至可以指定并进行。

506
00:36:25,299 --> 00:36:28,500
他们有一些花哨的编译器可以使用。

507
00:36:30,079 --> 00:36:31,579
而且有一个拼写错误。

508
00:36:31,659 --> 00:36:32,440
你知道我写了这篇文章。

509
00:36:32,559 --> 00:36:33,519
我知道那是错误的。

510
00:36:34,119 --> 00:36:36,059
稍后将幻灯片带出时，我将修复此问题。

511
00:36:37,179 --> 00:36:38,739
但是第一层，第二层桥接，

512
00:36:38,799 --> 00:36:40,539
维护桥梁有很多问题

513
00:36:40,539 --> 00:36:41,460
从第一层，第二层。

514
00:36:41,460 --> 00:36:43,159
真的只能完成

515
00:36:43,159 --> 00:36:45,460
从EVM内部授权。

516
00:36:45,460 --> 00:36:49,539
我们只能在L2节点软件中的EVM之外作用。

517
00:36:50,079 --> 00:36:51,780
这就是我认为这些系统合同的原因，

518
00:36:51,880 --> 00:36:54,920
即使是完全在EVM中完成并通过事件发出信号的人，

519
00:36:55,260 --> 00:36:57,480
我认为这些系统合同只是不同的种类。

520
00:36:57,639 --> 00:36:58,920
我可以将它们放入预编译扫描中。

521
00:37:00,240 --> 00:37:02,840
您可能想这样做的另一个原因是您可能想托管，

522
00:37:03,059 --> 00:37:05,159
访问外国连锁服务。

523
00:37:05,760 --> 00:37:08,480
我在这里有三个例子是Moonbeam。

524
00:37:09,139 --> 00:37:11,780
Moonbeam是Polkadot之上的EVM实施。

525
00:37:11,780 --> 00:37:19,000
极光。 Aurora是近距离的EVM实施。和Hedera。 Hedera已实施

526
00:37:19,000 --> 00:37:23,760
智能合约服务，但在智能合约服务下，Hedera的差异很大

527
00:37:23,760 --> 00:37:28,760
令牌系统和会计系统。因此，系统合同可以在这些情况下使用

528
00:37:28,760 --> 00:37:33,440
访问其系统中的本地令牌作为本机代币，或进行本机操作

529
00:37:33,440 --> 00:37:42,400
在他们的帐户上，根据需要看到Moonbeams um漂亮的合同，我的意思是

530
00:37:42,400 --> 00:37:46,800
使用一种方法来延伸到底物，并且有很多非常多的圆点特定的东西

531
00:37:46,800 --> 00:37:53,119
您可能想进入并做与波尔卡圆点有关的事情

532
00:37:53,119 --> 00:38:00,079
就像嗯，它有DOW投票功能，它拥有自己的uh token um moonbeams

533
00:38:00,079 --> 00:38:05,639
它自己的代币系统，在不同的链条之间传达东西，跨链通信。

534
00:38:06,599 --> 00:38:11,719
这些是通过Moonbeam中预编译合同访问的。所以看来您只是在打电话

535
00:38:11,719 --> 00:38:17,440
另一份EVM合同，但我们实际上是在逃脱EVM，我们要去了，我们正在使用

536
00:38:17,440 --> 00:38:24,639
EVM并非典型的其他主机系统的功能。我认为附近的大部分是

537
00:38:24,639 --> 00:38:30,739
他们在那里做的同样的事情。同样，他们将现有的智能合约供

538
00:38:30,739 --> 00:38:36,099
那里存在。然后他们带来了他们需要做的所有其他事情

539
00:38:36,099 --> 00:38:43,339
进入附近。它们特定于Aurora与附近集成的方式。他们有自己的。

540
00:38:43,559 --> 00:38:48,920
而且，关于其地址的靠近的方式有趣的是没有映射到

541
00:38:48,920 --> 00:38:54,420
预编译地址。他们有这些地址在这里服务的具体原因。他们不使用

542
00:38:54,420 --> 00:38:58,460
创建或创建2来带来或创建交易，但它们有自己的机制

543
00:38:58,460 --> 00:39:02,159
确定地址是什么。这就是将其映射到以太坊的方式。

544
00:39:03,760 --> 00:39:09,380
和Hedera，他们拥有他们拥有的重要一件是代币的服务。

545
00:39:09,980 --> 00:39:14,980
他们有自己的本地令牌，而Hedera想要揭露它，因此看起来像ERC-20令牌。

546
00:39:14,980 --> 00:39:19,320
因此，这就是您正常对待令牌服务的合同的一部分。

547
00:39:19,880 --> 00:39:32,539
在Hedera代币将在此合同中添加此合同，然后进入并完成所有专业的Hedera工作，还有另一套预编译合同。

548
00:39:33,519 --> 00:39:35,400
他们也在这里暴露了它。

549
00:39:35,679 --> 00:39:44,179
有些事情非常具体，如果您需要以太坊永远不会添加的令牌费系统，您仍然可以签订此合同。

550
00:39:44,179 --> 00:39:46,739
但是，这个令牌费系统被烘烤到Hedera中。

551
00:39:47,339 --> 00:39:49,319
因此，当您访问它时，这提供了一个逃生舱口

552
00:39:49,319 --> 00:39:51,099
好像这是系统合同

553
00:39:51,099 --> 00:39:52,519
进入这些功能

554
00:39:52,519 --> 00:39:54,759
不必改变以太坊的本质。

555
00:39:56,559 --> 00:39:58,879
最后一件事，我之前提到过

556
00:39:59,440 --> 00:40:00,919
值得一提的几个名字

557
00:40:00,919 --> 00:40:03,199
是凤凰和仪式。

558
00:40:03,299 --> 00:40:03,719
我敢肯定

559
00:40:03,779 --> 00:40:05,599
我认为那里还有其他一些胖子

560
00:40:05,599 --> 00:40:06,859
还有其他AI模型，

561
00:40:06,919 --> 00:40:09,440
但是那是想到的两个名字

562
00:40:09,440 --> 00:40:11,799
以前与他们进行了互动。

563
00:40:11,800 --> 00:40:22,120
但是，他们将使用预编译来访问完全外国链条的事物，并且它们完全是陌生的，对于第1层和第2层。

564
00:40:22,640 --> 00:40:25,340
完全同态加密真的很整洁。

565
00:40:25,480 --> 00:40:26,480
您可以加密一个数字。

566
00:40:26,900 --> 00:40:28,019
您可以加密另一个数字。

567
00:40:28,380 --> 00:40:37,180
从这些加密数据中，您可以执行一个操作，说将这两个数字添加在一起，并且您不知道结果是什么，除非您有可以解密它的键。

568
00:40:37,340 --> 00:40:40,280
因此，您可以让所有人都投入所有这些数字。

569
00:40:41,200 --> 00:40:42,880
您可以说，就像在进行荷兰拍卖。

570
00:40:43,660 --> 00:40:49,240
每个人都可以投入出价，然后您可以相互比较，以找出清除点是什么。

571
00:40:49,240 --> 00:40:52,580
然后您可以揭示这个数字，没人知道您的出价是什么。

572
00:40:53,340 --> 00:40:59,300
不利的一面是，除了基于晶格的数学外，EVM确实有点扭曲和困难，

573
00:40:59,940 --> 00:41:08,460
这些数据可以是千数键和大型兆字节，可以在完全同态加密中执行其中需要做的一些功能。

574
00:41:09,199 --> 00:41:13,699
我认为它也是量子安全的，这是另一个整洁的功能，但是您无法传递大量数据。

575
00:41:13,900 --> 00:41:18,380
因此，他们将要以自己的方式处理它，但是他们将使用预编译合同来访问这一点。

576
00:41:18,460 --> 00:41:24,699
这就像您不想在EVM中投入的完全不同的服务，但是您仍然可以通过预编译合同来操纵它。

577
00:41:25,619 --> 00:41:27,679
仪式，我对他们的计划不太了解。

578
00:41:27,679 --> 00:41:31,380
我认为这不是很坚定，但是他们正在计划，建议做同样的事情。

579
00:41:31,380 --> 00:41:37,240
您可以获取一些信息，可以拥有AI模型，并且可以说，您知道，

580
00:41:37,340 --> 00:41:41,340
有了这个提示，我能从中得到什么？无论您是要问的是一种大语言

581
00:41:41,340 --> 00:41:46,519
模型，还是您是否要求某种财务投影或其他AI

582
00:41:46,519 --> 00:41:50,119
您可能想要的东西。这些是您通常不想放的东西，

583
00:41:50,380 --> 00:41:55,420
您无法在EVM中放置LLM并在合理的时间内运行它，

584
00:41:55,519 --> 00:41:59,559
只是矩阵数学，您会在那里进行。而且您无法有效地将其存储在EVM中。

585
00:42:00,079 --> 00:42:04,460
因此，他们将拥有一个系统，人们将出去执行它，然后将其放在那里并批处理它。

586
00:42:04,460 --> 00:42:05,779
并且将有一些检查它的方法。

587
00:42:06,440 --> 00:42:08,860
以及他们将通过预先编译合同访问的方式。

588
00:42:09,059 --> 00:42:15,659
同样，预编译合同是做您永远不会梦想在EVM中做的事情的逃生舱口，因为这是错误的地方。

589
00:42:15,840 --> 00:42:20,759
但是，如果您想对此有加密经济激励措施，则需要访问链上的事物。

590
00:42:20,760 --> 00:42:34,380
因此，这是您可以桥接这两个领域并仍然具有FHE或AI模型的力量的方式，但仍然重新添加并仍然添加这些功能，并且仍然具有加密经济激励措施。

591
00:42:36,900 --> 00:42:44,800
因此，除了EVM代码外，谈论L2S，我喜欢查看的另一个网站以获取有关此信息的信息是rollup.codes。

592
00:42:44,800 --> 00:42:48,540
这是Limechain提供的服务，以前与他们合作。

593
00:42:48,539 --> 00:42:51,500
女士们，他们是伟人和女孩。

594
00:42:51,840 --> 00:42:52,880
抱歉，我的话错误。

595
00:42:52,980 --> 00:42:54,679
但是他们是一大堆可以与之合作的工程师。

596
00:42:55,019 --> 00:42:56,099
他们把所有这些都放在一起。

597
00:42:56,900 --> 00:42:58,940
现在，这只是关注L2。

598
00:42:59,119 --> 00:43:03,159
但是您可以获取有关L2S中各种系统合同的所有信息。

599
00:43:03,619 --> 00:43:06,539
因为，您知道，仲裁的数量很少。

600
00:43:08,199 --> 00:43:10,019
有趣的是，您可以在这里链接。

601
00:43:10,099 --> 00:43:11,400
它们链接到实际实施中。

602
00:43:12,139 --> 00:43:14,719
因此，仲裁会在旅途中签订合同。

603
00:43:15,699 --> 00:43:18,320
或者，您可以回到擎天柱。

604
00:43:18,320 --> 00:43:20,220
我们将使用规范的乐观链

605
00:43:20,220 --> 00:43:21,760
显示其中一些。

606
00:43:22,480 --> 00:43:24,640
您知道，他们还有很多

607
00:43:25,300 --> 00:43:27,280
他们做自己的特殊事情，

608
00:43:27,860 --> 00:43:29,660
像L2一样，L1消息传球。

609
00:43:31,380 --> 00:43:32,740
同样，这些链接已经死亡。

610
00:43:34,539 --> 00:43:36,240
包裹，合同，基岩。

611
00:43:41,320 --> 00:43:43,820
转到Source，L2，是的，他们将其移动。

612
00:43:45,019 --> 00:43:46,460
所以l2到一个消息传递人，

613
00:43:46,460 --> 00:44:02,159
在这里，您可以看到他们已经实施了这些，这可能值得一点点钻探，这是进行系统合同集成的一种非常可行的方法。

614
00:44:02,920 --> 00:44:08,980
这一切都是在EVM中实施的，我认为他们没有具体的代码来具体实施。

615
00:44:09,679 --> 00:44:11,380
这可能是一个无聊的东西。

616
00:44:11,380 --> 00:44:15,619
您想去一些更多通用的东西。

617
00:44:16,340 --> 00:44:19,140
但是，就像，你知道，他们的基本vvault，

618
00:44:19,940 --> 00:44:23,140
它指VVAULT和i7版本。

619
00:44:23,760 --> 00:44:25,000
所以让我们回到环球

620
00:44:25,000 --> 00:44:27,760
并进入他们的Vvault代码。

621
00:44:28,780 --> 00:44:31,220
而且，您知道，您会做的所有事情

622
00:44:31,220 --> 00:44:32,820
以坚固性表示。

623
00:44:33,280 --> 00:44:35,099
但是他们要做的是发出事件

624
00:44:35,099 --> 00:44:36,980
这会发出信号向L2节点

625
00:44:36,980 --> 00:44:38,460
已经取出了。

626
00:44:38,460 --> 00:44:43,579
因此，您将某些安全模型本地定位在EVM本身中。

627
00:44:44,300 --> 00:44:50,980
而且，如果特定事件来自特定的地址，您只是相信这实际上是应该发生的事情。

628
00:44:51,599 --> 00:44:53,679
您必须相信EVM会做它所说的事情。

629
00:44:54,199 --> 00:44:58,940
因此，基于这些信息，您将在您身边进行所有簿记以更改各种状态。

630
00:44:59,480 --> 00:45:01,240
然后通过事件传达这些内容。

631
00:45:01,239 --> 00:45:04,599
和Zket EVMS也倾向于这样做

632
00:45:04,599 --> 00:45:07,039
他们的许多信号。

633
00:45:08,399 --> 00:45:10,519
让我们看看，这是更香草的之一。

634
00:45:11,379 --> 00:45:14,119
我认为多边形在这里链接到他们的代码。

635
00:45:15,319 --> 00:45:16,479
多边形很有趣。

636
00:45:16,599 --> 00:45:17,719
这是另一个有趣的设计选择。

637
00:45:17,859 --> 00:45:19,599
这全都是一份巨型合同。

638
00:45:20,659 --> 00:45:23,799
但是，再次，在这里您会发现会有

639
00:45:23,799 --> 00:45:29,919
他们在这里有很多活动

640
00:45:29,920 --> 00:45:32,519
他们如何来回交流，

641
00:45:32,659 --> 00:45:33,559
索赔和布里奇。

642
00:45:34,720 --> 00:45:42,519
再一次，它重点是使用发射机

643
00:45:42,519 --> 00:45:43,960
计算信息。

644
00:45:46,659 --> 00:45:49,519
因此，您知道，他们会做的事情，L2，L1通信，

645
00:45:49,960 --> 00:45:52,159
管理他们的钱和收费保险柜，

646
00:45:52,340 --> 00:45:54,360
当然，桥接是隐含的一部分。

647
00:45:54,740 --> 00:45:57,519
安全管理任务，如果您管理自己的权利

648
00:45:57,519 --> 00:45:59,240
到您的L2东西到各种地址，

649
00:45:59,239 --> 00:46:05,279
他们将使用系统合同来更新可能存储在EVM状态的UH中

650
00:46:05,279 --> 00:46:09,779
它可能存储在L2节点状态中，但它通过EV通过预编译系统

651
00:46:09,779 --> 00:46:15,319
合同嗯，但是有趣的是有些事情是链条信息查询也是

652
00:46:15,319 --> 00:46:18,879
通过预编译完成，这是我的希望层

653
00:46:18,879 --> 00:46:22,639
每当您拥有新的Blob base V时，就开始朝向而不是创建新的OP代码

654
00:46:22,639 --> 00:46:26,379
或其他一些特定于链的数据，

655
00:46:27,759 --> 00:46:29,239
他们经历了聪明的

656
00:46:29,379 --> 00:46:31,000
他们确实经历了预互换者

657
00:46:31,000 --> 00:46:32,679
因为，你知道，

658
00:46:32,699 --> 00:46:33,839
那将使所有的opcodes

659
00:46:33,839 --> 00:46:35,379
非常非常困难

660
00:46:35,379 --> 00:46:36,819
因为每个系统

661
00:46:36,819 --> 00:46:38,400
将有自己的自定义opcode

662
00:46:38,400 --> 00:46:40,599
而且没有牢固性和毒蛇

663
00:46:40,599 --> 00:46:41,539
还有其他所有人

664
00:46:41,539 --> 00:46:42,480
将支持所有这些功能。

665
00:46:43,799 --> 00:46:46,139
所以很多这样的重复

666
00:46:46,139 --> 00:46:47,879
30至40链中发生的事情。

667
00:46:48,599 --> 00:46:50,239
其中一些是新的，

668
00:46:50,420 --> 00:46:52,059
特定方式的独特事物

669
00:46:52,059 --> 00:46:54,079
各种L2工作

670
00:46:54,079 --> 00:46:55,980
因为您的L2块的概念

671
00:46:55,980 --> 00:46:57,179
和您的L1块不同

672
00:46:57,179 --> 00:46:58,440
是完全外国的东西

673
00:46:58,440 --> 00:46:59,779
到以太坊主网。

674
00:47:01,960 --> 00:47:03,820
现在，经历这一点，

675
00:47:03,940 --> 00:47:05,480
您可以看到一些值得注意的设计选择

676
00:47:05,480 --> 00:47:06,840
以L2合同的方式

677
00:47:06,840 --> 00:47:07,619
处理他们的预编译

678
00:47:07,619 --> 00:47:09,039
与以太坊主网想要的方式相对于。

679
00:47:09,820 --> 00:47:10,719
几乎普遍

680
00:47:10,980 --> 00:47:12,900
所有不是以太坊的事物，

681
00:47:13,579 --> 00:47:15,299
尤其是当他们在两层二层时，

682
00:47:15,719 --> 00:47:17,219
是他们使用的是固体API

683
00:47:17,219 --> 00:47:18,659
用于预编译的访问。

684
00:47:19,299 --> 00:47:21,079
在主网中，每个地址做一件事

685
00:47:21,079 --> 00:47:21,960
而且它只能做一件事，

686
00:47:21,960 --> 00:47:31,320
它做得很好，但是如果我们为um预编译而做到这一点，嗯，我会得到那是一个

687
00:47:31,320 --> 00:47:34,760
一个好问题，目前正在考虑的新预编译有EAPS，我会回来

688
00:47:34,760 --> 00:47:41,960
回到该Q A，这是一个很好的问题，但是至今我们都有一个预编译

689
00:47:41,960 --> 00:47:44,599
地址将有成千上万的预编译

690
00:47:44,599 --> 00:47:48,599
在第二层系统中的某些系统中编译，很难弄清楚发生了什么

691
00:47:48,599 --> 00:47:53,119
它。这些合同开发人员中有很多被用来理解和阅读坚固性

692
00:47:53,119 --> 00:47:57,559
文档以弄清楚应该发生的事情。所以有点变得

693
00:47:58,019 --> 00:48:03,299
坚固的ABI已成为两层之间传递消息传递的默认接口。

694
00:48:03,860 --> 00:48:10,079
这就提出了一个问题，也许我们需要一个ERC来构成坚固的ABI与坚固性分开。

695
00:48:10,619 --> 00:48:15,460
我不知道对此有多坚固，但是它被用于毒蛇，它被用于

696
00:48:15,460 --> 00:48:21,079
许多不同的地方，我认为值得将其提升为独立的标准。

697
00:48:21,980 --> 00:48:27,019
但是，它们如何实施它也有一些混合的API决定。某些第2层使用多个

698
00:48:27,019 --> 00:48:33,699
合同。一些ZK系统使用一份巨型合同来完成所有操作。那就是你分裂多远

699
00:48:33,699 --> 00:48:38,519
它分开。这没有真正的一致性。归根结底，这是设计

700
00:48:38,519 --> 00:48:43,539
偏爱您想如何作为实施者做到这一点。有些人有混合的持久性

701
00:48:43,539 --> 00:48:49,139
这些合同。有些是通过代理运行的，有些是固定部署的。再次有

702
00:48:49,139 --> 00:48:53,679
偏爱您如何在此公开安全风险。也有很多

703
00:48:53,679 --> 00:48:59,519
实施策略。有些连锁直接在节点中实施他们的系统合同

704
00:48:59,519 --> 00:49:06,759
软件，有些人以混合坚固性和L2节点软件的混合性实施

705
00:49:06,759 --> 00:49:12,639
来自坚固性的事件。如果您要

706
00:49:12,639 --> 00:49:16,960
设计其中之一，或者您参与设计这些，您可能需要考虑

707
00:49:16,960 --> 00:49:22,539
他们俩之间。而且，他们如何部署地址也有一种混合的方法。

708
00:49:23,219 --> 00:49:31,099
其中一些使用连续的地址。仲裁使用非常低的数字。乐观使用4200，

709
00:49:31,639 --> 00:49:37,519
一堆零进入他们的。有些系统使用创建对手。他们只会创建

710
00:49:37,519 --> 00:49:41,739
合同，当他们部署它时，无论创建合同将其放在何处，

711
00:49:41,739 --> 00:49:42,799
合同，就是这样。

712
00:49:42,879 --> 00:49:46,579
他们将使用create2，因为它具有更重复的部署语义

713
00:49:46,579 --> 00:49:47,539
基于地址。

714
00:49:48,839 --> 00:49:53,539
但是，如果您使用连续的地址，则显然可以进行地址

715
00:49:53,539 --> 00:49:57,339
系统合同，而当它是由Create2驱动的时，您真的必须知道该地址

716
00:49:57,339 --> 00:50:00,659
当您使用它时，当您查看它时正在工作的地址。

717
00:50:00,659 --> 00:50:05,239
因为当您查看在代码中调用乐观地址或任意地址时

718
00:50:05,279 --> 00:50:08,339
很明显，没有加密密钥。

719
00:50:08,559 --> 00:50:11,299
它的几率看起来同样如此。

720
00:50:11,739 --> 00:50:18,899
可以识别它很低，您知道所有地址都很难获得，但是您是

721
00:50:18,899 --> 00:50:23,539
主要将获得如此大的零序列的数字混合在一起

722
00:50:23,539 --> 00:50:31,559
真的很难获得，这是我提到的另一个使用系统合同的优势

723
00:50:31,559 --> 00:50:37,119
外国主机连锁服务UM Alt L曾经将使用它来访问其令牌UM Moonbeam Aurora

724
00:50:37,119 --> 00:50:41,839
Hedera都有其Alt L1代币系统的代理

725
00:50:41,839 --> 00:50:46,960
在UM以太坊标准中工作，以便人们可以使用他们的fefi菜并做

726
00:50:46,960 --> 00:50:50,799
与他们抗衡，但归根结底，它是一个圆点，或者是一个圆点或

727
00:50:50,799 --> 00:50:57,839
hedera doken嗯，这是我想我还没有完全写这片幻灯片

728
00:50:57,839 --> 00:51:02,319
可以访问他们可能需要在其不同的帐户模型上执行的帐户工具和系统

729
00:51:02,320 --> 00:51:09,360
Moonbeam和Polkadot在各种一层中都有投票和消息传递

730
00:51:09,360 --> 00:51:19,600
他们可以去与其他沟通交谈。 ZK还公开功能ZK Sync具有

731
00:51:19,600 --> 00:51:25,440
储存类别是不变的，他们通过Pre Pre Compiles通过

732
00:51:25,440 --> 00:51:27,940
因为他们实际上没有访问此操作的操作码。

733
00:51:29,960 --> 00:51:32,840
外国主机连锁服务。

734
00:51:33,740 --> 00:51:43,079
因此，当我谈论的是外国主机连锁店时，我说的是一个区块链，它在第一天就不是EVM区块链。

735
00:51:43,579 --> 00:51:50,079
因此，如果您像雪崩或Celo一样，这些基本上是EVM链，并具有自定义的构建。

736
00:51:50,079 --> 00:51:58,440
但是，如果您要像Cardano一样，坐着溶剂，一个近距离，一个polkadot，那是在没有EVM的情况下建立的。

737
00:51:58,639 --> 00:52:00,639
他们做自己的事情，并且有自己的决定。

738
00:52:00,739 --> 00:52:02,420
因此，这些就是我认为是外国主持人。

739
00:52:03,139 --> 00:52:10,259
因此，至少在Polkadot和附近的Hedera的情况下

740
00:52:10,779 --> 00:52:16,920
他们是否带入了一个系统，以便您可以在那里运行EVM并将其物品存储在链条上，并通过EVM访问它。

741
00:52:16,920 --> 00:52:20,800
但这不是他们的意图，您知道它们的建立。

742
00:52:21,079 --> 00:52:24,039
因此，您正在使用一个EVM系统，您将进入另一个EVM系统。

743
00:52:24,139 --> 00:52:27,240
这是一种外国系统。不是，就像，你知道，

744
00:52:27,320 --> 00:52:29,980
Windows内部具有Linux子系统。

745
00:52:30,400 --> 00:52:32,780
当您称之为一些窗口的东西时，它会有所不同。

746
00:52:33,500 --> 00:52:35,559
所以，这是我知道的，为什么我会考虑，你知道，

747
00:52:35,599 --> 00:52:38,940
外国主机访问基本上是一个操作系统，

748
00:52:38,940 --> 00:52:41,340
在同一过程中不同的操作系统。

749
00:52:41,680 --> 00:52:44,159
所以有，那里有问题，

750
00:52:44,159 --> 00:52:45,659
我认为下一个幻灯片。

751
00:52:45,659 --> 00:52:49,399
它是否回答了您关于外国宿主连锁店意味着什么的问题？

752
00:52:53,519 --> 00:52:56,079
其中一些外国主人有东西，

753
00:52:56,159 --> 00:52:59,059
它们建立在以太坊没有建立的事物的前提下。

754
00:52:59,139 --> 00:53:02,659
Polkadot希望像一个零层的零层一样。

755
00:53:03,019 --> 00:53:04,539
宇宙是我错过的。

756
00:53:05,579 --> 00:53:08,339
您知道，他们拥有这种内部链条通信协议。

757
00:53:09,079 --> 00:53:13,679
因此，他们可以通过预编译访问许多系统。

758
00:53:13,679 --> 00:53:18,039
因此，您做的事情并不是要在EVF中完成的事情，并且可以通过预编译访问这些事情。

759
00:53:19,519 --> 00:53:25,279
因此，当您进行系统呼叫时，要担心的一件大事是您需要了解一个安全模型。

760
00:53:26,059 --> 00:53:31,819
要注意的最大的事情是，预编译没有共享以太坊的内存模型。

761
00:53:31,980 --> 00:53:32,899
我的意思是什么？

762
00:53:33,819 --> 00:53:38,779
因此，在以太坊中，每个合同都有自己的合同存储组。

763
00:53:39,639 --> 00:53:43,059
只有该合同才能访问它。

764
00:53:43,059 --> 00:53:45,719
但是您添加了另一个称为委托呼叫的层。

765
00:53:45,799 --> 00:53:50,219
允许的是给您，好像另一合同有您的记忆

766
00:53:50,219 --> 00:53:53,059
模型在您的内存模型上采取行动，就好像是您一样。

767
00:53:53,559 --> 00:53:55,059
这就是代表呼叫的力量。

768
00:53:55,139 --> 00:53:58,799
这确实就是代理合同的工作方式是代理合同将部署的。

769
00:53:58,920 --> 00:54:02,519
它会在那里有记忆，但随后委派召集其他，其他，

770
00:54:02,940 --> 00:54:04,659
另一个可能非常非常的合同

771
00:54:04,880 --> 00:54:08,219
它或该版本的版本可以修复错误或添加新功能，

772
00:54:08,219 --> 00:54:10,019
但是内存模型保持不变。

773
00:54:10,019 --> 00:54:14,440
因此，您将征求实现V1或V2或V3的合同。

774
00:54:14,539 --> 00:54:15,179
您将升级它。

775
00:54:15,559 --> 00:54:18,179
但是记忆停留在代理合同中。

776
00:54:18,719 --> 00:54:21,039
因此，使用这些委托呼叫，您将无法访问内存。

777
00:54:21,780 --> 00:54:22,619
您有自己的记忆。

778
00:54:22,759 --> 00:54:27,820
而且，在这些呼叫中，也可以维护诸如发送方地址和本地地址之类的东西。

779
00:54:28,559 --> 00:54:33,940
现在，如果您不知道这一点，您可能会做的是，当您接到系统中的电话时，您可能会说，谁在打电话给我？

780
00:54:34,239 --> 00:54:36,480
您可能会问，您知道，谁是发件人，谁是地址？

781
00:54:36,480 --> 00:54:38,380
您可能会做一些事情，就好像是他们一样。

782
00:54:40,019 --> 00:54:42,300
他们知道，黑客很聪明。

783
00:54:42,860 --> 00:54:45,019
他们找到了通过代表呼吁滥用这一滥用的方法。

784
00:54:45,559 --> 00:54:47,960
而且通常是通过其他回电的合同。

785
00:54:48,579 --> 00:54:52,860
而且，他们会以回调或回调的方式进行代表呼吁。

786
00:54:52,960 --> 00:54:54,739
他们没有调用来自父母的代表呼叫。

787
00:54:55,320 --> 00:55:00,059
简而言之，发生的事情是他们可以模仿人们，使它看起来像一个人。

788
00:55:00,219 --> 00:55:05,039
这不是完美的，但是他们可以使用技术来实现自己的工作。

789
00:55:05,039 --> 00:55:11,679
这在Um Hedera中非常有名

790
00:55:11,679 --> 00:55:15,539
这样，我不确定Moonbeam是否刚刚穿过UM

791
00:55:15,539 --> 00:55:21,139
或者，如果他们对此进行了安全披露，但他们能够沥干

792
00:55:21,139 --> 00:55:27,320
UM UNISWAP风格的流动性将其用于合同的其中一些合同

793
00:55:27,320 --> 00:55:33,259
对于回调，嗯，因为这在这些外国链中起作用的原因

794
00:55:33,260 --> 00:55:38,600
系统但在基于EVM的系统中不是是因为内存模型不同。现在，解决方案

795
00:55:38,600 --> 00:55:43,600
对此很简单。这是为了禁止在系统预编译的系统中呼叫。你这样做的方式

796
00:55:43,600 --> 00:55:47,440
您是否检查您部署的合同的地址是否是您认为的地址。

797
00:55:48,220 --> 00:55:52,740
因此，当您在构造函数中部署合同时，您会将地址保存到不变的

798
00:55:52,740 --> 00:55:58,420
数据。在现代版本的坚固性中，已复制到部署的实际代码中

799
00:55:58,420 --> 00:56:03,060
有了合同，这是该代码的不变特征。因此您可以检测到您是否正在

800
00:56:03,059 --> 00:56:07,579
打电话给这个代表是否致电，您可以说，不，我拒绝打电话。当你控制

801
00:56:07,579 --> 00:56:11,279
节点软件，您可以进行类似的检查，而无需在地址中燃烧，

802
00:56:11,299 --> 00:56:13,799
但是您可以检查并确保我是否被委派。如果你是代表

803
00:56:13,799 --> 00:56:18,460
打电话，您可以拒绝系统合同。这就是Moonbeam为他们的系统所做的

804
00:56:18,460 --> 00:56:22,940
合同。这就是尼尔所做的。现在，这就是Hedera为确保这些不存在的事情所做的。

805
00:56:22,940 --> 00:56:35,940
另一个问题是，就预编译而言，EVM链主要涉及坚固的错误，这并不是真正的原因。

806
00:56:35,940 --> 00:56:43,940
EVM链中涉及的任何黑客都不是因为EVM实现本身，而不是代码。

807
00:56:43,940 --> 00:56:46,940
为什么我称呼这一点值得注意的是因为它利用了它。

808
00:56:46,940 --> 00:56:50,380
下面有一个外国链，一个EVM链，

809
00:56:50,380 --> 00:56:53,179
试图像EVM一样行动，但这不是EVM。

810
00:56:53,179 --> 00:56:55,820
他们能够使用略有差异

811
00:56:55,820 --> 00:56:58,539
在两者之间利用它。

812
00:56:58,539 --> 00:57:00,619
因此，当您执行这些实现时，

813
00:57:00,619 --> 00:57:02,139
您需要牢记这一点并确保

814
00:57:02,139 --> 00:57:05,539
任何差异都被阻止了。

815
00:57:05,539 --> 00:57:07,860
它可以做的最大的事情是乐队代表呼叫。

816
00:57:07,860 --> 00:57:10,380
但是接下来您需要意识到

817
00:57:10,380 --> 00:57:12,380
是恢复工作的方式。

818
00:57:12,380 --> 00:57:15,139
因此有人可能会打电话给您的系统合同

819
00:57:15,139 --> 00:57:16,539
您可能会提交数据。

820
00:57:16,539 --> 00:57:18,159
然后后来可能会恢复。

821
00:57:18,820 --> 00:57:23,420
如果您的包装电话被恢复，则需要确保您的系统合同更改也会恢复。

822
00:57:23,820 --> 00:57:27,699
我不确定，我还不知道这一点的任何东西，

823
00:57:27,699 --> 00:57:32,940
因为我认为正在实施此操作的每个人都痛苦地意识到如何恢复工作

824
00:57:32,940 --> 00:57:36,719
并已经构建了他们的系统，以使任何呼叫都将被恢复，

825
00:57:36,800 --> 00:57:39,460
如果它们在范围内恢复，则不会产生挥之不去的副作用。

826
00:57:39,940 --> 00:57:44,420
但这再次是您需要了解的系统合同时的另一件事。

827
00:57:44,420 --> 00:57:47,659
如果它完全实现了EVM模型，

828
00:57:47,659 --> 00:57:50,420
那你很好。

829
00:57:50,420 --> 00:57:52,340
但是，如果它没有完全实现EVM模型，

830
00:57:52,340 --> 00:57:53,420
您需要采取措施以确保

831
00:57:53,420 --> 00:57:55,920
如果您的系统呼叫被恢复，

832
00:57:55,920 --> 00:57:57,880
副作用不会流连忘返。

833
00:57:57,880 --> 00:57:59,639
这是一种微妙的天才

834
00:57:59,639 --> 00:58:03,000
对此的乐观解决方案，

835
00:58:03,000 --> 00:58:04,800
他们在牢固地写东西的地方，

836
00:58:04,800 --> 00:58:06,139
他们散发事件，

837
00:58:06,139 --> 00:58:07,599
然后根据那些发出的事件，

838
00:58:07,599 --> 00:58:09,720
他们在L2节点中执行操作。

839
00:58:09,720 --> 00:58:10,820
因为EVM的工作方式，

840
00:58:10,820 --> 00:58:12,700
如果您必须恢复某些内容，

841
00:58:12,700 --> 00:58:14,340
所有事件也被恢复。

842
00:58:14,420 --> 00:58:19,940
嗯，所以您知道您将其保持尽可能简单，嗯，它巧妙地效果很好

843
00:58:19,940 --> 00:58:22,900
因此，这是关于乐观的天才之一，为什么他们永远不必担心

844
00:58:22,900 --> 00:58:30,820
这是因为他们尽可能地使用EVM，所以我想谈的最后一件事

845
00:58:31,380 --> 00:58:35,139
至于EVM的未来，除了新合同

846
00:58:35,139 --> 00:58:41,860
有一个想法的想法，称为渐进的预编译嗯，为什么没有链接

847
00:58:44,420 --> 00:58:46,380
开始了。

848
00:58:48,940 --> 00:58:50,340
我正在使用旧版本。

849
00:58:53,440 --> 00:58:55,240
因此，在我进行进步的预编译之前，

850
00:58:55,300 --> 00:58:57,480
我将谈论预编译的一些功能。

851
00:58:58,159 --> 00:58:59,440
一般来说，关于主网，

852
00:58:59,539 --> 00:59:01,559
添加新的Mainnet预编译具有抵抗力。

853
00:59:02,039 --> 00:59:03,340
测试表面高，

854
00:59:03,579 --> 00:59:06,860
问题是我们必须永远继续下去。

855
00:59:07,200 --> 00:59:10,500
我们与Lake2和Ripemd的经历

856
00:59:10,500 --> 00:59:12,300
让我们犹豫要在那里添加东西。

857
00:59:12,300 --> 00:59:13,139
我们将必须永远维护

858
00:59:13,139 --> 00:59:14,360
有人可能会使用它的所有机会。

859
00:59:14,420 --> 00:59:17,800
这就是为什么BLS具有九个单独的功能，

860
00:59:17,800 --> 00:59:18,900
这是一个令人难以置信的点，

861
00:59:18,900 --> 00:59:22,180
自2020年或2021年以来，代码已经准备就绪，

862
00:59:23,380 --> 00:59:26,180
但尚未实施

863
00:59:26,180 --> 00:59:27,280
因为需要

864
00:59:27,280 --> 00:59:29,559
但是因为它是在共识层中实现的

865
00:59:29,559 --> 00:59:31,800
我们需要验证这些BLS签名，

866
00:59:31,800 --> 00:59:32,840
这就是为什么它被带进来的原因

867
00:59:32,840 --> 00:59:34,380
是否有令人信服的需求。

868
00:59:34,380 --> 00:59:35,940
这是非常高的迫切需求。

869
00:59:35,940 --> 00:59:37,820
这就是我们需要的水平

870
00:59:37,820 --> 00:59:40,980
将预编译带入主要网络。

871
00:59:40,980 --> 00:59:43,360
它要么对功能必不可少，要么基本上是

872
00:59:43,360 --> 00:59:48,640
它必须对其他功能至关重要，它不能独自站立

873
00:59:50,079 --> 00:59:54,220
嗯，正在努力解决其中的一些是一个叫做“滚动呼叫的呼叫”

874
00:59:54,220 --> 00:59:57,160
卷起两者的两者聚在一起，他们谈论了一些标准问题

875
00:59:58,360 --> 01:00:01,660
嗯，想确保他们在不知道的情况下应对的事情保持一致

876
01:00:01,660 --> 01:00:05,740
必须让每个人都在同一项目上工作，但是从中掉下来的一件事之一就是

877
01:00:05,740 --> 01:00:11,559
他们的早期合作是他们标准化SCCP-256-R1预编译的外观

878
01:00:11,559 --> 01:00:13,619
他们正在标准化地址，

879
01:00:13,840 --> 01:00:15,539
而且他们在界面上标准化

880
01:00:15,539 --> 01:00:18,820
因此，这是在L2预编译中存在的。

881
01:00:20,119 --> 01:00:22,980
上行是如果L2弄错了，

882
01:00:23,599 --> 01:00:25,480
只有L2才能永远与之生活在一起，

883
01:00:25,639 --> 01:00:26,360
不是主网。

884
01:00:26,860 --> 01:00:28,579
如果一个或两个L2实施它，

885
01:00:28,860 --> 01:00:29,920
但是，如果他们做对了，

886
01:00:30,360 --> 01:00:31,659
所有L2S都将实施它，

887
01:00:31,659 --> 01:00:34,559
然后它将进入主网

888
01:00:34,559 --> 01:00:35,699
因为它已被证明。

889
01:00:36,279 --> 01:00:38,599
这是一些核心开发人员

890
01:00:38,599 --> 01:00:40,920
在核心以太坊第1层上，

891
01:00:40,920 --> 01:00:44,980
工程努力，他们真的想采用这种方法

892
01:00:44,980 --> 01:00:49,180
可能会进入EVM首先是在第二层原型的，然后在证明它们时

893
01:00:49,180 --> 01:00:53,019
成功且经过证实的稳定，然后如果第一层需要它，则将其进入第一层。

894
01:00:53,980 --> 01:00:58,420
因此，我认为这是一个例子，说明未来的预编译如何进入主要网络

895
01:00:58,420 --> 01:01:03,579
看，我们将在大多数情况下采用第二层预编译，否则我们将要

896
01:01:03,579 --> 01:01:09,860
实现对Verkle或Blob等功能必不可少的一层预编译。和

897
01:01:09,860 --> 01:01:13,340
斑点是最近添加的斑点，即KZG预编译，

898
01:01:13,599 --> 01:01:14,700
因为那对此至关重要。

899
01:01:15,559 --> 01:01:17,700
另一件事可能会帮助预编译

900
01:01:17,700 --> 01:01:20,220
是地平线上的EVM功能，称为EVM Max。

901
01:01:20,760 --> 01:01:22,740
最大代表模块化数学扩展。

902
01:01:26,280 --> 01:01:26,640
模块化的...

903
01:01:26,640 --> 01:01:27,500
我可能错了。

904
01:01:27,579 --> 01:01:28,820
当我写这篇文章时，已经很晚了。

905
01:01:30,420 --> 01:01:31,880
但这是模块化的指数。

906
01:01:32,519 --> 01:01:35,460
因此，它提供了许多进行模块化数学的功能，

907
01:01:35,460 --> 01:01:37,500
模块化，模块化鸿沟，

908
01:01:37,500 --> 01:01:42,900
这对于EC-DSA样式曲线的工作方式至关重要。

909
01:01:43,960 --> 01:01:48,139
因此，在志向上，他们的目标是确保这些东西在2倍之内

910
01:01:48,139 --> 01:01:52,500
如果您本地进行工作，您可能会制作正常的预编译。

911
01:01:53,000 --> 01:02:02,179
而且由于这些扩展中的模块化数学中几乎所有难度都在处理，所以

912
01:02:02,880 --> 01:02:06,199
这是非常合理的，因为四处走动以将答案移动并打包，

913
01:02:06,199 --> 01:02:07,439
那不是很昂贵。

914
01:02:08,019 --> 01:02:19,339
真正的费用是在所有数字中进行这384位模块化部门，这些数字在普通的旧EVM中非常昂贵。

915
01:02:19,399 --> 01:02:26,119
因此，这也应该减少对预编译的需求，因为您可以合理地带入随机曲线。

916
01:02:26,579 --> 01:02:33,359
您可以在椭圆曲线类型的情况下合理地带入正在完成的随机新功能。

917
01:02:33,360 --> 01:02:37,019
您可以专门针对所需的工作，并且可以优化它。

918
01:02:37,519 --> 01:02:40,400
这将解决很多问题。

919
01:02:40,460 --> 01:02:44,340
但这也打开了下一个可能性，这是下一个算术扩展。

920
01:02:44,500 --> 01:02:46,039
好的，模块化算术扩展。

921
01:02:46,240 --> 01:02:48,620
是的，就是这样。

922
01:02:51,539 --> 01:02:55,240
但是，将来真正发生的事情就是渐进的预编译。

923
01:02:55,920 --> 01:02:57,480
因此，这是一个准能力。

924
01:02:57,800 --> 01:03:01,920
这是与以太坊魔术师线程的链接。

925
01:03:01,920 --> 01:03:08,900
嗯，这里的想法是您写任何要做的事情，然后在EVM中写下它

926
01:03:08,900 --> 01:03:13,780
然后您将其钉住，您完全正确地说，您说这是我们要签的合同

927
01:03:13,780 --> 01:03:18,500
这样做，这样您就可以供您使用您使用的合同，例如创建两个技术来制作

928
01:03:18,500 --> 01:03:24,220
当然，它总是在同一地址上提出，您将要做的是您的节点软件

929
01:03:24,220 --> 01:03:28,700
要么使用该EVM代码，要么将其本地实施并更快地实施

930
01:03:28,699 --> 01:03:45,059
因此，如果我们有EVM-MAX，并且我们拥有SCCP-256-R1的EVM-MAX版本，或者我们需要具有R2或其他任何不同尺寸的曲线，我们需要FIPS合规性，我们需要实现一些随机曲线在那里，我们将在EVM中批量化。

931
01:03:45,719 --> 01:03:52,960
因此，如果您不想花时间编写本机实现，那么您只需运行EVM版本，而您只需免费获得它即可。

932
01:03:53,059 --> 01:03:54,079
您只需加入合同即可。

933
01:03:54,079 --> 01:03:58,759
但是，如果需要速度，则可以在本地实现并提高速度。

934
01:03:59,460 --> 01:04:02,179
现在，一个悬而未决的问题之一是如何处理汽油。

935
01:04:03,019 --> 01:04:05,659
如果您这样做，那么您将希望能够为此收取少的钱。

936
01:04:05,840 --> 01:04:08,299
但是我们将如何在链条中表明这一点，以及我们将如何处理

937
01:04:08,299 --> 01:04:09,719
尚未弄清楚。

938
01:04:10,119 --> 01:04:12,319
为了真正使它起作用，我们需要运送EVMX。

939
01:04:12,420 --> 01:04:13,739
我认为这确实会解锁它。

940
01:04:14,599 --> 01:04:17,759
现在，我认为证明了这种可行的模型之一

941
01:04:17,759 --> 01:04:20,779
是客户选择实施EIP-4788的方式。

942
01:04:20,780 --> 01:04:23,600
这就是我们带来的信标街区路线的地方

943
01:04:23,600 --> 01:04:27,380
我们将其纳入智能合约的存储中。

944
01:04:29,160 --> 01:04:30,320
Geth和Reth变得简单。

945
01:04:30,460 --> 01:04:31,740
他们只是执行合同。

946
01:04:32,120 --> 01:04:33,400
在街区开始时，

947
01:04:33,720 --> 01:04:34,680
他们创建交易，

948
01:04:35,000 --> 01:04:36,900
他们指出合同

949
01:04:36,900 --> 01:04:38,019
他们只是执行它。

950
01:04:38,400 --> 01:04:39,680
而且副作用将很好。

951
01:04:40,080 --> 01:04:41,120
他们不收费汽油。

952
01:04:41,240 --> 01:04:42,740
他们只是让它运行并尽其所能。

953
01:04:43,340 --> 01:04:44,800
他们从字面上使用合同。

954
01:04:45,420 --> 01:04:47,300
因此，这是一个很好的例子

955
01:04:47,300 --> 01:04:47,920
是你可能会这样做

956
01:04:48,300 --> 01:04:50,560
您知道，您可以在那里签订合同。

957
01:04:50,780 --> 01:04:53,940
但是，它们的做法不同。

958
01:04:53,940 --> 01:04:55,720
首先，他们查看并查看合同是否存在，

959
01:04:55,720 --> 01:04:56,980
如果合同存在，

960
01:04:56,980 --> 01:04:59,740
然后，他们只是将数据直接写入存储。

961
01:04:59,740 --> 01:05:01,080
进入EVM层，

962
01:05:01,080 --> 01:05:02,740
他们不去执行，

963
01:05:02,740 --> 01:05:04,820
他们只是做合同所做的事，他们有

964
01:05:04,820 --> 01:05:07,720
就像您在本地实施一样，相同的副作用。

965
01:05:07,720 --> 01:05:11,100
我认为这是重要的概念证明

966
01:05:11,100 --> 01:05:12,840
进步的预编译可能如何工作

967
01:05:12,840 --> 01:05:15,420
以及它们如何在两个世界中存在。

968
01:05:15,420 --> 01:05:18,780
如果您的连锁软件想要优化它，

969
01:05:18,780 --> 01:05:20,360
继续进行优化，只要

970
01:05:20,360 --> 01:05:22,240
所有副作用都是相同的。

971
01:05:22,240 --> 01:05:23,559
如果您不想优化它，

972
01:05:23,559 --> 01:05:25,340
或者您没有时间优化它，

973
01:05:25,340 --> 01:05:28,519
只需将EVM代码带入其中，它也可以使用。

974
01:05:28,519 --> 01:05:29,680
我认为这是

975
01:05:29,680 --> 01:05:33,120
可能未来的预编译可能会出现在EVM中。

976
01:05:33,120 --> 01:05:34,860
我们不必经历ACD。

977
01:05:34,860 --> 01:05:37,220
这只是实现细节

978
01:05:37,220 --> 01:05:39,039
客户将选择实施。

979
01:05:39,039 --> 01:05:40,120
如果有的话，你知道，

980
01:05:40,120 --> 01:05:43,980
就像我们需要支持的384 k2曲线一样

981
01:05:43,980 --> 01:05:44,820
我只是在弥补。

982
01:05:44,820 --> 01:05:46,840
我不知道这是否是真正的曲线。

983
01:05:46,840 --> 01:05:48,280
你知道，你可以写一个evm max

984
01:05:48,280 --> 01:05:49,740
那将为您完成所有数学。

985
01:05:49,739 --> 01:05:52,939
而且，如果您没有时间嵌入它，则只需确保它在链上，它将被执行。

986
01:05:53,479 --> 01:05:58,019
但是，如果您确实需要获得表演，则将时间花在客户身上，并在准备就绪时运送它。

987
01:05:58,119 --> 01:06:02,199
您不必等待叉子来实现此预编译并获得性能提高。

988
01:06:02,339 --> 01:06:12,879
这实际上是一种原始设计方法的方式，他们将要处理以太坊的智能合约，就是合同中的汽油成本，越多，其执行越便宜。

989
01:06:13,279 --> 01:06:17,199
理论是它将激励客户实施其中一些本地合同。

990
01:06:17,199 --> 01:06:28,039
这个想法最终被提出了，但是它的核心是您需要更快的东西，您可以更快地写作，因为与哈希的合同是固定的，不变的，永远不会改变。

991
01:06:30,199 --> 01:06:40,079
因此，这是对未来所有事物的快速摘要，而不是全部，而是我将来在预编译中看到的一些亮点。

992
01:06:41,199 --> 01:06:43,639
太好了，所以现在我有时间提出任何问题。

993
01:06:47,199 --> 01:06:52,199
让我们回到拉胡尔（Rahul）的。

994
01:06:52,199 --> 01:06:55,539
拉胡尔（Rahul）在演讲早些时候问

995
01:06:55,539 --> 01:06:58,960
如果在客户端或多个客户的预编译中报告错误，

996
01:06:58,960 --> 01:07:00,159
什么是行动计划？

997
01:07:00,159 --> 01:07:02,399
它在更新中得到修补吗？

998
01:07:02,399 --> 01:07:05,219
以前在预编译中发现了错误。

999
01:07:05,219 --> 01:07:06,819
主网上的核心开发人员

1000
01:07:06,819 --> 01:07:08,399
我想您在主网上问

1001
01:07:08,399 --> 01:07:10,419
因为如果是乐观或任意的，

1002
01:07:10,419 --> 01:07:12,019
我真的不能说他们的过程，

1003
01:07:12,019 --> 01:07:13,419
但是他们的团队更加紧张

1004
01:07:13,419 --> 01:07:15,119
他们有一种修复它的更严格的方法。

1005
01:07:15,119 --> 01:07:16,899
主要网的不同之处在于您

1006
01:07:16,900 --> 01:07:19,740
至少四个不同的团队，四到六支球队，

1007
01:07:19,740 --> 01:07:21,960
您需要将这些更改传达给

1008
01:07:21,960 --> 01:07:24,420
并以安全的方式获取信息

1009
01:07:24,420 --> 01:07:25,700
并把它运出。

1010
01:07:25,700 --> 01:07:27,119
现在，如果预编译中有错误，

1011
01:07:27,119 --> 01:07:29,180
通常只会是一个客户

1012
01:07:29,180 --> 01:07:30,380
那将有错误。

1013
01:07:30,380 --> 01:07:33,099
如果他们共享两个或三个图书馆，也许有两个

1014
01:07:33,099 --> 01:07:34,940
但这通常是一个或两个错误，

1015
01:07:34,940 --> 01:07:36,360
一个或两个客户。

1016
01:07:36,360 --> 01:07:38,220
我们有一个安全的聊天

1017
01:07:38,220 --> 01:07:40,320
我们谈论我们的错误

1018
01:07:40,320 --> 01:07:42,099
我们谈论发生了什么。

1019
01:07:42,099 --> 01:07:43,860
从这些信息，

1020
01:07:43,860 --> 01:07:45,280
我们倾向于看我们自己的软件

1021
01:07:45,280 --> 01:07:46,740
如果只是别人有一个错误

1022
01:07:46,739 --> 01:07:49,119
它确保我们不会陷入同样的​​问题

1023
01:07:49,119 --> 01:07:50,239
如果我们没有以相同的方式设置。

1024
01:07:50,239 --> 01:07:51,739
而且有几次我知道，我知道

1025
01:07:51,739 --> 01:07:54,159
有人说，我们犯了这个错误，因为，你知道，

1026
01:07:54,159 --> 01:07:55,079
这导致了它发生的。

1027
01:07:55,079 --> 01:07:55,919
我看了我们的代码，就像

1028
01:07:55,919 --> 01:07:57,459
哦，我们也有同样的事情。

1029
01:07:57,459 --> 01:07:59,739
因此，我们采用了他们的解决方案，反之亦然。

1030
01:07:59,739 --> 01:08:01,759
有一些基础已经完成的事情，你知道，

1031
01:08:01,759 --> 01:08:05,199
我们被烧毁了，这使其他客户更加专心

1032
01:08:05,199 --> 01:08:08,379
对于某些事情，他们需要修复。

1033
01:08:08,379 --> 01:08:09,959
因此，这不仅仅是预编译。

1034
01:08:09,959 --> 01:08:12,119
我们实际上也为EVM提供了它，

1035
01:08:12,119 --> 01:08:12,959
但是有一个

1036
01:08:12,959 --> 01:08:14,279
有一个我们将讨论的小组，

1037
01:08:14,279 --> 01:08:15,959
我们将披露错误。

1038
01:08:15,960 --> 01:08:18,520
我们会发出一个补丁，我们将发货新版本，

1039
01:08:19,260 --> 01:08:22,100
在该版本中，是否真的很紧急

1040
01:08:22,100 --> 01:08:23,880
而且您需要挥舞危险信号，

1041
01:08:23,980 --> 01:08:24,899
嘿，您需要立即更新它，

1042
01:08:25,960 --> 01:08:27,560
您知道，我们将提供其中一个补丁。

1043
01:08:28,079 --> 01:08:30,140
但是，如果我们不知道是否有，如果我们自己找到了

1044
01:08:30,140 --> 01:08:31,859
而且我们可以肯定的是，它正在尝试利用它，

1045
01:08:32,319 --> 01:08:35,199
我们将在版本，版本或几个版本中发货，

1046
01:08:35,500 --> 01:08:37,260
您会宣布该错误的详细信息。

1047
01:08:37,800 --> 01:08:39,359
这个组发现了许多错误

1048
01:08:39,359 --> 01:08:40,819
我们尚未完全披露，

1049
01:08:40,899 --> 01:08:42,140
即使他们已经修补了几个月。

1050
01:08:43,000 --> 01:08:45,020
而且，您知道，没有理由给人们的想法

1051
01:08:45,020 --> 01:08:46,440
在一定要看的地方

1052
01:08:46,440 --> 01:08:49,120
直到我们确定一切都已经整理了。

1053
01:08:49,120 --> 01:08:50,600
但是，如果是，然后是狂野的虫子，

1054
01:08:50,600 --> 01:08:52,960
我们将尽可能快地修复它。

1055
01:08:52,960 --> 01:08:54,740
我认为Geth的最后共识休息

1056
01:08:54,740 --> 01:08:57,440
与他们优化他们有关，

1057
01:08:57,440 --> 01:08:59,180
我认为这是他们的副本，

1058
01:08:59,180 --> 01:09:00,760
当它预编译时，

1059
01:09:00,760 --> 01:09:04,020
跨不同版本具有不同的副作用。

1060
01:09:04,020 --> 01:09:05,580
其中一个是不规格的，

1061
01:09:05,580 --> 01:09:09,840
就像三，四年前一样。

1062
01:09:09,840 --> 01:09:11,120
但就错误和预编译而言，

1063
01:09:11,120 --> 01:09:13,060
自从我们有任何东西以来已经有一段时间了

1064
01:09:13,060 --> 01:09:15,340
它一直在主要网络。

1065
01:09:15,340 --> 01:09:17,620
通常，我们尝试在测试网或开发人员中摇动这些

1066
01:09:17,620 --> 01:09:20,220
网，我们变得非常积极，真的很疯狂

1067
01:09:20,220 --> 01:09:22,920
以我们的方式融合他们和事物

1068
01:09:22,920 --> 01:09:24,160
我们尽力打破它们。

1069
01:09:26,740 --> 01:09:29,940
好，还有其他问题吗？

1070
01:09:32,940 --> 01:09:34,300
有新免费编译的EFU吗

1071
01:09:34,300 --> 01:09:35,800
目前正在考虑？

1072
01:09:35,800 --> 01:09:38,760
那是值得讨论的一个。

1073
01:09:38,760 --> 01:09:50,100
我认为当前的BLS EIP 257。

1074
01:09:50,100 --> 01:09:58,640
3527，这是数字吗？

1075
01:09:58,640 --> 01:10:04,720
不，这是什么？

1076
01:10:04,720 --> 01:10:05,640
哦，这是四个，是的。

1077
01:10:06,180 --> 01:10:09,039
25、37，BLS 12、381的预菲尔。

1078
01:10:10,260 --> 01:10:13,440
72、12，这实际上是撕裂，而不是EIP。

1079
01:10:13,780 --> 01:10:19,539
因此，我要去EIP 25，37是第一个。

1080
01:10:20,220 --> 01:10:25,320
这引入了G1和G2数学，

1081
01:10:25,320 --> 01:10:31,039
在各组中，BLS所需的三个基本内容。

1082
01:10:31,039 --> 01:10:36,579
嗯，您有一个配对，需要一个地图UM映射从G2到G1和FP，以及

1083
01:10:36,579 --> 01:10:40,600
一堆月亮数学，我不明白我只是知道它有效并做神奇的事情

1084
01:10:40,600 --> 01:10:44,739
因此，这可能是最大的，这是目前计划进入Prog的最大一个

1085
01:10:44,739 --> 01:10:50,579
在该列表中的所有列表中，这是最有可能发货的一个是7212

1086
01:10:50,579 --> 01:10:54,399
嗯，在这里出现的意志会重定向我们

1087
01:10:54,399 --> 01:11:02,739
是的，实际上，这最初是EIP，它将成为RIP

1088
01:11:02,739 --> 01:11:06,259
因为它将在卷起上运输，所以它已经有了地址

1089
01:11:06,259 --> 01:11:16,420
um p256验证，所以这是在R曲线上进行R曲线值得注意的

1090
01:11:16,420 --> 01:11:21,539
这是在消费者硬件中使用的。

1091
01:11:22,119 --> 01:11:23,140
FIP兼容。

1092
01:11:24,399 --> 01:11:26,500
那我有我的Yubikey吗？

1093
01:11:27,760 --> 01:11:28,940
但是，如果您有那些Yubikees，

1094
01:11:29,039 --> 01:11:30,039
那些触摸的小东西，

1095
01:11:30,100 --> 01:11:34,260
您放入计算机侧面的那些nubbies

1096
01:11:34,260 --> 01:11:35,340
那触摸那里的预览，

1097
01:11:35,579 --> 01:11:36,600
具有硬件密钥，

1098
01:11:37,060 --> 01:11:38,779
这些都有很多消费级钥匙。

1099
01:11:38,840 --> 01:11:42,060
我认为Web，而不是Web auth，

1100
01:11:42,560 --> 01:11:45,680
Google和Facebook的新网络键

1101
01:11:45,680 --> 01:11:47,360
Github试图推动您。

1102
01:11:47,820 --> 01:11:49,440
商店手机上的密码键，

1103
01:11:49,500 --> 01:11:50,300
您的计算机系统，

1104
01:11:50,400 --> 01:11:51,460
因此，您不必管理密码。

1105
01:11:52,079 --> 01:11:53,240
这些使用R键。

1106
01:11:53,440 --> 01:11:54,840
我已经看到有劳力士

1107
01:11:54,840 --> 01:11:55,740
具有演示代码

1108
01:11:55,740 --> 01:11:57,600
他们如何使用这些验证

1109
01:11:57,600 --> 01:12:00,880
实际解锁帐户抽象任务。

1110
01:12:01,200 --> 01:12:02,520
所以您可以拥有一个AA帐户

1111
01:12:02,520 --> 01:12:04,200
可以由R键驱动

1112
01:12:04,200 --> 01:12:06,100
而那个键实际上可能是

1113
01:12:06,100 --> 01:12:10,600
在消费级Yubikey类型设备上

1114
01:12:10,600 --> 01:12:11,180
那会坚持。

1115
01:12:11,180 --> 01:12:19,980
um eip 7545是另一个示例，它将因um而被带入另一个例子

1116
01:12:19,980 --> 01:12:23,400
功能需要它是垂直证明验证预编译

1117
01:12:23,400 --> 01:12:27,600
可能会将其带入大阪，因为目前的思维嗯，它会给它带来改变的空间

1118
01:12:27,600 --> 01:12:31,560
如果我们需要支持垂直方面，如果我们将其带入可能将我们锁定到事物中的prog中，并且

1119
01:12:31,560 --> 01:12:36,820
进入可能需要更改的垂直方向，以便在大阪的垂直方向出现

1120
01:12:36,819 --> 01:12:38,179
最有可能的。

1121
01:12:38,960 --> 01:12:40,539
和EIP-5988，

1122
01:12:40,859 --> 01:12:42,099
那是最有争议的

1123
01:12:42,099 --> 01:12:43,500
这四个

1124
01:12:43,500 --> 01:12:44,259
那是被带进来的

1125
01:12:44,299 --> 01:12:45,920
但这也是另一个重要的

1126
01:12:46,319 --> 01:12:47,840
这就是Poseidon哈希功能。

1127
01:12:48,479 --> 01:12:50,219
那陷入了一些ZK的东西。

1128
01:12:50,340 --> 01:12:53,579
ZK真的不开心

1129
01:12:53,579 --> 01:12:55,219
性能

1130
01:12:55,219 --> 01:12:56,279
当被要求这样做

1131
01:12:56,279 --> 01:12:57,880
kachak哈希或sha哈希。

1132
01:12:58,840 --> 01:13:00,039
有点twiddling不是什么

1133
01:13:00,039 --> 01:13:01,179
那个防ZK的系统

1134
01:13:01,179 --> 01:13:02,799
非常擅长。

1135
01:13:03,259 --> 01:13:04,039
有这样做的方法，

1136
01:13:04,079 --> 01:13:04,960
但这很昂贵。

1137
01:13:04,960 --> 01:13:11,119
Poseidon是基于椭圆曲线的哈希函数。我不知道它是如何工作的，

1138
01:13:11,680 --> 01:13:18,880
但是最大的外部是可以通过防zk-Prof的逻辑来实现它

1139
01:13:18,880 --> 01:13:23,760
更有效地，因为它到达哈希的方式对

1140
01:13:23,760 --> 01:13:29,600
ZK系统的工作方式。他们使用相同的椭圆曲线般的东西来获取曲线

1141
01:13:29,600 --> 01:13:37,520
是的，答案护理是的，是的，Poseidon Hash是它使用椭圆曲线的

1142
01:13:37,520 --> 01:13:43,520
我认为它本身不做ECDSA，但对当前ZK系统的工作方式非常友好

1143
01:13:49,039 --> 01:13:52,720
IMP确实会对网络充血有任何影响

1144
01:13:53,680 --> 01:13:58,079
他们可能会对网络拥堵产生影响的唯一唯一的方法是，您是否经过一个大型

1145
01:13:58,079 --> 01:14:02,239
关于预编译的数据量和有现成的协议对冲，以防止它

1146
01:14:02,239 --> 01:14:10,640
Geth不会在128K超过128k的任何交易中闻名的太多影响

1147
01:14:10,640 --> 01:14:15,119
使东西更大的方法，但这是脖子上的疼痛，所以交易大小

1148
01:14:15,119 --> 01:14:20,640
限制还有天气成本，我们正在为UM收取有效载荷的费用

1149
01:14:20,640 --> 01:14:26,319
交易带来了大量数据

1150
01:14:26,319 --> 01:14:29,159
这不一定会引起任何网络拥塞。

1151
01:14:29,159 --> 01:14:31,319
这确实是网络被打击的地方。

1152
01:14:31,319 --> 01:14:33,359
您知道，这不是更好的方法

1153
01:14:33,359 --> 01:14:35,340
引起网络拥塞问题

1154
01:14:35,340 --> 01:14:37,479
而不是滥用预编译。

1155
01:14:37,479 --> 01:14:39,460
滥用预编译是您的方式

1156
01:14:39,460 --> 01:14:41,359
导致执行放缓。

1157
01:14:41,359 --> 01:14:43,639
我们付出了很多努力来确保

1158
01:14:44,500 --> 01:14:46,840
您可以滥用它的任何方法

1159
01:14:46,840 --> 01:14:50,579
效率较小，而不是进行一堆聊天电话。

1160
01:14:51,380 --> 01:14:54,319
可能是，或者那是最难优化的事情

1161
01:14:54,319 --> 01:14:57,159
因为它已经是一个非常优化的操作。

1162
01:14:57,159 --> 01:14:58,840
只要我们能做的任何事情

1163
01:14:58,840 --> 01:15:03,359
比聊天电话更有效，

1164
01:15:03,359 --> 01:15:05,880
然后，它解决了很多问题。

1165
01:15:13,439 --> 01:15:17,819
是为了编译前问题吗？

1166
01:15:19,279 --> 01:15:22,599
好吧，我向有关Java代码和贝叶的一个讲话。

1167
01:15:24,319 --> 01:15:26,319
冷却其他任何问题

1168
01:15:31,439 --> 01:15:38,559
好的，非常感谢你嗯，嗯，嗯，也许我想问你是否可以

1169
01:15:38,559 --> 01:15:46,079
详细说明添加预编译的问题是什么，您有这些

1170
01:15:46,079 --> 01:15:50,960
您去了您的建议，是的，您看到的其他挑战是什么

1171
01:15:50,960 --> 01:15:53,340
例如，但是您的意思是，但是我们会说，

1172
01:15:53,340 --> 01:15:57,779
但是我听说问题是它只会像一组一样

1173
01:15:57,779 --> 01:16:02,960
哈希的参数，其他链没有使用，依此类推。

1174
01:16:04,020 --> 01:16:06,380
是的，有什么挑战？我认为，

1175
01:16:06,500 --> 01:16:08,720
我认为这些预编译，复杂性是什么？

1176
01:16:11,260 --> 01:16:15,460
正确的。因此，我的意思是，我们可以在ECDSA中看到这一点。

1177
01:16:15,600 --> 01:16:17,039
我们没有ECDSA预编译。

1178
01:16:17,039 --> 01:16:21,359
那是BLS 2537的原始音调。

1179
01:16:22,039 --> 01:16:25,640
第一个实施是引入BLS。

1180
01:16:26,220 --> 01:16:34,819
编写一个非常通用的哈希函数，可以被参数化，它的测试表面就具有巨大的性能。

1181
01:16:35,140 --> 01:16:43,260
我们在MODDXP上的经验，我们很害羞地引入巨大的未知和不可估量的性能问题。

1182
01:16:43,439 --> 01:16:45,619
这只是引起安全问题的绝佳机会。

1183
01:16:45,619 --> 01:16:49,159
因此，这就是为什么当我们引入特定的预编译时，我们会想要特定的曲线。

1184
01:16:49,779 --> 01:16:54,920
这就是为什么我非常看好渐进的预编译和EVM-MAX的原因，

1185
01:16:55,039 --> 01:16:58,599
因为似乎可以使用EVM-MAX实施Poseidon。

1186
01:16:59,239 --> 01:17:02,779
您可以拥有一份实现我的曲线参数的合同，

1187
01:17:03,019 --> 01:17:05,500
或者您可以拥有实现曲线参数的合同，

1188
01:17:05,779 --> 01:17:07,619
您可以同等地将它们带入。

1189
01:17:08,140 --> 01:17:10,680
因此，您知道，引进波塞冬的问题之一就是

1190
01:17:10,739 --> 01:17:12,659
我们带来什么参数？

1191
01:17:12,659 --> 01:17:17,859
每个人都可以使用这些参数，并且确实适合您的特定ZK系统

1192
01:17:17,859 --> 01:17:22,899
要成为对您有用的东西，还是会成为您知道257

1193
01:17:22,899 --> 01:17:26,340
字节版本200我不知道这些参数是什么，但是这些是事物的类型

1194
01:17:26,340 --> 01:17:32,500
当我研究各种uh um加密事物时，就会有各种各样的

1195
01:17:32,500 --> 01:17:37,139
小旋钮和可以调整的东西，密码学家嗯，确切知道他们为什么

1196
01:17:37,139 --> 01:17:41,460
需要它，他们确切地知道为什么他们需要那个数字，所以他们是他们真的知道

1197
01:17:41,460 --> 01:17:44,760
他们真的希望出于高性能原因而拥有他们确切需要的东西。

1198
01:17:45,500 --> 01:17:47,600
但是我们不能，当我们进行预编译时，

1199
01:17:47,980 --> 01:17:52,079
具有巨大的开放系统，难以测试

1200
01:17:52,079 --> 01:17:56,560
因为这将在主要网络中带来重大风险。

1201
01:17:56,960 --> 01:18:00,319
现在，如果您想在L2上尝试一下，什么都没有阻止您

1202
01:18:00,319 --> 01:18:04,520
因为如果事情真的发生，只有L2才会有错 - 

1203
01:18:04,520 --> 01:18:07,800
故障可能不是正确的词，但只有L2会处于危险之中。

1204
01:18:08,239 --> 01:18:10,039
如果预编译中有错误，

1205
01:18:10,039 --> 01:18:11,399
在L2内会容易得多。

1206
01:18:11,460 --> 01:18:13,980
解决这个问题并立即将其带入

1207
01:18:13,980 --> 01:18:15,939
因为他们都有安全委员会。

1208
01:18:16,180 --> 01:18:18,380
即使没有训练轮模式，

1209
01:18:18,439 --> 01:18:19,939
有一个机会，

1210
01:18:20,020 --> 01:18:22,439
您知道，这些关键要关闭所有内容。

1211
01:18:22,800 --> 01:18:23,739
无法在主要网上这样做。

1212
01:18:24,220 --> 01:18:25,779
如果主要网上发货的东西，

1213
01:18:25,840 --> 01:18:26,720
它将永远存在。

1214
01:18:27,960 --> 01:18:29,800
我认为这是很多犹豫的地方

1215
01:18:29,800 --> 01:18:32,000
引入预编译

1216
01:18:32,000 --> 01:18:34,680
这是其中很多是单向门。

1217
01:18:35,399 --> 01:18:36,480
如果我们错了，

1218
01:18:37,000 --> 01:18:40,199
从破碎的预编译中捡起碎片

1219
01:18:40,199 --> 01:18:41,060
将非常困难。

1220
01:18:41,460 --> 01:18:48,739
是的，那么，是否有关于删除预编译的讨论？

1221
01:18:48,739 --> 01:18:53,699
例如，您在开头提到的身份，就像无效

1222
01:18:53,699 --> 01:18:55,420
记忆副本，是吗？

1223
01:18:55,420 --> 01:18:58,619
是的，有关于删除预编译的讨论。

1224
01:18:58,619 --> 01:19:00,920
最大的原因是它将简化客户端软件。

1225
01:19:00,920 --> 01:19:05,720
我认为，就像您提到的身份一样

1226
01:19:05,720 --> 01:19:07,640
wrip MD和Blake功能。

1227
01:19:07,640 --> 01:19:12,920
这些是基于理由之一的是，它们的用途几乎为零。

1228
01:19:12,920 --> 01:19:16,160
在某些块中，它们的用途确实为零。

1229
01:19:16,160 --> 01:19:19,400
因此，有关于将其删除的话题，但我认为更有可能发生的事情

1230
01:19:19,400 --> 01:19:26,140
而不是删除它们，而是他们可能会迁移到合同中。

1231
01:19:26,140 --> 01:19:31,600
如果我们可以在合理尺寸的EVM合同中做成熟的MD，我可以看到我们正在迁移

1232
01:19:31,600 --> 01:19:36,720
固定合同，您将执行该合同，而汽油价格将适当上升。

1233
01:19:36,720 --> 01:19:39,000
Blake功能的同一件事，

1234
01:19:39,000 --> 01:19:41,240
将其迁移到价格的合同

1235
01:19:41,240 --> 01:19:42,960
然后会适当上升。

1236
01:19:42,960 --> 01:19:46,340
身份，实际上有字体模式可以做到这一点，

1237
01:19:46,340 --> 01:19:48,480
您知道，汽油价格上涨。

1238
01:19:48,480 --> 01:19:50,680
但是我的意思是，当涉及到其中的一些事情时

1239
01:19:50,680 --> 01:19:51,860
像其中一些事情一样

1240
01:19:51,860 --> 01:19:54,539
您只是不在新操作中使用它们。

1241
01:19:54,539 --> 01:19:59,000
除非您正在做审核员，否则

1242
01:19:59,000 --> 01:20:00,699
您的电话未征用的事情，

1243
01:20:00,699 --> 01:20:02,240
如果您像汽油有限的电话一样

1244
01:20:02,240 --> 01:20:05,000
或依靠某些电话的津贴回报，

1245
01:20:05,000 --> 01:20:08,779
然后上涨的价格是这些预编译中的一些，

1246
01:20:08,779 --> 01:20:10,960
解决方案是发送更多气体。

1247
01:20:12,600 --> 01:20:14,859
因此，这些缺点并不糟糕。

1248
01:20:14,859 --> 01:20:16,340
它的作用是移动逻辑

1249
01:20:16,340 --> 01:20:19,380
在客户端代码中，将其移至EVM中，

1250
01:20:19,380 --> 01:20:21,359
您知道，它解决了很多问题。

1251
01:20:21,359 --> 01:20:23,460
只是，这只是另一个EVM程序。

1252
01:20:27,239 --> 01:20:28,260
好吧，很棒。

1253
01:20:28,260 --> 01:20:30,460
是的，非常感谢，达娜。

1254
01:20:30,460 --> 01:20:34,119
我有一个与预编译无关的问题

1255
01:20:34,119 --> 01:20:35,939
更多关于Bessu和Java的更多信息，

1256
01:20:35,939 --> 01:20:40,439
因为我经常读到有新的Java版本，所以

1257
01:20:40,439 --> 01:20:43,939
就像，你知道，我可以使用Java 23，21，

1258
01:20:43,939 --> 01:20:45,460
我相信现在。

1259
01:20:45,460 --> 01:20:48,220
所以我想知道，贝苏用了什么版本

1260
01:20:48,220 --> 01:20:50,399
更新到新版本时面临哪些挑战

1261
01:20:50,399 --> 01:20:52,680
什么是潜在的好处？

1262
01:20:52,680 --> 01:20:55,180
所以，是的，所以有，爪哇很有趣

1263
01:20:55,180 --> 01:20:58,239
这是一个运行的系统，您可以运行程序，

1264
01:20:58,239 --> 01:21:00,239
您可以升级下面的Java系统

1265
01:21:00,239 --> 01:21:01,420
几乎总是没有问题。

1266
01:21:01,420 --> 01:21:03,059
他们做了很多向后的兼容性。

1267
01:21:04,119 --> 01:21:07,979
因此，现在，Basu用Java 17编译。

1268
01:21:08,099 --> 01:21:09,659
该代码必须在Java 17中。

1269
01:21:10,260 --> 01:21:11,800
当我们在构建服务器上构建时，

1270
01:21:11,920 --> 01:21:13,500
贾斯汀将其设置为GitHub动作。

1271
01:21:13,840 --> 01:21:15,779
它使用Java 17编译器，

1272
01:21:15,880 --> 01:21:17,359
它将其编译到Java 17。

1273
01:21:17,800 --> 01:21:19,079
但是从该字节码，

1274
01:21:19,079 --> 01:21:22,640
您可以将其下面的系统更改为运行Java 21。

1275
01:21:24,000 --> 01:21:26,739
只是从Java 17更改为Java 21

1276
01:21:26,859 --> 01:21:28,359
您会增加20％的速度。

1277
01:21:28,460 --> 01:21:29,579
很棒的东西的总和

1278
01:21:29,579 --> 01:21:31,439
他们已经完成了JIT技术。

1279
01:21:31,619 --> 01:21:32,800
这是疯狂的东西。

1280
01:21:34,119 --> 01:21:37,199
因此，问题正在升级。

1281
01:21:37,680 --> 01:21:40,079
因此，我们想从Java 17到Java 21。

1282
01:21:40,199 --> 01:21:43,180
这是明年基本上会发生的事情，

1283
01:21:43,680 --> 01:21:45,840
也许几个月。很难说。

1284
01:21:46,399 --> 01:21:50,079
但是我们需要确保我们所有的工具都支持Java 21。

1285
01:21:50,699 --> 01:21:53,099
格拉尔以落后的支持而闻名。

1286
01:21:53,220 --> 01:21:56,000
他们总是落后大约六个月。你知道，

1287
01:21:56,000 --> 01:21:58,599
他们不支持我一直在等待的最新一个

1288
01:21:58,599 --> 01:22:00,340
一点。因此，我们的构建工具需要支持它。

1289
01:22:00,340 --> 01:22:04,699
然后我们使用的一些库来支持它。

1290
01:22:04,699 --> 01:22:07,220
一个目前即将修复的

1291
01:22:07,220 --> 01:22:10,000
Web3J有一些不兼容

1292
01:22:10,000 --> 01:22:11,360
带有较新版本的Gradle。

1293
01:22:11,360 --> 01:22:13,360
所以我们必须使用较旧版本的gradle

1294
01:22:13,360 --> 01:22:15,020
不支持21。

1295
01:22:15,020 --> 01:22:16,440
这主要是，您知道，只是，您知道

1296
01:22:16,440 --> 01:22:19,140
良好的旧构建工程，软件工程问题。

1297
01:22:19,140 --> 01:22:20,319
当您想升级版本时，

1298
01:22:20,319 --> 01:22:22,480
您必须确保整个纠结

1299
01:22:22,480 --> 01:22:25,279
您拥有的依赖项可以支持Java 21。

1300
01:22:25,279 --> 01:22:27,380
我们使用的许多工具，我们都使用的工具

1301
01:22:27,380 --> 01:22:29,980
你知道，我们试图远离工具

1302
01:22:29,979 --> 01:22:33,000
已经变得僵化，从未改变。

1303
01:22:33,000 --> 01:22:35,259
因此，当我们找到这些时，我们倾向于将其删除。

1304
01:22:36,500 --> 01:22:40,059
GCOCO，这是我们使用的构建工具

1305
01:22:40,059 --> 01:22:43,119
判断我们的测试的覆盖范围，

1306
01:22:43,119 --> 01:22:44,599
他们对保持最新状态非常好。

1307
01:22:44,599 --> 01:22:47,019
这是我们升级Gradle的另一个。

1308
01:22:47,019 --> 01:22:49,139
因此，将其升级到Java 21是什么

1309
01:22:49,139 --> 01:22:53,039
这将在短期内发生。

1310
01:22:53,039 --> 01:22:55,039
现在，爪哇是一种有趣的野兽。

1311
01:22:55,039 --> 01:22:58,000
并非每个释放都得到长期的支持。

1312
01:22:58,000 --> 01:23:05,840
他们决定采用的模式就像每四个发行版一样，就是长期发布。

1313
01:23:06,560 --> 01:23:14,199
因此，支持Java 17的较新版本，但是Java 18、19和20，这些版本在大多数情况下都具有最后版本。

1314
01:23:14,979 --> 01:23:18,319
Java 21是将获得更多重复支持的另一个版本。

1315
01:23:18,979 --> 01:23:22,100
因此，Java 21将得到多年的支持。

1316
01:23:22,100 --> 01:23:30,260
因此，许多项目，他们的工作，一段时间以来一直在做什么，我们将针对当前或上一个的长期支持发布之一。

1317
01:23:30,940 --> 01:23:33,300
当我们使用前一个时，我们将迁移到当前的迁移。

1318
01:23:33,860 --> 01:23:35,880
所以在那之前是Java 11。

1319
01:23:36,900 --> 01:23:41,660
因此，几年前，我们从Java 11迁移到Java 17。

1320
01:23:41,980 --> 01:23:42,980
已经有几年了。

1321
01:23:43,039 --> 01:23:44,840
现在，我们将从Java 17到21做一个。

1322
01:23:45,320 --> 01:23:47,160
几年后，我们将前往Java 21和25。

1323
01:23:47,159 --> 01:23:58,579
升级到新版本的Java的令人兴奋的是，这是您真正牢固地看到的东西，但是您可以使用新的语言功能和新事物通常使事情更快。

1324
01:23:58,760 --> 01:24:05,079
就像，我们有这个名为Immutables的库，但是Java 17中有一个名为Records的新功能，我们可以用来替换它。

1325
01:24:05,619 --> 01:24:16,239
在Java 21中，有一个新的二进制访问层对本机库，对于我们而言，使用Java 21来引入任意库应该不那么容易。

1326
01:24:17,159 --> 01:24:18,279
在Java 17中不存在。

1327
01:24:18,619 --> 01:24:19,960
因此，它只是解锁了新功能。

1328
01:24:20,760 --> 01:24:21,680
这是，这就是

1329
01:24:22,099 --> 01:24:24,920
当人们谈论骨化EVM时，

1330
01:24:26,539 --> 01:24:28,699
你知道，爪哇一直在做虚拟机

1331
01:24:28,699 --> 01:24:29,619
自20世纪以来。

1332
01:24:30,579 --> 01:24:31,819
EVM是另一台虚拟机。

1333
01:24:32,000 --> 01:24:33,500
我喜欢尝试应用一些课程

1334
01:24:33,500 --> 01:24:34,739
还有一些最佳实践

1335
01:24:34,739 --> 01:24:36,399
并避免一些最糟糕的做法。

1336
01:24:36,659 --> 01:24:38,380
你知道，我们已经看到爪哇犯了错误。

1337
01:24:38,920 --> 01:24:41,239
因此，我们主要避免了EVM中的一些。

1338
01:24:41,800 --> 01:24:44,479
但是它在EVM中采用了其中一些最佳实践。

1339
01:24:44,479 --> 01:24:48,139
其中之一，我们没有时间在这次演讲中进行研究，

1340
01:24:48,139 --> 01:24:52,659
我热衷于EVM对象格式之一。

1341
01:24:52,659 --> 01:24:55,819
这会做一个简单的更改，这是获得EVM代码的，

1342
01:24:55,819 --> 01:24:57,679
为其写一个容器格式，

1343
01:24:57,679 --> 01:25:01,359
为了支持该容器格式的最小变化是否最小。

1344
01:25:01,359 --> 01:25:05,419
这为我们提供了方式，因此第2层可以在EVM中兼容实验，

1345
01:25:05,419 --> 01:25:09,299
表明他们正在实验，并做令人兴奋的事情。

1346
01:25:09,299 --> 01:25:14,359
它基本上使核心EVM保持不变，它只是在其周围放置一个包装。

1347
01:25:14,359 --> 01:25:16,819
这就是JVM使用其班级格式所做的。

1348
01:25:17,019 --> 01:25:18,979
它总是有一个用于班级格式的容器。

1349
01:25:19,479 --> 01:25:24,880
它在其类文件中放置了信号，上面写着，嘿，我被Java 7编译了。

1350
01:25:25,259 --> 01:25:26,179
你能支持我吗？

1351
01:25:26,460 --> 01:25:27,739
我被Java 8编译了。

1352
01:25:27,859 --> 01:25:28,639
你能支持我吗？

1353
01:25:29,579 --> 01:25:39,479
从字面上看，它已经编写了，有代码一直在Java 1.0中一直编写，并且在JVM中仍在运行和执行的Beta中。

1354
01:25:39,739 --> 01:25:43,679
因为执行会看到它并执行它。

1355
01:25:43,680 --> 01:25:54,800
现在，有些使我们陷入困境的事情，以及为什么我不一定想在EVM中这样做以像Java一样大，厚实的历史，这是有些事情永远的。

1356
01:25:54,920 --> 01:25:57,220
那里有代码无法摆脱。

1357
01:25:57,980 --> 01:26:01,860
因此，您知道，每次您执行艰苦的分叉时，我们都不总是能做一个新版本。

1358
01:26:01,980 --> 01:26:05,119
这不一定是可行的容器版本。

1359
01:26:07,039 --> 01:26:10,360
但这也是他们介绍了一些比所需的要复杂得多的事情。

1360
01:26:10,359 --> 01:26:16,839
我认为，某些Java东西的复杂性证明了为什么保持EVM中的事情很重要。

1361
01:26:17,880 --> 01:26:21,259
因为，您知道，曾经有这样的说法，哦​​，Mac永远不会感染病毒。

1362
01:26:21,460 --> 01:26:22,239
他们永远不会得到特洛伊木马。

1363
01:26:23,000 --> 01:26:29,659
其中一些错误违反了Java VM的规格。

1364
01:26:30,239 --> 01:26:34,179
但是Java实现，您可以做一些事情来混淆那里的类型检查。

1365
01:26:34,199 --> 01:26:37,099
您可以逃脱，您可以做一些事情来逃脱沙箱。

1366
01:26:37,100 --> 01:26:43,920
因此，从Java Applet中，系统系统配置为仅安装和运行，您可以在系统上安装特洛伊木马。

1367
01:26:44,079 --> 01:26:46,700
人们，他们的Mac会因为正在运行Java小程序而获得所有。

1368
01:26:47,380 --> 01:26:51,320
您会注意到Java小程序不再存在。 Flash不再存在。

1369
01:26:51,900 --> 01:27:00,500
作为一个类别，可以从大多数系统中删除了可以完成系统级别的事情。

1370
01:27:00,760 --> 01:27:04,520
因此，这就是为什么我在系统合同中的演讲非常有限。

1371
01:27:04,520 --> 01:27:06,220
而且您需要小心安全性

1372
01:27:06,220 --> 01:27:08,260
因为有侵犯的东西

1373
01:27:08,260 --> 01:27:08,920
因此。

1374
01:27:12,880 --> 01:27:14,560
非常感谢您。

1375
01:27:14,660 --> 01:27:19,820
从您的OG高级Java角度来看，这非常有趣

1376
01:27:19,820 --> 01:27:24,180
和通往EVM的桥，LTS发布。

1377
01:27:24,360 --> 01:27:24,760
这很有趣。

1378
01:27:24,860 --> 01:27:25,340
太感谢了。

1379
01:27:27,180 --> 01:27:31,160
在总结不和谐之前，我们在这里还有一个问题。

1380
01:27:31,900 --> 01:27:34,440
捍卫加斯科的过程是什么？

1381
01:27:34,520 --> 01:27:35,160
用于预编译。

1382
01:27:35,260 --> 01:27:37,820
所以你提到你总是对抗

1383
01:27:37,820 --> 01:27:42,140
定价编译的最坏情况。

1384
01:27:42,380 --> 01:27:47,740
我们甚至如何达到这个气价？

1385
01:27:48,200 --> 01:27:49,480
这是一个很好的问题。

1386
01:27:50,980 --> 01:27:52,860
这些年来发生了变化。

1387
01:27:53,940 --> 01:27:57,340
但最终，您想出了一些实现

1388
01:27:57,340 --> 01:27:58,300
在各种客户上。

1389
01:27:58,960 --> 01:28:00,280
您确保客户实施它。

1390
01:28:00,740 --> 01:28:02,580
而且您将有一个客户将成为领导者，

1391
01:28:02,579 --> 01:28:04,640
他们将获得对天然气的估计。

1392
01:28:05,180 --> 01:28:07,180
但是您要做的就是将获得所有典型的

1393
01:28:07,180 --> 01:28:08,119
和最坏的用法，

1394
01:28:08,239 --> 01:28:09,220
而且您将使它们紧密地循环。

1395
01:28:09,680 --> 01:28:11,920
您会弄清楚多少基准，

1396
01:28:12,239 --> 01:28:13,640
你知道，壁钟时间

1397
01:28:13,640 --> 01:28:17,680
要执行这些编译器，这些预编译。

1398
01:28:18,399 --> 01:28:19,979
因此，您将弄清楚实际的实际

1399
01:28:19,979 --> 01:28:22,420
这些执行的壁时钟时间是。

1400
01:28:22,939 --> 01:28:25,420
您可以将其与系统上的基准进行比较

1401
01:28:25,420 --> 01:28:27,340
进行比较。

1402
01:28:27,960 --> 01:28:29,760
但是我认为最有效的方法之一

1403
01:28:29,760 --> 01:28:31,260
发生了，这是为了

1404
01:28:31,260 --> 01:28:37,220
mod exp，当他们合理化价格时，他们只是每秒挑选一个巨型汽油

1405
01:28:37,220 --> 01:28:40,920
标准它应该在空中执行。我认为当时是30或35岁，

1406
01:28:41,659 --> 01:28:46,159
也许是25岁。多年来，这个数字增加了。我认为25是最初的目标。

1407
01:28:46,720 --> 01:28:53,380
我认为BLS是针对35个Mega Gas作为目标进行计算的。因此，如果您进行此预编译，

1408
01:28:53,380 --> 01:28:57,640
您以紧密的循环执行它，给它一个最糟糕的答案，它将燃烧

1409
01:28:57,640 --> 01:29:02,119
每秒3500万天气。因此，前提是您能做的最糟糕的事情

1410
01:29:02,680 --> 01:29:10,119
就是这样做。目的是实现这一目标，以便Kachak拥有最糟糕的解决方案。

1411
01:29:10,780 --> 01:29:15,420
因此，我的意思是，如果我们要这样做，我们正在谈论基于旧数字的重新定位BLS，

1412
01:29:15,660 --> 01:29:19,800
因为从那以后，每个人在VM上的表现都在上升。所以我们可能会去

1413
01:29:19,800 --> 01:29:26,380
看看一个新的数字，我不知道它是否将是40或60或80兆瓦。但这意味着

1414
01:29:26,380 --> 01:29:29,680
不幸的是，预编译的成本必然会增加。

1415
01:29:30,539 --> 01:29:35,500
但是，目的是确保如果他们将其用作拒绝服务的攻击，

1416
01:29:35,600 --> 01:29:39,760
这不是在以太坊引起拒绝服务攻击的最有效方法。

1417
01:29:40,119 --> 01:29:46,260
它将花费您的天然气钱，并且将会有更有效的操作使其放慢速度。

1418
01:29:46,960 --> 01:29:51,819
而且我知道基地有很多谈话，他们有一个成为gigagas的梦想，

1419
01:29:51,819 --> 01:29:55,239
这将是激烈的战斗之一

1420
01:29:55,239 --> 01:29:56,899
是要弄清楚如何处理预编译。

1421
01:29:57,699 --> 01:29:59,259
但是我认为与吉加斯的战斗

1422
01:29:59,259 --> 01:30:01,479
将被诸如并发之类的工具征服

1423
01:30:01,479 --> 01:30:05,119
要解决它，而不仅仅是并行化。

1424
01:30:05,579 --> 01:30:07,319
我认为有很多并发想法

1425
01:30:07,319 --> 01:30:08,239
需要带进来

1426
01:30:08,239 --> 01:30:10,059
在操作系统中众所周知

1427
01:30:10,059 --> 01:30:11,960
我们只需要带入EVM

1428
01:30:11,960 --> 01:30:14,579
建造我们的链

1429
01:30:14,579 --> 01:30:16,899
这样我们就可以以并发的方式执行

1430
01:30:16,899 --> 01:30:18,639
块并同时构建块

1431
01:30:18,640 --> 01:30:37,640
这样我们就可以在Giga气体数量上获得，因为没有一个Pre汇编在Giga气体水平上执行。他们全部，他们都有各种各样的您知道其中一些人所知道的，就像您知道的数百种巨型汽油一样，其中有些人并不是这样，这就像击中可靠的Giga Gas的障碍之一一样。

1432
01:30:37,640 --> 01:30:40,940
那很有趣。

1433
01:30:40,940 --> 01:30:43,180
非常感谢，达诺。

1434
01:30:43,180 --> 01:30:50,020
我没有意识到价格可能有问题，我的意思是，巨大的问题

1435
01:30:50,020 --> 01:30:55,039
甚至有足够的客户能够处理这些Giga气体号码，但这是

1436
01:30:55,039 --> 01:30:56,380
非常有趣的见解。

1437
01:30:56,380 --> 01:30:58,060
是的，非常感谢。

1438
01:30:58,060 --> 01:30:59,200
是的，我们没有时间。

1439
01:30:59,200 --> 01:31:01,560
我认为我们可以在这里总结。

1440
01:31:01,560 --> 01:31:03,600
但这真的很棒。

1441
01:31:03,600 --> 01:31:04,600
非常感谢，达诺。

1442
01:31:04,600 --> 01:31:06,840
非常感谢。

1443
01:31:06,840 --> 01:31:12,680
今天肯定学到了很多东西，那一直是一个很棒的旅程

1444
01:31:13,960 --> 01:31:21,000
非常感谢您今天加入我们的加入，非常感谢，谢谢Dano和

1445
01:31:21,000 --> 01:31:28,039
每个人都在观看，我们将在周三见到您，参加我们与Francesco的最后一项研究曲目

1446
01:31:28,039 --> 01:31:32,000
在一些共识升级上。

1447
01:31:34,000 --> 01:31:34,659
谢谢大家。

1448
01:31:35,640 --> 01:31:36,960
非常感谢。祝你有美好的一天。

