1
00:00:30,000 --> 00:00:59,980
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:59,979
我爱你。

10
00:03:00,000 --> 00:03:29,979
谢谢。

11
00:03:30,000 --> 00:03:42,719
好的，欢迎所有人回到另一个以太坊协议奖学金研究小组

12
00:03:42,719 --> 00:03:50,659
这是研究轨道的第九周，我们在这里与Piper Miriam长期EF

13
00:03:50,659 --> 00:03:59,920
成员和他将在这里谈论今天有些过期的事情，所以所有的事情都清除了

14
00:03:59,919 --> 00:04:05,359
因此，我将把它传递给马里奥，他会给派珀提供更多适当的介绍。

15
00:04:07,019 --> 00:04:09,560
乔什非常感谢，谢谢派珀（Piper）在这里。

16
00:04:10,319 --> 00:04:14,399
正如乔什（Josh）所说的那样，派珀（Piper

17
00:04:14,599 --> 00:04:17,779
因此，很难快速总结他的工作。

18
00:04:17,779 --> 00:04:25,819
但是我相信，他一直在2015年，2016年，为以太坊的各种核心项目做出了贡献，

19
00:04:25,819 --> 00:04:27,439
Python生态系统。

20
00:04:27,439 --> 00:04:30,939
因此，如果您曾经使用过Web3py，Viper之类的东西

21
00:04:30,939 --> 00:04:32,779
或多年来，

22
00:04:32,779 --> 00:04:35,639
人们一直在研究实际

23
00:04:35,639 --> 00:04:38,899
Python客户实施3D，

24
00:04:38,899 --> 00:04:40,899
我们已经在

25
00:04:43,959 --> 00:04:45,060
一周，

26
00:04:46,060 --> 00:04:49,240
Python规格的第六周。

27
00:04:49,240 --> 00:04:51,319
是的，

28
00:04:51,319 --> 00:04:53,959
派珀只是给了我更多时间介绍它，

29
00:04:53,959 --> 00:04:54,800
那太棒了。

30
00:04:55,819 --> 00:05:01,659
派珀也是一个随机的有趣事实。派珀一直是最早的人之一

31
00:05:01,659 --> 00:05:07,579
也许是以太坊上的第一个或第二个实际演示，

32
00:05:07,579 --> 00:05:11,420
如果您想这样称呼它，则是NFTS的发明者。

33
00:05:12,779 --> 00:05:17,500
是的，所以在Python生态系统工作并为各种专业项目做出贡献之后，

34
00:05:17,500 --> 00:05:26,800
我相信三年前，他开始了门户网络的研究和开发，该网络是

35
00:05:26,800 --> 00:05:31,399
将是当今主要主题之一，因为门户网站是替代解决方案之一

36
00:05:31,399 --> 00:05:34,899
对于历史提供商。

37
00:05:34,899 --> 00:05:41,040
派珀非常感谢您在这里。

38
00:05:41,040 --> 00:05:43,319
在这里有这样的狂欢是一种荣幸。

39
00:05:43,319 --> 00:05:48,759
更重要的是，是的，Piper是最初称为CDAP的创造者，并成为BPF。

40
00:05:48,759 --> 00:05:54,120
实际上，他也是整个计划的父亲。研究组是

41
00:05:58,199 --> 00:06:03,719
协议奖学金的衍生，确实是由Piper在这里开始的。所以这是一种荣誉

42
00:06:03,719 --> 00:06:08,920
再次在这里。我不得不说，到目前为止，我最喜欢的演示格式，实际的白色

43
00:06:08,920 --> 00:06:21,400
工作，这是不可思议的。所以，派珀，继续前进。你好。音频好吗？每个人都能听到我的声音吗？

44
00:06:22,120 --> 00:06:28,680
凉爽的。好的。因此，我开始制作一些幻灯片，然后我开始感觉像忙碌的工作，

45
00:06:29,879 --> 00:06:35,560
图表以太坊数据结构以及事物和幻灯片。感觉很无聊。

46
00:06:35,560 --> 00:06:39,720
我希望这种格式最终起作用。我们要找出答案。

47
00:06:43,319 --> 00:06:54,360
我们去。因此，这有点像清除。因此，清除是其中之一

48
00:06:54,360 --> 00:06:59,480
维塔利克（Vitalik

49
00:06:59,480 --> 00:07:08,180
以太坊进行的研究轨道。清除本身是专门针对的，

50
00:07:09,200 --> 00:07:13,140
我的幻灯片中呕吐到厕所里有这张精美的照片，因为它是

51
00:07:13,140 --> 00:07:19,500
我们只是试图从我们的协议中获取一些东西，具体取决于多样的话

52
00:07:19,500 --> 00:07:25,540
您想使用，它们只是关于如何设计协议的错误

53
00:07:25,540 --> 00:07:28,920
以及我们想清理的东西

54
00:07:28,920 --> 00:07:30,840
因为他们没有工作，所以他们错了，

55
00:07:31,060 --> 00:07:34,080
他们从根本上限制了我们做事。

56
00:07:35,120 --> 00:07:37,000
我开始绘制一些形状

57
00:07:37,000 --> 00:07:40,500
以太坊数据结构的外观

58
00:07:40,500 --> 00:07:45,000
但是我实际上想进一步备份。

59
00:07:46,240 --> 00:07:49,900
有一个EPF，其中之一，我想大概一个星期，

60
00:07:50,000 --> 00:07:51,600
两个星期，几周前关于Verkle。

61
00:07:51,600 --> 00:08:05,760
嗯，所有这些东西都以一些非常内在的方式将其链接在一起，但是其中一种链接在一起，但是我想像在这种垂直的背景下一样开始，并努力前进。

62
00:08:06,560 --> 00:08:16,520
所以，嗯，我没有在这里绘制完整的结构，就像你知道的那样，以太坊区块链数据结构的内容。

63
00:08:16,519 --> 00:08:24,699
但是我想谈谈块执行以及块执行期间发生的情况。

64
00:08:26,079 --> 00:08:31,519
一个街区充满了这一系列...

65
00:08:32,500 --> 00:08:38,899
您有一个障碍，其中是一系列交易。

66
00:08:40,059 --> 00:08:42,519
这些交易中的每一项都在一个块中执行。

67
00:08:42,519 --> 00:08:47,960
当我们踏上这些交易中的每一笔交易时，它可能有一些喜欢的数据

68
00:08:47,960 --> 00:08:55,399
通过它，我们呼叫呼叫数据，该呼叫数据被送入EVM uh交易

69
00:08:55,399 --> 00:09:00,679
参数类似于发送的地址来决定是否执行合同和

70
00:09:00,679 --> 00:09:05,519
大多数交易都有很多简单的价值转移，而这些交易确实触摸了

71
00:09:05,519 --> 00:09:11,000
州但大多数交易是合同，因此他们开始挖掘到以太坊状态

72
00:09:11,000 --> 00:09:21,960
以及以太坊状态，儿童垃圾和我地板上的图纸，以太坊状态是默克尔·帕特里夏（Merkle Patricia）树。

73
00:09:23,039 --> 00:09:34,080
您可以通过各种方式来绘制这些图表，并且在白板上对它们进行真实的图表是一种巨大的痛苦，因为它们在每个层面上都有16个分支，而且要画很多。

74
00:09:34,080 --> 00:09:43,520
因此，在这里的任何图表中，我经常会画出看起来像二进制树的东西，但实际上，将每个东西都视为拥有16个分支。

75
00:09:44,540 --> 00:09:49,060
以太坊状态就像大型怪物数据集一样。

76
00:09:50,420 --> 00:09:58,200
我们称其为Merkle Patricia树，在我们称为状态根的该值下，它在每个块上固定在每个块上。

77
00:09:58,200 --> 00:10:06,500
在状态根下是一棵节点树，最终找到了他们在这里获得帐户的底部的方式。

78
00:10:08,600 --> 00:10:15,440
在这些帐户中的每个帐户中，有时它们是外部拥有的帐户，并且它们没有内置的国家概念。

79
00:10:15,480 --> 00:10:19,140
但是，当它们是合同时，它们中的每一个都有一个状态。

80
00:10:20,100 --> 00:10:25,820
这些都悬挂在底部。

81
00:10:25,820 --> 00:10:35,000
好的，当我们进入块执行时，有一组交易，对吗？

82
00:10:35,240 --> 00:10:42,840
每个块都有一个气体限制，并且气体极限和默克尔 - 帕特里亚树和Verkle都捆绑在一起。

83
00:10:44,000 --> 00:10:53,000
因此，以太坊客户端拥有此功能 - 因此我们进入了块执行，该代码表示​​访问SIM状态，访问SIM状态，

84
00:10:53,000 --> 00:11:00,360
我们必须到达这棵巨大的树，如今它有数万亿个价值观，

85
00:11:00,399 --> 00:11:09,559
绝对是数十亿美元。这是一个很大的数据。为了做阻止

86
00:11:09,559 --> 00:11:15,779
执行，您实际上在做的事情是随机访问这件事，这是一个很大的

87
00:11:15,779 --> 00:11:26,839
丑陋的数据集。因此，Merkle-Patricia树的一些早期实现始于我

88
00:11:26,839 --> 00:11:32,100
通常称呼天真的方法。这是一种简单的方法，就像真实的

89
00:11:32,100 --> 00:11:37,379
一块软件，那就是他们用所有这些节点存储了所有内容

90
00:11:37,379 --> 00:11:42,480
在树上。如果您想在这里到这里，客户必须做的是必须走路

91
00:11:42,480 --> 00:11:47,840
通过其数据库在这里。现在，这些天，数据集足够大，以至于

92
00:11:47,840 --> 00:11:52,620
帐户，您必须深入七层。因此，您在这里读了七种磁盘。

93
00:11:52,940 --> 00:11:58,759
然后，当我们开始进入智能合同存储等等时，您甚至要去

94
00:11:58,759 --> 00:12:04,820
进一步进入这些树。因此，以太坊客户的早期瓶颈之一是

95
00:12:04,820 --> 00:12:08,600
此访问模式。

96
00:12:08,600 --> 00:12:10,780
因此仅此访问模式

97
00:12:10,780 --> 00:12:13,740
必须向下逐步穿过每个树节点

98
00:12:13,740 --> 00:12:16,680
当你去的时候很重，对吗？

99
00:12:16,820 --> 00:12:18,280
磁盘访问非常快。

100
00:12:19,440 --> 00:12:21,740
您知道，客户正在使用级别DB之类的东西

101
00:12:21,740 --> 00:12:22,840
然后有些人弄清楚

102
00:12:22,840 --> 00:12:25,060
岩石DB可能会更快一些。

103
00:12:25,300 --> 00:12:25,940
我不确定

104
00:12:25,940 --> 00:12:27,879
如果这几天实际上是正确的，

105
00:12:27,960 --> 00:12:29,060
但是无论哪种方式

106
00:12:29,080 --> 00:12:31,360
他们正在使用这些非常快速的钥匙值商店，

107
00:12:31,360 --> 00:12:39,820
高速SSD，甚至在那里，以太坊客户执行块的瓶颈是

108
00:12:39,820 --> 00:12:47,720
他们可以访问这些东西的比率。如此快进了几年的艰苦工程

109
00:12:47,720 --> 00:12:56,519
工作，而您得到的是您获得了这些数据的新模型。所以这就像一个O，

110
00:12:56,519 --> 00:13:03,639
我不会完全正确，但这是类似o log in incess访问的东西

111
00:13:03,639 --> 00:13:12,460
图案在这里，好吗？这很昂贵。就某些事情而言，它很便宜，但最终是

112
00:13:12,460 --> 00:13:17,699
昂贵，对吗？您在这里的某些平均情况中谈论，挖掘

113
00:13:17,699 --> 00:13:25,460
七到10层的树数据可以进入事物。所以这就是瓶颈。这是

114
00:13:25,460 --> 00:13:33,340
吞吐量。因此，客户团队做了大量的工程工作，他们构建了我们所谓的工作，

115
00:13:33,440 --> 00:13:41,820
我想，平面数据库设计仅访问O1，这意味着对于此键

116
00:13:41,820 --> 00:13:46,820
数据集，他们通常可以直接去，好吗？我不会准确地进入

117
00:13:46,820 --> 00:13:52,420
该设计如何产生或实施方式的细节。去阅读一些客户端代码，

118
00:13:52,419 --> 00:13:56,139
去询问一些客户开发人员。他们可以与您谈谈。这不是这个谈话的重点。

119
00:13:58,659 --> 00:14:03,699
因此，这种O1访问模式打开了很多吞吐量，对吗？所以在此之前，

120
00:14:03,839 --> 00:14:09,379
在这种访问模式中的o登录登录中，客户端被瓶颈。这有效

121
00:14:09,379 --> 00:14:16,899
决定整体块气体限制，好吗？气体极限有点像以太坊缩放

122
00:14:16,899 --> 00:14:23,139
号码，对吗？我们永远不会像Mastercard Visa交易来通过提高投票

123
00:14:23,139 --> 00:14:30,360
气体限制，但气体限制确实决定了基本链的价值数量

124
00:14:30,360 --> 00:14:37,279
可以做。因此，因此，我们从这种访问模式登录，登录的访问模式中找到了一种从中获取的方法

125
00:14:37,279 --> 00:14:44,899
要喜欢一个，一个非常好，哦，一个。这东西给以太坊客户有点速度

126
00:14:44,899 --> 00:14:53,919
提高他们可以执行块的速度。但是即使仍然如此，最终还是

127
00:14:53,919 --> 00:15:00,199
据我所知，以太坊的客户实际上在磁盘上有效地瓶颈。因为

128
00:15:00,199 --> 00:15:06,299
即使转到此O1访问模式，块内也有大量的状态访问

129
00:15:06,299 --> 00:15:12,259
执行。状态访问是非常随机的访问，状态本身非常

130
00:15:12,259 --> 00:15:23,360
很大。所以我们想做的事，所以我们想做的就是说，好吧，也许我们可以

131
00:15:23,360 --> 00:15:28,139
做这个无状态的事情。这么多年前，我们都聚集在一起，开始研究什么，

132
00:15:28,240 --> 00:15:33,740
您知道，无国籍以太坊看起来像。最终，是什么主要瓶颈

133
00:15:33,740 --> 00:15:41,059
是默克尔 - 帕特里亚树。因此，默克尔 - 帕特里亚树本身最终成为

134
00:15:41,059 --> 00:15:47,879
这有点阻止了我们能够从这种最好的事情中脱离

135
00:15:47,879 --> 00:15:51,519
我们可以在客户设计方面做到他们在本地存储的所有国家，他们已经

136
00:15:51,519 --> 00:15:57,099
明白了，他们拥有这种不错的O1访问模式。但是即使在那里，那是

137
00:15:57,099 --> 00:16:03,019
瓶颈让我们走得更快，这个想法是见证人。因此见证是所有的证明

138
00:16:03,019 --> 00:16:07,839
块访问的状态。而不是需要读取所有状态的客户

139
00:16:07,840 --> 00:16:16,519
它是磁盘，它可以得到它，并将其用作uh的状态数据

140
00:16:16,519 --> 00:16:24,280
执行一个块，问题是Merka Patricia树UH确实有效率低下的证据

141
00:16:25,000 --> 00:16:30,660
嗯，实际上，它甚至有点像可攻击的证据，例如最坏的案例证明大小

142
00:16:30,660 --> 00:16:34,940
想一想当我们查看这些数字时，我正在从相当深刻的记忆中拉出东西，所以

143
00:16:34,940 --> 00:16:36,980
因此，将所有这些用一粒盐拿走。

144
00:16:38,240 --> 00:16:45,340
但是用默克尔 - 帕特里亚树做证据，这意味着有可能在数十个兆字节中的证据。

145
00:16:45,340 --> 00:16:55,460
原因是分支因子为16，即在默克尔·帕特里夏树（Merkle Patricia Tree）的每个级别，如果您想向任何人提供证明，则必须对此进行分支。

146
00:16:56,060 --> 00:17:05,160
您必须包括所有这些，例如，可能是15个兄弟姐妹节点元素，以便为执行数据提供完整的证明。

147
00:17:05,579 --> 00:17:08,860
因此，这就是Verkle的来源。

148
00:17:08,859 --> 00:17:24,859
处女座来自我们需要一种不同的树设计，该设计具有更简洁的形状，以便我们实际上可以在分发证明的情况下完成整个无状态的事情。

149
00:17:24,859 --> 00:17:50,019
好的。在进入无国籍以太坊的过程中，我们发现的是，我们想清理很多东西，对吗？获得证据就像是其中的一部分，在那里我们拥有如此巨大的效率，这种大的技术债务，我们选择使用的旧事物，对吗？

150
00:17:50,019 --> 00:17:51,440
奇迹帕特里夏树很棒。

151
00:17:51,579 --> 00:17:53,960
在以太坊建造时，您知道，就像

152
00:17:54,460 --> 00:17:55,559
virkle树不存在。

153
00:17:55,700 --> 00:17:59,240
还没有人提出。

154
00:18:01,019 --> 00:18:05,279
但是随着我们的进一步，我们意识到有一些我们想要的东西

155
00:18:05,279 --> 00:18:07,539
那奇迹帕特里夏树阻止了我们。

156
00:18:07,740 --> 00:18:10,819
因此，Virkle是我们努力解锁的这些事情之一。

157
00:18:13,359 --> 00:18:17,259
Virkle也许是解锁我们想要的一件事的东西，

158
00:18:17,400 --> 00:18:18,139
无状态，好吗？

159
00:18:18,140 --> 00:18:27,759
现在，那是一件。因此，我想看的是我们想要解锁的其他一些作品，以及我们试图摆脱的一些东西。

160
00:18:27,759 --> 00:18:34,120
因此，我将删除其中一些杂乱无章的位。

161
00:18:34,119 --> 00:18:47,559
好的。

162
00:18:48,439 --> 00:18:59,579
因此，在Vitalik的图片中，路线图的图像，我们最终看了许多事情。

163
00:18:59,579 --> 00:19:11,899
因此，随着时间的流逝，我们结束了，或者以太坊的最初设计具有一大堆随着时间的线性生长的东西。

164
00:19:11,900 --> 00:19:35,120
尽管它们不一定是从根本上杀死以太坊或使以太坊节点只是停止工作，但他们已经表明，我们发现它们在我们的协议设计中有点问题，因为它们是有问题的给我们这些只是不断成长的东西。

165
00:19:35,580 --> 00:19:38,620
因此，简单的只是块，对吗？

166
00:19:38,619 --> 00:19:47,179
在很长一段时间内，我们最终得到了什么，这是什么，大约有1900万个街区

167
00:19:47,179 --> 00:19:55,979
今天大约这个数字。因此，有1900万块事物的悠久历史。

168
00:19:57,219 --> 00:20:03,639
事实证明，实际上，客户实际上只需要那些东西

169
00:20:03,739 --> 00:20:08,459
就像，在这里朝前部，以及深，深，深，深，深，

170
00:20:08,460 --> 00:20:21,180
深层历史对于协议的日常运作并不重要。

171
00:20:22,420 --> 00:20:29,120
实际上，随着信标链的出现，深厚的历史甚至不是你

172
00:20:29,120 --> 00:20:35,259
实际上，由于整个信标连锁主观性作品，您可以合理地遵循

173
00:20:35,259 --> 00:20:41,980
实际上需要跳到链的前部，所以要跟踪事物，所以其中之一

174
00:20:41,980 --> 00:20:46,539
这是正在努力的，它可能像是头脑的前面，也是最简单的

175
00:20:46,539 --> 00:20:54,299
我们称之为四个四分之一的好工作，可以点亮客户端以抢夺eip号码

176
00:20:54,299 --> 00:21:00,700
在这里真的很容易记住，所以四个四分之一是我们的eips之一，建议是

177
00:21:00,700 --> 00:21:07,180
客户开始放弃他们的深刻历史，客户开始摆脱深刻的历史

178
00:21:07,180 --> 00:21:14,460
在所有标题和块中，以及这样的一切。现在事实证明

179
00:21:14,460 --> 00:21:22,059
对于我们来说，弄清楚该怎么做是一件艰难的事情，因为这些数据在哪里

180
00:21:22,059 --> 00:21:27,900
来自，客户如何同步到链的前部，对，如果我们输了

181
00:21:27,900 --> 00:21:34,220
数据是人们喜欢说嗯的事情之一，我实际上认为如果我们丢失数据是什么

182
00:21:34,220 --> 00:21:41,660
可能是最不有趣的人，因为我相信我们失去的机会

183
00:21:42,380 --> 00:21:49,900
以太坊的历史接近零，有太多的人因此而做事

184
00:21:49,900 --> 00:21:54,700
我们要丢失它的技术，但重要的是要说像人们要去哪里

185
00:21:54,700 --> 00:21:57,819
能够可靠地获得这种事情。

186
00:21:58,860 --> 00:22:03,259
因此4-4S是技术债务清理之一

187
00:22:03,259 --> 00:22:04,259
我们正在努力做

188
00:22:04,360 --> 00:22:06,160
这就是说客户自己

189
00:22:06,160 --> 00:22:07,759
不需要保持这么深刻的历史。

190
00:22:08,920 --> 00:22:12,620
我们会像以后的某些工作一样进入某种程度上，

191
00:22:12,940 --> 00:22:15,400
但是我相信有一些

192
00:22:15,400 --> 00:22:17,100
就像这里发生的三种方法一样。

193
00:22:18,160 --> 00:22:23,180
我认为Aragon正在研究基于洪流的解决方案。

194
00:22:23,180 --> 00:22:26,560
因此，阿拉贡喜欢做自己的方式。

195
00:22:27,799 --> 00:22:34,720
至少Aragon，我没有在这次演讲之前立即仔细检查所有这些，但至少在历史上，

196
00:22:34,940 --> 00:22:39,440
他们一直在考虑使用Bittorrent协议来弄清楚如何同步这些内容。

197
00:22:40,380 --> 00:22:46,400
还有另一个称为ARA1文件的解决方案，它像平面文件格式一样。

198
00:22:46,720 --> 00:22:50,080
这两件事彼此非常兼容。

199
00:22:50,079 --> 00:22:55,779
我不知道Aragorn在他们的洪流中使用了哪种格式，但是如果它像错误文件，我不会感到惊讶。

200
00:22:56,839 --> 00:23:07,919
因此，error1文件只是客户端至少能够摄入旧深块数据的文件格式，这只是我们要做的档案格式。

201
00:23:08,299 --> 00:23:17,119
它们具有一些不错的特性，这些属性基本上只是可​​以随机访问它们的能力，以便能够直接读取并获得所需的任何封锁。

202
00:23:17,119 --> 00:23:30,179
然后，门户是我一直在开创和建造的现场直播，按需解决方案。

203
00:23:30,919 --> 00:23:37,119
这是我的孩子。这是我的项目。还有很多其他人在研究它。我没有为此获得所有的荣誉。

204
00:23:37,259 --> 00:23:44,759
但是门户网站是一种用于以太坊数据的存储和检索的对等分散的网络和协议。

205
00:23:44,759 --> 00:24:06,180
因此，历史是我们追溯到的第一个数据集。在过去的几周中，我们实际上已经挤压了我们需要挤压的适当错误，以使事情真正有效。我们基本上开始积极地接近生态系统，并说，嘿，我们已经准备好让你们从我们那里获取这些历史数据。

206
00:24:06,180 --> 00:24:16,480
因此，四四个只是我们要做的清除中的一件事情，它正在清除所有旧的历史数据。

207
00:24:18,860 --> 00:24:25,400
如果我要努力摆脱协议，请原谅我。

208
00:24:26,140 --> 00:24:32,700
我并没有太努力地尝试构建一个很好的干净叙述，我们可以在这些过程中浏览这些东西。

209
00:24:32,700 --> 00:24:39,660
嗯，他们都非常依恋，就像核心协议件一样，但它们是一个

210
00:24:39,660 --> 00:24:46,940
在我们正在做的事情方面，一点点遍布另一件事

211
00:24:46,940 --> 00:24:52,460
我们正在努力摆脱协议的是此称为自我毁灭的OP代码

212
00:24:52,460 --> 00:25:04,880
嗯，当前和历史形式的自我毁灭都清除了合同的存储数据

213
00:25:04,880 --> 00:25:13,700
嗯，最初有这个合同能够能够的概念似乎是一个很好的主意

214
00:25:13,700 --> 00:25:22,519
决定删除自己。嗯，当我们看时，当我们看状态树之类的东西时

215
00:25:22,519 --> 00:25:28,240
而且它是正确的，所有这些事情都将其悬挂在一起，然后您签订了合同

216
00:25:28,240 --> 00:25:33,380
然后，这里的合同中有几件事，您知道在其中存储了几件事。

217
00:25:33,580 --> 00:25:39,840
这个想法是，当该合同决定自我毁灭时，所有这些都应该消失。

218
00:25:39,839 --> 00:25:48,799
好吧，这很好，所有这些都是针对以太坊设计的一些原始设计。

219
00:25:48,799 --> 00:25:52,439
为了理解这一点，我们研究了状态树的设计。

220
00:25:52,439 --> 00:26:01,679
因此，状态树拥有所有这些，它具有整个树的分支结构，您可以在这里到达，实际上并不是这样。

221
00:26:01,680 --> 00:26:16,820
状态树确实在这里只有一个帐户，并且是帐户存储的状态根，以及其他几个领域，例如结，平衡等。

222
00:26:17,380 --> 00:26:26,460
事实证明，这是代表合同存储的状态树中唯一的东西。

223
00:26:26,460 --> 00:26:42,340
现在，该合同存储必须居住在某个地方，对吗？它的所有这些数据都挂在其下面。但这不是其中的。它不在这条状态树内。它只有此参考。

224
00:26:42,339 --> 00:26:52,480
当您去实施以太坊协议和今天存在的MPG时，您会意识到有几个事情。

225
00:26:52,619 --> 00:26:56,879
因此，这里有另一个称为代码哈希，对吗？

226
00:26:57,059 --> 00:27:04,679
您知道，合同本身，帐户很大，其中一些人喜欢大型的大型代码流。

227
00:27:04,959 --> 00:27:09,539
该代码实际上并未存储在状态树中。

228
00:27:09,539 --> 00:27:13,579
仅从此代码哈希（Hash）中引用它，

229
00:27:13,779 --> 00:27:17,759
类似于状态根的方式仅不透明引用

230
00:27:17,759 --> 00:27:19,539
在这里通过这个哈希。

231
00:27:20,879 --> 00:27:22,759
在实施级别，

232
00:27:22,920 --> 00:27:25,119
实际上，我们必须将代码存储在某个地方

233
00:27:25,119 --> 00:27:30,839
因为当我们在帐户中执行代码时，

234
00:27:31,200 --> 00:27:33,700
EVM需要该代码阅读，

235
00:27:33,799 --> 00:27:35,920
这意味着客户实施

236
00:27:35,920 --> 00:27:36,920
必须将其存储在某个地方。

237
00:27:36,920 --> 00:27:50,600
但这并不是在这些地方都被引用的任何地方，因此客户必须将其实际存储在某个地方。在这里，我们实际上会得到客户内部的存储泄漏。

238
00:27:50,599 --> 00:27:58,699
嗯两个，所以客户必须决定其实施，我将重复说明

239
00:27:58,699 --> 00:28:07,759
合同代码或我要进行参考计数，还是我要泄露嗯，呃

240
00:28:07,759 --> 00:28:15,139
合同代码，因此这三件事可能不会尝试所有这些内容，以便您必须存储

241
00:28:15,140 --> 00:28:22,420
此代码在某个地方。因此，每次我收到新合同

242
00:28:22,420 --> 00:28:28,160
代码，然后我将其存储在此代码哈希下的密钥值数据库中。这意味着什么

243
00:28:28,160 --> 00:28:34,080
是，如果两个合同部署相同的代码，我将在数据库中有一个条目

244
00:28:34,080 --> 00:28:39,680
该代码，虽然这里有多个帐户具有相同的代码哈希。这意味着

245
00:28:39,680 --> 00:28:46,580
当这个帐户自我毁灭时，我可以清除其数据，但是我实际上无法清除其代码

246
00:28:46,580 --> 00:28:52,660
我的数据库是因为我不知道这里是否有另一个帐户存储相同的帐户

247
00:28:52,660 --> 00:28:57,080
代码。如果我删除它，然后另一个执行，那我就被搞砸了。

248
00:28:58,720 --> 00:29:04,259
因此，典型的实现是这样。他们存储它，然后从未删除它，这意味着

249
00:29:04,259 --> 00:29:06,539
那个长期运行的以太坊客户

250
00:29:06,539 --> 00:29:09,079
实际上是积累额外的代码

251
00:29:09,079 --> 00:29:10,480
它不应该坚持

252
00:29:10,480 --> 00:29:13,779
由于整个实施。

253
00:29:14,660 --> 00:29:15,940
现在，你可以做一些开销

254
00:29:15,940 --> 00:29:17,619
要么进行参考计数。

255
00:29:18,799 --> 00:29:20,400
我忘记了我说的另一件事，

256
00:29:20,680 --> 00:29:22,000
但是无论哪种方式，您都可以做一些开销

257
00:29:22,000 --> 00:29:24,379
为了更好地清理或更好的删除，

258
00:29:24,519 --> 00:29:26,879
或者您可以存储额外的

259
00:29:26,879 --> 00:29:28,920
并为每个帐户存储所有副本

260
00:29:28,920 --> 00:29:30,480
这样你就知道你可以删除

261
00:29:30,480 --> 00:29:31,680
该帐户的副本。

262
00:29:32,259 --> 00:29:34,039
但是无论哪种方式，您都在谈论开销，

263
00:29:34,259 --> 00:29:39,059
存储条款。这是我们清理某些东西的另一个地方

264
00:29:39,059 --> 00:29:46,000
VERCL。因此，VERCL实际上将代码本身存储在主状态树中。所以

265
00:29:46,000 --> 00:29:49,980
这些是我们需要进行清理的地方。这是另一个

266
00:29:49,980 --> 00:29:57,599
在提供证据复杂或复杂的地方

267
00:29:57,599 --> 00:30:03,200
事物的默克尔·帕特里夏树模型。如果您想象试图提供

268
00:30:03,200 --> 00:30:08,360
幼稚地实施提供默克尔帕特里夏树以进行执行

269
00:30:08,360 --> 00:30:13,019
在一个块中，您可能会忘记您需要包含实际代码

270
00:30:13,019 --> 00:30:22,920
对于在块执行中遇到的任何代码，因为

271
00:30:22,920 --> 00:30:26,720
默克尔·帕特里夏（Merkle Patricia）再次仅参考代码哈希而不是代码

272
00:30:26,720 --> 00:30:31,799
代码本身，因此回到自我毁灭，我们有此参考

273
00:30:31,799 --> 00:30:37,779
在状态根目的上，合同状态实际上并未存储在内部的任何地方

274
00:30:37,779 --> 00:30:41,819
实际状态树。客户实现只需实施一个

275
00:30:41,819 --> 00:30:48,299
将其存储在其他地方的东西，只是将该状态存储在其他地方，从而将

276
00:30:48,299 --> 00:30:53,700
当这种模型中有自我毁灭时，

277
00:30:53,700 --> 00:31:03,080
树模型，客户可以通过并实际删除其中的每一个。

278
00:31:03,080 --> 00:31:09,400
数据库。但是事实是合同可能有一个，二或一亿

279
00:31:09,400 --> 00:31:15,259
其数据库中的状态条目。当您遇到那亿款模型时，

280
00:31:15,720 --> 00:31:20,120
然后您实现客户，以便它穿过这棵树并删除其中的每一个

281
00:31:20,119 --> 00:31:25,279
钥匙从数据库中出来，您的客户在执行块时突然挂起，因为它

282
00:31:25,279 --> 00:31:29,259
花几个小时在其数据库中挖掘，删除所有这些内容。

283
00:31:29,939 --> 00:31:37,939
这不是一个可以的设计。在旧的默克尔分区树中，我们可以通过

284
00:31:37,939 --> 00:31:43,539
就像毫无意义的参考资料一样，如果我们愿意的话，就把这些东西留在周围。

285
00:31:43,539 --> 00:31:48,399
问题在于我们将其修复在virkle中。

286
00:31:50,059 --> 00:31:52,960
因此，Virkle是我们清理了很多东西的地方之一。

287
00:31:53,099 --> 00:31:58,079
在virkle中，这些东西，合同存储的东西并不分开。

288
00:31:58,220 --> 00:32:01,420
它不生活在这种神奇的其他领域。

289
00:32:01,779 --> 00:32:05,119
它位于主状态树的内部。

290
00:32:05,220 --> 00:32:07,680
实际上，一切都在主要状态树的内部。

291
00:32:07,779 --> 00:32:10,000
这是Virkle所做的非常漂亮的清理工作之一。

292
00:32:10,000 --> 00:32:36,700
但是这样做，这样做，这意味着自我毁灭会变得难以置信的问题，因为如果我们要允许自我毁灭，并且我们的数据在主树的内部，则意味着我们有点需要经历并删除所有这些内容，这意味着我们引入了一种自我毁灭的拒绝服务因素。

293
00:32:36,700 --> 00:32:40,860
因此，自我毁灭的去除，本质上是自我毁灭的，

294
00:32:42,660 --> 00:32:46,480
像为了进行这种过渡一样

295
00:32:46,480 --> 00:32:49,319
我们必须处理自我毁灭。

296
00:32:49,319 --> 00:32:51,279
如此自我毁灭，其中之一

297
00:32:51,279 --> 00:32:53,059
我们摆脱了清除。

298
00:32:58,200 --> 00:32:59,039
让我们来看看。

299
00:33:04,580 --> 00:33:05,420
好的。

300
00:33:06,700 --> 00:33:15,660
因此，预编译是要清除事情的另一件事。

301
00:33:15,660 --> 00:33:29,440
因此，我认为我们都听说过ZKEVM，零知识EVM的东西。

302
00:33:29,440 --> 00:33:37,700
任何类型的技术都应用于EVM执行。

303
00:33:38,740 --> 00:33:49,320
因此，出现的问题之一是能够零知识 -  ZK-EVM事物是预编译。

304
00:33:49,900 --> 00:33:52,860
Kekak是其他人之一。

305
00:33:52,859 --> 00:34:05,539
因此，事实证明，预编译和Kekak是其中之一，实际上是有问题的ZK事情。

306
00:34:05,539 --> 00:34:19,579
现在，我将在这部分中进行大量努力，因为这不是我深厚的专业知识的领域。我高度了解这些事情。我对它们的工作方式没有深入的了解。

307
00:34:19,579 --> 00:34:41,819
但是我确实了解的是，在此模型中实施KECAC是为了使Z-K-Fi事情要做Zero-newledge-Fi的事物，必须完成的计算中很大一部分的计算。

308
00:34:41,820 --> 00:34:56,480
因此，我们知道，我们在来源中有了这个想法，即以太坊的成立，是我们想要Kekak之类的东西，因为我们的协议本身，对以太坊的协议在各地都有kekak。

309
00:34:57,519 --> 00:35:02,640
这就是我们获得块缓存的方式。凯卡克（Kekak）遍布梅克尔·帕特里夏（Merkle Patricia）树，对吗？

310
00:35:03,100 --> 00:35:07,360
因此，在EVM内部使用Kekak确实很有价值。

311
00:35:07,360 --> 00:35:10,140
与SHA-256这样的东西也一样

312
00:35:10,140 --> 00:35:12,260
SHA-256用于固定

313
00:35:12,260 --> 00:35:14,460
到处都是各种数据

314
00:35:14,460 --> 00:35:16,420
并能够做

315
00:35:16,420 --> 00:35:18,640
EVM中的SHA-256便宜

316
00:35:18,640 --> 00:35:22,200
很有价值

317
00:35:22,200 --> 00:35:24,460
所以有很多用例

318
00:35:24,460 --> 00:35:26,480
在那周围，它变成了

319
00:35:26,480 --> 00:35:28,420
是通过包括

320
00:35:28,420 --> 00:35:30,440
这类事情我们要做的事情

321
00:35:30,440 --> 00:35:32,480
我们是做ZK的事情吗

322
00:35:32,480 --> 00:35:33,900
从根本上硬

323
00:35:33,900 --> 00:35:34,740
那

324
00:35:34,739 --> 00:35:41,699
将ZK的事物应用于这些方面使它们从根本上困难，因此是其中之一

325
00:35:41,699 --> 00:35:47,299
我们正在寻找人们正在进行的清理工作本质上是

326
00:35:48,099 --> 00:35:55,059
尽力而为，我们可以预先编译并试图弄清楚我们对

327
00:35:55,059 --> 00:36:02,579
其余的

328
00:36:02,579 --> 00:36:07,759
预编译的事物类型。所以这就是为什么我们试图找到获取这些的方法

329
00:36:07,759 --> 00:36:17,139
出去。这些事情发生的主要工作之一是以太坊对象格式。我相信

330
00:36:17,139 --> 00:36:23,699
协议研究文档中与此演讲有关的文档中有指向这些内容的链接。但

331
00:36:23,699 --> 00:36:28,639
以太坊对象格式是发生大量此类清理的地方之一。

332
00:36:28,639 --> 00:36:43,179
因此，您知道要摆脱预编译的原因是要摆脱前，不要摆脱，而是让我们有可能进入这种ZK-EVM的位置。

333
00:36:43,179 --> 00:36:47,699
因为像垂直行业一样惊人，是我们分发的能力

334
00:36:49,480 --> 00:36:53,359
使黑色执行的状态的垂直证明

335
00:36:56,859 --> 00:36:58,480
容易做

336
00:36:58,480 --> 00:37:00,779
在客户层面，因为您要做的就是

337
00:37:00,940 --> 00:37:05,419
让您要执行和证明的块，您可以将其全部运行在内存中，而您不必

338
00:37:05,419 --> 00:37:09,239
存储任何状态和类似的东西，它很棒

339
00:37:09,699 --> 00:37:11,899
这里的世界更大？

340
00:37:11,900 --> 00:37:15,980
到那时，证据变得更小

341
00:37:15,980 --> 00:37:18,340
证明的验证甚至更快。

342
00:37:18,700 --> 00:37:21,340
因为事实证明即使在virkle模型中，

343
00:37:21,980 --> 00:37:24,960
执行一个块相对昂贵

344
00:37:24,960 --> 00:37:28,240
就像一个轻度的客户世界一样，

345
00:37:28,440 --> 00:37:31,780
在手机之类的事情上做到这一点

346
00:37:31,780 --> 00:37:34,720
可能仍然比我们想要的要贵。

347
00:37:34,960 --> 00:37:38,460
从理论上讲，这实际上是可以访问的

348
00:37:38,460 --> 00:37:42,400
以类似资源受限的轻型设备世界。

349
00:37:53,679 --> 00:37:57,960
这是一个合适的停顿地点。

350
00:37:58,059 --> 00:38:01,579
我真的应该暂停并看到是否有任何疑问

351
00:38:01,579 --> 00:38:05,579
至少以前的主题边界之一。

352
00:38:05,579 --> 00:38:10,380
但是，我们有任何问题或任何人希望我深入研究的问题吗？

353
00:38:10,380 --> 00:38:11,900
有澄清的领域吗？

354
00:38:11,900 --> 00:38:15,980
是的，我们对不和谐有一些疑问。

355
00:38:15,980 --> 00:38:21,559
首先，很难，因为未定义为EVM的语言代码或

356
00:38:21,559 --> 00:38:25,460
ZKVM在您刚才说的上下文中？

357
00:38:25,460 --> 00:38:26,460
是的。

358
00:38:26,460 --> 00:38:30,400
因此，通常通常不是EVM代码。

359
00:38:30,400 --> 00:38:32,819
它们倾向于是机器代码。

360
00:38:32,819 --> 00:38:35,139
还是外部，对吗？

361
00:38:35,139 --> 00:38:38,299
就像，我不知道其他客户做了什么。

362
00:38:38,799 --> 00:38:42,059
我决定多年前在Python写一位客户。

363
00:38:42,239 --> 00:38:46,239
这是一个错误，但是我学到了很多事情，

364
00:38:46,239 --> 00:38:47,619
所以也许这不是一个错误。

365
00:38:48,079 --> 00:38:50,900
但是无论哪种方式，在我的Python客户中，

366
00:38:51,119 --> 00:38:53,679
当您打电话给kekak的预编译时，

367
00:38:54,299 --> 00:38:57,699
我使用了kekak的python库

368
00:38:57,799 --> 00:38:59,440
我喂了它，我做了凯卡克，

369
00:38:59,519 --> 00:39:02,559
我希望Python图书馆做得完全正确。

370
00:39:02,559 --> 00:39:25,119
实际上，我认为人们在模糊器中发现的许多错误往往像预编译区域一样，因为您将在GO库中获得诸如数字溢出和内容之类的行为，也许是比逮捕图书馆比在c图书馆中撰写的图书馆不同。

371
00:39:25,119 --> 00:39:36,460
因此，大多数客户本质上都在向其他一些实现SHA-256，KECAC的库，无论是Blake2b，这些东西。

372
00:39:38,000 --> 00:39:50,839
所以，是的，我不知道我们对KECAC未来的计划的计划是什么，或者我们是否这样做，或者我们如何做SHA-256，或者如果我们这样做。

373
00:39:50,840 --> 00:39:57,240
我不知道我们能在EVM级别上做这些事情是否可行。

374
00:39:59,800 --> 00:40:04,940
但是无论哪种方式，问题在于他们将机器代码淘汰，

375
00:40:05,059 --> 00:40:12,220
这意味着您如何为仅在计算机上运行的GO库做一个ZK-POND-PRODACE？

376
00:40:12,740 --> 00:40:15,100
我认为这是问题出现的地方。

377
00:40:18,460 --> 00:40:19,640
太好了，非常感谢。

378
00:40:19,639 --> 00:40:25,960
是的，砖头编译是非常复杂的话题，我们在APF上也有一篇文章

379
00:40:25,960 --> 00:40:34,679
维基百科，也放在那里。我还有另一个问题，因为我还没有抓住那个，

380
00:40:34,679 --> 00:40:41,879
当您提到时，我们正在解释自我毁灭机制以及合同代码

381
00:40:41,879 --> 00:40:47,719
存储，您提到有一些存储泄漏或某种泄漏正在发生，

382
00:40:47,719 --> 00:40:51,879
嗯，我并没有真正抓住你能从那是什么样子中详细说明

383
00:40:51,879 --> 00:41:01,159
非法掌握了，所以您可以在任何合同代码桥上查看它，我都相信

384
00:41:01,159 --> 00:41:07,559
实际上最终具有相同的机制，因此，因为现有的状态

385
00:41:07,559 --> 00:41:15,079
以太坊状态仅通过代码哈希或或合同具有参考文献

386
00:41:15,079 --> 00:41:23,420
存储路线，正在做自我毁灭的客户，正在做自我毁灭的客户

387
00:41:23,420 --> 00:41:29,259
必须决定是否要删除代码本身以及是否

388
00:41:29,259 --> 00:41:32,480
他们将自己删除存储元素。

389
00:41:35,219 --> 00:41:39,340
从理论上讲，要做的卫生要做的事情是删除它们。

390
00:41:39,340 --> 00:41:47,000
但是，实现这一目标意味着可能允许您的客户从网络上脱离网络。

391
00:41:47,700 --> 00:41:56,780
因此，如果一份非常大的合同本身会删除，则可能需要删除数十万或数百万的存储键。

392
00:41:56,780 --> 00:42:14,220
而且，如果您天真地实施自我毁灭，以便实际上经过并删除这些毁灭，那么您可能会发现，在一个称为大型合同上的自我毁灭的街区中，您的客户将悬挂很长时间试图做到这一点。

393
00:42:16,080 --> 00:42:23,060
这意味着您可能需要限制客户将花费多长时间删除它们。

394
00:42:23,059 --> 00:42:44,259
如果您想真正卫生，但实际上，我认为现实是，如果您想编写一个强大的客户，那要做的事情是，这只是不是要删除这些东西或对多少限制了多少钥匙您愿意花时间删除，然后再迫使客户继续前进。

395
00:42:44,260 --> 00:42:47,660
然后有可能再也不会回来清理这些东西了。

396
00:42:48,880 --> 00:42:54,780
因此，对于合同存储，您会得到DOS矢量，可能很难清理合同

397
00:42:54,780 --> 00:42:58,940
这种自我毁灭本身具有非常大量的存​​储键。

398
00:43:00,280 --> 00:43:08,020
因此，您会得到某种像存储泄漏，您的数据库将使用商店合同存储

399
00:43:08,520 --> 00:43:13,460
在一段时间内，如果您不实施完美的删除机制，

400
00:43:13,460 --> 00:43:21,059
做工程工作不是不可行的，但不是最重要的

401
00:43:21,059 --> 00:43:25,840
我认为大多数客户都在工作的事情，因此期望许多客户或

402
00:43:25,840 --> 00:43:31,119
有些客户，甚至所有客户，我都不知道他们在引擎盖下做什么，但我不会

403
00:43:31,119 --> 00:43:35,559
如果有客户，当发生自我毁灭时，他们实际上并没有感到惊讶

404
00:43:35,559 --> 00:43:42,139
从磁盘上擦除所有内容

405
00:43:42,139 --> 00:43:46,659
它并没有重置它的存储数据库，而事物会累积

406
00:43:46,659 --> 00:43:52,339
在此数据库中的数据库中的额外存储在该数据库中

407
00:43:52,339 --> 00:43:58,639
可删除但是的，但没有删除，因为也许他们做出了明智的选择

408
00:43:58,639 --> 00:44:03,699
要限制限制，甚至只是说您知道我们甚至都不会清理

409
00:44:03,699 --> 00:44:07,940
合同存储删除我们只会让它坐下来，以免我们得到

410
00:44:07,940 --> 00:44:11,799
从网络中加入，因为这不是我们遇到的最高优先级问题

411
00:44:11,800 --> 00:44:12,600
现在就开始工作。

412
00:44:13,260 --> 00:44:15,539
这就是这些东西带有合同存储的地方。

413
00:44:16,920 --> 00:44:19,460
有了合同代码，

414
00:44:22,480 --> 00:44:25,700
两个合同可以共享完全相同的代码，

415
00:44:25,900 --> 00:44:27,940
这意味着他们将具有完全相同的代码哈希，

416
00:44:28,380 --> 00:44:30,600
这意味着在实施级别，

417
00:44:31,180 --> 00:44:34,820
由于代码未存储在状态树中，因此

418
00:44:35,580 --> 00:44:39,600
客户可以选择如何存储它，

419
00:44:39,599 --> 00:44:43,039
存储它的天真方法是通过哈希储存。

420
00:44:44,119 --> 00:44:46,980
而且由于两个帐户可以具有完全相同的代码哈希

421
00:44:46,980 --> 00:44:49,039
并且可以具有相同的代码，

422
00:44:49,819 --> 00:44:51,360
如果您选择该机制，

423
00:44:51,360 --> 00:44:53,279
当合同自我毁灭时，

424
00:44:53,299 --> 00:44:55,819
您不能从数据库中删除其代码

425
00:44:55,819 --> 00:44:57,500
因为你不知道是否

426
00:44:57,500 --> 00:44:59,420
还有另一个具有相同代码的帐户。

427
00:45:00,019 --> 00:45:01,619
那就是泄漏发生的地方。

428
00:45:02,079 --> 00:45:04,039
这些不是主要问题。

429
00:45:04,239 --> 00:45:09,259
这些不是会遇到的问题

430
00:45:09,260 --> 00:45:14,060
立即导致客户脱离网络或类似的东西，它们只是

431
00:45:14,060 --> 00:45:20,540
随着时间的流逝，很少的债务会导致客户存储比他们需要更多的数据。

432
00:45:21,260 --> 00:45:27,340
而且它们可能不是大多数客户团队的最高工程问题，

433
00:45:27,340 --> 00:45:31,500
他们可能不是大多数客户团队工作的最高优先工程问题

434
00:45:31,500 --> 00:45:37,580
在。好的，非常感谢。那很有趣。我不知道

435
00:45:37,579 --> 00:45:41,739
那里的潜在剂量向量非常有趣。

436
00:45:41,739 --> 00:45:43,719
下一个问题是在门户网站报告中

437
00:45:43,719 --> 00:45:45,940
我想你可以继续

438
00:45:45,940 --> 00:45:47,980
最终我们将获得这个话题。

439
00:45:49,819 --> 00:45:51,340
是的，我想我们有两个，

440
00:45:51,340 --> 00:45:55,880
像两个半的清除话题一样，

441
00:45:55,880 --> 00:45:57,920
然后我会暂停一秒钟，

442
00:45:57,920 --> 00:46:00,000
然后我们会做一些类似的门户

443
00:46:00,000 --> 00:46:01,500
我们要去哪里？

444
00:46:02,659 --> 00:46:05,619
因此，清理的其他主要领域之一

445
00:46:05,619 --> 00:46:09,779
我们想做的是在州，对吗？

446
00:46:09,779 --> 00:46:12,719
早些时候，我们谈到了4-4S的目的是如何清理

447
00:46:12,719 --> 00:46:15,279
线性增长的悠久历史，对吗？

448
00:46:15,279 --> 00:46:19,639
这一悠久的块历史随着时间的流逝而增长。

449
00:46:19,639 --> 00:46:22,920
国家本身拥有如此悠久的历史

450
00:46:22,920 --> 00:46:24,359
线性增长，对吗？

451
00:46:24,359 --> 00:46:26,059
状态树不断越来越大

452
00:46:26,059 --> 00:46:27,719
而且越来越大，我们只是继续投掷更多

453
00:46:27,719 --> 00:46:30,699
还有更多的东西，我们需要所有这些东西才能在那里。

454
00:46:30,699 --> 00:46:32,039
那我们该怎么办？

455
00:46:32,039 --> 00:46:34,019
我们如何清理它？

456
00:46:34,019 --> 00:46:42,820
几年前，当我们聚集在一起试图解决这些问题时，我们提出了这个称为州到期的概念。

457
00:46:45,780 --> 00:46:52,360
实际上，哪个可能是一个可怕的名字，因为它使它成为一个暴力词，对吗？

458
00:46:52,400 --> 00:46:54,699
它说它到期了。它消失了。正确的。

459
00:46:55,219 --> 00:47:01,880
因此，也许我们应该在某个时候谈论一些品牌，并在这里提出一个带有更好，更友好的词的品牌。

460
00:47:01,880 --> 00:47:06,619
但是今天，我们将其称为状态到期，因为这就是我们永远在协议讨论中所说的。

461
00:47:07,160 --> 00:47:11,820
如果我们使用的词与到期不同的话，也许我们会减少恐惧。

462
00:47:12,380 --> 00:47:17,740
因为事实是它实际上没有过期。只是睡觉。那就是主意。

463
00:47:18,380 --> 00:47:25,900
因此，我们的想法是我们定义史诗，对吗？我们到处都是史诗，对吗？

464
00:47:25,900 --> 00:47:35,360
这是整个事情。国家到期背后的想法是，我只会在

465
00:47:35,360 --> 00:47:42,840
最高水平，因为这里有很多细微差别。国家到期背后的想法是

466
00:47:42,840 --> 00:47:51,980
现在，我们会说这是今天。今天，我们在这个史诗般的内部，好吗？有很多

467
00:47:51,980 --> 00:47:53,340
也在这里闲逛。

468
00:47:54,480 --> 00:47:55,760
因此，在这个史诗般的情况下

469
00:47:56,139 --> 00:47:57,639
我们有一个状态。

470
00:47:58,679 --> 00:48:00,559
我们也有一个状态

471
00:48:00,559 --> 00:48:02,780
每个人

472
00:48:02,780 --> 00:48:04,480
这些其他史诗也是如此。

473
00:48:05,179 --> 00:48:06,619
而且这还没有发生。

474
00:48:07,619 --> 00:48:07,820
好的？

475
00:48:08,079 --> 00:48:10,000
在执行的块中

476
00:48:10,000 --> 00:48:11,860
在这个史诗般的就在这里，

477
00:48:15,519 --> 00:48:17,420
当它读取状态时

478
00:48:17,940 --> 00:48:19,820
首先会尝试

479
00:48:19,820 --> 00:48:21,400
从此阅读。

480
00:48:21,980 --> 00:48:32,219
它将查看该值是否存在。当它写成状态时，它将永远写

481
00:48:32,219 --> 00:48:38,800
对此。因此，我们从中读出来，然后从中读书。如果该状态

482
00:48:38,800 --> 00:48:45,639
这是缺少的，这个想法是我们像以前一样回到这种情况

483
00:48:45,639 --> 00:48:53,239
国家树。让我尝试从这里阅读状态。如果不是

484
00:48:53,239 --> 00:49:01,719
这些，太糟糕了，它不在这里。如果在这里，我们要做的就是将其提升到活动状态。

485
00:49:02,440 --> 00:49:08,920
因此，我们有这种活跃状态和先前状态的概念。

486
00:49:08,920 --> 00:49:28,039
这个想法是，这些史诗可能是六个月，九个月，12个月的时间，这是一个粗糙的领域，并且每当您越过史诗般的边界时，您都会说，现在这里的先前状态现在只读。

487
00:49:28,039 --> 00:49:43,340
现在，我们得到了一个不错的新空名，它是读写的，并且在此时间范围内定期访问的任何东西都会自动向前移动。

488
00:49:44,300 --> 00:49:53,119
而且任何仍然没有回到这里的东西，但客户不再将其保留在这里。

489
00:49:53,539 --> 00:49:54,800
它仍然存在。

490
00:49:55,239 --> 00:49:56,219
有人明白了。

491
00:49:56,219 --> 00:50:02,879
我们可能会为其制作类似错误的文件格式

492
00:50:02,879 --> 00:50:05,459
这样人们就可以很好地打包

493
00:50:05,980 --> 00:50:10,059
将其运送到周围，为之制作洪流或类似的东西。

494
00:50:10,759 --> 00:50:13,980
然后这里的机制是

495
00:50:13,980 --> 00:50:16,559
你在这里做某事

496
00:50:16,559 --> 00:50:20,859
确实需要访问某些东西

497
00:50:20,859 --> 00:50:23,559
从几个史诗般的后面开始

498
00:50:23,559 --> 00:50:27,420
在EVM中不再可以立即访问

499
00:50:27,420 --> 00:50:32,719
因为允许客户放弃超越这个边界的东西，所以

500
00:50:33,239 --> 00:50:39,699
这个想法是，对于以太坊协议来说，它非常容易

501
00:50:39,699 --> 00:50:42,799
只是跟踪旧路线。

502
00:50:43,799 --> 00:50:47,500
只要协议跟踪所有这些旧状态路线，

503
00:50:48,199 --> 00:50:51,400
然后有人可以建立自己的证据

504
00:50:51,400 --> 00:50:54,519
对于他们想重新恢复的一种状态

505
00:50:55,639 --> 00:50:58,980
他们可以将其包括在交易中

506
00:50:58,980 --> 00:51:02,059
这样当执行在这里发生

507
00:51:02,059 --> 00:51:04,059
想在这里访问一些东西

508
00:51:04,059 --> 00:51:06,019
这不是立即访问，

509
00:51:06,820 --> 00:51:09,460
它可以看一下这个旧的根，检查证明，

510
00:51:09,460 --> 00:51:10,820
看到它与根相匹配，

511
00:51:11,160 --> 00:51:12,780
然后将其写入状态。

512
00:51:14,260 --> 00:51:19,079
因此，国家有效期是这样，

513
00:51:19,079 --> 00:51:25,559
真的很棒，很好，干净的解决方案。

514
00:51:26,599 --> 00:51:28,199
我认为这是我们去的地方。

515
00:51:29,400 --> 00:51:32,219
我认为这是我们要去的地方，但这很难。

516
00:51:32,380 --> 00:51:33,579
这是很多工作。

517
00:51:34,159 --> 00:51:35,099
这很复杂。

518
00:51:35,539 --> 00:51:38,239
对，这是一个很大的功能。

519
00:51:38,239 --> 00:51:41,539
这是一个像Verkle一样大的功能，对吗？

520
00:51:41,639 --> 00:51:45,840
这是以太坊协议如何工作的基本变化。

521
00:51:45,840 --> 00:51:52,720
旧事物的到期是新事物，对吗？

522
00:51:52,720 --> 00:51:58,600
但是国家到期就是其中之一，它确实是大清除物品

523
00:51:58,600 --> 00:52:03,240
这可能是我们想做的最大的事情，这很难

524
00:52:03,240 --> 00:52:09,480
但这通常是概念。我意识到我想要的下一个话题

525
00:52:09,480 --> 00:52:21,980
谈论，这是解决空间扩展，我认为我将无法画画

526
00:52:21,980 --> 00:52:24,440
您是我们为什么需要这个的完美图片。

527
00:52:24,440 --> 00:52:29,219
但是我将能够为您提供通常的手动答案。

528
00:52:29,900 --> 00:52:35,740
协议研究文档中有很多链接详细介绍

529
00:52:35,740 --> 00:52:38,380
解决空间扩展以及为什么我们需要它。

530
00:52:38,380 --> 00:52:50,539
但是，普遍的观点是，在这些史诗中，我们需要一个略有不同的寻址方案，以便非常清楚我们正在谈论哪种史诗。

531
00:52:52,119 --> 00:53:05,960
从本质上讲，我们在20字节以太坊讲话中没有足够的熵。

532
00:53:05,960 --> 00:53:27,340
我认为被引用的数字是，比特币区块链已经完成了这么多的计算，比特币区块链有效地遇到了蛮力至少在那里发生的计算量中的几个以太坊地址。

533
00:53:27,340 --> 00:53:39,340
因此，分析是，我们的20个字节地址实际上还不够安全，无法实施国家到期，因为它们不够大，对吗？

534
00:53:39,519 --> 00:53:45,960
我们采用32字节值，然后将其截断为20字节值。

535
00:53:45,960 --> 00:54:09,340
嗯，虽然这是，但这也很复杂。州到期很复杂，很难做。您知道，它有很多活动部件。我们，我们，我们真的知道如何做所有这一切。嗯，这很难，但是，但是，它在大多数方面都以此为名。

536
00:54:09,340 --> 00:54:32,559
我们所遇到的是阻碍者，这实际上是从根本上很难EVM，这样的事情。

537
00:54:32,559 --> 00:54:43,759
因此，甚至只是大量的工具，这些工具完全知道如何做到这一点，并且不知道如何进行32字节的地址。

538
00:54:46,779 --> 00:54:54,320
因此，基于地址的扩展最终实际上是这里更困难的问题之一，我认为这是一个技术问题。

539
00:54:54,460 --> 00:54:56,000
州到期是一个技术问题。

540
00:54:56,820 --> 00:55:02,480
基于地址的扩展存在一些埋藏的技术问题，但是它确实有很多人问题。

541
00:55:02,559 --> 00:55:06,860
内置，对吗？很多涉及20字节地址的客户库，

542
00:55:07,360 --> 00:55:15,380
它将盲目地占据32字节的地址，然后将其撕下并将其变成20字节

543
00:55:15,380 --> 00:55:19,440
地址，无话可说，也没有丢弃任何错误或类似的错误。

544
00:55:20,259 --> 00:55:24,400
因此，我们遇到的一个阻滞剂就是在这里扩展空间。

545
00:55:24,400 --> 00:55:34,240
嗯，很酷。嗯，对此有任何疑问吗？

546
00:55:40,039 --> 00:55:46,320
呃，没有什么具体的国家到期的东西，除非人们有一些问题

547
00:55:46,320 --> 00:55:52,440
想快速输入。呃，我们有一个来了，嗯，在第五周，

548
00:55:52,440 --> 00:56:01,200
唐纳西（Donathy）提到，他认为由于复杂性，国家到期可能永远不会被实施，并且PBS和无状态使其成为较低的优先事项。

549
00:56:01,980 --> 00:56:07,079
您对国家到期实施的可能性有何看法？

550
00:56:09,840 --> 00:56:13,079
我认为我在这里没有明智的意见。

551
00:56:14,679 --> 00:56:18,700
我有自己的意见，但我认为我没有生态系统的意见。

552
00:56:18,699 --> 00:56:24,299
我认为这是正确的，有一个可行的未来，我们永远不会实施国家到期。

553
00:56:26,460 --> 00:56:33,799
我觉得那种令人失望的事情，我认为我可以理解我的理由。

554
00:56:33,800 --> 00:56:40,860
它似乎是完全可行的

555
00:56:40,860 --> 00:56:42,400
永远不要国家到期

556
00:56:42,400 --> 00:56:50,160
该硬件可能应该超过状态增长

557
00:56:50,160 --> 00:56:55,620
并且可以期望阻止建造者是合理的

558
00:56:55,620 --> 00:57:00,260
在此东西上投掷高端，伟大，令人惊叹的硬件

559
00:57:00,260 --> 00:57:05,520
并能够管理10个Terabyte状态数据库

560
00:57:05,520 --> 00:57:07,020
只是为了弄清楚

561
00:57:07,020 --> 00:57:09,540
并做工程工作来做到这一点。

562
00:57:09,860 --> 00:57:13,860
我认为这是我们所做工作的可行未来，

563
00:57:14,540 --> 00:57:16,540
但是男孩，我不喜欢它。

564
00:57:17,420 --> 00:57:21,080
其中一些人受到直接影响

565
00:57:21,080 --> 00:57:23,440
根据我工作的上下文，即门户网络。

566
00:57:23,800 --> 00:57:26,260
原因是国家

567
00:57:26,260 --> 00:57:28,320
是一个非常困难的数据集。

568
00:57:28,320 --> 00:57:31,620
您将获得该值是状态根。

569
00:57:32,840 --> 00:57:37,880
国家根源参考了存在于其中的巨大数据集。

570
00:57:38,140 --> 00:57:45,480
不仅引用了它，而且国家随机变化迅速，不断变化。

571
00:57:47,120 --> 00:57:51,700
因此，这是一个非常困难的数据集合

572
00:57:51,700 --> 00:57:54,640
因为它总是试图从您下方搬出。

573
00:57:54,639 --> 00:58:01,019
如果您有副本，则必须不断执行每个块。

574
00:58:01,519 --> 00:58:11,319
否则，您努力地收集，建造和倾向和爱的事情突然变得无用，因为您已经走了10分钟。

575
00:58:11,759 --> 00:58:13,559
现在，您实际上无法做任何事情。

576
00:58:13,679 --> 00:58:16,460
这不是一个很好的感觉。

577
00:58:18,179 --> 00:58:24,139
我们想要 - 因此，在PBS模型中，它非常注重协议，对吗？

578
00:58:24,139 --> 00:58:31,480
我相信，可以说，你知道吗？这很好。没关系。我们很好，

579
00:58:31,480 --> 00:58:38,359
我们的协议只能继续前进是完全可行的，因为块构建器

580
00:58:38,359 --> 00:58:47,480
有强烈的动力将大型硬件放在街区建筑物上以存储大型大型

581
00:58:47,480 --> 00:58:52,779
陈述树，根本没有任何问题，进行块构建和阻止执行。

582
00:58:52,780 --> 00:59:10,500
我认为这有点像盲目的观点，因为它非常以协议为中心，这并不是完成协议发展的一种坏方法。但是用户呢？这有点像我的问题。

583
00:59:10,500 --> 00:59:20,360
因此，为了建立和发送交易，我必须做我们称为煤气的事情

584
00:59:20,360 --> 00:59:21,360
估计。

585
00:59:21,360 --> 00:59:26,920
气体估计意味着运行任意EVM代码，并且运行任意EVM代码表示

586
00:59:26,920 --> 00:59:28,800
访问状态。

587
00:59:28,800 --> 00:59:37,880
因此，尽管协议可以很好地进行，但用户将如何构建交易

588
00:59:37,880 --> 00:59:45,400
他们自己的方式在意识形态上与我们所说的那样一致，

589
00:59:45,400 --> 00:59:48,380
是权力下放，类似的事情。

590
00:59:49,920 --> 01:00:01,760
因为一个单片，巨大的大型状态意味着我们对用户说，所以您应该使用

591
01:00:01,760 --> 01:00:02,820
集中提供商。

592
01:00:03,579 --> 01:00:05,200
您应该使用infura。

593
01:00:05,559 --> 01:00:06,559
您应该去使用炼金术。

594
01:00:06,559 --> 01:00:08,619
因为这就是我们要说的话。

595
01:00:10,799 --> 01:00:19,619
州到期将很难与之合作的州的整体规模限制。

596
01:00:20,360 --> 01:00:23,559
国家仍然很难在州到期模型中使用

597
01:00:23,840 --> 01:00:28,900
但是，这个困难被牢固地绑定到了这个盒子中。

598
01:00:29,500 --> 01:00:35,400
每当这里有某些东西到期时，与之合作变得非常容易

599
01:00:35,400 --> 01:00:36,860
因为它停止摇摆

600
01:00:36,860 --> 01:00:38,200
从你下方搬出

601
01:00:38,200 --> 01:00:39,039
它被冻结了。

602
01:00:40,000 --> 01:00:42,680
因此它变得可行

603
01:00:42,680 --> 01:00:44,860
建立可持续协议

604
01:00:44,860 --> 01:00:47,480
可以提供此状态数据。

605
01:00:48,079 --> 01:00:53,340
构建门户网络模型更容易

606
01:00:53,340 --> 01:00:55,360
为此状态数据服务

607
01:00:55,360 --> 01:00:56,539
因为有上限

608
01:00:56,539 --> 01:00:58,619
关于其中的多少。

609
01:00:59,320 --> 01:01:00,680
而在整体上，

610
01:01:01,500 --> 01:01:03,200
单状态，单路

611
01:01:03,320 --> 01:01:04,519
没有州到期模型，

612
01:01:04,519 --> 01:01:16,119
这意味着像门户网络这样的解决方案必须弄清楚如何不断扩大其提供的存储空间，以便能够存储所有历史状态以服务。

613
01:01:16,340 --> 01:01:28,420
因此，我敢肯定，那里的推理中有一些漏洞，但这就是为什么我发现这种方法令人失望的原因。

614
01:01:28,780 --> 01:01:34,079
是的，非常感谢您的论文。

615
01:01:34,079 --> 01:01:38,980
我真的很感激，因为当Domotis说出来时，我个人感到非常失望。

616
01:01:38,980 --> 01:01:42,420
由于您所说的原因，我完全是Statexparry的粉丝。

617
01:01:42,420 --> 01:01:46,119
我正在学习一个节点，正在学习一个存档节点，我会继续这样做，提供

618
01:01:46,119 --> 01:01:47,119
数据。

619
01:01:47,119 --> 01:01:48,119
因此，这是一个很好的论点，戴夫。

620
01:01:48,119 --> 01:01:49,119
太感谢了。

621
01:01:49,119 --> 01:01:59,799
是的，我们还有一个问题，因为您提到了地址空间扩展，这是

622
01:01:59,799 --> 01:02:03,079
我已经有一段时间没有听说过的东西了。

623
01:02:03,079 --> 01:02:04,759
我想知道那里的优先事项是什么？

624
01:02:05,159 --> 01:02:08,599
当前的ASE研究状态是什么？

625
01:02:12,739 --> 01:02:16,420
我知道EOF，因此以太坊对象格式，

626
01:02:16,559 --> 01:02:21,380
正在做一些工作以使基于地址的扩展成为可能。

627
01:02:21,380 --> 01:02:23,539
因此，它似乎是优先的。

628
01:02:23,779 --> 01:02:27,259
我暂时没有拇指对核心开发的脉搏。

629
01:02:27,519 --> 01:02:30,099
我在自己的门户网站项目中一直处于困境，

630
01:02:30,099 --> 01:02:35,400
因此，我一直待在，我一直在赶上，但我不知道。

631
01:02:35,799 --> 01:02:54,559
我可以更普遍地谈论它，这就是我们生态系统中的大多数事情都会因为决定在那个山上死去的一些非常有动力的人，他们决定拿起旗帜并奔跑并实现它。

632
01:02:54,559 --> 01:03:01,539
我几乎开始列出谁做的事情的名字，但是如果我这样做，那我就会离开

633
01:03:01,539 --> 01:03:06,759
一个重要的人参与其中的人，我不想这样做，而是几乎所有

634
01:03:06,759 --> 01:03:13,559
我们很难完成的主要协议更改和倡议，因为有人决定

635
01:03:13,559 --> 01:03:18,380
他们将实现这一目标，或者少数人决定他们要去

636
01:03:18,380 --> 01:03:25,640
实现它。通常，那是客户团队或客户团队中的某人

637
01:03:25,720 --> 01:03:31,440
因为您实际上并没有直接在协议上工作，而不是很有效，没有

638
01:03:31,440 --> 01:03:37,599
成为客户团队，因为客户实施非常重要。所以我认为基于地址的

639
01:03:37,599 --> 01:03:43,300
扩展发生，我认为这意味着有人必须决定那是山丘

640
01:03:43,300 --> 01:03:48,220
他们想死于还是不死。希望我们不会在这些山丘上死，但这就是

641
01:03:48,219 --> 01:03:57,500
隐喻。因此，您知道，国家即将到来吗？接下来是地址空间扩展吗？是

642
01:03:57,500 --> 01:04:07,439
一切都没有阻碍，对吗？维塔利克（Vitalik）美丽的路线图文档确实有点努力

643
01:04:07,439 --> 01:04:13,819
按依赖顺序。因此，我不确定地址空间扩展是否已完全解锁。

644
01:04:13,820 --> 01:04:19,100
我认为使整个生产线扩展空间扩展的过程是

645
01:04:19,100 --> 01:04:23,920
与一百个不同的开源进行一百对话

646
01:04:23,920 --> 01:04:28,100
所有人都需要更新其图书馆的项目，

647
01:04:28,100 --> 01:04:30,559
您知道，支持32个字节地址。

648
01:04:30,559 --> 01:04:35,519
无论做到这一点的人都必须弄清楚并铺设

649
01:04:35,519 --> 01:04:41,100
人行道和前进的道路，即我们从今天的位置到

650
01:04:41,099 --> 01:04:45,079
就像可行的地址空间扩展实现一样。

651
01:04:45,079 --> 01:04:48,679
所以也许不是最令人满意的答案，

652
01:04:48,679 --> 01:04:50,380
但这就是我所拥有的。

653
01:04:53,440 --> 01:04:55,059
我还看到我们有一个小时，

654
01:04:55,059 --> 01:04:57,920
我们今天的时间限制是什么？

655
01:04:57,920 --> 01:04:58,759
什么是？

656
01:04:59,980 --> 01:05:01,500
这是安排90分钟的

657
01:05:01,500 --> 01:05:04,239
所以您还有30分钟的路程。

658
01:05:04,239 --> 01:05:05,039
伟大的。

659
01:05:05,920 --> 01:05:08,519
我认为这就是现在的所有问题。

660
01:05:08,519 --> 01:05:10,619
太好了，我在这里又有一个

661
01:05:10,619 --> 01:05:23,219
它将谈论。与此同时，我很好奇人们跌入

662
01:05:23,219 --> 01:05:31,139
聊天方向您想通过门户网络听到的内容。你想听任何东西吗

663
01:05:31,139 --> 01:05:35,079
关于它？你知道吗？你对此一无所知吗？有点像你

664
01:05:35,079 --> 01:05:40,019
知识水平，您是否希望我深入研究特定领域？

665
01:05:41,059 --> 01:05:41,579
凉爽的。

666
01:05:41,840 --> 01:05:45,400
最后一个非常简单，对数改革。

667
01:05:46,420 --> 01:05:46,460
好的。

668
01:05:50,460 --> 01:05:57,340
因此，有这四个Opcodes都是EVM中的日志opcodes。

669
01:05:59,000 --> 01:06:04,539
当执行EVM执行时，这些Opcodes被调用时，

670
01:06:05,079 --> 01:06:09,239
它通常有几个与之相关的数据。

671
01:06:10,519 --> 01:06:18,440
这些数据片段被哈希形成了我们所谓的主题。

672
01:06:19,299 --> 01:06:23,880
这个想法是，或者日志本身最终都以一个主题，

673
01:06:24,119 --> 01:06:26,599
然后其中的一些数据成为一个话题。

674
01:06:26,599 --> 01:06:42,519
因此，日志本身的结构决定了类似的主题，然后其中的所有数据元素也导致了主题。

675
01:06:42,519 --> 01:06:55,039
因此，这些东西都变得有点像捆绑在一起并粘在一个带有该绽放过滤器的收据中。

676
01:06:55,039 --> 01:07:09,880
好的，可以的想法是，作为一个具体的例子，ERC-20转移具有与之相关的特定主题。

677
01:07:10,739 --> 01:07:18,500
因此，想法是，实际上有很多人想知道ERC-20代币转移，因为令牌。

678
01:07:18,500 --> 01:07:29,260
这个想法是，当您在符合符合的ERC20中执行ERC20代币转移时

679
01:07:29,260 --> 01:07:38,219
合同将限制包含在收据中的特定主题的日志

680
01:07:38,219 --> 01:07:44,599
在这个花朵过滤器中，通过这样做，我们可以使应用程序容易

681
01:07:44,599 --> 01:07:49,920
为了使这些事件发生在这些事件发生时。

682
01:07:51,420 --> 01:07:58,819
现实是，我们有1900万，增长，

683
01:07:59,559 --> 01:08:00,279
我希望是

684
01:08:01,019 --> 01:08:02,860
今天早上应该看一下块号。

685
01:08:03,079 --> 01:08:04,960
我对这些事情没有足够的关注。

686
01:08:05,440 --> 01:08:07,860
我们拥有巨大的块历史

687
01:08:07,860 --> 01:08:09,599
这些块中的每一个

688
01:08:09,599 --> 01:08:11,299
正在吐出所有这些东西。

689
01:08:11,300 --> 01:08:40,900
然后，客户端客户端具有所有这些JSON RPC方法，GIT日志和所有这些 - 我不会记住所有这些方法所有这1900万个关于这些主题的街区。

690
01:08:40,899 --> 01:08:42,659
以及发生的事件。

691
01:08:44,199 --> 01:08:47,000
这很糟糕，作为客户开发人员。

692
01:08:47,879 --> 01:08:51,479
这样做，查询这些东西

693
01:08:51,479 --> 01:08:54,039
在1900万个可能的历史街区中，

694
01:08:54,279 --> 01:08:56,639
因为这些终点基本上说

695
01:08:56,639 --> 01:08:59,119
在任何数量的数据集中，

696
01:08:59,199 --> 01:09:00,779
您应该能够准确查询

697
01:09:00,779 --> 01:09:02,659
然后，正确，您应该能够

698
01:09:02,859 --> 01:09:05,219
我想知道所有ERC-20令牌，

699
01:09:05,420 --> 01:09:08,739
您能做的最糟糕的事情是问客户，

700
01:09:08,739 --> 01:09:13,679
请给我所有ERC-20代币转移，从0块0到1900万块。

701
01:09:14,279 --> 01:09:19,279
同样，这些是理论上犯的错误。

702
01:09:19,840 --> 01:09:25,979
我认为可以合理地说，用于访问日志的JSON-RPC API是一个错误。

703
01:09:27,539 --> 01:09:32,880
它具有无界的大量数据集，必须查询

704
01:09:32,880 --> 01:09:37,639
并有可能返回大量，庞大，大量数据。

705
01:09:38,739 --> 01:09:46,699
这是一团糟，这是一个不合理的API，可以为客户服务数量

706
01:09:46,699 --> 01:09:54,800
必须要继续服务这个api是令人讨厌的嗯，我不知道深处的细节

707
01:09:54,800 --> 01:10:01,079
其中，就像Geff一样，所有这些花过滤器和索引都有层和层

708
01:10:01,079 --> 01:10:08,059
能够回答您问的有关历史日志和服务这些终点的问题是

709
01:10:08,060 --> 01:10:18,060
糟糕而糟糕，所以提议是我们不再这样做了，这很简单

710
01:10:18,060 --> 01:10:24,980
嗯，那里有一个EEP，我不知道这个时间表在任何一个，但是

711
01:10:24,980 --> 01:10:32,700
但是所有这些有关是否发生ERC20代币转移的信息

712
01:10:32,699 --> 01:10:36,859
主题，所有这些东西，我们基本上都想说，

713
01:10:36,859 --> 01:10:39,859
我们只是不再这样做了。

714
01:10:39,859 --> 01:10:44,039
这是外部服务可以做的事情。

715
01:10:44,039 --> 01:10:46,859
如果您确实需要应用程序数据，

716
01:10:46,859 --> 01:10:50,059
然后构建一些精美的EVM工具

717
01:10:50,059 --> 01:10:52,300
执行每个块并监视它们

718
01:10:52,300 --> 01:10:54,779
当他们被执行并检测到事物时

719
01:10:54,779 --> 01:10:56,139
您想检测到。

720
01:10:56,139 --> 01:10:57,639
因此，这就是日志改革。

721
01:10:57,639 --> 01:11:00,460
它只是有效地删除了日志记录API。

722
01:11:02,699 --> 01:11:07,859
我相信这几乎触及了清除的每一部分。

723
01:11:08,500 --> 01:11:19,119
也许我唯一没有触摸过的是气体可观察性和气体力学，事实证明是有问题的。

724
01:11:19,119 --> 01:11:25,199
原因是在EVM中，您可以观察到有多少气体。

725
01:11:25,199 --> 01:11:45,779
并且在允许执行的代码观察天然气时的代码时，这意味着人们已经写了东西，而我写了深刻的历史，我写了一些东西，这些东西确实针对气体和气体时间表以及多少天然气编写代码。

726
01:11:45,779 --> 01:12:04,159
事实证明，通过使气体可观察到，这反过来又鼓励人们编写有关气体可观察性起作用的代码，这使我们更加复杂的是改变气体时间表。

727
01:12:04,579 --> 01:12:11,279
改变汽油计划，改变不同的Opcodes和事物的成本是我们从根本上需要做的。

728
01:12:11,279 --> 01:12:18,439
因此，这是在以太坊对象格式工作中清理的另一件事，正在发生，

729
01:12:18,679 --> 01:12:20,880
是去除气体可观察性。

730
01:12:21,420 --> 01:12:21,699
就是一切。

731
01:12:23,599 --> 01:12:25,779
好吧，我认为这就是清除的所有东西。

732
01:12:31,420 --> 01:12:37,239
所以，让我们看看。

733
01:12:37,239 --> 01:12:41,059
我看到有关旧交易类型的问题。

734
01:12:41,279 --> 01:13:09,079
我相信我们在那里看的东西，然后再用一粒盐来服用，这是随着时间的流逝，我们实施了多种新交易类型，而且我认为我们想做的是这样的整体努力尝试最终将其统一成像，希望，希望像最终类型的交易一样

735
01:13:09,079 --> 01:13:16,239
完全捕获了所有不同类型的功能

736
01:13:16,239 --> 01:13:18,460
我们希望能够通过交易进入

737
01:13:18,739 --> 01:13:21,359
从理论上讲，这一点，我们可以

738
01:13:21,579 --> 01:13:25,519
丢弃旧的原始交易类型

739
01:13:25,519 --> 01:13:28,960
并有一种现代化的交易。

740
01:13:39,079 --> 01:13:44,920
好吧，我将继续谈论门户网络。

741
01:13:46,359 --> 01:13:50,039
不知道我需要多少，但是我神奇地清洁了白板。

742
01:14:04,039 --> 01:14:07,880
所以，

743
01:14:09,079 --> 01:14:12,600
我们在这里说什么？

744
01:14:14,920 --> 01:14:24,100
因此，哪个门户是以太坊的非常专业的存储引擎。

745
01:14:25,300 --> 01:14:26,399
我不会进来。

746
01:14:26,500 --> 01:14:30,059
我在这里不到20分钟，所以我不会详细介绍。

747
01:14:30,059 --> 01:14:34,000
我在互联网上有很多演讲，我对此深入研究。

748
01:14:34,000 --> 01:14:46,880
嗯，然后，这将有些像这样的简短凝结版本。嗯，但是Portal是以太坊数据的非常专业的存储引擎。

749
01:14:46,880 --> 01:15:08,480
一般的想法是看看您需要用以太坊做事的所有数据，然后弄清楚我们如何获取这些数据，并且我们拥有了这么大的数据块。

750
01:15:08,479 --> 01:15:13,339
这是一个完整的节点，对吗？

751
01:15:13,419 --> 01:15:17,519
而且有一些，就像一个人一样，我不知道，

752
01:15:17,779 --> 01:15:20,159
就像一个数据的数据一样。

753
01:15:20,519 --> 01:15:26,419
门户网络背后的想法是我们拥有整个协议，对吗？

754
01:15:26,519 --> 01:15:31,339
在哪里，对，我们有一个块哈希，对吗？

755
01:15:31,479 --> 01:15:34,019
在那个块哈希下，我们拥有所有这些领域，

756
01:15:34,020 --> 01:15:38,580
就像交易路线，州路线以及类似的事情一样。

757
01:15:39,400 --> 01:15:41,620
而且我什至不会进入信标连锁店，

758
01:15:41,740 --> 01:15:45,880
但是，信标连锁店拥有所有这些路线和事物以及其中的内容。

759
01:15:46,400 --> 01:15:51,680
这个想法是，您需要与以太坊一起做事需要的所有数据

760
01:15:51,680 --> 01:15:56,320
以某种方式解决，对吗？

761
01:15:57,240 --> 01:16:01,260
所有这些块都有一个块哈希

762
01:16:01,260 --> 01:16:07,780
所有这些块都有一条交易路线，其中引用了一些交易列表。

763
01:16:08,420 --> 01:16:15,619
所有这些区块都有一个状态，一个州路线，引用了一些

764
01:16:15,619 --> 01:16:23,500
状态数据，对吗？和这样的事情。所有这些都以某种方式解决了。而且，我说的是

765
01:16:23,680 --> 01:16:28,220
也许是另一种说法是密码锚定的，但它已被引用，

766
01:16:28,220 --> 01:16:37,079
并以某种方式引用的是，如果我给您正确的数据，如果您有这些内容之一，则可以验证我确实确实为您提供了正确的数据。

767
01:16:38,300 --> 01:16:45,340
门户网络背后的想法是，我们已经拥有了分布式的点对点节点网络。

768
01:16:45,340 --> 01:17:08,460
为什么我们不能将其拿出来，将其切成一堆碎片，并以某种智能的计划方式将所有这些作品散布，以符合人们想要获取这些数据时使用的检索模式？

769
01:17:08,460 --> 01:17:19,460
因此，与其具有难以运行的一千个完整节点，不如

770
01:17:19,460 --> 01:17:23,420
而且这个数字也许总是有点像，我不认为它实际上是在下降，

771
01:17:23,560 --> 01:17:26,600
但是男孩，不是很大。

772
01:17:27,500 --> 01:17:32,420
而不是拥有少数重量且难以运行的完整节点，而是

773
01:17:32,420 --> 01:17:51,420
如果我们拥有一个更大的网络，该网络的网络非常较小，更简单，这些网络都坚持其中的某些部分，也许其中一些节点可以坚持更大的碎片或其他任何东西，但是我们将所有这些都拿走了，我们将其分配给我们将其放在所有这些不同的节点中？

774
01:17:51,420 --> 01:17:54,440
我的手机在响。道歉。

775
01:17:54,439 --> 01:18:03,239
因此，好时机想在那里破裂。

776
01:18:06,199 --> 01:18:18,159
考虑到这一点的另一种方法是，在当前有完整节点的范式中，您本质上已经填满了我的董事会。

777
01:18:24,439 --> 01:18:29,979
您有客户和网络，好吗？

778
01:18:29,979 --> 01:18:41,839
在当前模型中，客户端非常重，网络很轻，好吗？

779
01:18:42,319 --> 01:18:49,219
DevP2P是所有以太坊节点运行的网络，是一个非常简单的协议。

780
01:18:49,220 --> 01:18:55,680
它具有许多RPC方法，可从该网络的所有客户端检索数据段。

781
01:18:56,260 --> 01:19:01,220
该网络的所有客户端都是完整的节点，并且它使用的所有方法都非常简单。

782
01:19:01,560 --> 01:19:02,520
给我这个障碍。

783
01:19:02,680 --> 01:19:04,000
给我这个状态。

784
01:19:04,579 --> 01:19:05,560
给我这些收据。

785
01:19:07,240 --> 01:19:11,020
所以现在，对吧？

786
01:19:11,020 --> 01:19:19,580
在Portal，我们想说客户端很轻，网络很复杂。

787
01:19:20,680 --> 01:19:22,360
我不确定这是正确的词。

788
01:19:22,780 --> 01:19:29,020
但是这个想法是我想移动所有机械。

789
01:19:29,480 --> 01:19:35,780
它很重，因为它会沉没并管理状态并执行块和事情。

790
01:19:35,779 --> 01:19:53,659
我想做的事情以及我所做的事情以及我们正在做的事情是，我们将这些东西推入网络本身。我们要说的是网络，网络本身是一个完整的节点。和个别客户，他们的总和就是这样。

791
01:19:53,659 --> 01:20:12,659
因此，要做的是一个更难的事情，它是一个更复杂的网络，它是一个，但最终游戏是网络的净值是一个完整的节点，而不仅仅是一个完整的节点，而是一个存档节点。

792
01:20:12,659 --> 01:20:34,979
一个真正的全球共享存档节点是一个真正的分布式网络，它是真正的点对点，它通过许多众多较小的轻量级客户端的总和来揭示完整节点的功能。

793
01:20:34,979 --> 01:20:42,079
我不知道您还如何喜欢以太坊的客户。

794
01:20:43,539 --> 01:21:02,019
有一些很酷的替代方法，例如人们做了诸如可证明的JSON-RPC之类的事情，类似的事情，您可以在其中获得JSON-RPC响应，但可以在本地证明它们。

795
01:21:02,020 --> 01:21:17,280
但是，据我所知，所有这些仍然取决于一个完整的节点，该节点能够访问国家能够为您服务的任何调试获得证明内容。

796
01:21:17,279 --> 01:21:33,779
这仍然取决于一个完整的节点，这意味着那些轻度客户虽然非常适合浏览器上下文之类的东西，您知道，我并不是要说它们还不错，但它们不是轻的客户。

797
01:21:33,779 --> 01:21:34,759
不完全是。

798
01:21:34,979 --> 01:21:43,819
不是我喜欢的定义，我们不应该构建点对点解决方案？

799
01:21:43,819 --> 01:21:55,819
我认为这是我的电梯门户网站的要旨，现在我要看不和谐，看看人们在要求什么。

800
01:22:00,319 --> 01:22:06,420
预计门户网站客户将提供什么证据，因此不被视为水ech或启动？

801
01:22:06,420 --> 01:22:16,980
嗯，嗯，所以门户服务提供的每个数据都是密码锚定的，并且

802
01:22:16,980 --> 01:22:24,619
典型证明。所以，嗯，对于我们网络中的客户存储任何东西，嗯，它将永远

803
01:22:24,619 --> 01:22:30,680
通过任何需要的证明机制来保证，以固定自身

804
01:22:30,680 --> 01:22:36,260
规范。原因是我们必须确保您不能放垃圾

805
01:22:36,260 --> 01:22:44,500
数据进入我们的网络。我们需要一个具有固定，增长但固定量的网络

806
01:22:44,500 --> 01:22:50,340
给定时间，有一组固定的数据可行且可证明，可以存储在

807
01:22:50,340 --> 01:22:53,820
Poro网络。而且，如果您无法证明它是规范的，那么它就不能在网络中。

808
01:22:53,819 --> 01:23:02,299
嗯，我们还设计了我们所有的访问模式，呃，所以，呃，你知道，

809
01:23:02,299 --> 01:23:04,380
以访问它们的方式可证明。

810
01:23:04,840 --> 01:23:12,299
嗯，所以，食用和存储往往是非常简单的小数据包

811
01:23:12,299 --> 01:23:16,279
默克尔·帕特里夏树（Merkel Patricia Tree）证明了该树节点在州路线中，该状态

812
01:23:16,279 --> 01:23:19,039
路线是规范链的一部分。

813
01:23:19,039 --> 01:23:28,960
嗯，随着时间的流逝，这种细微差别在这一点上是一个很大的未知数，这是问题

814
01:23:28,960 --> 01:23:35,619
随着时间的流逝，我们期望有很多问题要解决，所以请考虑一下

815
01:23:35,619 --> 01:23:41,079
诸如您知道在开始之前必须提供多少服务或您知道的事情

816
01:23:41,079 --> 01:23:46,380
那句子的节点和类似的东西呢

817
01:23:46,380 --> 01:23:50,199
并说，这些对于我们来说将是一个好问题，而这些问题将很难

818
01:23:50,199 --> 01:23:56,020
各个客户团队将专注于解决的问题。所以网络本身不是

819
01:23:56,020 --> 01:24:06,000
可能根据leecher是什么或如何保护自己免受生存来定义细节

820
01:24:06,000 --> 01:24:10,279
启动了网络。而且确实没有踢开网络。这是一个分布式的同行

821
01:24:10,279 --> 01:24:14,920
无许可的同行网络。因此，没有真正的开始，但可能是

822
01:24:14,920 --> 01:24:20,840
某些客户在检测到客户时实现保护的合理合理

823
01:24:20,840 --> 01:24:27,800
也许不是通过任何指标来竭尽所能

824
01:24:27,800 --> 01:24:35,380
他们停止提供数据，或者甚至还有一个元层显示了人们的位置

825
01:24:35,380 --> 01:24:38,500
您知道，某种像黑名单或白名单之类的。

826
01:24:38,500 --> 01:24:45,380
但是，这些是我们期望解决，解决并解决道路的问题。

827
01:24:46,819 --> 01:24:53,180
为了把这东西弄出门，它很大，很复杂，我们必须切断范围。

828
01:24:53,500 --> 01:25:04,500
试图在第一天通过一个网络启动，该网络完全可以从所有这些不同类型的攻击方向上确保，这意味着我们永远都不会发货。

829
01:25:04,500 --> 01:25:11,340
嗯，所以德克的后续问题就像是多少存储和带宽

830
01:25:11,340 --> 01:25:14,640
客户是否需要参与将允许手机参与

831
01:25:14,640 --> 01:25:23,800
我认为手机上的问题将会存在

832
01:25:23,800 --> 01:25:28,760
有限的背景，但我们必须看到我认为移动可能是一个相对浸出的

833
01:25:28,760 --> 01:25:37,260
用例，因为您不想将移动带宽和电池花在服务上

834
01:25:37,260 --> 01:25:42,000
一堆数据，这意味着您的移动设备可能只参加

835
01:25:42,000 --> 01:25:46,480
在您积极使用它的时候网络，它可能会得到

836
01:25:46,480 --> 01:25:51,980
停止使用时，要快速入睡。但是我仍然没有答案

837
01:25:51,980 --> 01:25:56,600
问题，因为这将是特定于客户的事情，这将是一件事情

838
01:25:56,600 --> 01:26:02,400
随着时间的流逝，我们将不得不基本上对

839
01:26:02,400 --> 01:26:06,060
当我们看到这些问题的实际形状是什么，

840
01:26:06,260 --> 01:26:07,180
他们有多大，

841
01:26:07,240 --> 01:26:09,160
而且这可能也是一个功能

842
01:26:09,160 --> 01:26:11,120
我们的网络实际上有多大。

843
01:26:12,720 --> 01:26:15,260
我们的网络很有可能变得足够大

844
01:26:15,260 --> 01:26:18,840
我们可以吸收大量的浸出用例，

845
01:26:19,160 --> 01:26:22,380
客户有可能必须变得聪明

846
01:26:22,380 --> 01:26:24,200
并实施快速车道和慢速车道

847
01:26:24,199 --> 01:26:27,500
以及类似的东西。

848
01:26:38,099 --> 01:26:39,460
还剩七分钟。

849
01:26:40,479 --> 01:26:42,939
我很高兴回答更多问题，

850
01:26:42,939 --> 01:26:46,260
但是我认为没有有效的深度

851
01:26:46,260 --> 01:26:51,939
我将以像...

852
01:26:51,939 --> 01:27:06,859
所以，是的，您在谈话的早期提到了你们最近通过了一种特定的标记，在那里，您知道，您砸碎了足够的错误，并且准备好开始提供数据。

853
01:27:06,859 --> 01:27:17,099
您能否谈谈这一点，以及一个人如何参与网络，以及您希望人们成为什么样的人？

854
01:27:17,379 --> 01:27:17,539
是的。

855
01:27:17,699 --> 01:27:18,719
是的。他们如何参加？

856
01:27:18,720 --> 01:27:26,000
它？因此，嗯，您今天可以做的一件事就是跑一座桥。所以桥是我们的术语

857
01:27:26,000 --> 01:27:34,000
客户的客户神奇地将内容注入网络。所以，嗯，我相信有一个博客

858
01:27:34,000 --> 01:27:39,560
在门户网络博客上发布。那就是blog.eathportal.net。或许

859
01:27:39,560 --> 01:27:43,780
有人可以找到它并将其放入聊天中。嗯，我认为有一篇有关的博客文章

860
01:27:43,779 --> 01:27:51,219
跑四四个桥，东西很快腐烂。因此，我希望所有这些事情都起作用。如果

861
01:27:51,219 --> 01:27:57,479
他们没有，请告诉我们。但是现在，跑桥是您实际上可以的一种方式之一

862
01:27:57,479 --> 01:28:02,119
通过帮助我们注入所有历史四四个数据来为网络做出贡献和帮助

863
01:28:02,119 --> 01:28:11,099
进入网络。如果您想运行一个客户，那听起来很棒。但

864
01:28:11,100 --> 01:28:16,680
但是我要问的是，也许您目前没有在Nated Firewalls后面运行其中一堆。

865
01:28:17,060 --> 01:28:21,400
我们有一个路线图项目，目前我们只是故意剥夺了路线图

866
01:28:21,400 --> 01:28:26,060
因为我们还没有准备好加入人员用户。

867
01:28:26,320 --> 01:28:29,560
我们肯定准备好加入基础架构用户

868
01:28:29,560 --> 01:28:33,440
想要在数据中心和类似事物中运行事情的人，

869
01:28:33,760 --> 01:28:36,180
但是我们没有扎实的NAT遍历。

870
01:28:36,180 --> 01:28:54,980
所以，所以，我想我的意思是，就像，我希望你们能够经营门户客户，但目前我们并没有积极地营销，特别是因为添加了大量我们网络的新节点实际上是有问题的。而且我们有，我们有有关如何处理的路线图计划，但是它们还没有完成。

871
01:28:54,979 --> 01:29:11,179
嗯，如果您正在为客户工作，那么如果您在客户团队中工作，嗯，如果您，嗯，如果您有兴趣像前沿实验性的东西，那就是我们're。

872
01:29:11,180 --> 01:29:12,440
我们有四个四个数据。

873
01:29:13,000 --> 01:29:15,539
今年晚些时候，我们将为您提供状态数据。

874
01:29:15,700 --> 01:29:18,000
那真的就像是金色的赞美诗一样，

875
01:29:18,760 --> 01:29:22,000
产卵点的魔术赞美诗

876
01:29:22,000 --> 01:29:25,119
我们在哪里真正开始查看用户入职

877
01:29:25,119 --> 01:29:27,159
以及有趣的用例出现的地方。

878
01:29:27,460 --> 01:29:30,560
目前，我们四四个用例，历史案例。

879
01:29:30,680 --> 01:29:32,820
如果您想要历史数据，我们已经为您准备了它。

880
01:29:32,880 --> 01:29:34,240
我们准备为您服务。

881
01:29:34,720 --> 01:29:38,340
运行门户网站客户端和门户网站客户端，

882
01:29:38,340 --> 01:29:45,319
他们中的大多数应该有一些API，用于标准的JSON RPC API，以获取历史

883
01:29:45,319 --> 01:29:52,140
块。您可以尝试从门户网络获取历史块数据是什么。

884
01:29:52,420 --> 01:29:58,420
这就是我们所处的位置。是的，我之前说的事情开始起作用

885
01:29:58,420 --> 01:30:04,579
是我们已经建造了这个，我们的客户是复杂的机器，他们有一些错误

886
01:30:04,579 --> 01:30:07,760
他们。我们有一大堆我们放在一起的碎片，有些虫子一直在保留

887
01:30:07,760 --> 01:30:11,199
仅在线停留，内存泄漏等客户。

888
01:30:11,260 --> 01:30:12,880
这些是无聊的软件问题。

889
01:30:13,640 --> 01:30:17,320
我的团队的本质上是最近的最低点。

890
01:30:17,579 --> 01:30:19,239
你知道，他们已经在那个线程上拉了一段时间

891
01:30:19,360 --> 01:30:22,159
他们碰到了底部，一切都开始工作了。

892
01:30:22,720 --> 01:30:28,140
因此，我们在最新块数据（最近的块数据）上有100％的数据，

893
01:30:28,460 --> 01:30:32,980
而且我们只是在积极吹牛

894
01:30:32,980 --> 01:30:33,820
进入网络。

895
01:30:33,819 --> 01:30:50,439
而且我认为我们现在正在寻找一个为期两周的时间范围，从本质上击中了网络上所有以太坊块数据的99.9％。

896
01:30:53,439 --> 01:30:54,279
惊人的。

897
01:30:55,880 --> 01:30:56,719
雨云。

898
01:30:57,759 --> 01:30:59,319
我有一只大狗。

899
01:31:00,639 --> 01:31:01,719
那就是尼布斯。

900
01:31:02,299 --> 01:31:03,679
它被称为Nimbus。

901
01:31:03,819 --> 01:31:08,219
他是一个巨大的白色蓬松云。

902
01:31:08,539 --> 01:31:10,699
他不是以以太坊客户命名的。

903
01:31:11,519 --> 01:31:13,179
客户以他的名字命名。

904
01:31:13,880 --> 01:31:15,500
当然，客户以他的名字命名。

905
01:31:16,960 --> 01:31:17,299
伟大的。

906
01:31:17,500 --> 01:31:18,539
是的，非常感谢。

907
01:31:18,599 --> 01:31:21,139
我想恭喜Portal的所有进展。

908
01:31:21,319 --> 01:31:22,359
听起来很令人兴奋。

909
01:31:22,359 --> 01:31:25,840
我认为我们正在经营别人。

910
01:31:26,059 --> 01:31:27,359
不和谐中还有一些问题。

911
01:31:29,479 --> 01:31:32,059
是的，其他连锁店会有门户出口吗？

912
01:31:32,380 --> 01:31:33,299
喜欢第2层？

913
01:31:33,819 --> 01:31:36,319
因为他们还需要一个数据可用性密钥。

914
01:31:36,840 --> 01:31:37,619
啊，是的。

915
01:31:38,059 --> 01:31:39,699
我有一个快速的答案。

916
01:31:40,699 --> 01:31:44,319
因此，L2在我漫长的地平线路线图上。

917
01:31:44,639 --> 01:31:50,439
关于门户网站的问题是它是一个临界质量系统。

918
01:31:50,759 --> 01:31:55,439
因此，如果只有一个完整的节点，那么当前的以太坊网络效果很好，对吗？

919
01:31:55,500 --> 01:31:57,659
就像一个完整的节点一样，可以提供数据。

920
01:31:58,420 --> 01:32:01,960
门户需要大量的节点来存储所有节点。

921
01:32:01,960 --> 01:32:09,239
因此，从根本上讲，运行测试网的门户网站不是我们正在做的事情。

922
01:32:09,579 --> 01:32:11,779
我们有关于如何做的想法。

923
01:32:12,140 --> 01:32:23,859
但是，要运行一个测试网的门户网站可能意味着我们向其中投掷10个节点，我们自己运行的都是巨大的，而不是一堆小节点。

924
01:32:25,180 --> 01:32:28,800
因此，门户需要一个临界质量才能工作。

925
01:32:28,800 --> 01:32:44,000
因此，如果我们想为L2提供门户网站，那就很棒了，但是必须有大量的节点可以运行以达到能力，以达到服务于该数据所需的总体能力，对吗？

926
01:32:44,000 --> 01:32:51,579
对于档案的主要网络，我们要谈论的是下一年初的样子

927
01:32:51,579 --> 01:32:57,100
那一年，我不是你知道时间表是模糊的，但是今年年末，您可能会有什么可能

928
01:32:57,100 --> 01:33:02,359
从我们身上看到的东西看起来像是筹款活动，但这将是一个存储

929
01:33:02,359 --> 01:33:07,920
提高我们已经做好了所有我们准备的工作，以便您将节点带到网上

930
01:33:07,920 --> 01:33:28,279
我们已经为生活在NAT后面的消费者节点做好了准备。打开您的节点，并使用要向我们扔的多大存储配置。那太棒了。我们网络的奇妙之处在于，我们实际上可以查看网络，看看那里有多少存储空间。我们可以从网络上的节点信息中得出它。

931
01:33:28,279 --> 01:33:47,739
而且，我们将实质上为以太坊社区提供一个存储驱动器，以向我们提供200多个存储的东西，以便我们在所有以太坊状态数据中投入到所有每个人的全球档案节点，以实现世界上每个人的单个全球档案节点可以访问。

932
01:33:49,139 --> 01:33:55,599
因此，您知道，那会，我们还不到那儿，但是我们正在努力。

933
01:33:55,600 --> 01:34:02,600
是的，太神奇了。我非常期待这一点。我很高兴参加一段时间。

934
01:34:02,600 --> 01:34:07,600
我听说它起作用，尤其是是的，您的意思是，就像社区需要拥抱它一样。

935
01:34:07,600 --> 01:34:13,600
而且，我喜欢您对提交任务的说法，就像社交层一样。

936
01:34:13,600 --> 01:34:21,600
就像我想象的那样，您知道，洪流跟踪器可以思考我们可以在哪里得分并为这项工作做出贡献。

937
01:34:21,600 --> 01:34:22,960
我很高兴能加入。

938
01:34:23,960 --> 01:34:26,140
是的，我们没有时间。

939
01:34:26,280 --> 01:34:27,980
我不确定我们是否要再推。

940
01:34:28,120 --> 01:34:29,500
我认为我们应该在这里结束。

941
01:34:30,240 --> 01:34:31,600
我需要继续下一件事。

942
01:34:32,100 --> 01:34:32,940
是的，是的。

943
01:34:33,360 --> 01:34:35,140
不和谐中有一些问题。

944
01:34:35,360 --> 01:34:36,620
也许如果你加入那里，

945
01:34:37,880 --> 01:34:39,600
然后以后...

946
01:34:40,760 --> 01:34:43,260
我将在今天晚些时候通过

947
01:34:43,260 --> 01:34:44,460
当我有更多时间。

948
01:34:44,620 --> 01:34:46,760
如果有我没有解决的问题，

949
01:34:46,900 --> 01:34:50,360
我将在这个线程中高兴地回答它们。

950
01:34:51,600 --> 01:34:56,720
惊人的。是的，非常感谢，派珀。真是太神奇了。我爱白板

951
01:34:56,720 --> 01:35:02,280
以及所有解释。我学到了很多。我在门户网络中看到了您的演讲，我学会了

952
01:35:02,280 --> 01:35:07,160
今天甚至更多。所以这真的很棒。是的，非常感谢您

953
01:35:07,160 --> 01:35:09,000
这里。这是一如既往的荣誉。

954
01:35:09,000 --> 01:35:12,300
很高兴能做到这一点。

955
01:35:12,300 --> 01:35:17,560
谢谢吹笛者。每个人都在看。我们将在下周一见到大家

956
01:35:17,560 --> 01:35:21,020
预图像。谢谢。

957
01:35:21,600 --> 01:35:23,420
哦，休息和堆。

958
01:35:24,280 --> 01:35:25,039
休息和堆。

959
01:35:25,760 --> 01:35:26,000
是的。

960
01:35:26,880 --> 01:35:28,280
日历显示前图像。

961
01:35:29,220 --> 01:35:31,280
好吧，我做到了。

962
01:35:31,400 --> 01:35:32,100
这是错误的。

963
01:35:32,700 --> 01:35:34,120
GET的前图像。

964
01:35:51,600 --> 01:36:01,600
¶¶

965
01:36:01,600 --> 01:36:31,380
谢谢。

966
01:36:31,600 --> 01:37:01,579
谢谢。

