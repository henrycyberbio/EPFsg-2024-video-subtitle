1
00:00:30,000 --> 00:00:54,379
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:59,979
与Mooji一起坐着

10
00:03:00,000 --> 00:03:29,979
谢谢。

11
00:03:30,000 --> 00:03:59,979
谢谢。

12
00:04:30,000 --> 00:04:51,519
好的。

13
00:04:51,519 --> 00:04:57,019
欢迎回到以太坊协议研究小组。

14
00:04:57,019 --> 00:05:02,120
我们在第九周就在这里，还剩几周。

15
00:05:03,219 --> 00:05:08,359
今天，我们与EF Devops的Pari Tosh在一起，

16
00:05:08,680 --> 00:05:15,859
谁会谈论一些测试网，原型制作以及各种有趣的东西。

17
00:05:16,019 --> 00:05:20,639
因此，我将继续前进，让Mario在这里介绍Pari更深一些，

18
00:05:20,680 --> 00:05:22,399
我们将开始。

19
00:05:22,979 --> 00:05:23,939
感谢您在这里，Pari。

20
00:05:25,500 --> 00:05:26,279
嘿，帕里。

21
00:05:26,279 --> 00:05:35,000
在这里有宪章真是太神奇了，因为嗯，我们之前已经在马里奥演讲了

22
00:05:35,559 --> 00:05:41,639
UH Montague UM我们一直在谈论测试，我提到这对于测试很重要

23
00:05:41,639 --> 00:05:48,039
合并等等，但是如果没有pari和uh ef devops或

24
00:05:48,039 --> 00:05:55,799
当它们在合并中实际上是熊猫OPS UH团队从事UH测试工具

25
00:05:55,800 --> 00:06:02,199
UH上的原型工具在这些开发工具上，不仅是启用事物本身，还可以

26
00:06:02,199 --> 00:06:10,439
使开发人员更容易运行UH本地或公共业务UH Shadow Forks and UH，他们

27
00:06:10,439 --> 00:06:16,759
嗯，他们开发了一些工具，可以帮助您监视自己的节点和嗯

28
00:06:17,400 --> 00:06:23,319
这就是很多有趣的东西

29
00:06:23,319 --> 00:06:29,639
事情和乌巴里和爸爸是UH打破测试网并创建的一种面孔

30
00:06:29,639 --> 00:06:34,920
新的，嗯

31
00:06:34,920 --> 00:06:41,480
进入它准备演示文稿，所以舞台是您的，是的，这是一个暂时的完美

32
00:06:42,360 --> 00:06:48,120
谢谢你们再次拥有我，所以今天我要谈论UH测试和

33
00:06:48,120 --> 00:06:53,560
原型以太坊升级，这对你们中的许多人来说可能是一个有趣的话题，因为

34
00:06:53,560 --> 00:06:58,120
我假设通过协议研究，一旦完成，您将想

35
00:06:58,120 --> 00:07:04,879
尝试更改以太坊。最好的部分是因为一切都是开源的，

36
00:07:04,879 --> 00:07:12,879
您可以自己运行。可能只是，有很多学习曲线

37
00:07:12,879 --> 00:07:18,060
运行一个新的网络，您不会破坏任何东西，或者您不会破坏某人的系统。

38
00:07:18,120 --> 00:07:22,800
因此，我们一直在努力使它更容易。我们一直在尝试使原型制作的概念更加容易。

39
00:07:23,819 --> 00:07:27,139
通过此，我们还构建了许多新的测试工具。

40
00:07:27,240 --> 00:07:30,800
因此，我今天将向您介绍一些这些概念。

41
00:07:32,160 --> 00:07:35,879
因此，我想只是设置舞台的第一件事，对吗？

42
00:07:36,579 --> 00:07:40,360
以太坊具有大约20多个客户组合。

43
00:07:40,360 --> 00:07:43,500
每个月每周都有更多。

44
00:07:43,500 --> 00:07:51,399
嗯，我们最近将开始登上我们工作的lambda类长辈客户端

45
00:07:51,399 --> 00:07:56,980
上个月登上Grandin客户的登机，这感觉就像组合的数量和

46
00:07:56,980 --> 00:08:03,740
此矩阵不断增加，因为我们尝试用每一个CL测试每个EL

47
00:08:03,740 --> 00:08:11,379
因此，即使拥有一个新客户端也添加了10个新系统，用于矩阵矩阵中的10列新列

48
00:08:11,379 --> 00:08:19,000
对于我们来说，调试它们也变得非常困难，因为您可以想象您必须有点

49
00:08:19,000 --> 00:08:24,259
进入每个人都必须进入每个EL和CL的复杂性

50
00:08:24,259 --> 00:08:30,800
我们必须弄清楚如何可靠地测试所有这些事情，如果一个人跑了

51
00:08:30,800 --> 00:08:38,159
一台机器上的脚本，然后说相信我，它一直在努力，直到合并我认为我们主要是

52
00:08:38,159 --> 00:08:45,439
只是进行了单个客户端测试。因此，您会本身测试Geth，您将测试Nethermind

53
00:08:45,439 --> 00:08:48,740
本身，也许有一两个测试套件，您将在这里测试Geth和

54
00:08:48,740 --> 00:08:53,759
nethermind在一起，但没有那么多。所以在过去的两年或两年中，我们已经去过

55
00:08:53,759 --> 00:08:58,159
专注于进行此次级别测试。因此，您拥有所有这些客户

56
00:08:58,159 --> 00:09:03,299
旋转并确保它们的运作良好，无论是否

57
00:09:03,299 --> 00:09:09,699
多数客户端还是不是um，另一件事是每个升级都将继承一些

58
00:09:09,699 --> 00:09:15,899
这种复杂性，因此我们试图构建诸如此类的东西有些扩展，因此，如果您构建

59
00:09:15,899 --> 00:09:20,799
它一旦您可以在接下来的几个升级中使用它，我们就不想重新启动测试堆栈

60
00:09:20,799 --> 00:09:25,199
对于每次增加劳动的升级，都会增加很多时间，因此我们正在尝试保留

61
00:09:25,199 --> 00:09:31,139
尽可能通用的事情以及过去使用软件的任何人都可以

62
00:09:31,139 --> 00:09:36,919
要非常困难，因为我们甚至都不知道以太坊的会发生什么，所以您如何推广

63
00:09:36,919 --> 00:09:42,480
不知道正确的东西，我将介绍一下我们如何试图解决问题的方法

64
00:09:42,480 --> 00:09:49,659
至少ELS和CLS的能力是非常分开的，所以不同的团队看起来建立

65
00:09:49,659 --> 00:09:56,100
不同的客户没有多少人对整个堆栈有重叠，所以我们尝试

66
00:09:56,100 --> 00:10:01,460
分开测试的方式也有利于它。所以我们首先尝试弄清楚，

67
00:10:01,460 --> 00:10:07,460
这是CL问题吗？这是一个问题吗？然后，我们尝试升级这些方向。所以

68
00:10:08,100 --> 00:10:14,340
如果您将每个CL错误升级到所有El Devs，那就是您获得的方式，这是毫无意义的

69
00:10:14,340 --> 00:10:24,420
人们忽略错误。因此，引言的下一个步骤是我们的重要组成部分

70
00:10:24,419 --> 00:10:31,139
测试堆栈UH它们称为开发网络，因此您过去可能已经与测试网进行了互动

71
00:10:31,139 --> 00:10:37,539
主要区别在于，开发网确实大约几个月的时间很短，然后

72
00:10:37,539 --> 00:10:44,019
他们掉下来绝对没有对开发网的长期支持，甚至可能是本地人

73
00:10:44,019 --> 00:10:50,259
另一方面，他们可能只能持续半小时的测试网，我们有一个可靠的

74
00:10:50,259 --> 00:10:56,500
现在的测试网络时间表，因此您可以期待像Go Girly这样的测试网，对不起，不是Girly，但是

75
00:10:56,500 --> 00:11:02,819
Holsky和Sepolia持续一年

76
00:11:03,460 --> 00:11:10,100
因此，devnet本身是以太坊基层的um测试镜，所以它们具有相同的

77
00:11:10,100 --> 00:11:16,980
以太坊主要网拥有UH的组件，它们包含执行客户端，它们包含共识

78
00:11:16,980 --> 00:11:22,500
层，信标节点客户端，它可以包含验证器，您的MEV基础架构在那里。

79
00:11:24,259 --> 00:11:30,740
我们这样做的方式是因为我们控制了整个DEVNET生态系统，我们可以将其设置在

80
00:11:30,740 --> 00:11:36,519
无论我们想要什么配置。因此，您可以想象，无论出于何种原因，我们都想测试

81
00:11:36,519 --> 00:11:43,300
超级错误，对吗？因此，我们可以设置大多数客户端验证者正在运行

82
00:11:43,299 --> 00:11:50,819
特定的客户，我们可以模拟该事件。因此，在DEVNETS上拥有这种控制水平可以

83
00:11:50,819 --> 00:11:56,399
我们在不影响主网的情况下部署叉子和更改，而不会影响任何稳定的测试

84
00:11:56,399 --> 00:12:03,939
网络或任何东西。他们仍然是公开的，所以社区成员，所以你们，例如

85
00:12:04,279 --> 00:12:09,359
非常欢迎与我们一起测试。一个例子，现在我们没有任何

86
00:12:09,360 --> 00:12:15,800
UH PETRA DEVNET UP我们打算在接下来的几周内实现一个

87
00:12:15,800 --> 00:12:21,399
例如，人声devnets例如，您可以参加人声devnet尝试打破它，如果您

88
00:12:21,399 --> 00:12:30,560
打破它，然后它将进入修复程序，您在那里成名，嗯，喜欢

89
00:12:30,560 --> 00:12:35,320
我在您可以设计所有这些网络故障和事物之前提到

90
00:12:35,320 --> 00:12:44,740
像这样的其他地方和今天的测试更难以做，所以我们积极地是

91
00:12:44,740 --> 00:12:50,740
谈论佩特拉·德维尼特（Petra Devnet）um tbd，也许在接下来的两个星期里，你会看到一些东西

92
00:12:50,740 --> 00:12:57,800
呃，我们现在的很多重点都在工作，所以试图进行一些工作过渡测试

93
00:12:57,800 --> 00:13:02,260
确保该工具已准备好用于下一个叉子，因为我们有一些停机时间进行工作

94
00:13:02,259 --> 00:13:09,279
现在。最近，我们重新启动了Costinan Devnet，并从中发现了一些更改

95
00:13:09,279 --> 00:13:16,379
较早的迭代。我们也在做一些原型。因此，包容列表是一个强大的

96
00:13:16,379 --> 00:13:23,439
例子。另一个是EIP-7441，即WISC，您有一定数量的基层层

97
00:13:23,439 --> 00:13:29,120
验证器隐私。因此，我们也有一些长期运行的测试网。

98
00:13:29,120 --> 00:13:36,399
不仅是，对不起的开发网络可以实现这一目标，不仅仅是开发网络可以使用的未来人。

99
00:13:36,399 --> 00:13:44,340
有时目前的客户也需要某种测试，对吗？

100
00:13:44,340 --> 00:13:49,000
例如，是希望在其客户那里获得Snapsync支持的以太列赛。

101
00:13:49,000 --> 00:13:53,379
在全面的测试网上这样做很重。

102
00:13:53,379 --> 00:13:56,840
您有很多障碍，这是很多状态。

103
00:13:56,840 --> 00:13:59,200
您可能不想立即定位这一点。

104
00:13:59,680 --> 00:14:03,780
因此，我们设置了一个小规模的以太坊。JSSnapsink测试

105
00:14:03,780 --> 00:14:07,120
他们只能将其用于该用例。

106
00:14:07,660 --> 00:14:11,660
而且我们经常运行，我们称它们为大男孩信标连锁测试。

107
00:14:11,660 --> 00:14:15,920
因此，他们最大化了信标链的任何一个参数

108
00:14:15,920 --> 00:14:18,460
我们认为最大化是有意义的。

109
00:14:18,600 --> 00:14:21,480
因此一个例子可能正在增加验证者

110
00:14:21,480 --> 00:14:24,940
到一百万半验证者或200万验证器。

111
00:14:24,940 --> 00:14:30,860
这确实是我们在承诺霍尔斯基（Holsky）上的验证器的大小之前进行的测试，

112
00:14:31,120 --> 00:14:35,780
这样我们就知道客户实际上能够处理如此大的网络。

113
00:14:36,500 --> 00:14:41,720
与斑点一样。我们会垃圾邮件斑点，嘿，如果在我们的受控环境中，

114
00:14:41,880 --> 00:14:46,820
我们无法进行X斑点，我们无法在主网上执行此操作。

115
00:14:47,180 --> 00:14:52,820
因此，这种DEVNET级测试使我们能够在那里实现许多不同的事情。

116
00:14:54,940 --> 00:14:59,100
但是开发网络需要很多协调。

117
00:14:59,840 --> 00:15:02,580
您需要一群客户团队。

118
00:15:02,580 --> 00:15:08,060
您可能会期望DevOps团队建立此网络。

119
00:15:08,420 --> 00:15:12,660
而且需要一定的努力来协调每个人。

120
00:15:13,680 --> 00:15:19,860
而且我们不想总是这样做，尤其是如果我们付出了所有这些努力

121
00:15:19,860 --> 00:15:23,300
网络仅仅是因为客户没有启动而破裂

122
00:15:23,299 --> 00:15:29,059
或仅仅因为有人实施了错误的规范，这很辛苦

123
00:15:29,059 --> 00:15:35,539
努力太少了，去年的某个时候，我们意识到这一点，我们想推动我们想要的

124
00:15:35,539 --> 00:15:40,659
要大力推动本地测试，因为我可以旋转一个非常小的网络

125
00:15:41,539 --> 00:15:45,699
理智，请检查一切在我致力于更大的DEVNET之前是否有效

126
00:15:46,419 --> 00:15:52,019
因此，这也使我们进行更快的迭代，因此我可以不知道10个不同的参数

127
00:15:52,019 --> 00:15:58,100
更改超过20个不同的开发网，全部运行在一台笔记本电脑上，然后找出是的

128
00:15:58,100 --> 00:16:03,939
好吧，我在这个和那个的一个中发现了这个错误，让我们看看哪个是最佳的

129
00:16:03,939 --> 00:16:12,179
我将承诺为开发人员承诺它也使我们能够在许多功能上进行异步，因此如果客户端

130
00:16:12,179 --> 00:16:18,019
b说它们是功能完整的，我们通常会像每个人都可以使用的配置一样发布，并且

131
00:16:18,019 --> 00:16:22,179
然后，您可以更新和附加自己的客户端，看看Interop是否有效。

132
00:16:22,179 --> 00:16:27,299
而且，如果有效，那么您已经知道，当DevNet发生时，DEVNET也将起作用。

133
00:16:28,659 --> 00:16:36,179
为了帮助此局部快速迭代测试，我们还允许您配置插槽

134
00:16:36,179 --> 00:16:41,939
时间，您可以更改叉子时期版本，可以完成整个地图工作流程。所以有很多

135
00:16:41,940 --> 00:16:48,260
在这里可能会发生的非常好的事情，我将介绍几个例子

136
00:16:48,900 --> 00:16:53,540
这些本地测试的外观，我肯定想关注这一点，尤其是在

137
00:16:53,540 --> 00:16:59,220
原型的背景是因为我认为它不仅是一个非常强大的工具

138
00:16:59,220 --> 00:17:05,140
了解以太坊的工作原理，但要知道以太坊拥有的组件以及每当您感觉到

139
00:17:05,140 --> 00:17:13,700
准备如何在您自己的网络上测试自己的更改，以便您获得更多

140
00:17:13,700 --> 00:17:21,940
它的信心，我们拥有的设置也非常可扩展，我们有

141
00:17:21,940 --> 00:17:28,900
通过此工具（称为峰度）实现了这一点

142
00:17:28,900 --> 00:17:38,580
它消耗um yaml，然后通过定义通过此yaml，定义都是

143
00:17:38,580 --> 00:17:45,220
在Starlark中，这是一种基于Python的语言，它吐出的内容也是Docker

144
00:17:45,220 --> 00:17:51,860
正如Kubernetes引擎可以理解的那样，您将从YAML的定义转变为以太坊

145
00:17:51,860 --> 00:17:57,540
部署在您本地Docker机器或远程Kubernetes实例上的网络

146
00:17:57,539 --> 00:18:11,539
我们要支持这两个的原因是对于本地码头实例，如果您只想要两个，三个节点，您只想快速设置一些东西，您想看看叉子是否在五分钟内工作，然后您才能使用'完成。

147
00:18:11,539 --> 00:18:25,539
尽管我们想进行更大的测试，但要说您想要500个节点，因为您想测试某些边缘情况，或者想使用提供给您的Kubernetes层抽象，例如，混乱测试。

148
00:18:25,539 --> 00:18:31,680
测试，对吗？然后，您也需要支持Kubernetes引擎。所以我们提供了

149
00:18:31,859 --> 00:18:36,599
或者您想拥有一个可以在云中运行的更多生产系统，有人可以访问数据

150
00:18:36,599 --> 00:18:43,099
从中，您可以像云中的公共开发网络一样，可以使用Kubernetes引擎。

151
00:18:43,099 --> 00:18:48,539
都是可以配置的，您可以查看峰度文档。还有一个存储库，

152
00:18:48,539 --> 00:18:54,440
我强烈建议你们也去这个存储库。请在

153
00:18:54,440 --> 00:18:59,559
此通话过程尝试下载峰度，并确保Docker在您的本地

154
00:18:59,559 --> 00:19:06,039
机器是因为到最后，如果您想要UH并尝试运行其中一些示例，您

155
00:19:06,039 --> 00:19:12,920
有问题我们也可以谈论非常简单的问题，我我

156
00:19:12,920 --> 00:19:16,860
只是要仔细研究这个定义，因为我们将使用此定义

157
00:19:16,860 --> 00:19:24,180
稍后，您也在使用CLI的名称上，您想运行飞地是分类的

158
00:19:24,180 --> 00:19:29,920
命名空间中包含该网络将被调用的内容，而其他网络不会触摸此网络

159
00:19:29,920 --> 00:19:35,019
因此，这只是一定程度的分离，您可以在机器上有一个以上的飞地

160
00:19:35,019 --> 00:19:40,140
可以用飞地做很多有趣的事情，我们通常称其为以太坊

161
00:19:40,140 --> 00:19:46,380
网络或每个两个或您想称其为粘贴的下一个github链接

162
00:19:46,380 --> 00:19:53,600
是网络需要看起来的星球定义只是通用的理解

163
00:19:53,599 --> 00:19:58,019
例如，该定义定义了一个get节点是什么。

164
00:19:58,439 --> 00:20:02,359
它定义了YAML字段的含义。

165
00:20:02,439 --> 00:20:05,099
我该如何处理创世纪时间？

166
00:20:05,480 --> 00:20:07,279
它定义了所有这些东西。

167
00:20:07,399 --> 00:20:08,459
这是非常可扩展的。

168
00:20:08,819 --> 00:20:11,899
真正很酷的部分是如果您克隆此git存储库

169
00:20:11,899 --> 00:20:15,279
而且您要更改星星锁，甚至不需要推动它。

170
00:20:15,500 --> 00:20:19,519
您只需用dot替换该远程github URL

171
00:20:19,519 --> 00:20:22,500
或任何路径，存储库的本地路径。

172
00:20:22,500 --> 00:20:28,920
峰度会捡起它，而峰度不会在github中部署网络，它将

173
00:20:28,920 --> 00:20:34,660
部署本地计算机中定义的网络，因此您不仅可以修改参数

174
00:20:34,660 --> 00:20:41,559
在网络中，您还可以修改成为网络本身的含义，而下一个是ARGS

175
00:20:41,559 --> 00:20:47,420
文件，然后您传递一个具有一堆预定义参数的文件，我将通过

176
00:20:47,420 --> 00:20:53,519
其中一些可以通过此本地测试工具向您展示可以设置哪种类型的网络。

177
00:20:54,700 --> 00:21:02,940
因此，这是YAML定义的示例。因此，您定义参与者。你是说你想要

178
00:21:02,940 --> 00:21:12,160
一个是get tecku节点的参与者。因此，这将是EL，Tecku，Cl以及

179
00:21:12,160 --> 00:21:17,320
验证者，然后您希望一个参与者是一个幽默的思想EL和

180
00:21:17,320 --> 00:21:25,420
棱镜CL和验证器您还可以覆盖此的每个部分

181
00:21:25,420 --> 00:21:29,320
顺便说一句，我将在以后再说一遍，但每一点

182
00:21:29,320 --> 00:21:36,420
峰度的毛发病在这里不足，然后您可以在这里定义

183
00:21:36,420 --> 00:21:40,100
您想要一些其他服务，希望该网络有一个

184
00:21:40,099 --> 00:21:43,939
交易垃圾邮件发送者，以便您想要的网络上有一些交易负载

185
00:21:43,939 --> 00:21:48,419
这个网络要有斑点垃圾邮件发送者某些交易在此网络上负载一些斑点负载

186
00:21:49,299 --> 00:21:55,299
Dora是探险家，因此它将为您提供一个URL，您可以访问本地资源管理器

187
00:21:55,299 --> 00:21:59,939
您了解网络中正在发生的事情，您将收集所有指标并推动

188
00:21:59,939 --> 00:22:08,740
它是您自己的普罗米修斯实例，一个侦探者位于所有可用的API之间

189
00:22:08,740 --> 00:22:14,720
在信标API中的发动机API中与每一个发动机API之间的引擎之间，它只是吐口水

190
00:22:14,720 --> 00:22:18,420
消除该界面上正在发生的每件事，所以它是一个中间的男人

191
00:22:18,420 --> 00:22:24,460
嗯，如果您正在做新叉，并且实际上想知道嘿，这非常有用

192
00:22:24,460 --> 00:22:31,120
Cl发送了一些东西，这打破了EL，我可以弄清楚EL向我发送了什么消息，以便我可以

193
00:22:31,120 --> 00:22:36,880
重现此错误UH为我们节省了很多时间，使这种人在中间和钥匙

194
00:22:36,880 --> 00:22:41,720
启用管理器启用密钥管理器API，您可以使用密钥管理器进行任何操作

195
00:22:41,720 --> 00:22:55,040
API也是。我猜你们中的很多人都在MEV环境中，或者至少对

196
00:22:55,040 --> 00:23:03,480
MEV环境。我们还支持整个MEV工作流程有关峰度的工作流程。所以，如果这样做，

197
00:23:03,480 --> 00:23:10,759
例如，MEV类型已满，然后它将旋转本地继电器，它将旋转本地接力赛

198
00:23:12,279 --> 00:23:19,160
用于访问所有继电器验证器注册的数据库，它将旋转MEV提升，以便

199
00:23:19,160 --> 00:23:24,920
您的验证器可以连接到继电器，它将旋转一个构建器，它将使用所有开源

200
00:23:24,920 --> 00:23:29,720
图像，所以大多数来自闪存锅，您可以覆盖其中的任何一个，以防您建造

201
00:23:29,720 --> 00:23:35,160
如果您建立自己的地图提升实施或任何内容，那么您自己的继电器以及

202
00:23:35,799 --> 00:23:41,000
如果您在上一个列表中注意到参与者，请注意的一件重要的事情要注意

203
00:23:41,000 --> 00:23:47,079
而在这里没有参与者，所以每当您不指定某些内容时，

204
00:23:47,079 --> 00:23:51,880
使用默认值，默认值是我认为一个参与者在灯塔中与Geth一起

205
00:23:51,880 --> 00:23:59,160
在这个网络中会吐出的内容，在这里我们还提供了一些其他服务，所以

206
00:23:59,160 --> 00:24:10,040
因此，这种自定义洪水以及自定义洪水的作用是发送非常可延展的交易，因此建造者可以建造一些多汁的有效载荷。

207
00:24:10,500 --> 00:24:14,779
否则，构建器不会构建验证者将要提出的任何东西。

208
00:24:16,560 --> 00:24:26,400
如果您查看MEV参数，那么我的意思是我的意思，所以我正在使用自定义洪水进行启动。

209
00:24:26,400 --> 00:24:33,240
这也很早就可以了，我正在指定MEV继电器图像，这意味着您

210
00:24:33,240 --> 00:24:39,420
不再想要Kurtosis携带的默认MEV继电器图像，而是您拥有

211
00:24:39,420 --> 00:24:44,420
拥有您已经实施的MEV Boost继电器，您想在那里使用Docker Image

212
00:24:44,420 --> 00:24:51,259
因此，这也是可能的，这对我们进行快速分叉测试非常有用，因此我们可以

213
00:24:51,259 --> 00:24:56,839
具有尚未发布的最新版本在此处覆盖它

214
00:24:56,839 --> 00:25:00,680
只有当它打破某些东西时，它只会破坏我的本地测试

215
00:25:00,680 --> 00:25:05,779
环境无处

216
00:25:05,779 --> 00:25:12,500
某些参数，因此任何有意义的覆盖的参数

217
00:25:12,500 --> 00:25:16,259
共识规格有一个称为冲突或伽玛的文件，所以这是

218
00:25:16,259 --> 00:25:20,680
信标链的定义看起来像是有意义的

219
00:25:20,680 --> 00:25:25,960
覆盖我们允许您在这里覆盖，因此其中一个是每个插槽的秒

220
00:25:25,960 --> 00:25:31,720
今天每个插槽有12秒，我在这里说这太长了，我实际上并不在乎

221
00:25:31,720 --> 00:25:36,279
等待12秒我实际上并不关心最终性，我只想确保我的有效载荷

222
00:25:36,279 --> 00:25:41,720
即将交付，所以您将其覆盖每三秒钟一次，现在您有四个

223
00:25:41,720 --> 00:25:47,240
次通话的数量嗯，这意味着您要测试的任何机会

224
00:25:47,240 --> 00:26:01,319
触发或大概是四倍。所以，是的，接下来的事情是，我告诉你们

225
00:26:01,319 --> 00:26:07,640
您如何进行一些本地测试。问题现在是我如何实际原型的事情，对吗？

226
00:26:08,440 --> 00:26:13,000
因此，就像我之前提到的那样，Kurtosis在所有事物的概念上都可以覆盖

227
00:26:13,000 --> 00:26:15,799
在网络基础之外。

228
00:26:16,160 --> 00:26:20,220
因此，一个简单的示例是Mainnet规范，

229
00:26:20,279 --> 00:26:23,420
每个e-box总会有32个插槽。

230
00:26:24,000 --> 00:26:25,619
您可以尝试覆盖它。

231
00:26:25,779 --> 00:26:27,220
任何客户都不支持它。

232
00:26:27,960 --> 00:26:30,420
因此，如果需要，您可以在峰度中指定它。

233
00:26:30,500 --> 00:26:31,380
我们只是要忽略它

234
00:26:31,380 --> 00:26:33,720
因为这是一个理智的检查

235
00:26:33,720 --> 00:26:36,359
我们知道会破坏网络。

236
00:26:36,940 --> 00:26:39,059
这样，我们有很多理智检查

237
00:26:39,059 --> 00:26:43,339
这确保您不能过多打破设置。

238
00:26:43,859 --> 00:26:45,419
因此，只要您阅读文档，

239
00:26:45,500 --> 00:26:48,659
只要您更改我们在文档中指定的内容，

240
00:26:49,019 --> 00:26:50,879
有可能运作良好。

241
00:26:52,440 --> 00:26:54,940
如果您要测试协议更改，

242
00:26:55,039 --> 00:26:59,480
您可能需要更新或覆盖客户端图像本身。

243
00:26:59,639 --> 00:27:02,379
因此，您不想最新使用Nethermind。

244
00:27:02,720 --> 00:27:07,200
您可能想使用自己已经建立的nethermind叉

245
00:27:07,200 --> 00:27:09,720
为了测试新工具。

246
00:27:10,140 --> 00:27:12,140
您可以运行现有的峰度网络。

247
00:27:12,240 --> 00:27:14,180
您可以像微小的峰度网络一样运行。

248
00:27:14,720 --> 00:27:17,120
在峰度结束时，

249
00:27:17,220 --> 00:27:19,360
它将为您提供所有API端点。

250
00:27:19,580 --> 00:27:21,240
您的工具可以连接到这些API

251
00:27:21,240 --> 00:27:23,340
您可以测试构建您想构建的任何东西。

252
00:27:24,360 --> 00:27:27,340
一个例子是，我们为此构建了一个本地资源管理器。

253
00:27:27,620 --> 00:27:30,019
因此，我们不再需要同步整个网络。

254
00:27:30,259 --> 00:27:31,420
您不必做所有这些。

255
00:27:31,480 --> 00:27:34,840
您可以同步本地网络，这要快得多。

256
00:27:34,839 --> 00:27:40,000
然后，您可以确保您的探险家在做任何疯狂之前就可以按预期工作

257
00:27:40,000 --> 00:27:46,119
许多人也为他们构建的较小工具做到了这一点，所以有一个工具

258
00:27:46,119 --> 00:27:53,439
当您选择验证器以进行建议时，您可以在哪里可以通知您的CLI

259
00:27:53,439 --> 00:28:01,879
据我所知，我是由在T-Mobile工作的人建造的

260
00:28:01,880 --> 00:28:09,000
而且他正在使用峰度在本地运行它，所以请连接到当地的Devnet，所以他不是

261
00:28:09,000 --> 00:28:13,300
控制整个验证器集，他希望他的工具做很多其他事情，他有

262
00:28:13,300 --> 00:28:19,020
整个控制而无需依靠公共网络而无需花费千兆字节下载某些内容

263
00:28:19,020 --> 00:28:25,720
将其保持在同步等，如果您想像我之前显示的那样要快速测试较快的叉子，您可以更改

264
00:28:25,720 --> 00:28:30,860
叉子发生时，您可以更改的每个插槽第二个插槽，所以您可以说嘿，为什么我没有我的

265
00:28:30,859 --> 00:28:38,459
叉子已经发生在epoch的一个

266
00:28:38,459 --> 00:28:45,659
几秒钟，然后在大约两分钟内您要测试一个非常快的叉子

267
00:28:45,659 --> 00:28:51,339
当您想在想原型打字时迭代内容时，这是一个示例

268
00:28:51,339 --> 00:28:58,379
在原型测试中，人声是一只巨大的野兽，这是一个大叉子，我们一直在努力

269
00:28:58,380 --> 00:29:05,340
尽可能多地通过本地测试来支持它

270
00:29:05,340 --> 00:29:11,580
作为工人在本地过渡的过渡，如果您复制此并在Kurtosis中运行它，

271
00:29:11,580 --> 00:29:17,100
您基本上是在测试工人的过渡

272
00:29:17,100 --> 00:29:22,300
因此，发生的事情是现在我要指定参与者列表，我说我想要一个Geth

273
00:29:22,299 --> 00:29:27,980
节点和我希望Geth节点运行此特定的Docker图像此特定的Docker

274
00:29:27,980 --> 00:29:34,139
图像是由正在从事工人工作的Guillaume的Geth的叉子建造的，是的

275
00:29:34,139 --> 00:29:41,339
他正在做一个网络创世纪的过渡，并且有G11 Tech拥有的Lodestar图像

276
00:29:41,339 --> 00:29:46,299
支持工人过渡的建造，因为EL和CL都需要一个

277
00:29:46,299 --> 00:29:50,460
叉子的概念只是为了工作，我想要三个

278
00:29:50,460 --> 00:29:54,779
您可以将计数指定为您想要的任何东西，并且它将复制相同

279
00:29:54,779 --> 00:29:59,919
所有参与者的定义，然后在我的网络参数中

280
00:29:59,919 --> 00:30:05,619
指定当时被称为electra叉时期

281
00:30:05,619 --> 00:30:10,639
基于基础，所以不要关注那个特定的名字，但它是伊莱克

282
00:30:10,640 --> 00:30:18,240
epoch1因此，过渡将在epoch1上发生，网络将在大约100秒开始

283
00:30:18,240 --> 00:30:23,700
我运行我的Kurtosis命令，您可能想这样做，原因有很多原因

284
00:30:23,700 --> 00:30:31,100
UM需要花费大量时间来旋转所有UH终端窗口

285
00:30:31,100 --> 00:30:37,720
日志也许您想等待一些时间来处理您的节点必须在其中进行的处理

286
00:30:37,720 --> 00:30:41,880
也许您只是不想立即拥有它，所以您不会错过任何东西。

287
00:30:41,880 --> 00:30:46,600
因此，在这种情况下，我们只是以100秒的创世纪延迟来进行。

288
00:30:46,600 --> 00:30:50,400
然后窥探者可以启用，所以我可以看到发生的每个呼叫

289
00:30:50,400 --> 00:30:56,880
在EL和CL之间，这很早就很有用，因为CL Dev可以说，哦，

290
00:30:56,880 --> 00:30:59,180
这就是我解释规格的方式。

291
00:30:59,180 --> 00:31:03,940
我想打来这些电话，而El Dev就像是的，但这使我处于这种状态。

292
00:31:03,940 --> 00:31:06,200
也许您以这种方式发送。

293
00:31:06,200 --> 00:31:08,799
它可以帮助我们实际查看发生了什么。

294
00:31:10,059 --> 00:31:15,740
如果您想让该网络运行更长的时间，则持久性很重要。

295
00:31:16,200 --> 00:31:20,740
这只是意味着如果容器重新启动或其他任何内容，则以同一状态开始备份。

296
00:31:21,160 --> 00:31:27,680
因此，如果您坚持不懈，您可以说敬意，以阻止参与者第二。

297
00:31:28,100 --> 00:31:32,019
您可以等待10秒或其他时间，两分钟，直到建造一些块，

298
00:31:32,019 --> 00:31:34,299
然后您可以再次启动该特定实例，

299
00:31:34,299 --> 00:31:38,240
然后该实例将开始同步到链的头部。

300
00:31:38,700 --> 00:31:40,579
因此，您还可以在某种程度上测试同步。

301
00:31:41,319 --> 00:31:44,460
因此，您可以将其用于很多非常酷的东西。

302
00:31:44,660 --> 00:31:47,139
否则也可能很简单，

303
00:31:47,279 --> 00:31:50,980
嘿，如果我建立了一个客户端，然后关闭节点，然后开始备份，

304
00:31:51,180 --> 00:31:52,480
它甚至会重新开始吗？

305
00:31:53,420 --> 00:31:55,859
这也是您要测试的东西，对吗？

306
00:31:56,980 --> 00:32:00,299
是的，我想推出一些其他服务。

307
00:32:00,299 --> 00:32:05,579
服务之一是探险家多拉（Dora），另一个是我不会谈论的Certer

308
00:32:05,579 --> 00:32:12,059
现在某个嗯，我不想让你们用工具超载，但是现在有点是

309
00:32:12,059 --> 00:32:18,220
您将如何进行原型测试，因此，如果您有自己的EL叉叉，并且想测试

310
00:32:18,220 --> 00:32:26,220
您要做的就是替换El Image和Cl图像，也许是一个很好的第一个示例是分叉

311
00:32:26,220 --> 00:32:31,420
一个客户都没关系到哪一种您喜欢的语言，只需添加一些语言

312
00:32:31,420 --> 00:32:37,339
日志消息说您在这里构建一个Docker映像，然后将Docker图像放在此处

313
00:32:37,339 --> 00:32:43,180
在日志中启动网络，它将说您在这里，这是一个很好的开始，以了解如何了解

314
00:32:43,180 --> 00:32:53,019
原型测试系统将起作用，因此一旦人们对本地测试感到满意

315
00:32:53,019 --> 00:32:59,980
通常，DO会升级到远程测试。我已经提到了较早的原因，远程测试

316
00:32:59,980 --> 00:33:05,339
需要更多的同步时间。我们只有一旦我们觉得客户就准备就绪，我们就尝试这样做。

317
00:33:06,940 --> 00:33:13,740
例如，工人对正在进行的重生进行了许多本地测试，但是我们已经部署了

318
00:33:13,740 --> 00:33:21,819
一些用于公共DEVNET测试的较旧版本。即使他们确实付出了一些努力

319
00:33:21,819 --> 00:33:29,579
随着时间的流逝，我们希望使它们尽可能容易地进行设置。和

320
00:33:29,579 --> 00:33:35,500
他们曾经很容易出错且耗时，因为如何定义如何

321
00:33:35,500 --> 00:33:42,379
旋转开发网络，其中有什么参数。我认为三年前，每个团队

322
00:33:42,379 --> 00:33:49,339
在早些时候维护自己的开始测试网脚本，至少这在很大程度上是如何工作的。

323
00:33:49,339 --> 00:33:52,139
而且我确定他们仍然会这样做，而且他们做得很好。

324
00:33:53,959 --> 00:33:57,220
但是很难进行中断测试

325
00:33:57,220 --> 00:33:59,480
如果您依靠这些脚本。

326
00:33:59,659 --> 00:34:02,039
修改事物很难。

327
00:34:02,959 --> 00:34:06,419
而且漂移很容易发生

328
00:34:06,419 --> 00:34:09,519
在您可能需要的设置配置和自定义之间。

329
00:34:09,519 --> 00:34:11,759
因此，Verkle需要很多自定义

330
00:34:11,759 --> 00:34:13,840
在相当多的层面上。

331
00:34:14,059 --> 00:34:16,860
所以，我们有...

332
00:34:16,860 --> 00:34:18,759
Verkle具有特定类型的创世纪，

333
00:34:18,760 --> 00:34:27,140
而且该创世纪要求您使用另一个正在使用另一个叉子的叉子的叉子

334
00:34:27,140 --> 00:34:33,180
图书馆，大约需要三个级别的叉子，需要维护并需要维护

335
00:34:33,180 --> 00:34:38,600
现在您可以想象，如果我们在许多客户中这样做，它就开始变得非常乏味

336
00:34:38,640 --> 00:34:41,180
有一个我可能不想的巨大漂移

337
00:34:41,180 --> 00:34:48,180
您会漂移太多，以至于您可能无法在您的主要身上合并回主

338
00:34:48,179 --> 00:34:54,199
所以我们所做的就是我们分开了裸词的逻辑

339
00:34:55,219 --> 00:34:57,219
什么是节点？

340
00:34:57,379 --> 00:35:03,339
网络上需要发生什么IE生成验证器密钥获得创世纪？

341
00:35:04,279 --> 00:35:06,279
启动一个节点

342
00:35:06,639 --> 00:35:11,299
等待节点启动获取节点点对点地址

343
00:35:12,079 --> 00:35:14,199
关闭节点清理节点

344
00:35:14,199 --> 00:35:21,359
我们采用了这些通用定义，并且使用了通常写全部的我们

345
00:35:21,359 --> 00:35:26,500
在Ansible Ansible中，这些事情是我称之为花哨的脚本

346
00:35:26,500 --> 00:35:33,359
语言不是一种语言，就像一种花哨的脚本方法

347
00:35:33,359 --> 00:35:38,919
在许多节点中，很多云实例，并且有一个概念

348
00:35:38,920 --> 00:35:45,960
角色因此，角色就像一个函数，您可以调用传递一些参数以及您传递的内容

349
00:35:45,960 --> 00:35:53,480
在发生的是，我们已经将这些概念概括为这个Ansible Collection一般

350
00:35:54,280 --> 00:36:00,680
然后，我们将通用组件转移到了他们自己的工具中，因此创世纪是一个概念，

351
00:36:00,680 --> 00:36:06,440
如果您没有创世纪，几乎每个Devnet都必须在某个时候做

352
00:36:06,440 --> 00:36:13,720
网络将无法启动的Genesis文件，因此我们构建了Genesis Generator

353
00:36:13,720 --> 00:36:20,519
uh工具，它只是一个docker文件，它包含许多工具和脚本，因此有一些

354
00:36:20,519 --> 00:36:28,840
理智检查一些有关您如何称呼它的方法，但非常可配置

355
00:36:28,840 --> 00:36:34,920
处理我刚刚给您的声音的情况

356
00:36:34,920 --> 00:36:42,720
以及主网以及ShadowFox以及下一个额外的Devnet以及其中的所有内容

357
00:36:42,720 --> 00:36:48,539
一个存储库以及此存储库与Ansible连接之间的接口定义

358
00:36:48,539 --> 00:36:57,019
因此，它们以这种方式紧密结合，但是如果您想要UM，您可以同时修改，并且可以得到一个

359
00:36:57,019 --> 00:37:04,940
新的不同事物，下一个问题是工具，例如我有工作

360
00:37:05,900 --> 00:37:10,699
工作DEVNET改变了很多事情，我的探险家可能无法开箱即用

361
00:37:10,699 --> 00:37:17,340
我可能需要我的探险家的叉子，很难维持这一点，而且很难保持它们

362
00:37:17,340 --> 00:37:23,739
当网络运行时，很难将它们扩展到它，是的，您有操作问题

363
00:37:23,739 --> 00:37:31,259
我们要做的就是使用kubernetes，并且有一个名为git ops的概念，所以git ops是

364
00:37:31,259 --> 00:37:37,739
基本上，git上的东西是在您的kubernetes实例上部署的是一对一，所以您

365
00:37:37,739 --> 00:37:45,179
定义您在Github和Uh Kubernetes上想要的东西使我们使用Argo的git操作事物

366
00:37:45,179 --> 00:37:52,379
发生在您身上，这些定义通过UM另一个包装语言或包装系统发生

367
00:37:52,380 --> 00:37:58,260
称为Helm图表。因此，例如，这将为我们旋转我们的所有工具。所以

368
00:37:58,260 --> 00:38:06,800
我们现在有一种方法可以旋转以太坊节点，我们有一种方法可以旋转网络是什么，

369
00:38:06,920 --> 00:38:11,420
我们有一种方法可以旋转工具是什么。问题是，您如何带来所有这些

370
00:38:11,420 --> 00:38:17,019
一起贬低事物，对吗？所以我们做的是我们已经概括了设置

371
00:38:17,019 --> 00:38:24,420
对于所有可能进入该存储库的测试网称为模板testnet，

372
00:38:24,420 --> 00:38:28,679
什么模板测试网是

373
00:38:28,900 --> 00:38:37,840
Template TestNet具有terraform代码来旋转网络，然后使用

374
00:38:37,840 --> 00:38:45,360
当您定义它以旋转节点并旋转创世纪时，Ansible代码

375
00:38:45,360 --> 00:38:52,519
信息并获取所有这些并将其放在某个地方。然后它也旋转

376
00:38:52,519 --> 00:38:57,980
您的工具需要外观的整个定义。然后，一旦您推动了整个

377
00:38:57,980 --> 00:39:04,360
github的事情是，Gitops只是使该工具神奇地出现。因此，Gitops还确保

378
00:39:04,360 --> 00:39:11,980
您的证书出现了，您的URL看起来不错，您的URL在前面有负载平衡器，

379
00:39:11,980 --> 00:39:17,579
所有这些好东西都得到了照顾，因此将这些东西分成小

380
00:39:17,579 --> 00:39:23,500
组件，然后将它们混合在模板testnet中，当我有巨大的差异时，我可以

381
00:39:23,500 --> 00:39:28,619
在模板测试网中很好地维护它，然后将其移回模板中

382
00:39:28,619 --> 00:39:34,380
向后移动它变得很重要，这样您就可以减少发生的漂移数量

383
00:39:34,380 --> 00:39:41,179
在设置建立冲突的模板UH之间，我们成功地将其用于大约

384
00:39:41,179 --> 00:39:48,139
一年，现在我们同时进行了整个Denkoon叉子的测试，同时进行测试

385
00:39:49,099 --> 00:39:55,579
发声同时进行其他测试网，我们为我们的

386
00:39:57,339 --> 00:40:03,019
holesky节点sepulia nodes ass last so

387
00:40:03,019 --> 00:40:08,539
系统，我们对此非常满意，并不是说它没有弊端，但我会说

388
00:40:08,539 --> 00:40:12,860
一旦某人理解系统，我们将弊端尽可能最小

389
00:40:14,619 --> 00:40:22,699
嗯，我不确定我们是怎么做问题的，但也许这是一个停止问题的好地方，也许嗯

390
00:40:22,699 --> 00:40:29,420
Mario或Josh可以告诉我，这是一个好主意，是的，很好，非常感谢您，我们有

391
00:40:29,420 --> 00:40:34,460
UH讨论在这里在此法院进行，然后问问题，有时会回答您是否

392
00:40:34,460 --> 00:40:36,840
如果我能回答。

393
00:40:36,840 --> 00:40:38,619
所以我们一直在经历。

394
00:40:38,619 --> 00:40:41,220
人们在这里运行峰度。

395
00:40:41,220 --> 00:40:44,480
让我们看看你们是否对

396
00:40:44,480 --> 00:40:45,179
峰度。

397
00:40:45,179 --> 00:40:48,679
如果您遇到了一些问题或其他问题，请告诉我们。

398
00:40:48,679 --> 00:40:52,280
我还更新了当地的峰度二进制

399
00:40:52,280 --> 00:40:53,699
然后再次运行。

400
00:40:53,699 --> 00:40:56,360
过了一会儿，我不得不说它效果很好。

401
00:40:56,360 --> 00:40:59,420
快速开始非常容易

402
00:40:59,420 --> 00:41:04,099
拼凑出一些客户团队的bash脚本

403
00:41:04,099 --> 00:41:07,539
三年前运行两个测试网。

404
00:41:07,539 --> 00:41:08,779
就像它令人难以置信。

405
00:41:08,779 --> 00:41:09,279
是的。

406
00:41:11,779 --> 00:41:13,819
是的，有一个问题。

407
00:41:15,219 --> 00:41:17,619
Docker图像如何发布？

408
00:41:17,619 --> 00:41:20,779
我在Docker Hub上分享了他们的ItpandaOps。

409
00:41:21,860 --> 00:41:23,579
也许如果您可以告诉我们更多有关此的信息，

410
00:41:23,579 --> 00:41:25,819
就像如何发布图像以进行测试？

411
00:41:25,819 --> 00:41:30,420
也许您是否还使用客户团队本身的图像？

412
00:41:30,420 --> 00:41:32,019
是的。是的。

413
00:41:32,019 --> 00:41:51,980
因此，我们采取了两种方式。第一个是，也许我可以解释要开始的问题。在开始之前，每个客户团队都发布了Docker图像，他们仍然可以。但是，何时或何时触发Docker Image发布的内容会差异很大。

414
00:41:51,980 --> 00:42:04,599
因此，某些客户团队在最新的客户团队上发布，一些客户团队仅发布主品牌，有些在每个PR上发布，有些发布叉子，有些不发布叉子。

415
00:42:05,039 --> 00:42:15,480
始终在叉子上工作的开发人员始终与他们的Devops人联系以为我们建立码头图像，这真是令人头疼。

416
00:42:15,880 --> 00:42:20,420
这样做非常失控。

417
00:42:20,420 --> 00:42:28,980
因此，我们所做的是，当然，当有客户端映像时，我们会使用客户端图像，因为我认为这是一种更好的测试方式。

418
00:42:29,700 --> 00:42:38,500
但是，例如，如果没有其他叉子的早期叉子，这是基于许多其他叉子，我们就会有一个广义的Docker Image Builder。

419
00:42:38,760 --> 00:42:45,380
我在这里的私人聊天中分享了链接，也许Mario或Josh可以将其转移到其他聊天中。

420
00:42:45,380 --> 00:42:55,599
因此，此存储库能够构建每个EL和CL的客户端图像。

421
00:42:56,140 --> 00:43:02,320
有一个config.yaml文件，该config.yaml文件由计划的构建器消费。

422
00:43:02,579 --> 00:43:10,760
因此，每两个小时一次，对于我们认为可以针对的分支机构，我们会构建和先发制地发布图像。

423
00:43:10,760 --> 00:43:20,060
因此，我们发布的每个图像都会有一个广义的名称，因此最新的魔鬼都将更新

424
00:43:20,060 --> 00:43:29,800
每两个小时，以及最新的Dash Char提交slug，所以当我们进行测试时，我不想

425
00:43:29,800 --> 00:43:34,580
运行最新的话，说，嘿，我的最新消息被打破了，因为这对开发人员来说没什么意义。他们

426
00:43:34,579 --> 00:43:42,340
想知道您运行哪个提交您的跑步。因此，您可以在某些情况下选择例如CI

427
00:43:42,340 --> 00:43:47,219
测试只使用最新信息是有意义的。在某些情况下，当您进行本地测试时，

428
00:43:47,219 --> 00:43:54,900
觉得确切地指定您正在做哪种提交哈希。因此，您可以构建每个EL和

429
00:43:54,900 --> 00:44:02,259
CL，如果您转到此处的“动作”标签，我们还支持手动构建它们。你会的

430
00:44:02,260 --> 00:44:08,660
需要邀请该存储库来构建，因为它很容易垃圾邮件

431
00:44:08,660 --> 00:44:15,940
否则请求，但几乎所有想要访问访问权限的客户端都没有真实的客户

432
00:44:15,940 --> 00:44:21,780
在那边的门控，如果你们中的任何一个人真的觉得自己正在积极测试某些东西，也是如此

433
00:44:21,780 --> 00:44:28,820
您想访问此建筑商，请让我们知道UM，然后如果您选择了

434
00:44:28,820 --> 00:44:36,019
构建以太坊。在右上角，有一个运行工作流程。

435
00:44:36,480 --> 00:44:42,720
因此，我可以指定要定位哪个存储库以及哪个分支以及哪些结果

436
00:44:42,720 --> 00:44:50,580
应该调用Docker图像。这样，我可以对此进行此临时测试，嘿，我不想

437
00:44:50,580 --> 00:44:56,300
将此修复程序推入以太坊。JS主存储库。我有一个我的小叉

438
00:44:56,300 --> 00:44:58,120
没有人知道，您可以使用这个吗？

439
00:44:58,580 --> 00:45:00,240
我仍然可以从那里构建一个码头图像

440
00:45:00,240 --> 00:45:01,680
不依靠我的本地机器。

441
00:45:02,260 --> 00:45:04,280
它将建立手臂图像，它将建立

442
00:45:04,280 --> 00:45:06,420
Linux X86图像，

443
00:45:06,620 --> 00:45:08,039
它将为您构建MacOS图像，

444
00:45:08,160 --> 00:45:09,000
所有的好东西。

445
00:45:09,980 --> 00:45:11,700
然后每个人都很高兴。

446
00:45:12,240 --> 00:45:14,220
您可以定位，它总是

447
00:45:14,220 --> 00:45:15,840
导致EthpandaOps

448
00:45:15,840 --> 00:45:17,900
客户名称Docker映像。

449
00:45:22,519 --> 00:45:24,300
是的。我希望那样

450
00:45:24,300 --> 00:45:26,240
回答了有关码头图像的问题

451
00:45:26,239 --> 00:45:31,679
通常，我们通常是我们消耗它们的方式，是的，是的，完全做了

452
00:45:31,679 --> 00:45:39,119
分享我的屏幕显示实际的u，如果uh丢失了UH演示文稿，只是想要

453
00:45:39,119 --> 00:45:44,799
为了证明真棒的是的，非常感谢Barry UM非常感谢您这样做，并且

454
00:45:44,799 --> 00:45:51,279
如果有任何问题或峰度，您仍然可以继续询问是的，也许我们可以

455
00:45:51,280 --> 00:45:55,200
在我们前进之前，请再问一个问题

456
00:45:59,600 --> 00:46:07,120
嗯，我可以指向当地的峰度，还是只有远程存储库或dicker图像的分叉

457
00:46:07,760 --> 00:46:14,640
因此，您还可以将峰度指向本地任何事物，因此，如果您不想使用GitHub，

458
00:46:14,640 --> 00:46:20,720
削减任何东西，然后如果您将其指向点斜线，然后放置相对路径，然后

459
00:46:20,719 --> 00:46:26,559
它只是使用本地是的，是的

460
00:46:26,559 --> 00:46:32,719
关闭存储库，然后迅速进行修改，这是非常非常好

461
00:46:32,719 --> 00:46:40,079
您可以提供一条本地路径，嗯，真棒，是的，整个库尔托萨

462
00:46:40,079 --> 00:46:45,759
设置是完全开源的，您可能会弄乱峰度本身

463
00:46:45,760 --> 00:46:50,560
定义您可能会弄乱基本上想弄乱整个堆栈开源的任何东西

464
00:46:52,480 --> 00:46:56,880
好吧，太棒了，谢谢你巴里，我想我们可以继续演讲

465
00:46:57,520 --> 00:47:05,600
它回到了完美的问题，所以下一个是一个加载的主题um shadowfox

466
00:47:05,600 --> 00:47:11,360
因此，您可能已经在合并的背景下听说过Shadowfox

467
00:47:11,360 --> 00:47:17,760
发生的所有单一以太坊升级都会发生，因此阴影叉使我们能够

468
00:47:19,360 --> 00:47:25,440
从本质上讲，您要做一个主网络，然后分叉，但要分叉

469
00:47:25,440 --> 00:47:31,920
仅在一小部分节点中，因此您继承了主要网络

470
00:47:31,920 --> 00:47:39,599
主网络的状态，但是如果您配置了叉子，那么您就在微小的影子链中分叉

471
00:47:39,599 --> 00:47:46,699
下一个图中有一个不错的视觉效果，但是在我们到达那里之前，进行此设置有帮助我们

472
00:47:46,699 --> 00:47:51,980
在整个生命周期中了解和检查客户之间的兼容性。所以

473
00:47:51,980 --> 00:47:59,639
您本质地构建了一个主网块。例如，以太坊的主网

474
00:47:59,880 --> 00:48:05,139
拒绝您的区块，因为它是非典型的。但是您已经完成了建设的过程

475
00:48:05,139 --> 00:48:13,059
主网块，这是我测试观点的重要组成部分。这使我们可以检查很多

476
00:48:13,059 --> 00:48:19,699
例如，例如，当我们进行斑点测试时，如果出于何种原因进行blob测试

477
00:48:19,699 --> 00:48:26,579
Blob并验证Mainnet状态大小是不可行的，我们会在这里看到这一点。这

478
00:48:26,579 --> 00:48:33,619
合并非常有价值，因为我们将设定一个刚刚发生的替代TTD

479
00:48:33,619 --> 00:48:39,059
将来有几个街区。当我们这样做时，您实际上是在模拟合并

480
00:48:39,059 --> 00:48:44,099
没有接触主要的以太坊，这是一种非常强大的测试工具。

481
00:48:45,839 --> 00:48:50,039
您正在压力测试客户，这将尽可能接近主网，

482
00:48:50,039 --> 00:48:54,739
或尽可能靠近您的任何网络分叉。所以它带有所有

483
00:48:54,739 --> 00:49:03,919
那些假设。由于点对点的工作方式，您仍然凝视着主要网络

484
00:49:03,919 --> 00:49:10,859
大量时间。因此，您仍在导入交易负载。因此，如果Mainnet以太坊

485
00:49:10,859 --> 00:49:16,539
有一百件事在一个街区中发生的交易，您的Shadowfork也有

486
00:49:16,539 --> 00:49:22,159
包括这些交易。并非所有人都可能

487
00:49:22,159 --> 00:49:29,039
它们不会以相同的方式被包括在内，但从根本上讲，它们包括在内

488
00:49:29,039 --> 00:49:37,199
对于压力测试网络的性能真的很有用，是的，您正在控制

489
00:49:37,199 --> 00:49:42,559
整个验证器集，因此您可以照顾网络的需要，并且它充当

490
00:49:42,559 --> 00:49:48,879
发布测试，因此这是我们看到的测试DEVNET测试网络周期的最后阶段

491
00:49:48,880 --> 00:49:50,340
它将按预期工作。

492
00:49:52,180 --> 00:49:55,980
因此，我将原则上简单地对此进行序言。

493
00:49:55,980 --> 00:50:00,220
这很简单，但这有点像是一个硬性的概念

494
00:50:00,220 --> 00:50:02,559
一开始就gro吟着。

495
00:50:02,559 --> 00:50:07,059
因此，您要做的是忽略它正在使用Girly。

496
00:50:07,059 --> 00:50:08,260
我没有更新幻灯片。

497
00:50:08,260 --> 00:50:10,640
到目前为止，应该是波尔斯基或索波里亚

498
00:50:10,640 --> 00:50:13,700
但是，是的，好的，几乎是一样的。

499
00:50:13,700 --> 00:50:15,099
所以几乎一样。

500
00:50:15,099 --> 00:50:16,599
所以几乎一样。

501
00:50:16,599 --> 00:50:24,000
到现在为止

502
00:50:24,000 --> 00:50:30,480
Girly Genesis文件您可以在GitHub Slash Eth dash客户端中找到此存储库

503
00:50:30,480 --> 00:50:38,360
嗯，每个testnet都在所有Genesis Files存在的位置，我修改了Genesis文件，所以忘记了

504
00:50:38,360 --> 00:50:46,920
这是Genesis.json和我添加了一个叉时间戳。所以我说佩特拉时间戳结肠

505
00:50:48,280 --> 00:50:56,920
从现在起一个小时。现在，我建立了一个带有验证器的新的信标连锁店，也有

506
00:50:56,920 --> 00:51:02,920
Electra叉在相同的精确时间戳和存款合同点配置

507
00:51:02,920 --> 00:51:11,159
到较早的少女链，所以现在您所做的就是您有一部分验证器

508
00:51:11,159 --> 00:51:18,360
在一条新的信标链中，了解叉子发生何时发生

509
00:51:18,360 --> 00:51:24,360
带有修改的Genesis JSON文件的节点，认为应该在某个时候发生叉子

510
00:51:24,360 --> 00:51:29,720
网络中没有其他Golly节点只有此配置，因此

511
00:51:29,719 --> 00:51:35,480
时间戳被击中，因此在这种情况下，当TTD击中时，规范链，

512
00:51:35,480 --> 00:51:39,679
您或我或其他任何人正在使用的少女链，只是继续好像

513
00:51:39,679 --> 00:51:46,000
什么都没有发生。但是我使用此修改后的Girly配置的本地节点会认为

514
00:51:46,000 --> 00:51:54,139
叉子已经发生了，因此他们将执行叉子代码。而且由于El只是

515
00:51:54,139 --> 00:52:02,519
当CL告诉它并配置CL时，将构建块

516
00:52:02,519 --> 00:52:11,420
时间戳它将建立在最后一个规范的少女块之上，但是这个新的卷曲块

517
00:52:11,420 --> 00:52:16,940
在主链中是无效的

518
00:52:16,940 --> 00:52:23,379
或识别但在我的受控验证器设置中，所有人都没有人识别该验证者

519
00:52:23,380 --> 00:52:30,240
他们接受。因此，我本质上所做的就是派遣EL建立在少女状态的顶部

520
00:52:30,240 --> 00:52:36,579
但仅仅是我的验证者子集。没有人有任何迹象。

521
00:52:37,760 --> 00:52:44,360
这个新的链子建立在无限的基础上。每个在少女上保持平衡的人也会

522
00:52:44,360 --> 00:52:50,619
在这个阴影叉上保持平衡。当然，一些复杂性，但这本质上都是

523
00:52:50,619 --> 00:52:57,480
您在现有网络之上构建的与您构建的一样

524
00:52:57,480 --> 00:53:02,839
最重要的是有一些mempool复杂性，我不会真正进入这里，但是您会留下来

525
00:53:02,839 --> 00:53:08,019
凝视您仍然会从孟买的一定时间慢慢地从孟买那里获取

526
00:53:08,019 --> 00:53:12,719
由于您正在按照不同的订单分配交易，因此将继续分歧

527
00:53:12,719 --> 00:53:20,059
一段时间后，余额失去同步，然后您停止与主网络凝视，然后

528
00:53:20,059 --> 00:53:23,900
Shadowfork只是它自己的事，将继续直到您关闭它。

529
00:53:24,539 --> 00:53:28,699
但是在那一段时间内，它一直连接到主网络，这非常非常

530
00:53:28,699 --> 00:53:33,820
有价值的。基于大多数测试，这段时间并不小，它停留在两天的时间里，

531
00:53:33,820 --> 00:53:38,460
三天，取决于您的网络大小和交易数量以及您的工作

532
00:53:38,460 --> 00:53:47,820
这个影子福克等。我知道在上一个问题会议之后很快，但通常

533
00:53:47,820 --> 00:53:53,660
ShadowFox，由于这是一个大主题，所以我想在谈论什么之前先停止提问

534
00:53:53,660 --> 00:53:57,580
我们拥有的工具以及在测试世界中可以玩的东西。

535
00:54:00,620 --> 00:54:05,820
是的，谢谢Pari。所以Shadowfox非常令人兴奋，我喜欢跟随他们，看看什么

536
00:54:05,820 --> 00:54:10,940
节点下降了，这给了我们这种令人兴奋的感觉

537
00:54:10,940 --> 00:54:22,280
它总是像一个小月亮休息室或类似的东西。

538
00:54:22,280 --> 00:54:25,159
我正在等待一些问题进来。

539
00:54:25,159 --> 00:54:28,340
也许当我们在等待时，我发送了一个链接，

540
00:54:28,340 --> 00:54:31,079
您可以打开此链接，然后我

541
00:54:31,079 --> 00:54:35,760
可以展示正在发生的事情。

542
00:54:35,760 --> 00:54:40,360
因此，您实际上可以，我们将Shadowfox添加到OpScore中，

543
00:54:40,360 --> 00:54:45,320
狐狸到峰度，因此您可以像单行的阴影叉一样，只需使用峰度命令

544
00:54:45,320 --> 00:54:53,000
我们每晚都会用CI进行声音UM进行此操作，所以我以后也谈论此事，我

545
00:54:53,000 --> 00:54:58,360
认为我稍后在幻灯片中链接了它，也许是因为我们在这里或您可以打开链接

546
00:55:00,599 --> 00:55:08,920
所以嗯，您在这里看到的是Kurtosis config um，因为您仅在三个小时前就更新了

547
00:55:08,920 --> 00:55:12,079
这是一个现场测试系统，对吗？

548
00:55:12,079 --> 00:55:16,079
因此，Guillaume正在努力重新审议工作代码库

549
00:55:18,039 --> 00:55:19,500
如此的过渡

550
00:55:19,500 --> 00:55:23,500
以及创世记也发生在同一事物中

551
00:55:23,500 --> 00:55:25,139
它有一个概念。

552
00:55:26,320 --> 00:55:29,360
因此，这是我们正在测试的重新观察。

553
00:55:29,360 --> 00:55:31,760
我们定义了一次负载星获得

554
00:55:31,760 --> 00:55:35,240
有一次，这一次都是负载星，

555
00:55:35,240 --> 00:55:36,820
您也可以更改二

556
00:55:36,820 --> 00:55:40,260
并实现同样的事情。

557
00:55:40,260 --> 00:55:45,380
我希望Electra发生在Epoch Fort 1上，所以这是工作将实际上过渡的时候

558
00:55:45,380 --> 00:55:46,380
发生。

559
00:55:46,380 --> 00:55:54,880
在这里，我正在进行网络holeski-shadowfork-workl和网络同步基础URL，这是我们

560
00:55:54,880 --> 00:55:59,760
在本地运行它，因此我们有一个带有Holeski快照的S3桶。

561
00:55:59,760 --> 00:56:05,880
因此，这是什么是，Kurtosis将转到此IP地址并获取S3桶

562
00:56:05,880 --> 00:56:11,160
拥有整个霍尔斯基州

563
00:56:11,880 --> 00:56:20,440
它将有一个在一个时期发生的声叉，所以在这种情况下唯一缺少的部分

564
00:56:21,160 --> 00:56:28,440
是我怎么知道过渡成功或不正确，只是为了撒一些洒水

565
00:56:28,440 --> 00:56:33,880
明确的是，我们在kubernetes群集上执行此操作，因此，如果您看到全局节点选择器UM

566
00:56:33,880 --> 00:56:38,599
除了我们的kubernetes实例之外，这对其他任何人都没有什么意义

567
00:56:38,599 --> 00:56:42,440
将在知道如何访问该IP地址的一台计算机上运行此过渡。

568
00:56:42,440 --> 00:56:50,300
因此，我们正在运行另一种称为Asserta的工具，您可能已经看到一次或两次

569
00:56:50,300 --> 00:56:54,940
将来，我会更深入地了解它的作用，但Asserta所做的是

570
00:56:54,940 --> 00:57:02,820
它检查并断言某个条件是真或错误，在这种情况下，Asserta是

571
00:57:02,820 --> 00:57:06,059
正在获取此测试定义，

572
00:57:06,059 --> 00:57:08,059
工作将转换检查，

573
00:57:08,059 --> 00:57:10,880
每个时期左右都可以检查

574
00:57:10,880 --> 00:57:13,180
如果工作或过渡是成功的。

575
00:57:13,180 --> 00:57:15,059
因此从CI的角度来看，

576
00:57:15,059 --> 00:57:18,120
这是每天一次

577
00:57:18,120 --> 00:57:21,240
我正在从Guillaume的叉子中摘下最新图片，

578
00:57:21,240 --> 00:57:23,780
我正在获取最新的Holsky快照，

579
00:57:23,780 --> 00:57:26,039
我正在完成整个工作或过渡，

580
00:57:26,039 --> 00:57:28,740
然后Asserta会给我一个tick或十字架

581
00:57:28,740 --> 00:57:31,360
在GitHub CI中告诉我是否过渡

582
00:57:31,360 --> 00:57:36,880
昨晚的成功或不嗯，您也可以手动触发此功能，因此，如果我做出了很大的更改

583
00:57:36,880 --> 00:57:42,400
在我合并PR之前，我想确保它可以正常工作，我可以做到这一点，这只是

584
00:57:42,400 --> 00:57:49,840
一个工作的一个例子，没有理由不可能发生这种情况，否则您也可以

585
00:57:49,840 --> 00:57:56,000
如果您没有指定网络同步基础URL，则在计算机上本地运行此操作

586
00:57:56,000 --> 00:58:01,920
在本地同步一个holesky节点，这没什么大不了的，只需花费更多的时间，所以您可能想

587
00:58:01,920 --> 00:58:07,199
添加更大的起源延迟，但100秒就足以让本地网络拉动快照，因此

588
00:58:07,199 --> 00:58:08,639
我们正在运行它

589
00:58:12,880 --> 00:58:18,000
非常感谢您向我们展示了这个UM，因为有一个问题

590
00:58:18,000 --> 00:58:23,760
那里像什么工具可以为它运行阴影，所以你只是是的，所以有一个示例

591
00:58:23,760 --> 00:58:38,300
那里，也许还有另一个快速示例，应该是，所以我会发送

592
00:58:38,300 --> 00:58:44,880
您另一个链接一秒钟，如果您可以打开此链接

593
00:58:44,880 --> 00:58:56,640
马里奥

594
00:58:59,519 --> 00:59:07,200
是的，所以这是我们的UM CI跑步者，用于UM kurtosis本身，我们想测试

595
00:59:07,200 --> 00:59:11,920
我们没有破坏任何功能，所以我们只是定义了您的广泛的内容

596
00:59:11,920 --> 00:59:19,200
可以使用峰度，然后CI在PR um之前将其运行，因此，如果您需要示例

597
00:59:19,200 --> 00:59:25,039
如何配置某个东西这是值得的地方，例如，您可以看到Hoski Shadow

598
00:59:25,039 --> 00:59:35,039
叉子工作在挂钩上没有跑步，是的

599
00:59:35,039 --> 00:59:45,119
并查看下一个示例嗯，所以不工作是，所以这个示例就是你在哪里

600
00:59:45,119 --> 00:59:52,079
做一个沙哑的影子叉，将运行最新版本的Get Teku，这是没有复杂性的

601
00:59:52,079 --> 00:59:57,759
当然，您必须为Kipok设置Denkoon，因为整个滑雪网络已经拥有

602
00:59:57,759 --> 01:00:04,639
denkoon um，然后这将为您旋转一个探险家，这就是所有文件

603
01:00:04,639 --> 01:00:07,579
因此，您可以随心所欲地玩Shadowfox，

604
01:00:07,579 --> 01:00:09,900
单个单线，您可以覆盖图像

605
01:00:09,900 --> 01:00:11,239
如果您想测试更改，

606
01:00:11,239 --> 01:00:13,940
是的，可以做很多事情，

607
01:00:13,940 --> 01:00:17,699
我们也支持Ephemery。

608
01:00:17,699 --> 01:00:19,779
是的，你可以，顺便说一句

609
01:00:19,779 --> 01:00:23,059
还使用峰度来同步实时网络。

610
01:00:23,059 --> 01:00:25,239
因此，如果您回到Ephemery，

611
01:00:27,579 --> 01:00:31,599
这将使所有这些参与者旋转

612
01:00:31,599 --> 01:00:33,159
并将它们配置为同步

613
01:00:33,159 --> 01:00:35,039
最新的迭代迭代。

614
01:00:36,440 --> 01:00:38,639
不需要别的，您可以同步到短片

615
01:00:38,639 --> 01:00:42,440
就是这样，您可以更改以成为主网，

616
01:00:42,440 --> 01:00:44,199
我真的不推荐主网

617
01:00:44,199 --> 01:00:46,420
因为峰度是一种本地测试工具，所以

618
01:00:46,420 --> 01:00:49,659
这并不是要用于主网级别，

619
01:00:49,659 --> 01:00:53,039
一个Terabyte节点，您的笔记本电脑会填满，

620
01:00:53,039 --> 01:00:55,819
我们只在Kubernetes上进行主网，

621
01:00:55,819 --> 01:00:58,519
但是你可以做波尔斯基，塞波利亚，无论它是什么，

622
01:00:58,519 --> 01:01:01,079
它将同步您指定的网络。

623
01:01:01,079 --> 01:01:07,239
如果您这样做的命名约定，我们也会尝试标准化事物，因此它始终是网络名称

624
01:01:07,799 --> 01:01:13,400
破折号阴影叉如果您想做dash shadow fork，然后在那之后发声

625
01:01:13,400 --> 01:01:18,119
发生了一些创世纪的魔法，它使用了声乐创世纪信息

626
01:01:20,119 --> 01:01:27,799
是的，很棒的是的，非常感谢，非常有趣的是

627
01:01:27,800 --> 01:01:40,940
包装储备金，因此在阴影叉上有一些问题，我们如何定义

628
01:01:40,940 --> 01:01:47,900
成功的过渡只是客户没有失败，但是您有一些

629
01:01:47,900 --> 01:01:56,059
按照您通常为我们测量的测试的定义，现在过渡成功

630
01:01:56,059 --> 01:02:03,820
只是如果所有节点都处于同一头部，并且我们正在与Get Guys一起工作

631
01:02:03,820 --> 01:02:10,700
知道过渡何时完成的API，然后我们是的，我们只等待它们都在

632
01:02:10,700 --> 01:02:16,220
我认为同一头和日志中，这是正在进行的交易或其他

633
01:02:16,219 --> 01:02:21,500
但是，是的，我们想通过API进行配置，以便您可以查询API

634
01:02:21,500 --> 01:02:24,779
它说正在进行的过渡或过渡完成。

635
01:02:24,779 --> 01:02:27,559
谢谢。

636
01:02:27,559 --> 01:02:35,019
还有一个问题，您是否可以运行新验证器，从Shadowforks中删除验证器，

637
01:02:35,019 --> 01:02:38,459
您是否正在进行进一步的测试？

638
01:02:38,459 --> 01:02:40,299
你能再说一遍吗？

639
01:02:40,299 --> 01:02:41,599
如果您运行新验证器？

640
01:02:41,599 --> 01:02:47,059
是的，如果您在影子之后，无论是您参加的测试之一还是可以做的测试之一

641
01:02:47,059 --> 01:02:51,019
就像这样做，将其存入您的是。

642
01:02:51,019 --> 01:02:58,219
因此，当我向大家介绍它时，我会谈论这个特定的问题。

643
01:02:58,219 --> 01:02:59,779
但是目前，答案是肯定的。

644
01:02:59,779 --> 01:03:01,480
我会告诉你如何。

645
01:03:01,480 --> 01:03:02,480
好吧，很棒。

646
01:03:02,480 --> 01:03:03,480
惊人的。

647
01:03:03,480 --> 01:03:04,480
太感谢了。

648
01:03:04,480 --> 01:03:14,880
有一些问题，以调查峰度的问题，

649
01:03:14,880 --> 01:03:17,860
但这是一个日志，所以也许我们可以稍后再留下来。

650
01:03:17,860 --> 01:03:19,740
是的。

651
01:03:19,740 --> 01:03:23,599
Kurtosis的家伙也有不和谐。

652
01:03:23,599 --> 01:03:25,920
他们有一个产品支持页面。

653
01:03:25,920 --> 01:03:28,320
请随时放在那里。

654
01:03:28,320 --> 01:03:29,699
因为我们积极改变了东西，所以

655
01:03:29,699 --> 01:03:31,099
有时我们也会破坏东西。

656
01:03:31,099 --> 01:03:33,420
但是我们尽可能地尝试不破裂。

657
01:03:34,480 --> 01:03:43,039
很棒的帕里，继续前进，我们将解决问题。

658
01:03:43,039 --> 01:03:48,800
我认为我们的剩下的电话大约有大约半小时。

659
01:03:48,800 --> 01:03:53,280
这应该足以完成问题。

660
01:03:53,280 --> 01:03:57,960
好的，因此概述了方便的工具。

661
01:03:57,960 --> 01:04:01,019
我们有一个网站EthpandaOps.io。

662
01:04:01,019 --> 01:04:08,059
访问网站非常不言自明该工具在顶部有一个工具页面

663
01:04:08,059 --> 01:04:14,980
是的，您可以看到我们维护的所有工具以及我们拥有的所有工具

664
01:04:14,980 --> 01:04:19,360
除了一些有关如何使用它们的博客文章，还有更多的博客文章

665
01:04:19,360 --> 01:04:25,259
下周本周即将到来，我们构建的每个工具的所有代码库

666
01:04:25,260 --> 01:04:33,100
可以在github中找到一切都是开源的，除了我们的逻辑是工具始终打开

667
01:04:33,100 --> 01:04:38,920
根据是否有秘密或其他任何可能不是开源的配置，而是每个配置

668
01:04:38,920 --> 01:04:44,140
单个工具从许可的角度来看，我们拥有的每个测试都是开源的

669
01:04:44,140 --> 01:04:53,300
使用麻省理工学院有时可能是GPL AGPL

670
01:04:53,300 --> 01:05:00,280
制作PR，添加功能。当人们添加功能时，我们非常高兴。是的，也很乐意修改

671
01:05:00,280 --> 01:05:07,600
我们支持其他任何人的工具。我们经常，工具被其他网络重新使用。他们被用了

672
01:05:07,600 --> 01:05:15,620
由L1S，L2S。像Obal这样的一些DVT家伙也使用了一些工具。所以我们试图容纳

673
01:05:15,620 --> 01:05:22,780
每个人的需求，以便还可以更好地维护。这就是您建立生态系统的方式

674
01:05:22,780 --> 01:05:29,420
周围而不是每个人都在孤岛上建立自己的东西，嗯

675
01:05:29,420 --> 01:05:37,180
伙计们和我将确保稍后将其放在一些聊天中或复制时，但是有

676
01:05:37,180 --> 01:05:42,540
一个测试概述文档，所以马里奥和我在上周花了一些时间来编译它

677
01:05:42,540 --> 01:05:49,820
还没有用尽，但我们到达那里的目的是定义我们

678
01:05:49,820 --> 01:05:59,740
具有谁是维护者，工具的作用以及堆叠的哪一层

679
01:05:59,740 --> 01:06:12,940
正在接触或测试。所以请看看这个。当我们进入Pectra时，

680
01:06:12,940 --> 01:06:18,460
我们还将使用此测试概述文档尝试并了解我们应该测试的顺序

681
01:06:18,460 --> 01:06:24,539
如果您有兴趣测试，则可以在不同团队之间更好地协调一点

682
01:06:24,539 --> 01:06:30,860
本身发现一个项目开始贡献一个项目，通常会关注Ith r d Interop

683
01:06:31,980 --> 01:06:36,539
您可能会注意到哦，这很难

684
01:06:36,539 --> 01:06:43,900
捡起它的工具使现有工具的公关通常增加对新叉的支持，通常是

685
01:06:43,900 --> 01:06:49,420
Neofock的定义是我们必须为某些库做一些PR的列表

686
01:06:49,420 --> 01:06:54,619
某些用于工具的创世纪工具可以帮助我们使这些PRS成为学习的好方法

687
01:06:54,619 --> 01:07:02,460
一个新所库奇

688
01:07:02,460 --> 01:07:08,940
想一想的详细思考，所以我不会更多地涉足峰度嗯，请看看

689
01:07:08,940 --> 01:07:17,179
在GitHub测试中加入它是以太坊Kato对不起的kurtosis Discord Chat UH服务器

690
01:07:17,179 --> 01:07:22,780
如果您有疑问，他们有一个很好的支持团队UM是的，就像我说的一切一样

691
01:07:22,780 --> 01:07:29,900
开源可以随意使用模板Devnets随意使用它，所以我确实提到了

692
01:07:29,900 --> 01:07:37,659
模板Devnets UH存储库正在结合所有这些不同的Ansible Terraform以及

693
01:07:37,659 --> 01:07:44,539
创世纪文件和所有这些都成为一个连贯的存储库。因此，Github具有此功能

694
01:07:45,420 --> 01:07:51,659
您可以从模板中分配存储库，也可以像实现模板一样，对吗？

695
01:07:52,460 --> 01:07:56,859
因此，如果您转到模板测试网络，则应在某处说使用此按钮

696
01:07:56,859 --> 01:08:02,219
模板。那将要做的是它将在您的模板中创建一个新的存储库

697
01:08:02,219 --> 01:08:08,779
命名空间，我们通常会这样做

698
01:08:08,779 --> 01:08:16,219
它会说从模板测试网或模板测试网的一部分中分叉，所以如果您想

699
01:08:16,219 --> 01:08:21,420
了解我们的模板和工作之间的整个差异，只是在主和主之间和

700
01:08:21,420 --> 01:08:28,939
您将看到带扣测试所需的所有更改，如果您想

701
01:08:28,939 --> 01:08:34,299
如果您想运行自己的以太坊节点，则在更大范围内运行节点，所以我运行以太坊节点

702
01:08:34,299 --> 01:08:40,479
在家里，我们在办公室运行以太坊节点，我们使用此确切的基础设施来完成所有操作

703
01:08:40,479 --> 01:08:47,179
它非常兼容，这是非常安全的，请随时使用它，没有太多的魔法发生

704
01:08:47,179 --> 01:08:55,379
这是一旦本地测试工具不足，您通常会进行的测试水平

705
01:08:55,380 --> 01:09:03,079
它往往会在叉子过程中发生一点，因此，如果有人质疑它，我会说花

706
01:09:03,079 --> 01:09:08,140
更多的时间峰度，因为使用模板testnet，您需要知道您是什么可接管的

707
01:09:08,140 --> 01:09:13,180
需要知道什么是Terraform，然后才能真正开始做事，例如

708
01:09:13,180 --> 01:09:19,600
旋转一个Terraform一堆云实例，Terraform也将花费您

709
01:09:19,600 --> 01:09:25,000
钱，而在峰度中，最糟糕的事情可能是您有一个码头容器

710
01:09:25,000 --> 01:09:31,239
跑步太久了。那里没有风险。所以玩模板

711
01:09:31,239 --> 01:09:38,359
测试网，尤其是如果您是一个希望扮演更多Devops-y角色的人，

712
01:09:38,359 --> 01:09:42,920
对DevOps的工作原理有了更深入的了解，这是去的地方。

713
01:09:45,000 --> 01:09:51,960
因此，对于大个子来说，Asserta。因此，您可以在IthpandaOps下找到Asserta存储库。

714
01:09:51,960 --> 01:09:57,659
Asserta的想法是它主张网络级别的期望。

715
01:09:57,659 --> 01:10:01,260
例如，网络可以处理存款吗？

716
01:10:01,260 --> 01:10:05,920
它可以处理每个opcode都被调用的交易吗？

717
01:10:05,920 --> 01:10:07,659
它可以处理reorg吗？

718
01:10:07,659 --> 01:10:10,699
这就是Asserta试图回答的问题。

719
01:10:10,699 --> 01:10:17,920
它是一种广义测试工具，因此您可以将其用于任何网络上的断言。

720
01:10:17,920 --> 01:10:24,180
您只需要定义什么是断言，健康检查或正确的错误是什么，

721
01:10:24,520 --> 01:10:28,800
然后，您必须使用该测试定义进行断言，并且必须指出它

722
01:10:28,800 --> 01:10:34,500
节点要检查。因此，当您做这三件事时，主张会根据您的

723
01:10:34,500 --> 01:10:39,199
定义，它将断言您在那儿给出的定义断言。

724
01:10:40,239 --> 01:10:45,960
因此，我提到的例子就是过渡成功。因此，理想情况下，我们想

725
01:10:45,960 --> 01:10:52,840
它在我可以查询所有API的地方，API表示过渡成功等于

726
01:10:52,840 --> 01:10:58,520
过渡等于完整，然后Asserta会说好的工作过渡被定义为

727
01:10:58,520 --> 01:11:04,760
当此API调用返回正确时，它已经完成，您可以添加一个超时说明是否没有发生

728
01:11:04,760 --> 01:11:10,199
在一小时内就失败了，Asserta会说好的，它没有在一小时内发生

729
01:11:10,199 --> 01:11:17,159
让我们退回失败。可以通过API与Asserta进行交互，因此您可以运行它，然后

730
01:11:17,159 --> 01:11:23,720
配置测试。在某些情况下，这非常有用，例如Kubernetes或您有公共实例，

731
01:11:23,720 --> 01:11:29,319
您还可以在定义的所有测试中运行时运行它，您可以从

732
01:11:29,319 --> 01:11:35,319
通过其API asserta，您可以通过其日志获取信息。有点像这个中间件

733
01:11:35,319 --> 01:11:42,599
您需要做的一切，以确保网络的行为表现

734
01:11:45,079 --> 01:11:51,159
因为超时也可以配置

735
01:11:51,159 --> 01:11:57,880
对此进行测试，我们确实对此进行了削减测试，因此我可以定义分类器如何创建一个

736
01:11:57,880 --> 01:12:02,439
可靠的条件，然后为我执行可倾斜的条件，并确保

737
01:12:02,439 --> 01:12:08,839
每个节点都接受了猛击。因此，您知道何时以及如果发生在真实网络上，

738
01:12:08,839 --> 01:12:15,159
所有这些都在起作用。您也可以配置类似的东西，请确保每个

739
01:12:15,799 --> 01:12:22,199
我本地开发网络中的节点至少提出了一个块。这真的很有用

740
01:12:24,359 --> 01:12:28,199
分叉测试，因为您想确保自己没有破坏证明，所以

741
01:12:28,199 --> 01:12:32,519
打破建议，即您不会打破建立网络的基本部分。

742
01:12:34,599 --> 01:12:41,079
是的，所以您可以做很多这些事情。而且我们也这样做，我们目前致力于尝试

743
01:12:41,720 --> 01:12:47,159
每个验证器客户端与每个信标节点兼容。所以这是一个很大的矩阵。

744
01:12:47,960 --> 01:12:54,199
这应该与每个执行层节点兼容。我认为您可以看到

745
01:12:54,199 --> 01:12:59,639
页面上的峰度已经有一个矩阵，您可能会看到哪些组合不起作用

746
01:12:59,639 --> 01:13:04,840
在Interop频道上也对此有些chat不休，我们正在慢慢将它们取下

747
01:13:04,840 --> 01:13:12,039
我们一一我们到达那里，但我们主要使用Assorter来弄清楚这一点，也可以

748
01:13:12,039 --> 01:13:17,880
在本地运行，就像我早些时候通过kurtosis向您展示的那样，它具有一定的内置，或者您可以

749
01:13:17,880 --> 01:13:23,399
将其集成到CI中，因此有一个自信的github动作，您可以使用此github动作

750
01:13:23,399 --> 01:13:29,399
在您的存储库中，这就是我们对Vocal uh devnets存储库所做的工作

751
01:13:29,399 --> 01:13:34,920
在那个示例中，一种指向kubernetes群集的某种指向它的阴影叉和

752
01:13:34,920 --> 01:13:42,039
阴影叉在这里可以看出，阴影叉进行本地转换检查测试

753
01:13:42,039 --> 01:13:46,119
可能已经猜到也可能是本地定义，它不一定是远程定义

754
01:13:46,119 --> 01:13:53,319
成为github要点，可以是hackmd上的笔记，这可以是你想要的，所以这是一个非常

755
01:13:53,319 --> 01:13:57,639
非常概括的测试工具，请尽可能多地使用索特尔

756
01:13:57,639 --> 01:14:01,779
相对较新的工具，此时只有几个月的历史了，因此还没有

757
01:14:01,779 --> 01:14:08,799
获得了应有的黄金时间，但我们希望更多地使用它

758
01:14:08,799 --> 01:14:12,699
那些参加马里奥打电话的人可能会注意到它有很多

759
01:14:12,699 --> 01:14:18,219
与Hive重叠，因此Hive也做了很多断言，我说我给

760
01:14:18,219 --> 01:14:22,420
这笔交易这是需要发生的EVM状态转变。

761
01:14:22,420 --> 01:14:27,260
发生在此节点上。蜂巢这样做。那么，为什么我们要构建一个全新的工具来做到这一点呢？

762
01:14:27,960 --> 01:14:36,100
因为蜂巢的构建方式对于单节节点来说非常好。在蜂巢中有可能

763
01:14:36,100 --> 01:14:43,920
要进行孔间的多个节点测试，它只是更加笨拙，并且建立了蜂巢

764
01:14:43,920 --> 01:14:49,300
测试需要很短的时间。您可以将其配置为更长的时间

765
01:14:49,300 --> 01:14:56,460
为此。 Asserta没有这些假设。例如，一个押金，完美

766
01:14:56,460 --> 01:15:04,199
网络级别需要半天通过队列处理。蜂巢，不是

767
01:15:04,199 --> 01:15:10,140
必然以相同的方式进行多线程，因此可能会根据您的配置方式，被卡住

768
01:15:10,140 --> 01:15:15,140
在该存款上，直到网络处理到下一个测试之前。所以

769
01:15:15,140 --> 01:15:21,280
Asserta刚刚从头开始建造，以在整个网络的情况下工作。

770
01:15:22,079 --> 01:15:25,720
因此，我的心理模型的工作方式是我们将永远使用的方式

771
01:15:25,720 --> 01:15:30,820
对于单个节点黑盒级测试，

772
01:15:31,420 --> 01:15:33,900
Asserta是我们将用于网络级测试的方法，

773
01:15:33,980 --> 01:15:35,560
网络本身是黑匣子，

774
01:15:35,600 --> 01:15:37,700
我只想在网络中宣称行为。

775
01:15:38,360 --> 01:15:40,579
因此，它们非常协同。

776
01:15:40,579 --> 01:15:46,340
理想情况下，这是充满活力

777
01:15:46,340 --> 01:15:49,539
分类水平，但如果这样做也很高兴拥有这两个工具

778
01:15:49,539 --> 01:15:53,720
这可以比较输出，并说嘿，这应该在蜂巢中失败了

779
01:15:53,720 --> 01:15:58,539
不是还是应该失败的，或者为什么还没有给我们

780
01:15:58,539 --> 01:16:05,500
我们可以从中受益的这种灵活性，因此请尝试一下

781
01:16:05,500 --> 01:16:12,479
因此，让我们知道您是否有反馈，我们将在接下来的几周内宣布它。

782
01:16:15,159 --> 01:16:19,680
现在，要使用一些较小的Cli级工具。

783
01:16:19,960 --> 01:16:23,000
你们中有些人可能很想在叉子选择上工作。

784
01:16:24,180 --> 01:16:30,420
可以在这一努力中相信您支持您的哪个DAT。

785
01:16:30,420 --> 01:16:36,199
这是一个困难的领域，很难理解叉子选择正在发生的事情

786
01:16:36,199 --> 01:16:43,960
因此，我们建立了borky

787
01:16:43,960 --> 01:16:50,899
标准API，因此每个节点都支持它，而这是它连接到节点

788
01:16:50,899 --> 01:16:57,340
您已经将其链接到，它可视化叉子选择您还可以从当地上传叉子选择

789
01:16:57,340 --> 01:17:02,460
节点，它将为您提供可视化，有时有助于叉子选择调试

790
01:17:02,460 --> 01:17:09,260
看到树木建立在什么和体重上的东西真正有帮助的树

791
01:17:09,260 --> 01:17:16,140
在危急情况下，这可以以二进制文件作为docker文件作为helen图表作为二进制

792
01:17:16,140 --> 01:17:22,460
如您所见，在峰度下，我们支持各种各样的事情，如果您有兴趣

793
01:17:22,460 --> 01:17:26,779
叉车和主网所做的一切请不要将实例放下一千人

794
01:17:26,779 --> 01:17:32,380
同时打电话给它，但让我们看看自动缩放是否效果很好

795
01:17:32,380 --> 01:17:39,179
将会看到以太坊上的叉子选择在这一刻，您会看到微小的线条

796
01:17:39,179 --> 01:17:45,420
在底部，这些线路是每一个插槽一次拍摄的快照，以便您可以

797
01:17:45,420 --> 01:17:51,899
还可以与某人共享快照链接，并且它链接到S3存储桶，因此甚至在一天之后，如果您

798
01:17:51,899 --> 01:17:57,059
想要调试一些可以从该快照中加载的东西，这是很多

799
01:17:57,059 --> 01:18:03,460
我们花了一些时间的生活质量改进。我要的下一个工具

800
01:18:03,460 --> 01:18:08,519
谈论示踪剂，这仍然是一项积极的工作，我不知道如何

801
01:18:08,519 --> 01:18:13,319
你们中的许多人都已经与Trace API合作，但这不是最标准的

802
01:18:13,319 --> 01:18:23,960
世界上的事情，当有大型的主网事件时，痕迹往往是我们走的第一件事

803
01:18:23,960 --> 01:18:31,019
或我们要看的第一件事之一。因此，我们有一个连接到每个的主网示踪剂

804
01:18:31,019 --> 01:18:38,059
EL和CL以及它的作用是每个块它跟踪它，将其上传到那里，每个插槽

805
01:18:38,060 --> 01:18:46,660
它获取了Beacon SSE，State SSE，将其上传到那里。它有有关如何采用的说明

806
01:18:46,660 --> 01:18:52,940
从两个不同的EL进行跟踪，然后比较它们以查看是否有差异。理想情况下，在主网，

807
01:18:53,020 --> 01:18:58,160
有零差异。但是，当存在问题时，差异可以帮助我们找出问题所在。

808
01:18:59,000 --> 01:19:05,160
借助state.sse，您可以做的是您可以采取以前的状态，下一个状态，

809
01:19:05,159 --> 01:19:10,159
然后，您可以使用许多工具进行此过渡。理想情况下，每一个

810
01:19:10,159 --> 01:19:15,059
这些工具为您提供相同的输出。如果没有，您有问题，您需要弄清楚原因。

811
01:19:15,979 --> 01:19:24,260
而这种工具是我们希望永远不会使用的工具，但是当您需要使用它时，

812
01:19:24,319 --> 01:19:30,199
这是我们要使用的东西。我们最近有一篇博客文章。并以与

813
01:19:30,199 --> 01:19:33,319
检查点Z，团队已经建立了此工具，

814
01:19:33,599 --> 01:19:36,340
但是理想情况下，我们希望社区运行它。

815
01:19:36,720 --> 01:19:38,519
我们不想自己运行。

816
01:19:38,519 --> 01:19:41,939
作为精神，Eth Panda Ops团队

817
01:19:41,939 --> 01:19:43,880
试图从未为mainnet运行任何东西

818
01:19:43,880 --> 01:19:46,939
因为我们不想将mainnet是什么。

819
01:19:47,079 --> 01:19:48,500
这应该取决于社区。

820
01:19:48,739 --> 01:19:50,420
我们倾向于只运行测试网络的东西。

821
01:19:50,899 --> 01:19:52,619
我们正在为mainnet运行示踪剂

822
01:19:52,619 --> 01:19:55,439
纯粹直到社区的网络影响

823
01:19:55,439 --> 01:19:57,260
运行这些工具正在积累。

824
01:19:58,679 --> 01:20:00,099
这确实有帮助。

825
01:20:00,199 --> 01:20:01,939
因此，如果您有很多，那就去做。

826
01:20:04,359 --> 01:20:05,779
下一个是多拉。

827
01:20:06,720 --> 01:20:12,380
因此，多拉（Dora）是一款轻巧的信标连锁探险家，非常可扩展。

828
01:20:12,579 --> 01:20:16,340
因此，我们有Verkle的Dora，我们为Holsky提供了Dora，您为所有事情都有Dora。

829
01:20:17,019 --> 01:20:22,019
即使是Beacon Chain Guys也将Dora作为备份，如果Beacon Chain有问题。

830
01:20:22,760 --> 01:20:25,019
它为您提供了对数据库的低水平访问。

831
01:20:25,020 --> 01:20:32,000
如此之多，以至于您可以经常运行Dora，并且经常想做一些MEV风格

832
01:20:32,000 --> 01:20:36,480
分析我们只是像SQL查询一样对DORA数据库进行运行，我们获得了所需的信息

833
01:20:36,480 --> 01:20:44,320
要做到这一点非常有用，请让外观易于运行，Dora具有内置

834
01:20:44,320 --> 01:20:48,740
像叉可视化器一样，如果您有10个节点，它将告诉您是否有两个节点

835
01:20:48,739 --> 01:20:57,779
或您可以做的任何事情Elf或Clfox，它可以完成我的下一个和最后一个工具的所有美好事物

836
01:20:57,779 --> 01:21:04,979
今天要谈论的是Xatu对数据和数据可视化真正感兴趣的人

837
01:21:05,779 --> 01:21:10,659
应该关注这两个存储库以太坊点对点

838
01:21:10,659 --> 01:21:16,420
众所周知，很难获得有关有很多噪音的可见性

839
01:21:16,420 --> 01:21:18,699
有数百万事件发生。

840
01:21:22,380 --> 01:21:23,699
好的，那是不同的。

841
01:21:23,699 --> 01:21:26,819
有数百万事件需要进行。

842
01:21:26,819 --> 01:21:31,220
实际上每个插槽都有几百万

843
01:21:31,220 --> 01:21:34,460
或经历了数十万个证明。

844
01:21:34,460 --> 01:21:37,579
所以我们所做的是Zhaotu

845
01:21:40,380 --> 01:21:44,300
分析或收集所有这些数据，将其放在共享数据库中，

846
01:21:44,300 --> 01:21:51,720
然后，您可以使用像Grafana这样的工具来可视化这一点，

847
01:21:51,860 --> 01:21:53,960
但是数据库也可以直接查询。

848
01:21:54,699 --> 01:21:58,159
Zato拥有的所有数据或几乎所有数据都是开源的。

849
01:21:58,340 --> 01:22:02,079
我们仍在开放采购剩下的一切。

850
01:22:02,900 --> 01:22:05,820
如果您是对数据挑战感兴趣的人

851
01:22:05,820 --> 01:22:09,579
以太坊基金会现在的组织

852
01:22:09,940 --> 01:22:11,199
请查看Zato数据。

853
01:22:11,340 --> 01:22:13,820
它可以为您节省大量时间收集自己的时间。

854
01:22:14,300 --> 01:22:21,279
它的工作方式是，我们有这些称为Xatu哨兵的东西，因此这些哨兵收集

855
01:22:21,279 --> 01:22:27,360
共有节点，并使用事件流，它获取事件流，并注释

856
01:22:27,360 --> 01:22:31,039
数据并将其推到XATU服务器。

857
01:22:31,039 --> 01:22:35,380
还有另一个爬网手做一些diskv5，diskv4的东西，还有其他东西

858
01:22:35,380 --> 01:22:43,720
收集MEMPOOL数据，所有这些都将重新填充，放入XATU服务器，这是持续存在的

859
01:22:43,720 --> 01:22:50,440
我认为我们在这条管道中拥有一年多的主要净数据，其中有数十亿，

860
01:22:50,440 --> 01:22:57,280
有很多。所有这些都将摄入到数据管道中。以及它进入数据的原因

861
01:22:57,280 --> 01:23:03,900
管道是您想回答的问题，从数据中不明显，您可能需要做

862
01:23:03,900 --> 01:23:09,820
转换，您可能需要进行一些分析，正确，并且您想进行规范化

863
01:23:09,819 --> 01:23:15,259
这些分析，因此我们已经为此构建了整个数据管道以及数据的输出

864
01:23:15,259 --> 01:23:21,340
管道可以是这样的图表

865
01:23:21,340 --> 01:23:27,019
毫秒在哪个网络上，您可以看到他们花了多长时间沿网络传播

866
01:23:27,019 --> 01:23:32,219
您可能会发现有趣的东西通常是在四秒标记处有一个很强的热图

867
01:23:32,219 --> 01:23:38,299
因为那是有证明截止日期和提议在那之前往往会经过的时候

868
01:23:38,300 --> 01:23:43,220
而且，您还可以查看Blob Sidecars以及不同的节点看到它。

869
01:23:43,340 --> 01:23:46,220
您可以像p95度量一样创建，以了解，

870
01:23:46,940 --> 01:23:50,520
好的，我在50个不同的位置有100个节点。

871
01:23:50,520 --> 01:23:57,340
他们中有95％看到了特定数量的斑点到来

872
01:23:57,340 --> 01:24:02,140
在一定时间内，我们期望网络以健康的方式处理。

873
01:24:02,500 --> 01:24:06,300
这使我们能够就以太坊做出真正的决策，

874
01:24:06,300 --> 01:24:10,440
有多少个斑点，传播统计的外观，等等。

875
01:24:11,300 --> 01:24:14,619
并且整个堆栈在测试网络上都是可重现的。

876
01:24:14,779 --> 01:24:18,500
我们确实在测试网上复制了它，它可以帮助我们回答很多此类问题。

877
01:24:19,860 --> 01:24:23,699
我们仍在努力的一件事是试图自动进行更多的分析。

878
01:24:23,699 --> 01:24:26,060
因此，您可能会在Eth Pandaops博客中注意到

879
01:24:26,180 --> 01:24:29,760
我们对主网和库恩福克进行了一项手动分析。

880
01:24:29,760 --> 01:24:39,260
我们正在尝试分析并弄清楚如何在没有某人的情况下更好地获得这种输出

881
01:24:39,260 --> 01:24:46,340
每次都必须筛选数据时，都有一些答案可以使用本地LLM型号等内容

882
01:24:46,340 --> 01:24:51,739
分析数据仍然不满意，如果有人想探索该方面，请这样做

883
01:24:51,739 --> 01:24:57,960
数据全部都在那里，是的，我认为这是一种很棒的协同作用

884
01:24:57,960 --> 01:25:05,159
接下来的我要提到的是，我认为在大多数电话中，我的价值最高的东西我

885
01:25:05,159 --> 01:25:09,939
希望你们能带走如何运行本地Devnet以及如何制作原型

886
01:25:09,939 --> 01:25:19,079
因此，请在最低限度的叉子上添加客户端向终端输出添加Hello World

887
01:25:19,079 --> 01:25:24,180
与您的叉子客户kurtosis，并为您的名字打印在Get Logs中

888
01:25:24,180 --> 01:25:30,659
这只是一个门户，让您知道系统如何运作如何扩展它

889
01:25:30,659 --> 01:25:36,280
去年有协议奖学金的人从事

890
01:25:36,280 --> 01:25:41,680
我想说的EPB的一个版本，但我不太确定是否是EPB

891
01:25:41,680 --> 01:25:48,680
他广泛使用峰度进行测试，一旦他完成了峰度的测试

892
01:25:48,680 --> 01:25:52,600
我认为，他还将整个堆栈迁移到了Girly网络上。

893
01:25:53,619 --> 01:25:57,240
这有助于我们了解什么有效，什么不起作用。

894
01:25:57,360 --> 01:26:01,980
他与研究人员合作，对实施的难度有多大分析，

895
01:26:02,060 --> 01:26:03,820
可能存在哪些边缘情况，依此类推。

896
01:26:04,840 --> 01:26:13,100
而且我确实认为每个人都应该使用测试和测试作为一个很好的起点

897
01:26:13,100 --> 01:26:16,560
因为这是学习以太坊如何工作的一种非常好的方法。

898
01:26:16,560 --> 01:26:23,220
请再次通过Mario在最后一个UH谈话中向你们展示的任何事情

899
01:26:23,220 --> 01:26:28,700
令人惊讶的是，它们非常包容，我们也非常包容，所以如果您觉得

900
01:26:28,700 --> 01:26:33,720
您想为测试堆栈的任何一层做出贡献

901
01:26:33,720 --> 01:26:39,780
编写Hive测试编写规格测试无论如何，这使您有了新的了解

902
01:26:39,780 --> 01:26:44,800
以太坊如何工作的边缘案例是什么，以便当您从事任何工作时

903
01:26:44,800 --> 01:26:49,900
您想从事的工作您知道整个空间的外观以及什么

904
01:26:49,900 --> 01:26:56,480
您可能想拥有的注意事项，谢谢您帮助我们测试

905
01:26:56,480 --> 01:27:01,880
下一个叉子关注Github在Twitter上关注我，我们希望它留给我

906
01:27:01,880 --> 01:27:10,960
是时候提出问题了，这很棒，这是很多我，这就是为什么我在

907
01:27:10,960 --> 01:27:13,960
您开始照顾这些工具的封面房屋的开始，因为

908
01:27:13,960 --> 01:27:16,239
其中有很多。

909
01:27:16,239 --> 01:27:23,260
是的，我只想重复您所说的话，这是了解它的好方法之一

910
01:27:23,260 --> 01:27:27,520
工作并只是运行所有这些工具，例如将它们连接到您的客户并看到

911
01:27:27,520 --> 01:27:30,279
指标以及那里实际发生的事情。

912
01:27:30,279 --> 01:27:36,140
真的很棒。而且，您所说的话，您可以避免在主机上运行它

913
01:27:36,140 --> 01:27:41,359
公开广告。所以，我想，如果有人想托管这一点，请自由。

914
01:27:41,359 --> 01:27:45,139
它实际上我实际上是在我的笔记上运行示踪剂，我想弄清楚

915
01:27:45,139 --> 01:27:50,960
我做了一些事情，但我读了它，也许我应该托管它

916
01:27:50,960 --> 01:27:57,000
知道是的，谢谢你的帕里很酷

917
01:27:57,000 --> 01:28:04,519
很多人，所以像域问题这样的人是人们想看到的

918
01:28:04,520 --> 01:28:10,840
您进行一些演示，一些实用的实验。

919
01:28:10,840 --> 01:28:12,560
但是我不确定我们是否有时间

920
01:28:12,560 --> 01:28:15,860
以及您是否可用。

921
01:28:15,860 --> 01:28:17,660
而且您已经提到了很多事情

922
01:28:17,660 --> 01:28:19,880
人们可以尝试自己。

923
01:28:19,880 --> 01:28:23,840
如果您愿意，我可以迅速对某些东西进行峰度测试

924
01:28:23,840 --> 01:28:25,460
并向你们展示看起来的样子，

925
01:28:25,460 --> 01:28:30,480
如果这是最简单的第一件事。

926
01:28:30,480 --> 01:28:31,940
但是，如果还有其他问题，

927
01:28:31,939 --> 01:28:34,219
也许您可以在此之前做问题。

928
01:28:34,219 --> 01:28:36,099
是啊是啊。

929
01:28:36,099 --> 01:28:38,259
好的。

930
01:28:38,259 --> 01:28:42,359
是的，人们希望进行实践。

931
01:28:42,359 --> 01:28:43,639
另一个问题进来。

932
01:28:43,639 --> 01:28:46,099
好的。

933
01:28:46,099 --> 01:28:48,519
是的，人们正在询问Python规格，

934
01:28:48,519 --> 01:28:52,399
还是规格测试，无论您在某个时候使用它们。

935
01:28:52,399 --> 01:28:55,819
是的。

936
01:28:55,819 --> 01:29:00,219
对于Python规格测试，因此

937
01:29:00,220 --> 01:29:06,539
更多的是个人，因此我们定义或分裂领土的方式，以便我们可以

938
01:29:07,180 --> 01:29:12,860
两者都更容易地专业是您可以期望在一个节点上测试的任何内容

939
01:29:13,740 --> 01:29:21,100
马里奥测试团队UH Python规格团队，他们处理的任何预期将在

940
01:29:21,100 --> 01:29:27,100
Interop级别的ETH PANDA OPS团队测试，因此理想情况下我们已经定义了它们，所以我

941
01:29:27,100 --> 01:29:33,340
个人很少运行规格测试。我帮助维护一些运行规格测试的服务器，但是

942
01:29:33,340 --> 01:29:39,260
否则我不会自己运行规格测试。是的，这很有意义。我想这一切都像

943
01:29:39,260 --> 01:29:43,340
从类似规格和实施的地方进步该客户主题和

944
01:29:43,340 --> 01:29:48,220
统计本身，然后被证明是整个统计数据，所以就像您已经是另一个

945
01:29:48,220 --> 01:29:53,420
那里的一面。只是为了上下文，因为人们也在询问

946
01:29:53,420 --> 01:29:58,699
马里奥的话题，我将您指向第四周，这一切都很好地解释了

947
01:29:59,260 --> 01:30:09,340
那里。凉爽的。好的，如果有人想看一个小例子，我可以显示现实世界中的用例

948
01:30:09,340 --> 01:30:16,140
在上周我们遇到的问题中，我们仍然面临着面对的，但我们想看看。所以当你

949
01:30:16,140 --> 01:30:24,060
运行此或上周跑步时，将发生的是第一个版本

950
01:30:24,060 --> 01:30:30,360
第一位参与者只是一个cl teku，默认的el是geth效果很好

951
01:30:30,360 --> 01:30:35,600
Teku在验证器中构建，因此验证器和信标在相同

952
01:30:35,600 --> 01:30:42,660
处理这提出了块零问题，下一个问题是单独的vc，所以

953
01:30:42,659 --> 01:30:46,659
因此，在此中，您有一个Teco Beacon和一个TECO验证器客户端。

954
01:30:47,059 --> 01:30:48,639
而且这也很好。

955
01:30:48,840 --> 01:30:49,819
它提出了块。

956
01:30:50,000 --> 01:30:50,639
它可以证明。

957
01:30:50,760 --> 01:30:51,420
一切都可以。

958
01:30:52,099 --> 01:30:58,399
但是，当我启用VC和Snooper分开时，它就会失败。

959
01:30:59,239 --> 01:31:00,619
我们不知道为什么。

960
01:31:00,840 --> 01:31:07,559
失败的原因是teco信标和验证器客户端使用二进制

961
01:31:07,560 --> 01:31:14,280
八位位集流以通信UM他们想交流的有效载荷

962
01:31:14,280 --> 01:31:19,320
而且我们有嗯，我可能必须共享另一个屏幕

963
01:31:22,760 --> 01:31:24,440
所以我们有

964
01:31:28,200 --> 01:31:36,200
一秒钟让我只分享我的整个屏幕，是的，是的，你们应该能够看到这个

965
01:31:36,199 --> 01:31:43,239
因此，我们有一个由JSON-RPC-SNOOP构建的一个工具。所以JSON-RPC-SNOOP

966
01:31:43,800 --> 01:31:49,559
是在生锈的

967
01:31:50,840 --> 01:31:57,000
因为当被击中时，它正在击中边缘案件，因此您可以看到它试图解开它，并且

968
01:31:57,000 --> 01:32:05,559
那没有解决

969
01:32:05,560 --> 01:32:11,640
能够弄清楚发生了什么，所以我们弄清楚发生了什么的实用方法是

970
01:32:13,000 --> 01:32:18,920
然后，我们与Techu团队进行了交谈，询问为什么这可能会发生，然后

971
01:32:18,920 --> 01:32:25,080
我们有一个AHA的时刻哦，是的，这可能是因为您可以限制八位钟频段。

972
01:32:25,080 --> 01:32:32,600
禁用那是这样，我们添加了此额外的VC参数，这说明不这样做

973
01:32:32,600 --> 01:32:39,880
给我SSE我很高兴，因此我再次提出了建议，所以我知道那是因为我

974
01:32:39,880 --> 01:32:48,440
json rpc snooper被打破了，所以现在唯一要做的变量就是删除此更新

975
01:32:48,440 --> 01:32:56,520
JSON RPC Snooper，然后我必须正确更新图像，所以我在本地版本中所做的是

976
01:32:56,520 --> 01:33:13,960
是的，在当地的Docker映像中，我正在对此进行更新。因此，无论哪种pari tosh dot json rpc

977
01:33:15,720 --> 01:33:20,440
测试一个，然后我可以进行完全相同的测试。

978
01:33:20,439 --> 01:33:36,339
像这样。现在发生的是我知道已损坏的确切测试定义，

979
01:33:36,979 --> 01:33:43,899
将使用此Docker映像，而不是在远程存储库中配置的图像。我测试了

980
01:33:43,899 --> 01:33:49,119
这在本地广泛。一旦工作，我对解决方案感到满意。我做了所有的

981
01:33:49,119 --> 01:33:53,739
Adqisite PR，然后我们认为这是一个解决问题。我们找到了其他东西

982
01:33:53,739 --> 01:33:57,939
通过事件流，我们仍在尝试弄清楚其他问题，因此

983
01:33:57,939 --> 01:34:03,739
有人想要一个中等困难的问题，尝试一下，尝试此配置

984
01:34:03,739 --> 01:34:08,539
您会看到Teco提出了块，但时不时地失败了

985
01:34:08,539 --> 01:34:13,880
提出建议，仅是第三名参与者，然后转到JSON RPC

986
01:34:13,880 --> 01:34:17,359
Snupper并弄清楚为什么失败并制造PR，我们对

987
01:34:17,359 --> 01:34:23,000
关于它，我向您展示了如何在本地测试整个过程，以便您知道如何重现它

988
01:34:23,000 --> 01:34:28,659
知道什么时候没有失败，是的，您都了解了我们如何进行原型制作和

989
01:34:28,659 --> 01:34:35,239
解决这些问题都不需要我与我自己之外的任何人交谈，我可以测试一百万次

990
01:34:35,239 --> 01:34:40,960
我一生中从未写下生锈代码，我能够使用不同的工具来了解什么

991
01:34:40,960 --> 01:34:47,920
错误可能已经存在，并且自己尝试了一些解决方案，而不必推动任何重大更改

992
01:34:47,920 --> 01:34:55,920
不知道它有效，所以这是一个实用的例子，是的，我的意思是我可以为此而来

993
01:34:55,920 --> 01:35:04,560
如果您愿意，您将需要一段时间，但是您可以看到它通过的所有步骤哦，是的，是的

994
01:35:04,560 --> 01:35:10,480
您可以想象，这立即失败了，因为这个图像不存在

995
01:35:12,080 --> 01:35:20,960
让我们改回正常

996
01:35:20,960 --> 01:35:27,920
它将创造创世纪，嗯，我知道我们已经在时间之前已经uh了

997
01:35:27,920 --> 01:35:33,520
如果我花了几分钟才能完成此操作，那当然只取决于您，我们不想知道

998
01:35:33,520 --> 01:35:39,360
花点时间，如果你有空的话，可以的人还可以，呃，呃，呃

999
01:35:40,240 --> 01:35:45,520
非常感谢实验非常兴奋，很高兴看到它运行是一个很好的例子

1000
01:35:45,520 --> 01:35:52,320
uh当前问题的方式和相关性也是因为上周我们在这个电话中有UM UH

1001
01:35:52,320 --> 01:35:58,160
如果来自Teku Uh的Paul解释了技术架构，所以他们应该有一个主意

1002
01:35:58,159 --> 01:35:59,300
所以这是完美的。

1003
01:36:00,180 --> 01:36:00,619
完美的。

1004
01:36:00,899 --> 01:36:03,840
因此，如果有人想解决我们的所有问题，

1005
01:36:03,939 --> 01:36:04,559
我们很高兴。

1006
01:36:07,720 --> 01:36:08,479
很棒，很棒。

1007
01:36:09,139 --> 01:36:10,340
是的，可能只需要一点

1008
01:36:10,340 --> 01:36:13,000
因为它也必须下载docker图像，所以

1009
01:36:13,380 --> 01:36:16,399
但是希望这不会花太长时间。

1010
01:36:16,680 --> 01:36:17,800
如您所见，

1011
01:36:17,880 --> 01:36:19,939
这是通过配置进行的。

1012
01:36:20,579 --> 01:36:23,939
它只是部署需要部署的一件事。

1013
01:36:24,260 --> 01:36:26,159
它将获取对等信息。

1014
01:36:26,159 --> 01:36:31,699
它将按照预期进行凝视，希望您也能看到有一个好处

1015
01:36:31,699 --> 01:36:38,519
如果我添加vc额外参数，我知道我的验证器正在运行一个额外

1016
01:36:38,519 --> 01:36:42,979
参数和我可以测试其他验证者没有的东西，因此您可以执行

1017
01:36:42,979 --> 01:36:57,299
是的，很多迭代测试是的，现在应该是现在创建验证器，也许是

1018
01:36:57,299 --> 01:37:05,059
如果我做Docker PS Dash A，这是一堆Docker

1019
01:37:05,059 --> 01:37:12,419
包含任务的容器，您可以在这里看到我的EL和我的CL，但我不建议进行互动

1020
01:37:12,420 --> 01:37:19,300
如果您等待完成此操作，则使用Kurtosis进行这种方式，Kurtosis CLI本身可以使您能够

1021
01:37:19,300 --> 01:37:24,180
以更好的方式获取所有这些信息，以查看您可以直接与之互动的方式

1022
01:37:24,739 --> 01:37:30,980
Docker没有什么阻止您的

1023
01:37:30,980 --> 01:37:41,699
要转到此URL，它将为我打开Dora，所以我很快就会分享我的屏幕和

1024
01:37:41,699 --> 01:37:43,059
向您展示Dora的外观。

1025
01:37:50,579 --> 01:37:56,819
因此，这是Dora，它与我的本地Devnet一起在Dineb Fork上运行，该Devnet有三个Geth

1026
01:37:56,819 --> 01:38:02,179
参与者。您可以查看块，可以查看涂鸦，您可以看到一切，

1027
01:38:02,179 --> 01:38:07,460
您可以看到验证器键，而我在谈论的错误本质上是第一个发生的

1028
01:38:07,460 --> 01:38:16,520
第一，错过的障碍物不应该错过。如果我要做峰度服务日志，

1029
01:38:16,880 --> 01:38:23,579
然后我指定了我的飞地名称。然后我指定了要从中获取日志的实例。所以

1030
01:38:23,579 --> 01:38:29,699
请使用Autofill，它非常好。然后我想遵循日志。这

1031
01:38:29,699 --> 01:38:37,220
是我的第三个CL的日志。您可以看到有一些错误，但这就是

1032
01:38:37,220 --> 01:38:42,819
验证者费用收件人，别无其他。否则看起来还不错。它只是建立了一个块

1033
01:38:42,819 --> 01:38:49,779
在插槽12上。因此，如果我等待一秒钟，则插槽12是由三个建造的。因此整个系统起作用。

1034
01:38:49,779 --> 01:39:01,019
例如，如果我做Snopper Beacon 3这是Beacon 3的Snopper，那么您

1035
01:39:01,019 --> 01:39:06,399
可以看到有关此的所有请求响应

1036
01:39:06,399 --> 01:39:13,119
接口，然后还有什么有趣的是，看看

1037
01:39:13,119 --> 01:39:30,279
服务日志，如果您需要知道发生了什么，我忘记了飞地

1038
01:39:30,279 --> 01:39:34,659
检查命令，但您可以检查运行中正在运行的内容

1039
01:39:34,659 --> 01:39:41,000
同时也是飞地。太好了，真的很棒，所以您基本上喜欢

1040
01:39:41,000 --> 01:39:45,159
您没有Docker工具，而是具有此峰度包装纸，它为您提供了所有

1041
01:39:45,159 --> 01:39:49,560
选项，为此而制定，它的效果非常好。

1042
01:39:49,560 --> 01:39:51,420
是的，很棒。

1043
01:39:51,420 --> 01:39:57,500
我认为已经过了几分钟了，我真的不想让您更长的时间，但是很大

1044
01:39:57,500 --> 01:40:01,800
感谢您为我们提供演示的额外努力。

1045
01:40:01,800 --> 01:40:03,020
我们真的很感激。

1046
01:40:03,020 --> 01:40:08,520
我个人喜欢所有的DevOps工具，这真的很有趣，您会看到

1047
01:40:08,520 --> 01:40:11,120
其他人会毗邻嗅探者。

1048
01:40:11,120 --> 01:40:12,760
还抢走了。

1049
01:40:12,760 --> 01:40:14,760
总有东西

1050
01:40:14,760 --> 01:40:16,480
我们正在努力，但它在附近。

1051
01:40:16,480 --> 01:40:17,820
是的。

1052
01:40:17,820 --> 01:40:20,120
是的，这对您的所有工作都非常重要，Pari，

1053
01:40:20,120 --> 01:40:22,620
尤其是在这个演讲中

1054
01:40:23,220 --> 01:40:25,780
这是一次很棒的学习经历。

1055
01:40:25,780 --> 01:40:28,120
是的，人们正在试图去法院。

1056
01:40:28,120 --> 01:40:30,280
他们在不和谐中问一些问题。

1057
01:40:30,760 --> 01:40:33,580
如果您加入不和谐，您可以去那里

1058
01:40:33,780 --> 01:40:36,120
如果您有一分钟，但这仍然取决于您。

1059
01:40:36,120 --> 01:40:37,980
稍后我将向您展示链接。

1060
01:40:37,979 --> 01:40:41,099
但是，对于所有一直关注的人，都非常感谢。

1061
01:40:41,099 --> 01:40:43,099
希望您希望您学到一些东西。

1062
01:40:43,319 --> 01:40:45,899
如果您对Pari有一些额外的问题

1063
01:40:46,559 --> 01:40:50,559
或者，如果您正在尝试这些事情，请与我们分享您的结果。

1064
01:40:50,859 --> 01:40:54,179
我们非常感谢您给出了很好的特定例子

1065
01:40:54,179 --> 01:40:58,519
人们可以练习，之后可以尝试的东西。

1066
01:40:58,779 --> 01:41:00,939
这是非常有帮助的。

1067
01:41:00,939 --> 01:41:05,599
是的，我会在星期三见到你们，派珀·玛丽安（Piper Marianne）进行演讲。

1068
01:41:05,600 --> 01:41:08,079
我们可以在这里结束它。

1069
01:41:08,260 --> 01:41:08,400
是的。

1070
01:41:08,760 --> 01:41:09,960
非常感谢您，帕里。

1071
01:41:10,120 --> 01:41:10,720
感谢它。

1072
01:41:10,940 --> 01:41:11,380
不客气。

1073
01:41:11,620 --> 01:41:12,380
见你们。

1074
01:41:13,700 --> 01:41:14,240
再见。

1075
01:41:14,720 --> 01:41:15,020
再见。

