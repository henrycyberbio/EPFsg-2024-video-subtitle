1
00:00:30,000 --> 00:00:59,980
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:59,979
我爱你。

10
00:03:00,000 --> 00:03:29,979
谢谢。

11
00:04:30,000 --> 00:04:59,980
谢谢。

12
00:05:00,000 --> 00:05:20,100
好的。

13
00:05:20,100 --> 00:05:25,660
欢迎回到以太坊协议研究小组。

14
00:05:25,660 --> 00:05:40,880
我们在第七周，今天与Reth的Dragan一起开发轨道，在这里谈论执行客户的复杂性。

15
00:05:41,480 --> 00:05:46,560
因此，马里奥（Mario），如果您想对Dragan进行快速介绍，我们将在这里开始。

16
00:05:46,560 --> 00:05:52,079
是的，当然。首先，非常感谢Dragan来到这里很荣幸

17
00:05:52,720 --> 00:06:01,360
因为您真的很适合我们的学习小组时间表。我们有康斯坦斯和执行层规格

18
00:06:02,399 --> 00:06:07,680
上周在开发轨道的第一部分，从抽象级别开始

19
00:06:07,680 --> 00:06:13,759
规格，我们现在将在本周进入实际客户端，执行客户端，这是

20
00:06:13,759 --> 00:06:17,199
在这里有Dragan代表红色真的很棒。

21
00:06:17,199 --> 00:06:18,939
红色相对较新，

22
00:06:18,939 --> 00:06:22,319
我相信这是目前最年轻的执行客户。

23
00:06:22,319 --> 00:06:26,599
以前，我们从马特（Matt）进行了类似的潜水，

24
00:06:26,599 --> 00:06:28,159
不是很具体，

25
00:06:28,159 --> 00:06:32,060
但是，仍然基本上是最古老的生活客户。

26
00:06:32,060 --> 00:06:35,420
今天我们将进行比较，

27
00:06:35,420 --> 00:06:39,000
雷德做的很大的建筑变化，

28
00:06:39,000 --> 00:06:40,459
因为红色很有趣，所以

29
00:06:40,459 --> 00:06:42,839
不仅从新的角度来看，

30
00:06:42,839 --> 00:06:50,679
在生锈中，但是做出许多有趣的选择并大修整个执行层设计。

31
00:06:51,719 --> 00:06:57,799
因此，向您学习非常有趣。 Dragan是RV-EVM的创建者，Rust

32
00:06:57,799 --> 00:07:03,000
EVM的实施，我相信Red的首席开发人员，如果我错了，请纠正我，

33
00:07:03,639 --> 00:07:09,799
但是红色的主要维护者之一，顺便说一句，最近变成了

34
00:07:09,800 --> 00:07:16,040
嗯，beta生产准备好了，嗯，嗯

35
00:07:16,040 --> 00:07:20,780
您在这里展示它，是的，舞台是您的嗯，请随时分享您的屏幕

36
00:07:20,780 --> 00:07:32,900
嗯，uh潜入红色代码基础uh你好，大家好，是的，我是在revm之前

37
00:07:32,899 --> 00:07:40,259
在那之前，我是公开以太坊的一部分，我从事了一位生锈客户，它被弃用了

38
00:07:40,979 --> 00:07:46,659
在那之后，Revm被Foundry使用，所有内容和法官来了说嘿，让我们建造

39
00:07:46,659 --> 00:07:53,139
客户和法官领导着围绕它的主要努力，所以我加入了一些帮助，

40
00:07:53,139 --> 00:08:01,699
是的，我在那里，做ret和revm以及一切之间的一切。

41
00:08:03,539 --> 00:08:06,500
让我们开始共享屏幕。

42
00:08:10,740 --> 00:08:13,319
是的，一个可耻的屏幕。

43
00:08:13,560 --> 00:08:14,639
对此很抱歉。

44
00:08:16,680 --> 00:08:22,800
让我们开始...

45
00:08:23,139 --> 00:08:25,279
仅一秒钟。

46
00:08:26,439 --> 00:08:27,120
是的。

47
00:08:27,939 --> 00:08:33,819
这是Georgios最近做的快速演讲。

48
00:08:34,639 --> 00:08:38,139
这是对RET的好介绍，它的开始方式，

49
00:08:38,399 --> 00:08:43,220
基本上，我们现在在哪里，我们想要创造的未来和时间

50
00:08:43,220 --> 00:08:47,960
以及我们基本上要移动它的地方。

51
00:08:47,960 --> 00:09:00,560
它是在2020年12月推出的

52
00:09:00,560 --> 00:09:10,100
我认为我们刚刚完成了我们终于在P2P上出现的现场，所以非常

53
00:09:10,100 --> 00:09:17,840
在那个时间点令人兴奋

54
00:09:17,840 --> 00:09:29,600
激动人心的时代UH首次发行了6月的第一次发行，这是我们同步的地方

55
00:09:29,600 --> 00:09:39,440
我们从创世纪成功同步到链的尖端的客户，是的，这就是我们

56
00:09:39,440 --> 00:09:40,900
输入Alpha软件。

57
00:09:43,600 --> 00:09:47,780
就像几周前一样，最近

58
00:09:47,780 --> 00:09:49,100
我们进入了Beta。

59
00:09:51,200 --> 00:09:54,060
我们输入beta的要求很少

60
00:09:54,060 --> 00:09:58,560
是我们所拥有的数据库的一些破坏变化。

61
00:09:58,560 --> 00:10:03,560
我们开始审核RET和EVM

62
00:10:04,080 --> 00:10:09,080
这样我们就更确定

63
00:10:09,080 --> 00:10:12,740
客户的行为应应有的。

64
00:10:12,740 --> 00:10:16,580
进行审核后，它很有帮助。

65
00:10:16,580 --> 00:10:21,520
但是即使没有，也有一个大的用户群

66
00:10:21,520 --> 00:10:24,300
所有用户都在生产中，

67
00:10:24,300 --> 00:10:29,780
很高兴看到这一点。

68
00:10:29,780 --> 00:10:35,040
如果我读到，那是几点，客户多样性，

69
00:10:35,039 --> 00:10:44,759
拥有快速，稳定的客户，每个人都可以用来堆放或在周围修补它，

70
00:10:44,759 --> 00:10:54,379
或仅将其用于某些爱好项目，甚至将其用于生产来促进所需的任何提供商基础架构。

71
00:10:55,620 --> 00:11:01,579
人才弹性，更多的人了解核心开发人员，了解核心协议。

72
00:11:02,719 --> 00:11:04,699
这就是一切。

73
00:11:05,039 --> 00:11:15,759
客户稳定性呃，是的，我们需要客户来建立我们想要扩展的每秒L2世界的高气

74
00:11:15,759 --> 00:11:24,959
红色uh可以被很多人使用

75
00:11:24,959 --> 00:11:30,879
延长RPC应该很容易扩展EVM，而围绕它的新漂亮的代码

76
00:11:30,879 --> 00:11:43,480
最快的目标，L1以太坊的使用，最快的L2和用于构建EVM的基础设施。

77
00:11:43,480 --> 00:11:54,100
对于任何想基本上跳入代码或检查的贡献者，我们都很开放

78
00:11:54,100 --> 00:12:00,580
对于一个好的第一个问题，只需打开公关，我们就为此感到自豪，因为它们有好处

79
00:12:01,300 --> 00:12:07,779
任何核心贡献者的快速回应，这就是为什么我们拥有这些不错的统计数据

80
00:12:11,139 --> 00:12:16,420
他们基本上正在成长，我们正在发展星星和独特的贡献者

81
00:12:16,419 --> 00:12:27,000
嗯，我们很快就可以将红色从创世纪同步到尖端，需要50个小时

82
00:12:27,000 --> 00:12:30,639
大约是两个gigabytes数据

83
00:12:30,639 --> 00:12:42,919
嗯，历史同步崩溃啊，这是2023年，我们刚刚使用Beta Switch

84
00:12:42,919 --> 00:12:49,000
对于静态文件，我将稍后再讨论，但我们的存档节点是

85
00:12:49,719 --> 00:13:00,279
大约两个terabytes虽然我们的完整节点在2024年一次大约是一口

86
00:13:00,919 --> 00:13:05,399
虽然在2023年是50。

87
00:13:05,399 --> 00:13:16,500
状态和像新街区一样增加了一年，我们现在比

88
00:13:16,500 --> 00:13:24,819
我们是一年前，但我们会更了解这一点，因为我们没有保存所有数据

89
00:13:24,820 --> 00:13:30,660
因此，全身为尖端同步的42小时非常好。

90
00:13:35,220 --> 00:13:41,180
有埃尔贡（Ergon）和我们从中使用的东西。

91
00:13:41,400 --> 00:13:46,220
我们已经分割了如何同步块。

92
00:13:46,580 --> 00:13:47,960
我们有历史同步。

93
00:13:48,740 --> 00:13:52,700
基本上，大鼠的一部分被优化为同步历史块。

94
00:13:52,700 --> 00:14:02,700
我们可以看到，我们可以有两个或取决于块，这是我们可以的数百万块

95
00:14:02,700 --> 00:14:11,160
每秒有两个GIGA气体用于历史同步，因为我们对此进行了优化

96
00:14:11,160 --> 00:14:20,220
同步我们在其中包含块，并检查每个块的状态路线少得多

97
00:14:20,220 --> 00:14:28,540
每秒是每秒100兆字节的100兆字节

98
00:14:30,779 --> 00:14:38,620
我们通过洪水和克雷奥（Creo）对这些东西进行基准测试，但范式制造的非常好

99
00:14:40,620 --> 00:14:48,220
是的，我们目前正在过渡到过渡到Beta，我们对坎昆和

100
00:14:48,220 --> 00:14:49,680
以及这样的一切。

101
00:14:49,680 --> 00:15:00,820
我们目前正在弄大EVM，我们支持OP堆栈。

102
00:15:00,820 --> 00:15:04,120
快照同步由Merkle完成。

103
00:15:04,120 --> 00:15:08,899
您甚至不需要从JS到小费同步。

104
00:15:08,899 --> 00:15:13,779
您只需下载快照即可重复使用。

105
00:15:13,779 --> 00:15:16,960
我们有一个很好的文档可以阅读。

106
00:15:16,960 --> 00:15:21,000
基于RPC，带有所需的所有迹线。

107
00:15:21,000 --> 00:15:27,600
是的，我们获得了最近刚进入协议公会的RET。

108
00:15:27,600 --> 00:15:31,440
很高兴看到。

109
00:15:31,440 --> 00:15:35,700
在生产中，这是一个模因

110
00:15:35,700 --> 00:15:40,740
我正在使用Ret Prism，运行测试网的有效托托，对吗？

111
00:15:40,740 --> 00:15:41,780
测试网。

112
00:15:41,780 --> 00:15:45,060
因此，有人在跑步。

113
00:15:45,059 --> 00:15:49,459
即使作为验证者，也很高兴看到。

114
00:15:52,159 --> 00:15:56,819
我们以生产为目标，将于5月准备生产。

115
00:15:56,819 --> 00:16:01,799
因此，目前正在进行两项审核。

116
00:16:01,799 --> 00:16:06,519
SimulPrior进行了RET，REVM由Gaudo完成。

117
00:16:06,519 --> 00:16:13,739
他是排行榜上的第一位ETH Bug Bounty领导者。

118
00:16:13,740 --> 00:16:18,740
并且有发展绩效的作弊曲目。

119
00:16:19,419 --> 00:16:24,419
因此，我们可以探索的路径很少

120
00:16:24,980 --> 00:16:27,700
从GTVM到平行evm

121
00:16:28,539 --> 00:16:33,539
只是瘫痪了我们的市场树计算

122
00:16:34,000 --> 00:16:35,340
目前已合并。

123
00:16:36,440 --> 00:16:41,440
内核允许修改

124
00:16:41,440 --> 00:16:46,440
在存储库之外的当前代码进行修改。

125
00:16:46,440 --> 00:16:47,980
因此，您无需克隆它。

126
00:16:47,980 --> 00:16:51,240
您需要分叉并进行更改。

127
00:16:51,240 --> 00:16:56,900
这可能非常麻烦且耗时。

128
00:16:56,900 --> 00:17:02,960
您只能在那里使用所有这些，但可以扩展它

129
00:17:02,960 --> 00:17:09,320
由RPC端点或Nuprix Opal。

130
00:17:09,319 --> 00:17:14,119
我们通过电布格的顶部运送了Cancun。

131
00:17:14,119 --> 00:17:17,079
我基本上是从事EOF的工作。

132
00:17:17,079 --> 00:17:20,259
我们正在垂直树，帐户障碍物。

133
00:17:20,259 --> 00:17:27,419
作为内核的一部分，很少有API，

134
00:17:27,419 --> 00:17:31,500
或部分节点构建器的一部分，对不起。

135
00:17:31,500 --> 00:17:38,519
是的，性能，这是我们目前研究的途径。

136
00:17:39,319 --> 00:17:41,339
其中一些可能将被实施。

137
00:17:42,980 --> 00:17:47,819
好吧，内核是用于出血边缘EVM基础架构的SDK。

138
00:17:48,619 --> 00:17:53,619
基本上，您可以制作可插拔的组件来插入当前节点

139
00:17:53,619 --> 00:17:54,619
并扩展它。

140
00:17:55,599 --> 00:18:00,000
一些想法要合并很多项目，这些项目需要在平行的情况下运行

141
00:18:00,000 --> 00:18:04,700
变成一个可以很好地运行主网的二进制

142
00:18:04,700 --> 00:18:06,839
一切都在那里。

143
00:18:06,839 --> 00:18:14,740
这些是一些例子。

144
00:18:14,740 --> 00:18:20,039
我会稍微浏览它们。

145
00:18:20,039 --> 00:18:25,959
这是Redkernel的示例。

146
00:18:25,959 --> 00:18:34,079
是的，是的，多节点卷，多租户，节点体系结构。

147
00:18:34,079 --> 00:18:40,879
当然，我们会看到拥有呼吸节点的主网，顶部的mainnet，一切都会非常好

148
00:18:40,879 --> 00:18:53,960
用一个命令继续进行，但这更像是中间，而不是直接的优先级，而不是直接的。

149
00:18:53,960 --> 00:18:55,839
是的。

150
00:18:55,839 --> 00:19:04,899
我敢肯定，你们是否有任何评论或任何您想问的东西或您想要的任何东西

151
00:19:04,899 --> 00:19:10,059
要说，只需写它，我会看到它回答。

152
00:19:10,059 --> 00:19:13,240
我会不时检查聊天。

153
00:19:13,240 --> 00:19:16,539
马里奥，如果你能从

154
00:19:16,539 --> 00:19:22,299
是的，大多数时候我们的聊天发生在不和谐频道中，我可以向您发送

155
00:19:22,299 --> 00:19:23,839
如果您想加入它的链接。

156
00:19:23,839 --> 00:19:30,959
但是马里奥和我将分类大多数在该渠道中发生的问题，并回答我们能做的事情，

157
00:19:31,359 --> 00:19:36,039
然后提出任何似乎相关或相关的问题。

158
00:19:36,899 --> 00:19:37,799
好吧，很好。

159
00:19:38,059 --> 00:19:39,240
听起来很棒。

160
00:19:40,419 --> 00:19:40,559
伟大的。

161
00:19:41,240 --> 00:19:43,439
是的，我想快速介绍。

162
00:19:43,599 --> 00:19:45,980
这些幻灯片非常好。

163
00:19:45,980 --> 00:19:53,579
因此，在那之后，我知道这将是更具技术性的，因此我将研究代码。

164
00:19:53,839 --> 00:19:59,379
并检查感兴趣的组件，与GET架构不同

165
00:19:59,379 --> 00:20:05,179
以及为什么它们与众不同以及我们有什么区别。

166
00:20:05,179 --> 00:20:14,899
所以，是的，希望没关系。

167
00:20:14,899 --> 00:20:20,879
不是公羊，而是天堂。

168
00:20:20,880 --> 00:20:27,560
雷德（Redd）有很多东西，总体而言，它有很多我们从事的项目。

169
00:20:27,560 --> 00:20:29,760
Redd是我们从事的客户。

170
00:20:29,760 --> 00:20:36,440
Foundry正在测试测试及其周围的所有内容。

171
00:20:36,440 --> 00:20:45,340
合金是，它主要是在REDD依赖性上。

172
00:20:45,339 --> 00:20:52,439
合金允许的，它为我们提供了原始数字，大数字，它为我们提供了RPC类型，它提供了

173
00:20:52,439 --> 00:20:58,639
我们周围的一切，例如阵列编码，周围的所有内容。

174
00:20:58,639 --> 00:21:03,439
因此，原始素大多在合金中找到。

175
00:21:03,439 --> 00:21:14,619
有REVM，只是EVM具有日记，它允许运行该部分，无论如何

176
00:21:14,619 --> 00:21:20,939
交叉路口是，我们的老鼠是使用所有这些的人

177
00:21:22,939 --> 00:21:30,939
客户和二进制项目的主要项目分为二进制文件和板条箱

178
00:21:30,939 --> 00:21:40,459
二进制文件只有uh命令，基本上封装了内部板条箱的所有内容

179
00:21:40,460 --> 00:21:44,120
它是一个板条箱。

180
00:21:44,120 --> 00:21:51,960
在里面，基本上有很多板条箱

181
00:21:51,960 --> 00:21:58,220
想让它变得容易导航，

182
00:21:58,220 --> 00:22:04,819
并且每个板条箱都可以由其他各方重复使用。

183
00:22:04,819 --> 00:22:08,740
例如，存储周围的所有内容都在网站存储中，

184
00:22:08,740 --> 00:22:12,599
我们有数据库提供商，编解码器，所有内容

185
00:22:12,599 --> 00:22:16,859
这封装了从数据库中保存或加载数据。

186
00:22:16,859 --> 00:22:20,819
这允许您使用可以使用提供商的情况

187
00:22:20,819 --> 00:22:23,579
在数据库上的阻塞，

188
00:22:23,579 --> 00:22:28,579
具有一定的实用程序功能，例如获取块，

189
00:22:29,759 --> 00:22:34,160
并以此为单位，仅使用此库

190
00:22:34,160 --> 00:22:41,640
并将其作为独立过程

191
00:22:41,640 --> 00:22:44,019
可以直接阅读数据库。

192
00:22:44,019 --> 00:22:46,840
这是一个非常好的用例，因为它给了您

193
00:22:46,840 --> 00:22:49,540
表现更多的读物。

194
00:22:49,540 --> 00:22:54,580
您无需ping json-rpc或ipc或类似的一切。

195
00:22:54,580 --> 00:22:57,380
您可以直接从数据库中读取磁盘。

196
00:22:57,380 --> 00:23:16,060
是的，也许最好开始我，我认为这是我去年制作的幻灯片

197
00:23:16,059 --> 00:23:25,019
但是几件事发生了变化，但是嗯，主要忽略仍然相同

198
00:23:27,179 --> 00:23:32,619
呃，红色由发动机驱动是

199
00:23:34,299 --> 00:23:40,700
驱动所有其他组件，并从共识层获得选择更新

200
00:23:40,700 --> 00:23:46,360
并检查收到的那个块或哈希

201
00:23:46,360 --> 00:23:48,039
对于共识层有效

202
00:23:48,039 --> 00:23:52,200
或基本上决定该怎么做。

203
00:23:53,360 --> 00:23:56,920
正如我所说，老鼠有两种同步模式。

204
00:23:56,920 --> 00:24:01,880
一个是管道完成的历史同步。

205
00:24:02,340 --> 00:24:08,700
基本上，管道在阶段基本上执行同步。

206
00:24:08,700 --> 00:24:17,039
当您在阶段同步时，您可以优化这些阶段，并允许

207
00:24:17,039 --> 00:24:24,960
允许您在基本上更快地进行优化，而当我们靠近尖端时

208
00:24:24,960 --> 00:24:32,819
我们切换到区块链树区块链树的链条是我们同步的另一种方式

209
00:24:32,819 --> 00:24:41,299
基本上是在状态真理，验证，执行发生的尖端附近

210
00:24:41,299 --> 00:24:53,059
仅当块获得规范化时，内存基本上移动到数据库提供商

211
00:24:53,059 --> 00:25:00,339
是在数据库上抽象的，该数据库允许某些辅助功能，因此我们不需要

212
00:25:00,339 --> 00:25:11,299
必须直接使用关键验证。下载器，这两个管道都在其前两个阶段使用

213
00:25:12,179 --> 00:25:21,059
或通过引擎缩小差距到小费的差距，用于下载块和标题

214
00:25:21,059 --> 00:25:29,619
从P2P，基本上是从P2P来

215
00:25:29,619 --> 00:25:38,819
我们收到的交易到部分池和部分池，基本上是以太坊的

216
00:25:38,819 --> 00:25:48,259
DDOS保护它具有用户想要的汽油价格订购的部分的n个数量

217
00:25:48,259 --> 00:25:56,819
付款和有效载荷构建器基本上采取并首先要构建新的有效载荷

218
00:25:56,819 --> 00:26:06,500
引擎所需的更多组件添加了uh，例如快照快照是

219
00:26:06,500 --> 00:26:18,920
我们的方式是um um只是静态文件对不起的静态文件，我们将一些数据直接移动到

220
00:26:18,920 --> 00:26:26,900
以二进制形式和附加组件的不同类型的数据库在这里

221
00:26:26,900 --> 00:26:36,800
它是修剪器，它允许我们在区块链树之后基本上承担全部负载

222
00:26:36,800 --> 00:26:46,519
规范化块需要等待的块，就像其他两个块64个块获得

223
00:26:46,519 --> 00:26:54,680
最终确定后最终确定，或者我认为我们有一些缓冲区10K，但是在完成后完成

224
00:26:54,680 --> 00:27:04,060
我们知道它不会是reorg，或者如果我们在整个节点中，我们可以删除一些数据。

225
00:27:07,060 --> 00:27:19,980
但是，是的，这些组件缺少，但是这种流程仍然与以前相同或相似。

226
00:27:24,680 --> 00:27:41,500
是的，我认为这里的主要区别是围栏，我将仔细研究它。

227
00:27:41,500 --> 00:27:50,120
因为阶段，我们如何下载块，我们如何检查块是什么不同

228
00:27:50,119 --> 00:27:53,979
从获得架构。

229
00:27:53,979 --> 00:28:01,459
我将在代码中选择这一点。

230
00:28:01,460 --> 00:28:04,940
不是那样，ret。

231
00:28:10,759 --> 00:28:24,680
创建RPC管道阶段。

232
00:28:24,680 --> 00:28:35,080
是的，但是在此之前，我们会很好地添加大量文档

233
00:28:35,799 --> 00:28:40,840
大部分在代码中，因此更容易修改和扩展

234
00:28:42,840 --> 00:28:47,960
因此，最好先检查文档是很好的

235
00:28:47,960 --> 00:28:59,299
但这是管道，不，这是阶段。

236
00:28:59,299 --> 00:29:05,840
是的。

237
00:29:05,840 --> 00:29:11,900
通常，舞台非常简单。

238
00:29:11,900 --> 00:29:17,900
它具有它的ID，就像嘿，我需要执行执行

239
00:29:18,540 --> 00:29:24,140
如果某些uh真实发生，则需要打开绑架，我们需要解开

240
00:29:24,940 --> 00:29:30,380
基本上可以具有侧块或侧面数据的阶段

241
00:29:32,300 --> 00:29:38,860
这是辅助功能是否准备就绪是否已准备就绪

242
00:29:38,859 --> 00:29:43,019
它在哪里？

243
00:29:43,019 --> 00:29:46,019
阶段。

244
00:29:46,019 --> 00:29:48,019
管道。

245
00:29:48,019 --> 00:29:53,079
仅一秒钟。

246
00:29:53,079 --> 00:30:02,399
好的，让我们跳入代码。

247
00:30:02,399 --> 00:30:08,279
也许在这里。

248
00:30:08,279 --> 00:30:20,039
管道基本上由多个阶段组成。

249
00:30:20,039 --> 00:30:28,059
如果您想，该管道用于一些命令行接口

250
00:30:28,059 --> 00:30:34,700
放松特定阶段，或者我们只想执行它用于的特定阶段

251
00:30:34,700 --> 00:30:44,460
测试或使用它进行调试或开发或任何您只想的地方

252
00:30:44,460 --> 00:30:48,940
刚开始默克尔舞台，放下默克尔舞台，放下那些桌子，然后再次运行。

253
00:30:50,860 --> 00:30:58,140
这是我们从第一个到最后阶段的默认设置列表。

254
00:30:58,140 --> 00:31:07,380
阶段。前两个阶段，标题阶段和车身阶段基本上是网络阶段

255
00:31:07,380 --> 00:31:18,900
他们在这个阶段的标题中获取，在这里拿起身体。他们用捆绑包获取

256
00:31:18,900 --> 00:31:27,860
末端的身体，他们需要等待P2P才能获得我们要求的节点

257
00:31:28,900 --> 00:31:36,820
块以返回身体或标头阶段，以便我们需要注意

258
00:31:36,820 --> 00:31:41,460
或未收到或我们需要检查我们看到的正确的身体是否正确

259
00:31:42,980 --> 00:31:45,780
我们看不到您正在显示不同幻灯片的阶段

260
00:31:45,779 --> 00:31:51,740
哦，我想跳入代码。

261
00:31:51,740 --> 00:31:52,940
对不起。

262
00:31:52,940 --> 00:31:57,539
是的，我们看到了不同的浏览器窗口。

263
00:31:57,539 --> 00:31:58,539
谢谢。

264
00:31:58,539 --> 00:31:59,539
好的。

265
00:31:59,539 --> 00:32:00,539
好的。

266
00:32:00,539 --> 00:32:02,359
我不知道。

267
00:32:02,359 --> 00:32:06,480
让我停止分享。

268
00:32:06,480 --> 00:32:11,740
抱歉，我跳入共享屏幕。

269
00:32:11,740 --> 00:32:16,859
是的，我想检查一下

270
00:32:16,859 --> 00:32:21,400
呃，你能看到我的

271
00:32:21,400 --> 00:32:27,859
不，我们现在没看到

272
00:32:27,859 --> 00:32:32,799
整个屏幕

273
00:32:41,740 --> 00:32:47,019
好吧，我需要启用它。

274
00:32:47,019 --> 00:32:51,240
我需要回来。

275
00:32:51,240 --> 00:32:53,079
我需要重新打开镀铬。

276
00:32:53,079 --> 00:32:55,960
仅一秒钟。

277
00:32:55,960 --> 00:32:59,140
好的，所以我们有一个快速的中场休息。

278
00:32:59,140 --> 00:33:06,559
同时，人们可以随时提出到目前为止您遇到的任何问题。

279
00:33:06,559 --> 00:33:12,799
它是不同的。

280
00:33:12,799 --> 00:33:15,039
马里奥，也许你想说一点

281
00:33:15,039 --> 00:33:18,599
关于历史同步之间的区别

282
00:33:18,599 --> 00:33:22,839
以及现场同步或SNAP同步情况。

283
00:33:22,839 --> 00:33:27,779
是的，我想问Dragan，以便他可以提供更多详细的信息

284
00:33:27,779 --> 00:33:32,399
说明，因为它可能更特定于红色代码

285
00:33:32,399 --> 00:33:33,220
一般而言。

286
00:33:33,220 --> 00:33:44,319
它的意思是，是否全节点是在删除当前数据并使用它们同步或

287
00:33:44,319 --> 00:33:45,319
从创世纪看到它？

288
00:33:45,319 --> 00:33:50,380
关于现场同步与历史同步，有些疑问，Dragan，但我们

289
00:33:50,380 --> 00:33:52,380
稍后可以进入。

290
00:33:52,380 --> 00:33:53,380
是的。

291
00:33:53,380 --> 00:33:55,460
你要它去吗？

292
00:33:55,460 --> 00:33:56,759
是的，现在应该很好。

293
00:33:56,759 --> 00:33:57,759
仅一秒钟。

294
00:33:57,759 --> 00:34:03,160
我想分享我的全屏幕，然后跳入VCCODE。

295
00:34:04,740 --> 00:34:05,299
是的。

296
00:34:05,579 --> 00:34:06,480
你现在看到了吗？

297
00:34:07,259 --> 00:34:07,940
是的，完美。

298
00:34:08,599 --> 00:34:09,059
好的。

299
00:34:09,519 --> 00:34:09,880
好的。

300
00:34:10,039 --> 00:34:10,860
对此很抱歉。

301
00:34:11,500 --> 00:34:12,480
我以为我们也有。

302
00:34:12,480 --> 00:34:12,840
没问题。

303
00:34:13,019 --> 00:34:13,139
是的。

304
00:34:14,880 --> 00:34:18,639
您是否想讨论问题，还是想以后再讨论？

305
00:34:18,639 --> 00:34:18,780
是啊是啊。

306
00:34:18,980 --> 00:34:22,079
我们现在可以解决一些问题。

307
00:34:22,079 --> 00:34:33,420
是的，问题是，让我正确阅读。

308
00:34:33,420 --> 00:34:37,039
历史同步和现场同步有什么区别？

309
00:34:40,539 --> 00:34:45,619
P历史同步就像同步历史块。

310
00:34:45,619 --> 00:34:51,500
但是实时同步正在同步共识层的块。

311
00:34:51,500 --> 00:34:55,820
这些是下一个将由共识层提出的块。

312
00:34:55,820 --> 00:34:59,179
虽然历史同步正在同步已经提出的那些块，但

313
00:34:59,179 --> 00:35:01,260
所有已知的和所有已验证的。

314
00:35:02,860 --> 00:35:06,300
因此，我们在这里有不同类型的假设。

315
00:35:07,019 --> 00:35:10,300
对于共识层，当我们收到共识层的块时，

316
00:35:10,300 --> 00:35:13,900
我们只收到一个街区，也许是多个块，

317
00:35:13,900 --> 00:35:17,500
但是它们大多就像在尖端附近，就像最新的块一样。

318
00:35:17,500 --> 00:35:26,380
块，但是对于历史同步，我们都不知道，我们已经知道哪些块需要

319
00:35:26,380 --> 00:35:33,699
要重新执行

320
00:35:33,699 --> 00:35:43,059
根据我们有什么尖端，我们有什么尖端或封闭的尖端

321
00:35:43,059 --> 00:35:49,619
从共识层的选择数据与获取执行历史数据和

322
00:35:49,619 --> 00:35:55,619
是的，红色的作用就像舞台同步uh不同的不同方法历史

323
00:35:55,619 --> 00:36:01,139
高度优化的场景，这就是您所进入的目的，只是不显示是的

324
00:36:01,139 --> 00:36:07,619
让你们有上下文，这是红色uh的最大区别之一

325
00:36:07,619 --> 00:36:12,019
它使用此阶段同步的红色架构非常有趣，这是一个不同的

326
00:36:12,019 --> 00:36:18,259
嗯，woodkit有不同的um，还有一个问题

327
00:36:18,259 --> 00:36:23,059
这与Arragon和Aquila有何不同，这是舞台同步

328
00:36:23,059 --> 00:36:27,699
由Arragon开创的，因此，如果您可以总结红色的其他区别

329
00:36:30,579 --> 00:36:35,139
UH与Arragon和Aquila的差异以及

330
00:36:35,139 --> 00:36:44,440
基本上，我们最近介绍的是静态文件。

331
00:36:44,440 --> 00:36:51,980
我们正在使用我们的数据库，密钥值数据库，例如，B3内部，基本上是在

332
00:36:51,980 --> 00:36:52,980
硬盘。

333
00:36:52,980 --> 00:36:55,839
我们只是使用它，只是二进制文件。

334
00:36:55,839 --> 00:37:02,819
我们放置了交易，块，收据，基本上是我们知道的数据

335
00:37:02,820 --> 00:37:10,100
要更改，我们将其以二进制文件的格式列出，并且我们得到了更多数据库

336
00:37:10,100 --> 00:37:17,220
甚至更快的同步时间，例如是的

337
00:37:18,660 --> 00:37:24,820
uh块uh uh将其同步以与区块链树尖端，一切都在内存中，所以我们不

338
00:37:24,820 --> 00:37:28,980
我们没有临时文件，所以

339
00:37:31,539 --> 00:37:36,580
这使我们不得将垃圾存储在数据库中，并且

340
00:37:37,780 --> 00:37:43,780
基本上处理内存中的所有内容，而处理只是依赖于数据

341
00:37:43,780 --> 00:37:51,780
仍然没有验证，所以这是很酷的区别之一，这很有趣

342
00:37:51,780 --> 00:37:57,220
因为是的，我首先认为它会非常相似，但就像我了解

343
00:37:57,220 --> 00:38:03,380
表演uh，例如与一些遗产获得基础，而休息会更快，但我当时

344
00:38:03,380 --> 00:38:07,620
当我认为当时它看起来很健康时，它很惊讶

345
00:38:07,620 --> 00:38:14,900
现在，它可能比每个人的数据库还要多，是的，我们做了很多

346
00:38:14,900 --> 00:38:25,139
诸如uh comp uh之类的优化基本上压缩了我们具有编码的自定义编码的数据

347
00:38:25,139 --> 00:38:32,900
例如，所有数据和接收数据的一切，甚至很少，我们可以使用一些压缩

348
00:38:33,860 --> 00:38:41,700
这样就像缩水了很多，是的，而当时甚至是

349
00:38:41,699 --> 00:38:48,980
可能是当管道同步阶段同步有效时，我们不对

350
00:38:48,980 --> 00:38:57,539
每个街区，而另一个过去的客户获得了公开的以太坊，就像传递一代一样做到了

351
00:38:57,539 --> 00:39:05,939
在每个块中，我们仅在最后才能做到这一点，因此我们仍然验证我们的状态是否有效，一切

352
00:39:05,940 --> 00:39:11,780
状态根基本上是在那里，但我们没有开销来检查每个块

353
00:39:13,940 --> 00:39:18,820
是的，那是很多不错的计算，是的，很有趣，所以我们回来了

354
00:39:18,820 --> 00:39:23,700
现在到舞台同步，也许可以继续您的屏幕，我们可以继续进行此操作，然后继续

355
00:39:25,860 --> 00:39:26,820
共享屏幕

356
00:39:26,820 --> 00:39:33,980
啊，在这里。

357
00:39:33,980 --> 00:39:35,380
惊人的。

358
00:39:35,380 --> 00:39:41,280
是的，我们是文档的忠实拥护者。

359
00:39:41,280 --> 00:39:49,640
是的，管道具有阶段的默认集，它们用于初始阶段

360
00:39:49,640 --> 00:39:54,059
基本上，当管道在代表内部运行时，同步。

361
00:39:54,059 --> 00:39:58,860
很少有这个标题阶段和身体阶段是分别分别的两个阶段。

362
00:39:58,860 --> 00:40:06,139
我们首先运行标头，检查哈希，基本上检查父母哈希，是否匹配。

363
00:40:06,779 --> 00:40:12,860
之后，我们基本上是从P2P下载的，这有点重一些。

364
00:40:14,219 --> 00:40:19,900
我们做发件人恢复阶段。发件人恢复可能很昂贵，所以我们在这里为每个

365
00:40:19,900 --> 00:40:27,579
我们在身体阶段收到的交易基本上需要提取它是谁发送的

366
00:40:28,700 --> 00:40:35,260
在那我们最大的阶段是我们最耗时的舞台执行阶段

367
00:40:36,139 --> 00:40:44,539
在这里，我们确实将发件人交易和标题进行操作，然后在REVM中执行它

368
00:40:44,539 --> 00:40:57,900
他们。输出基本上是我们检查气体是否相同。我们基本上创建收据

369
00:40:57,900 --> 00:41:07,759
我们创建更改集。更改集是帐户之间发生的更改

370
00:41:07,760 --> 00:41:12,760
在一个块中，它是块级别的更改集。

371
00:41:12,760 --> 00:41:15,100
如果执行区有三个，四个，

372
00:41:15,100 --> 00:41:19,980
两个部分，100部分，我们将进行所有这些更改

373
00:41:19,980 --> 00:41:23,460
并制作一张哈希地图。

374
00:41:25,080 --> 00:41:30,080
之后，在执行流中，

375
00:41:30,080 --> 00:41:32,740
这个默克尔阶段被跳过

376
00:41:32,740 --> 00:41:37,180
因为它在放松时就有自己的用途。

377
00:41:37,760 --> 00:41:44,640
基本上执行时，当您从顶部到底部时，

378
00:41:44,640 --> 00:41:51,440
但是，放松的时间以不同的顺序发生，从您想放松的地方，

379
00:41:51,440 --> 00:41:53,720
在哪里发现一些问题，到顶部。

380
00:41:56,240 --> 00:42:03,140
帐户哈希，帐户阶段，基本上处于执行阶段，

381
00:42:03,139 --> 00:42:10,900
我们只有一个普通的状态，即普通状态的关键价值仅为地址

382
00:42:10,900 --> 00:42:20,900
余额注释和余额笔记和代码哈希的帐户信息，而伯克利需要

383
00:42:21,699 --> 00:42:29,219
哈希，虽然需要哈希，但由于订单，它很重要，所以我们有

384
00:42:29,219 --> 00:42:36,099
我将下一步访问数据库，并向您展示这是什么意思，它的方式，数据库的方式

385
00:42:36,099 --> 00:42:43,679
布局是制造的，但是我们需要采取平原状态并将其保存在

386
00:42:43,679 --> 00:42:49,899
帐户，哈希帐户表。

387
00:42:49,899 --> 00:42:54,379
我们在存储中也这样做，然后进行默克尔阶段。

388
00:42:54,380 --> 00:43:02,000
默克尔阶段考虑了，存储，哈希帐户存储，并基本上说明

389
00:43:02,000 --> 00:43:09,200
root并验证状态根对我们需要的块是正确的。

390
00:43:09,200 --> 00:43:19,340
在那之后，我们拥有这是帮助我们进行交易查找的辅助阶段。

391
00:43:19,340 --> 00:43:30,680
之后，这两个阶段使我们能够访问任何历史记录数据。

392
00:43:30,680 --> 00:43:35,039
基本上，执行阶段创建了更改集。

393
00:43:35,039 --> 00:43:42,880
基本上，在执行块之前先前的数据。

394
00:43:42,880 --> 00:43:47,620
而这两个阶段则索引。

395
00:43:47,619 --> 00:44:00,619
这样做是为了使我们可以为我们要获得帐户的每个块号

396
00:44:00,619 --> 00:44:09,759
例如，平衡或帐户节点这个嗯，是的，这使我们能够相同的能力

397
00:44:09,760 --> 00:44:13,420
对于存储而言，也是如此。

398
00:44:13,420 --> 00:44:13,920
对不起。

399
00:44:17,040 --> 00:44:18,120
就回来了。

400
00:44:18,120 --> 00:44:19,200
对于存储而言相同。

401
00:44:19,200 --> 00:44:23,440
类似的是帐户。

402
00:44:23,440 --> 00:44:27,720
并完成了，我们只是宣布我们的结局。

403
00:44:27,720 --> 00:44:34,580
该引擎可以开始从中获得新的共识层

404
00:44:34,580 --> 00:44:36,300
功能从共识层进行更新。

405
00:44:39,760 --> 00:44:54,600
如果我们进入执行阶段，那就不存在。

406
00:44:54,600 --> 00:45:01,240
让我们去。

407
00:45:01,239 --> 00:45:09,099
舞台是最大的一个，所以最好去发送恢复

408
00:45:09,099 --> 00:45:19,539
发送一个恢复，就像某个提交阈值的想法您要如何优化这一点是您

409
00:45:19,539 --> 00:45:26,059
想要有一些界限，我们将要提交多少基本上的数据

410
00:45:26,059 --> 00:45:32,779
你想拥有。我认为这只是您要进行的交易的数量。

411
00:45:34,779 --> 00:45:38,779
例如，我们在发送恢复中检查执行。

412
00:45:40,299 --> 00:45:47,099
我们检查，我们得到的输入说，嘿，我们想从街区执行此阶段

413
00:45:47,099 --> 00:45:56,059
盖百万到街区200万或一百万，一半uh我们取下下一个街区

414
00:45:56,059 --> 00:46:06,400
范围交叉点基本上我们在该范围内采用块，它是空目标的

415
00:46:06,400 --> 00:46:14,960
对于周围的一切，我们进行恢复范围。

416
00:46:17,960 --> 00:46:20,720
例如，我们希望它非常优化。

417
00:46:20,760 --> 00:46:25,200
这样，它非常密集，因为它已经完成了恢复。

418
00:46:25,240 --> 00:46:30,680
我们催生了多个Tokyo任务，该任务可以在并行完成所有操作。

419
00:46:30,720 --> 00:46:36,119
如果在静态文件中获取我们需要的交易。

420
00:46:36,400 --> 00:46:41,820
在那之后，如果一切正常，请报告问题。

421
00:46:42,099 --> 00:46:53,900
如果不是这样，我们会更新具有相交中心的数据库表。

422
00:46:55,200 --> 00:47:02,099
此示例的想法是表明每个阶段都在做一件事。

423
00:47:02,099 --> 00:47:07,480
每个阶段都可以优化其参数

424
00:47:07,480 --> 00:47:11,259
关于需要完成的工作。

425
00:47:12,500 --> 00:47:14,279
它没有恢复，而是CPU密集型，

426
00:47:14,440 --> 00:47:18,839
因此，我们使用许多东京任务并行化

427
00:47:18,839 --> 00:47:22,619
我们希望它是，是的，

428
00:47:23,079 --> 00:47:26,739
我们可以更好地优化它。

429
00:47:26,739 --> 00:47:38,239
执行阶段是最大的乐趣之一，基本上花费了最长的执行时间。

430
00:47:38,239 --> 00:47:47,259
原因基本上是EVM，它是CPU密集的，是执行200亿

431
00:47:47,259 --> 00:47:56,000
交易它从标头的输入表典型的标题终端难度基本上难度

432
00:47:56,000 --> 00:48:05,039
所有标题和障碍交叉口都使其访问普通帐户状态和普通存储

433
00:48:06,239 --> 00:48:14,480
用引号用引号在单独的表中，基本更新是普通状态和帐户

434
00:48:14,480 --> 00:48:24,800
更改集um是的

435
00:48:24,800 --> 00:48:27,480
变更集被丢弃了。

436
00:48:35,000 --> 00:48:35,640
是的。

437
00:48:36,140 --> 00:48:37,080
哈希存储。

438
00:48:42,060 --> 00:48:44,560
我不确定是否有问题

439
00:48:44,560 --> 00:48:48,340
还是我应该转到数据库？

440
00:48:54,800 --> 00:48:59,280
嗯，您现在在说什么，但没有任何具体问题

441
00:48:59,280 --> 00:49:05,280
有一些要求UM的要求，也许您要经历建立块的过程

442
00:49:06,080 --> 00:49:12,160
并在愤怒中使用状态转移和功能也许适合这里

443
00:49:13,280 --> 00:49:16,640
稍后在演示文稿中如何构建块

444
00:49:16,639 --> 00:49:21,920
好吧，我会来到有效载荷构建器。

445
00:49:21,920 --> 00:49:23,920
凉爽的。

446
00:49:23,920 --> 00:49:27,980
好的，是的。

447
00:49:27,980 --> 00:49:39,139
嗯，是的，存储很有趣。

448
00:49:39,139 --> 00:49:44,139
在存储中，我们有一个法典，可以

449
00:49:44,179 --> 00:49:46,920
对于钥匙，它需要编码，

450
00:49:46,920 --> 00:49:50,159
对于值，它需要被压缩。

451
00:49:50,159 --> 00:49:51,519
我们仍然需要

452
00:49:53,480 --> 00:49:56,500
我们不能压缩整数和输

453
00:49:56,500 --> 00:49:58,960
大于能力。

454
00:50:02,279 --> 00:50:05,400
紧凑，这是用于压缩的。

455
00:50:07,039 --> 00:50:08,239
对于数据库，

456
00:50:09,139 --> 00:50:13,299
静态文件，是的。

457
00:50:13,299 --> 00:50:23,420
我们的抽象使我们能够抽象化数据库当前我们只有MDBX，但是

458
00:50:23,420 --> 00:50:33,179
这个想法是替换它或具有切换数据库的能力。

459
00:50:33,179 --> 00:50:45,779
是的，这在非常低级的数据库访问中实现了此基于跟踪的抽象

460
00:50:45,779 --> 00:50:51,639
您的部分可与部分相变，使您正确的访问光标很有趣

461
00:50:51,639 --> 00:51:00,259
一个允许您迭代值或数据库中的一个可以非常

462
00:51:00,260 --> 00:51:09,320
更快地获取相交或阻止或计算默克尔路线时的方法

463
00:51:09,320 --> 00:51:19,000
因为一个接一个地访问值的速度比随机寻求的速度要快得多

464
00:51:19,000 --> 00:51:22,540
值。

465
00:51:22,540 --> 00:51:25,460
写作是正确的。

466
00:51:25,460 --> 00:51:32,340
因此，如果您想编写大量数据，如果可以对它们进行排序，并且

467
00:51:32,340 --> 00:51:36,800
以排序顺序写入。

468
00:51:36,800 --> 00:51:54,199
DB基本上是IT实施的低级键值数据库。

469
00:51:54,199 --> 00:52:01,960
在这里，最有趣的是，我们在红色表视图中拥有的数据布局

470
00:52:04,039 --> 00:52:04,839
啊，他们是

471
00:52:07,799 --> 00:52:15,399
um规范的标题允许我们钥匙阻止数字到标题哈希

472
00:52:16,599 --> 00:52:18,839
计时器困难用于

473
00:52:18,840 --> 00:52:30,180
对于目前未使用的工作证明，此数字是实用程序块哈希

474
00:52:30,180 --> 00:52:39,900
编号标头这是uh的表格，该桌子由块号块主体索引

475
00:52:39,900 --> 00:52:45,880
索引我们有有趣的事务，这些交易是由交易索引的

476
00:52:45,880 --> 00:52:55,320
该部分的数字和块主索引基本上告诉我们此块号

477
00:52:55,320 --> 00:53:04,180
uh量的uh截面号基本上落入了这个块

478
00:53:04,179 --> 00:53:11,980
阻止UH Block Commerce UH

479
00:53:11,980 --> 00:53:18,940
块提取这是为了证明这一点的证明

480
00:53:18,940 --> 00:53:19,940
几乎基本上

481
00:53:19,940 --> 00:53:29,179
嗯，一切都是表

482
00:53:29,179 --> 00:53:35,379
这基本上是执行的部分和截面的编号。

483
00:53:35,379 --> 00:53:39,179
如果需要，进行一次交易要容易得多。

484
00:53:39,179 --> 00:53:41,679
哈希号的部分是逆的。

485
00:53:41,679 --> 00:53:49,279
如果要通过哈希获取部分，我们会得到交易号。

486
00:53:49,280 --> 00:53:54,280
该索引存储最高

487
00:53:55,019 --> 00:53:59,740
到此块的截面号。

488
00:53:59,740 --> 00:54:02,280
基本上，这并不是块的每个交集号码

489
00:54:02,280 --> 00:54:04,180
这是最高的公正。

490
00:54:04,180 --> 00:54:07,460
这使我们可以从截面号

491
00:54:07,460 --> 00:54:09,360
获取块号。

492
00:54:10,460 --> 00:54:13,440
收据由部分编号索引，

493
00:54:13,440 --> 00:54:15,500
字节代码由其哈希索引。

494
00:54:17,400 --> 00:54:18,980
这是普通状态。

495
00:54:19,280 --> 00:54:27,840
基本上是执行阶段更新平原状态，播放状态仅适用于Play帐户

496
00:54:27,840 --> 00:54:36,300
播放状态它具有地址，只有帐户信息帐户信息

497
00:54:36,300 --> 00:54:48,360
余额，所有在存储中都有钥匙基本帐户子键或

498
00:54:49,280 --> 00:54:57,960
是的，subkey是哈希，基本上是该存储的关键。

499
00:54:57,960 --> 00:55:09,560
因为我提到了子键，所以MDBX允许在表中具有重复的值。

500
00:55:09,560 --> 00:55:17,060
这使我们可以更快地访问某些值。

501
00:55:17,059 --> 00:55:29,099
在这种情况下，我们可以拥有主要的关键地址，并且基本上可以放大。

502
00:55:29,099 --> 00:55:37,980
帐户历史记录很有趣，但首先我想谈谈变更集。

503
00:55:37,980 --> 00:55:44,460
帐户更改集，每个块号的存储更改集，我们之前有帐户

504
00:55:44,460 --> 00:55:47,900
该部分和子键是地址。

505
00:55:47,900 --> 00:55:52,900
因此，对于每个块，对于每个变更帐户，

506
00:55:52,900 --> 00:55:55,480
我们有以前的值。

507
00:55:56,679 --> 00:56:00,559
为表的更改设置，每个块号

508
00:56:00,559 --> 00:56:03,760
地址的地址为帐户。

509
00:56:03,760 --> 00:56:08,659
我们有存储密钥和先前的存储值。

510
00:56:08,659 --> 00:56:12,659
这些更改集由执行生成

511
00:56:12,659 --> 00:56:16,219
并由默克尔树使用

512
00:56:16,219 --> 00:56:21,219
或任何历史记录跟踪RPC（如果需要）。

513
00:56:23,559 --> 00:56:26,699
格式树用于增量

514
00:56:26,699 --> 00:56:28,440
默克树计算，

515
00:56:28,440 --> 00:56:32,539
因为当您计算我们的第一个默克尔树时，

516
00:56:32,539 --> 00:56:35,719
所有文档，所有计算

517
00:56:35,719 --> 00:56:38,619
默克尔树的含量应为增量。

518
00:56:38,619 --> 00:56:56,099
而且，在我们进行了这些更改集之后，我们基本上都在做帐户历史记录

519
00:56:56,099 --> 00:57:07,039
在这种情况下，对于每个地址，碎片密钥，基本上都包含每个帐户，

520
00:57:07,039 --> 00:57:11,279
它包含更改该帐户的块列表。

521
00:57:12,320 --> 00:57:14,599
因此，如果您想找到块

522
00:57:14,599 --> 00:57:19,239
100万块的帐户余额

523
00:57:19,239 --> 00:57:21,579
我们正在检查

524
00:57:21,579 --> 00:57:27,380
下一个帐户在哪里更改。

525
00:57:27,900 --> 00:57:31,599
如果此更改是100万个块

526
00:57:31,599 --> 00:57:35,320
然后我们需要获取更改集

527
00:57:35,320 --> 00:57:44,280
在该帐户中，历史帐户历史和存储历史记录允许我们

528
00:57:45,240 --> 00:57:50,360
索引更改集并找到历史中发生的变化

529
00:57:54,440 --> 00:57:56,600
uh Hashed帐户在这里存储

530
00:57:56,599 --> 00:58:08,360
嗯，市场树使用了基本上需要进行第一次计算

531
00:58:08,360 --> 00:58:11,079
他们需要对哈希帐户进行分类

532
00:58:13,400 --> 00:58:15,079
天有主意

533
00:58:17,559 --> 00:58:24,119
基本上合并了Hashed帐户和普通帐户，基本上是与主题标签

534
00:58:24,119 --> 00:58:32,039
说明我们只有哈希州状态，它将减少数据库中的占地面积

535
00:58:32,039 --> 00:58:39,079
100千兆字节，如果您愿意

536
00:58:39,079 --> 00:58:45,319
获取帐户，您仍然需要获得您需要进行哈希的帐户，但是为了我们的测量

537
00:58:45,320 --> 00:58:52,940
因此，它留下了历史同步，主瓶颈执行同步是EVM。

538
00:58:52,940 --> 00:58:56,660
所以这很重要。

539
00:58:56,660 --> 00:59:13,200
帐户树，存储树是默克尔，帕特里夏，基本上是计算所需的节点

540
00:59:13,199 --> 00:59:28,480
它允许它获取执行中使用的地址，并且发件人恢复所需

541
00:59:29,679 --> 00:59:39,919
舞台检查点使我们能够知道舞台停止的位置以及我们需要什么

542
00:59:39,920 --> 00:59:52,800
接下来做。修剪检查点，直到我们修剪数据时，才能知道。基本上，修剪，

543
00:59:53,599 --> 00:59:59,519
可以设置多个参数，但是修剪主要意味着我们删除

544
01:00:00,559 --> 01:00:08,559
这些更改集的更改集和索引。因此它删除了历史数据，因此只有

545
01:00:08,559 --> 01:00:12,719
尖端可以被提取。

546
01:00:12,719 --> 01:00:22,239
当然，最后一个桌子是历史。

547
01:00:22,239 --> 01:00:29,679
您对此有疑问吗？

548
01:00:29,679 --> 01:00:38,519
还是太多了？

549
01:00:38,519 --> 01:00:39,360
你可以分享吗？

550
01:00:39,360 --> 01:00:44,360
不，目前没有特定的问题。

551
01:00:46,159 --> 01:00:47,000
好吧，很酷。

552
01:00:48,420 --> 01:00:52,000
是的，我想回到谈论

553
01:00:53,019 --> 01:00:56,860
检查验证，这是一个前面的方法，

554
01:00:56,860 --> 01:01:01,860
但是你，什么样的缺点不做什么

555
01:01:03,159 --> 01:01:06,460
每个块都有默克尔验证检查吗？

556
01:01:06,460 --> 01:01:16,900
基本上是缺点，我们没有历史的证据。

557
01:01:16,900 --> 01:01:26,099
基本上，以太坊的获取和打开的以太坊都可以在每个时间点基本上获取

558
01:01:26,099 --> 01:01:29,400
每个帐户存储的默克尔证明。

559
01:01:29,400 --> 01:01:30,400
这将被删除。

560
01:01:30,400 --> 01:01:35,680
我们只有一个时间点的市场证明

561
01:01:38,079 --> 01:01:47,119
因此，我们需要喜欢UM注意何时在小费上进行reorg，以解开市场树并更新

562
01:01:47,119 --> 01:01:53,119
市场也许一个缺点可能是增加复杂性，但在一般的市场树和一切

563
01:01:53,119 --> 01:02:00,000
这很复杂，因为最终您会得到一个哈希和

564
01:02:00,000 --> 01:02:05,639
每个验证都取决于该缓存，这并不意味着您不喜欢

565
01:02:05,639 --> 01:02:13,359
中级步骤如何获得您犯错的步骤，无论是否在哪里

566
01:02:13,359 --> 01:02:13,819
正确的

567
01:02:13,819 --> 01:02:20,639
你问的是

568
01:02:20,639 --> 01:02:25,199
关于验证。

569
01:02:28,159 --> 01:02:30,299
什么样的验证？

570
01:02:30,639 --> 01:02:32,139
块验证还是？

571
01:02:32,319 --> 01:02:32,759
是的。

572
01:02:33,019 --> 01:02:37,099
所以马特正在解释获取代码基础

573
01:02:37,099 --> 01:02:39,559
从状态过渡函数的角度来看。

574
01:02:39,559 --> 01:02:43,519
因此，基本上通过验证交易来创建新块

575
01:02:43,519 --> 01:02:46,139
并将它们包括在一个块中，计算标头。

576
01:02:46,139 --> 01:02:54,000
而且，就像，实际上，当您被要求建立博客时，这会发生，但通常是

577
01:02:54,000 --> 01:03:01,099
就像GET的验证一样，当然在红色上有所不同，但是如果您可以

578
01:03:01,099 --> 01:03:08,379
引导我们通过发生这种情况的代码库，在某些情况下，有些（例如）

579
01:03:08,380 --> 01:03:18,619
嗯，嗯，evm预编译为uh，这是红色和嗯，是的，是的

580
01:03:18,619 --> 01:03:25,740
我们被执行到第一节的三个地方在管道内

581
01:03:27,340 --> 01:03:32,300
这是在舞台内部的，它们都相似，但有点不同

582
01:03:32,300 --> 01:03:35,800
大多数不同的一半是数据的手柄输出。

583
01:03:39,060 --> 01:03:44,060
它在哪里，指标，阶段，来源。

584
01:03:46,000 --> 01:03:49,380
块上的大量检查和分段错误

585
01:03:49,380 --> 01:03:51,680
被封装在REVM中。

586
01:03:51,680 --> 01:03:55,120
因此，REVM完成了很多繁重的工作。

587
01:03:56,560 --> 01:04:01,560
示例在这里，在此处启动块，

588
01:04:02,300 --> 01:04:08,360
根据块的范围，我们将起始块迭代到最大块

589
01:04:08,360 --> 01:04:10,740
我们想执行。

590
01:04:10,740 --> 01:04:21,860
我们获取标题，我们获取该块的发件人，在这里我们执行验证收据。

591
01:04:21,860 --> 01:04:26,680
基本上，我们有一个障碍，我们有一个完全的困难来证明

592
01:04:26,679 --> 01:04:38,919
工作基本上是历史执行，这是我们有一个

593
01:04:38,919 --> 01:04:44,919
基本上封装不同的不同，它称为处理器

594
01:04:44,919 --> 01:04:50,619
乐观主义者处理器比关心分钟或处理器，并具有

595
01:04:50,619 --> 01:04:59,920
在需要时切换它们。例如，这是主要网络。是的，主处理器

596
01:04:59,920 --> 01:05:14,159
我们有。在此处，它执行内部块，它基本上是与之初始化的数组VM

597
01:05:14,159 --> 01:05:21,500
标题IT初始化应用UH信标根合同呼叫基本上是系统调用

598
01:05:21,500 --> 01:05:34,159
这是在更新UM共识层哈希块哈希和此处更新的cancun上完成的

599
01:05:34,159 --> 01:05:36,440
在这里，我们执行交易。

600
01:05:36,440 --> 01:05:42,259
基本上，这一切都是在处理器中完成的。

601
01:05:42,259 --> 01:05:52,119
在每个块中，我们进行交易，基本上是此迭代器，检查该迭代器的气体限制

602
01:05:52,119 --> 01:05:56,480
块和样带。

603
01:05:56,480 --> 01:05:58,980
这是REVM的功能。

604
01:05:58,980 --> 01:06:01,719
哦，我们还在这里

605
01:06:01,719 --> 01:06:04,280
是的

606
01:06:04,280 --> 01:06:05,159
我们填补了

607
01:06:05,159 --> 01:06:06,679
切除参数

608
01:06:06,679 --> 01:06:09,320
检查我们是否需要

609
01:06:09,320 --> 01:06:10,159
打电话

610
01:06:10,159 --> 01:06:11,179
示踪剂

611
01:06:11,179 --> 01:06:12,519
我们正在打电话

612
01:06:12,519 --> 01:06:13,300
IT检查员

613
01:06:13,300 --> 01:06:14,559
与Revm

614
01:06:14,559 --> 01:06:19,260
我们基本上

615
01:06:19,260 --> 01:06:21,219
需要

616
01:06:21,219 --> 01:06:22,199
添加

617
01:06:22,199 --> 01:06:23,119
处理者

618
01:06:23,119 --> 01:06:23,800
为此

619
01:06:23,800 --> 01:06:25,079
跟踪

620
01:06:25,079 --> 01:06:27,260
在这里

621
01:06:27,260 --> 01:06:28,240
我们在这里做

622
01:06:28,240 --> 01:06:28,900
切除

623
01:06:28,980 --> 01:06:37,860
总体而言，我们现在正在REVM中，它验证了我们从

624
01:06:37,860 --> 01:06:47,980
ret检查将检查初始交易气

625
01:06:47,980 --> 01:06:57,360
状态因此，我们在这里直到这里我们只检查了我们在此处收到的数据获取帐户

626
01:06:57,360 --> 01:07:02,079
那是交叉路口的交叉点。

627
01:07:06,240 --> 01:07:08,800
我们开始执行。

628
01:07:11,360 --> 01:07:19,599
是的，我们现在仍在REVM中。最近被重构了，

629
01:07:19,599 --> 01:07:24,599
因此，我们将上下文和逻辑分开。

630
01:07:25,299 --> 01:07:30,299
上下文是数据，交易，阻止和预编译，

631
01:07:30,400 --> 01:07:33,819
但是逻辑是在处理程序内部处理的，

632
01:07:35,539 --> 01:07:36,619
怎么称呼？

633
01:07:38,639 --> 01:07:41,039
在这里，上下文和处理者。

634
01:07:41,039 --> 01:07:44,539
处理程序包含功能列表

635
01:07:44,539 --> 01:07:46,159
包含逻辑。

636
01:07:46,159 --> 01:07:47,799
因此，您可以围绕它做任何事情。

637
01:07:47,800 --> 01:07:58,960
这个想法是将来能够使用的，即使现在已经使用了

638
01:07:58,960 --> 01:08:05,100
将允许您喜欢乐观级别的更改或乐观主义逻辑

639
01:08:05,100 --> 01:08:06,100
REVM。

640
01:08:06,100 --> 01:08:15,320
它在RET的范围上完成了类似的操作，但是现在好多了。

641
01:08:15,320 --> 01:08:19,480
仍然需要在REVM中进行一些重构

642
01:08:20,279 --> 01:08:24,760
嗯，它是样带

643
01:08:25,960 --> 01:08:30,920
在这里，我们是第一步，第一处理程序是加载帐户

644
01:08:30,920 --> 01:08:36,199
之后正在加载前围栏，例如，您可以使用处理程序

645
01:08:36,199 --> 01:08:39,720
加载额外的预媒体

646
01:08:39,720 --> 01:08:48,100
现在，我们以可能使用的最大气体限制来扣除呼叫者。

647
01:08:48,280 --> 01:08:58,180
想法是这样的，在该部分正在进行过程中，他无法提供比他更多的平衡。

648
01:08:58,180 --> 01:09:06,860
计算出的气体限制，具体取决于部分内部的气体限制并扣除初始气体限制

649
01:09:06,860 --> 01:09:14,260
汽油支出取决于您拥有多少零和零体

650
01:09:14,260 --> 01:09:22,579
在这里，我们执行它至少有两种类型的执行

651
01:09:22,579 --> 01:09:31,699
它广泛要求合同并在完成后建立新合同，我们有

652
01:09:32,739 --> 01:09:43,779
这是几个月前的主要循环

653
01:09:43,779 --> 01:09:49,939
召集的额外合同合同现在已更改为简单的循环

654
01:09:49,939 --> 01:10:02,319
它正在运行循环，即EVM的主要循环，在这里完成，它只是循环

655
01:10:02,319 --> 01:10:13,059
堆栈框架和堆栈帧例如，频段呼叫或sub呼叫，sub call，sub call，

656
01:10:13,060 --> 01:10:21,060
图表解释器检查字节码并执行IT指令，让我们回去

657
01:10:23,300 --> 01:10:24,900
执行完成后

658
01:10:27,220 --> 01:10:27,940
我们接受

659
01:10:31,700 --> 01:10:40,020
我们有一些UH基本上需要处理最后一个颜色的最后框架创建的最后框架

660
01:10:40,020 --> 01:10:47,380
回报我们需要在那里处理一些逻辑之后，我们用不属于的气体向呼叫者报销呼叫者

661
01:10:47,380 --> 01:10:57,620
花费的我们奖励受益人基本上发送较小的奖励uh un tir奖励。

662
01:10:57,620 --> 01:11:06,660
为了工作证明，这是的，它已发送给董事会证明和专业证明

663
01:11:06,659 --> 01:11:15,000
我们在这里处理输出，如果发生错误或返回字节代码，则返回错误

664
01:11:15,000 --> 01:11:24,279
返回的字节是的，是的，主要是从revm那里

665
01:11:24,279 --> 01:11:38,500
现在，我们仍在RET内，仍在处理器中，执行该部分。

666
01:11:38,500 --> 01:11:44,979
当该部分执行后，我们将获得一些结果。

667
01:11:44,979 --> 01:11:51,599
我们检查了多少时间，并在数据库内提交该状态。

668
01:11:51,600 --> 01:12:02,000
因此，如果您不想要它，它基本上不会提交任何内容。

669
01:12:02,000 --> 01:12:06,560
它基本上返回了变更的状态。

670
01:12:06,560 --> 01:12:15,860
之后，我们传达气体，创建收据，仅此而已。

671
01:12:15,859 --> 01:12:26,119
如果您返回，执行内部，我们检查气体是否与使用的气体相匹配，并检查

672
01:12:26,119 --> 01:12:27,619
如果...

673
01:12:27,619 --> 01:12:36,619
现在，我们有执行后状态变化，这是前面的较小奖励

674
01:12:36,619 --> 01:12:38,099
工作。

675
01:12:38,100 --> 01:12:49,660
我们检查，我们是否需要修剪数据，基本上不合并它。

676
01:12:49,660 --> 01:12:52,320
合并部分。

677
01:12:52,320 --> 01:12:56,340
和收据，退货收据。

678
01:12:56,340 --> 01:13:05,680
在这里，我们验证收据，如果可以的话，请保存收据。

679
01:13:05,680 --> 01:13:14,480
因此，两个阶段都使用执行和验证收据，而块构建器仅使用

680
01:13:14,480 --> 01:13:24,480
执行，因此在执行时不需要验证收据。

681
01:13:24,480 --> 01:13:27,920
这是在舞台上。

682
01:13:27,920 --> 01:13:33,359
阶段是使用REVM的一个地方。

683
01:13:33,359 --> 01:13:39,260
第二位是区块链树内。

684
01:13:39,260 --> 01:13:43,899
区块链树。

685
01:13:43,899 --> 01:13:51,600
事件，状态，街区，规范链。

686
01:13:51,600 --> 01:13:56,460
这是针对区块链树，一切都在内存中完成。

687
01:13:56,460 --> 01:14:09,800
因此，您有一些等待的状态，它已在数据库链周围包装中使用了包裹

688
01:14:09,800 --> 01:14:29,680
这不是扩展的规范链，不是因为它是捆绑状态没有可共享的叉子

689
01:14:29,680 --> 01:14:33,840
不是插入，而是

690
01:14:37,600 --> 01:14:44,480
叉忘了如何将其设置为侧边栏是如何在这里

691
01:14:44,480 --> 01:14:49,039
父母的阴影，我们将块附加到当前内部的链条

692
01:14:49,039 --> 01:14:52,880
它在链中

693
01:14:52,880 --> 01:14:56,920
在这里，我们称为palifattheexecute。

694
01:14:56,920 --> 01:15:04,699
validatTheexecute，我们现在需要像您想要的数据库上一样

695
01:15:04,699 --> 01:15:12,760
执行，加上我们在区块链树内的填充状态。

696
01:15:12,760 --> 01:15:21,320
我们将其包装在某些数据库中，然后在这里打电话给我们创建执行程序

697
01:15:22,600 --> 01:15:28,280
块执行执行验证收据我们都去过那里

698
01:15:31,480 --> 01:15:38,680
是的，基本上它再次使用处理器来验证所有内容以验证以执行所有内容

699
01:15:38,680 --> 01:15:48,920
因为区块链树和阶段都需要它拥有所有需要的数据

700
01:15:50,520 --> 01:15:52,440
验证他们是否正确

701
01:15:57,000 --> 01:16:02,600
第三位在节点内

702
01:16:05,000 --> 01:16:07,880
有效载荷以太坊

703
01:16:08,680 --> 01:16:28,560
我们有多个建筑商可以优化以太坊，因为它有些不同。

704
01:16:28,560 --> 01:16:30,520
我认为就是这样。

705
01:16:30,520 --> 01:16:34,640
默认以太坊有效载荷构建器。

706
01:16:34,640 --> 01:16:42,500
我们创建数据库，创建有效载荷所需的内容，预块信标路由合同

707
01:16:42,500 --> 01:16:47,700
呼叫，基本上，这是在坎昆内启用的系统调用。

708
01:16:47,700 --> 01:16:57,200
我们在此处获取部分池的部分，检查是否有更多的气体使用

709
01:16:57,199 --> 01:17:00,500
比您要构建的块的设定气体限制。

710
01:17:03,519 --> 01:17:12,340
是AIP，如果是斑点，我们只是创建我们的EVM

711
01:17:12,340 --> 01:17:16,239
我们使用EVM进行横切。

712
01:17:17,079 --> 01:17:18,840
它不会通过处理器。

713
01:17:19,179 --> 01:17:20,880
它直接使用EVM。

714
01:17:20,880 --> 01:17:24,079
如果是错误

715
01:17:24,079 --> 01:17:25,579
这意味着相同的验证

716
01:17:25,579 --> 01:17:28,180
或一些检查不是

717
01:17:28,180 --> 01:17:29,119
正确的

718
01:17:29,119 --> 01:17:31,840
如果可以的话

719
01:17:31,840 --> 01:17:33,720
那个状态得到

720
01:17:33,720 --> 01:17:35,500
致力于数据库

721
01:17:35,500 --> 01:17:37,920
这是完成的

722
01:17:37,920 --> 01:17:39,180
直到

723
01:17:39,180 --> 01:17:42,819
直到我们有

724
01:17:42,819 --> 01:17:47,640
直到我们有足够的气体

725
01:17:47,640 --> 01:17:48,539
填充块

726
01:17:48,539 --> 01:17:55,699
是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，

727
01:17:55,699 --> 01:17:59,880
是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，

728
01:17:59,880 --> 01:18:00,880
是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，

729
01:18:00,880 --> 01:18:01,880
是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，

730
01:18:01,880 --> 01:18:02,880
是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是，是否，是，是，是，是，是，是，

731
01:18:02,880 --> 01:18:09,260
需要标头状态根，计算截面根，在这里我们计算截面

732
01:18:09,260 --> 01:18:18,859
基本上是扎根，在这里我们应该计算，是的，主要是这样。

733
01:18:18,859 --> 01:18:26,019
这有什么问题吗？

734
01:18:26,019 --> 01:18:33,079
我不确定我是否杀了听众。

735
01:18:33,079 --> 01:18:38,739
我们仍然和你在一起。

736
01:18:38,739 --> 01:18:41,019
还有一些问题。

737
01:18:41,019 --> 01:18:43,260
我不确定与博客构建有关。

738
01:18:50,199 --> 01:18:56,000
是的，有一个问题跟随一个

739
01:18:56,000 --> 01:18:59,219
我们在跳过之前讨论了

740
01:18:59,219 --> 01:19:01,599
默克尔验证。

741
01:19:01,599 --> 01:19:07,800
因此，这是否也适用于存储余额，

742
01:19:07,800 --> 01:19:19,140
当您不计算默克尔时，我们如何获得特定块的准确帐户？

743
01:19:19,140 --> 01:19:25,199
所以基本上是...

744
01:19:25,199 --> 01:19:26,600
是的。

745
01:19:26,600 --> 01:19:31,340
我不确定我是否理解。

746
01:19:31,340 --> 01:19:33,520
是的，是的。

747
01:19:33,520 --> 01:19:42,960
Merkle优化，是否与其他客户进行比较，是否存在差异

748
01:19:42,960 --> 01:19:50,920
当您如何获得这些基本中间状态和特定块的所有数据

749
01:19:50,920 --> 01:19:57,060
您不会从Merkle数据中计算它来获得它。

750
01:19:57,060 --> 01:20:04,340
呃，为斑点我们为斑点或blob的帐户，我们没有任何东西

751
01:20:04,340 --> 01:20:15,220
在那里，但总的来说，我们检查的假设基本上是我们可以做出的

752
01:20:15,220 --> 01:20:19,620
对于最终确定的历史记录块，我们只需要检查一次

753
01:20:19,620 --> 01:20:24,900
我们不需要检查以前的每个状态，因为如果您仅检查当前状态

754
01:20:24,899 --> 01:20:34,420
或提示中的当前状态，我们知道我们有正确的状态。之后，我们只是逐步

755
01:20:35,539 --> 01:20:44,420
检查Merkle状态，类似Merkle的根，并且算法更快。

756
01:20:44,420 --> 01:20:49,319
是的，你可以吗

757
01:20:49,319 --> 01:20:51,340
这里的另一个问题是

758
01:20:51,340 --> 01:20:54,380
发件人恢复是什么

759
01:20:54,380 --> 01:20:55,960
在执行阶段

760
01:20:55,960 --> 01:21:00,359
基本上是发送部分时

761
01:21:00,359 --> 01:21:02,300
你只有

762
01:21:02,300 --> 01:21:04,380
有效载荷和你

763
01:21:04,380 --> 01:21:05,000
有签名

764
01:21:05,000 --> 01:21:08,380
从您正在恢复的签名中

765
01:21:08,380 --> 01:21:10,480
发件人基本上是谁

766
01:21:10,480 --> 01:21:11,920
男孩或女孩

767
01:21:11,920 --> 01:21:13,399
谁发送了该部分

768
01:21:13,399 --> 01:21:18,399
因此，这可能是非常密集的，这就是为什么我们有单独的阶段。

769
01:21:18,399 --> 01:21:24,739
我们将在数据库中保存该值，因此从数据库中获取它的速度更快

770
01:21:24,739 --> 01:21:28,359
而不是在SQL阶段再次重新计算它。

771
01:21:30,799 --> 01:21:37,659
好的，我们正在讨论数据库引擎MDBX。

772
01:21:37,659 --> 01:21:43,000
也许如果您可以告诉一下，例如LevelDB或Cebble的主要区别是什么？

773
01:21:43,000 --> 01:21:48,039
这主要是mdbx uh，我们基本上是

774
01:21:50,920 --> 01:21:57,880
缩小范围或我们如何使用IT静态文件作为交叉点，块和收据

775
01:21:57,880 --> 01:22:04,840
利润罚款基本上是二进制文件，说像打开文件一样，将部分放置一些索引

776
01:22:04,840 --> 01:22:08,920
它对MDBX的工作非常好，它允许它喜欢

777
01:22:08,920 --> 01:22:16,899
像原子一样，像原子一样，就像从硬盘级别获取。

778
01:22:16,899 --> 01:22:23,140
因此，它允许您具有打开新过程并阅读数据库的能力

779
01:22:23,140 --> 01:22:24,140
模式。

780
01:22:24,140 --> 01:22:26,319
那是用例之一。

781
01:22:26,319 --> 01:22:38,340
它是类似于位的数据库的读取速度，因此对执行更有用。

782
01:22:38,340 --> 01:22:44,659
是的，我们正在调查替代品。

783
01:22:44,659 --> 01:22:48,739
我认为这不会长期保持。

784
01:22:48,739 --> 01:22:55,300
但是就目前而言，它正在工作，基本上是在完成需要做的工作。

785
01:22:55,300 --> 01:22:59,039
因此，我们愿意寻求新的替代方案，但是现在，是的。

786
01:22:59,039 --> 01:23:01,560
是的，很有趣。

787
01:23:01,560 --> 01:23:05,060
是的，弗吉尼亚州的俄罗斯文档，对吗？

788
01:23:06,180 --> 01:23:06,700
是的。

789
01:23:06,700 --> 01:23:08,100
我们也有一个英语。

790
01:23:09,740 --> 01:23:10,260
好的。

791
01:23:10,860 --> 01:23:13,320
我看不到任何新问题。

792
01:23:13,680 --> 01:23:16,560
哦，是的，有，您是否可以指出我们，

793
01:23:16,780 --> 01:23:18,300
是的，我们有最后10分钟。

794
01:23:18,820 --> 01:23:21,400
也许如果您可以向我们展示引擎API通信

795
01:23:21,400 --> 01:23:25,200
以及如何通过新有效载荷触发该块建筑物，

796
01:23:26,120 --> 01:23:28,000
像，还是在哪里发生？

797
01:23:28,600 --> 01:23:29,120
好的。

798
01:23:29,119 --> 01:23:39,800
NG-API有点隐藏，因为它是内部共识，所以它是板条

799
01:23:39,800 --> 01:23:49,000
信标发动机。

800
01:23:49,000 --> 01:23:53,059
让我们来看看。

801
01:23:53,060 --> 01:24:09,020
block客户听众挂钩是的，很酷，考虑到这是有意识的

802
01:24:09,020 --> 01:24:14,280
可能结构有一个具有NGC控制器的区块链树控制

803
01:24:14,279 --> 01:24:24,679
管道嗯，基本上很复杂，因为它需要击中同步很多

804
01:24:24,679 --> 01:24:32,439
从有效载荷构建器到焦点更新到区块链树到管道的组件

805
01:24:33,000 --> 01:24:41,960
就像它周围所有事物的控制枢纽一样，它被实现为功能

806
01:24:44,279 --> 01:24:48,439
这里是。

807
01:24:48,439 --> 01:24:56,039
叉选择更新。

808
01:24:56,039 --> 01:25:02,880
关于叉选择更新。

809
01:25:02,880 --> 01:25:09,539
它应该是那种。

810
01:25:09,539 --> 01:25:13,699
一致的状态，确保规范更新头。

811
01:25:17,399 --> 01:25:20,039
流程有效载荷属性。

812
01:25:26,159 --> 01:25:27,199
是的，是。

813
01:25:28,659 --> 01:25:32,519
RPC部分称此工作跟踪更新，

814
01:25:32,519 --> 01:25:34,760
但是我认为这个主要切入点，

815
01:25:36,359 --> 01:25:39,279
最新工作应该在她身上

816
01:25:39,279 --> 01:25:47,259
基本上，在这里，我们检查管道是否处于活动状态。

817
01:25:47,259 --> 01:25:48,939
如果它活跃，我们将不会收到。

818
01:25:49,859 --> 01:25:51,500
我们处于同步过程中。

819
01:25:53,500 --> 01:25:57,319
我们检查数据库上是否有正确的挂钩。

820
01:25:59,159 --> 01:25:59,859
更多。

821
01:26:01,420 --> 01:26:02,719
在这里，制作规范。

822
01:26:03,539 --> 01:26:09,019
我们告诉区块链树以使我们收到的块。

823
01:26:09,279 --> 01:26:18,340
如规范性，因为要塞更新只有哈希，并且如果有一些问题或有一些问题

824
01:26:18,340 --> 01:26:26,099
我不知道状态真理不是正确计算的，或者我们需要去的类似事项

825
01:26:26,099 --> 01:26:35,179
喜欢箭头处理或失败的规范堡垒更新，或者如果可以的话，我们需要查看结果

826
01:26:35,180 --> 01:26:37,400
如果都是decan的

827
01:26:37,400 --> 01:26:39,340
因为可能

828
01:26:39,340 --> 01:26:41,240
有可能拥有

829
01:26:41,240 --> 01:26:42,700
多个共识层

830
01:26:42,700 --> 01:26:45,200
基本上连接到一个执行层

831
01:26:45,200 --> 01:26:47,100
所以也许他们正在发送

832
01:26:47,100 --> 01:26:48,539
同样的他妈的选择更新

833
01:26:48,539 --> 01:26:51,260
如果是

834
01:26:51,260 --> 01:26:53,119
全部decan讽，如果承诺

835
01:26:53,119 --> 01:26:55,060
这意味着它是

836
01:26:55,060 --> 01:26:56,720
发送到数据库

837
01:26:56,720 --> 01:26:59,940
和

838
01:26:59,940 --> 01:27:03,579
是的，确保状态一致

839
01:27:03,579 --> 01:27:14,159
是的，总的来说，这里发生了很多事情

840
01:27:14,159 --> 01:27:18,119
关于叉选择更新

841
01:27:18,119 --> 01:27:22,180
主要在哪里

842
01:27:22,180 --> 01:27:30,279
哦，这里是啊，这是主要池是赢得计划的未来

843
01:27:30,279 --> 01:27:45,639
BCOX-SYSENGINE上的循环表现得像是拉动所有动作的一切

844
01:27:45,639 --> 01:27:48,699
那需要发生。

845
01:27:48,699 --> 01:28:01,619
其中之一是他妈的选择更新，其中之一是过程同步活动，我认为在这里

846
01:28:01,619 --> 01:28:08,579
它将必须在钩结果上完成。

847
01:28:08,579 --> 01:28:12,899
是的，在这里，是的。

848
01:28:12,899 --> 01:28:18,019
如果是分叉的选择更新，如果它是从共识中获得的新有效载荷

849
01:28:18,019 --> 01:28:31,699
层，如果这是需要发生的新事件，则是配置。

850
01:28:31,699 --> 01:28:36,119
我不确定那是什么。

851
01:28:36,119 --> 01:28:42,439
也许我不是探索这个问题的最佳人选。

852
01:28:42,439 --> 01:28:50,340
但是，是的，如果您想更深入研究它，它基本上可以处理在Cosensus Beacon引擎中

853
01:28:50,340 --> 01:28:51,800
嗯

854
01:28:51,800 --> 01:28:56,860
管道之间的同步

855
01:28:56,860 --> 01:28:58,600
区块链树木建造者和

856
01:28:58,600 --> 01:29:00,600
周围的一切

857
01:29:00,600 --> 01:29:01,020
修剪

858
01:29:01,020 --> 01:29:14,619
对不起，我没有

859
01:29:14,619 --> 01:29:16,600
是的，那是

860
01:29:16,600 --> 01:29:18,819
是的，一切都很好

861
01:29:18,819 --> 01:29:25,139
非常感谢。我们对树的平行特征有疑问。

862
01:29:25,139 --> 01:29:33,039
无论您是否只能给我们一个概述，我们有最后几分钟的树平行。

863
01:29:33,039 --> 01:29:48,239
我们注意到的是，我们的论点实现了树平行。

864
01:29:48,239 --> 01:29:50,519
基本上，我们有树和树平行。

865
01:29:50,519 --> 01:29:52,760
他们做同样的事情，但是以不同的方式做。

866
01:29:57,199 --> 01:30:01,119
我们非常喜欢优化的计算方法

867
01:30:01,119 --> 01:30:06,119
来自平原状态的mclroute，

868
01:30:06,159 --> 01:30:09,319
从根本上讲，我们完成了管道。

869
01:30:09,319 --> 01:30:12,059
但是我们注意到相同的计算

870
01:30:12,059 --> 01:30:16,920
对小费还不够好

871
01:30:16,920 --> 01:30:26,819
因为对于小费，基本上，我们需要更好的方法是进行计算

872
01:30:26,819 --> 01:30:27,819
在平行中。

873
01:30:27,819 --> 01:30:33,699
我不知道算法并不是我从事的事情。

874
01:30:33,699 --> 01:30:36,800
所以这是非常新的。

875
01:30:36,800 --> 01:30:42,500
想法是我认为只有并行

876
01:30:51,020 --> 01:30:54,500
是的，说实话没有太多要说的

877
01:30:56,000 --> 01:31:01,880
没关系，非常感谢，是的，嗯，只是快速概述

878
01:31:01,880 --> 01:31:09,859
是的，你们想问的其他任何个人代码也许会问

879
01:31:09,859 --> 01:31:15,619
问一些更一般的东西，也许与红色本身有点远，因为

880
01:31:15,619 --> 01:31:19,980
我认识很多人试图做出贡献的学习休息我

881
01:31:19,980 --> 01:31:25,039
想知道，但我们有任何建议

882
01:31:25,039 --> 01:31:33,600
对于生锈的人们并学习这种不可原谅的语言？

883
01:31:33,600 --> 01:31:38,720
如果您从Rust开始，那么这本书是主要资源。

884
01:31:38,720 --> 01:31:43,640
基本上是官方文档，非常好，我认为每个生锈开发人员都开始

885
01:31:43,640 --> 01:31:46,600
从那里很好。

886
01:31:46,600 --> 01:31:58,600
您只知道Rust，并想为它贡献良好的标签。

887
01:32:00,360 --> 01:32:03,320
嗯，有很多很好

888
01:32:06,120 --> 01:32:13,640
嗯，是破折号还是是的，是的，是的，好的第一期，有很多小任务可以

889
01:32:13,640 --> 01:32:18,760
用扫描类型移动到合金上，就像移植一样，只是嗯

890
01:32:20,360 --> 01:32:29,240
马特（Matt）创建了四天前，马特（Matt

891
01:32:29,240 --> 01:32:37,000
Otter Scan的名称空间是的，我们认为是的，老实说，我没有很多事情

892
01:32:37,000 --> 01:32:44,520
对于REVM，我在那里有很多东西，但是，是的，我们有水扫描，我认为我们有

893
01:32:44,520 --> 01:32:51,720
水扫描支撑um，例如，逐步的食食者依赖替换

894
01:32:51,720 --> 01:32:56,680
例如，重要提供商始终提供新功能的新重写

895
01:32:58,760 --> 01:33:04,840
替换咬合光滑的反馈

896
01:33:04,840 --> 01:33:12,319
我们喜欢周围的玩笑，嗯，甚至有很多人在他扫描的地方制作了剧本

897
01:33:12,319 --> 01:33:18,880
这些问题以及如果他找到好的第一期，他只会抓住它，然后他像

898
01:33:18,880 --> 01:33:27,900
是的，他基本上在循环中评论了脚本，就像破碎了

899
01:33:27,899 --> 01:33:33,179
它试图狙击第一个好问题

900
01:33:33,179 --> 01:33:35,579
和垃圾评论

901
01:33:35,579 --> 01:33:36,859
是的

902
01:33:36,859 --> 01:33:40,859
但是无论哪种方式都有很多好的第一个问题

903
01:33:40,859 --> 01:33:43,259
可以采取

904
01:33:43,259 --> 01:33:45,460
是的，真棒

905
01:33:45,460 --> 01:33:49,319
我对红色的这一部分感到非常兴奋

906
01:33:49,319 --> 01:33:51,819
对贡献者如此开放

907
01:33:51,819 --> 01:33:52,920
尤其

908
01:33:52,920 --> 01:33:57,319
您如何从您身边看到它

909
01:33:57,319 --> 01:34:03,639
就像一个维护者一样，很难获得这么多你知道问题，只是PRS可能是

910
01:34:03,639 --> 01:34:09,960
低质量左右，就像您的流量基本上如何相处

911
01:34:13,479 --> 01:34:19,079
我是基本上维护的人，我需要照顾我的时间，但我想帮助人们

912
01:34:19,079 --> 01:34:27,000
因为您永远都不知道我特别是Revm，所以我知道我的第一个喜欢用户是Foundry和

913
01:34:27,000 --> 01:34:34,039
基本上，我想支持所有的是，也许是不同的是高级用户，但无论哪种方式

914
01:34:34,760 --> 01:34:41,800
你永远不知道何时会像你一样不知道太空发生了什么

915
01:34:41,800 --> 01:34:47,079
因为您永远不知道您是否会帮助这个家伙一点点，他会在这里呆好几年

916
01:34:47,800 --> 01:34:54,680
或在其中建立一些东西，但他在Gmail中喜欢问题

917
01:34:54,680 --> 01:35:01,000
不起作用，就像一个生锈功能一样，需要启用，并且它不起作用，并且

918
01:35:02,440 --> 01:35:09,400
他围绕图书馆构建了Rev，以及像我认为团队一样的一切

919
01:35:09,400 --> 01:35:17,240
是在Foundry的背后，现在直接出现的同一件事是惊人的，他们照顾了

920
01:35:17,239 --> 01:35:24,519
基本上，我们的电报小组非常活跃，我认为有很多回应

921
01:35:24,519 --> 01:35:29,639
很多问题，您在那里支持这就是为什么您最终建立社区的原因

922
01:35:32,279 --> 01:35:37,319
是的，很棒的嗯，我真的很感谢开放性和社区方法

923
01:35:37,319 --> 01:35:44,279
嗯，我知道有时可能会因为所有贡献者的进来可能很艰难吗？

924
01:35:44,279 --> 01:35:49,960
我们再也没有任何问题了，所以我认为我们可以在这里撕毁。但是非常感谢

925
01:35:49,960 --> 01:35:54,119
德拉曼。是的，我真的很感激。这确实是很棒的见识。我们学到了很多。

926
01:35:55,239 --> 01:36:00,840
另外，我还有更多了解实际阶段同步，因为在

927
01:36:00,840 --> 01:36:05,319
日志，对吗？就像，我正在做这个阶段，执行交易，完成此阶段，这样做。它是

928
01:36:05,319 --> 01:36:10,119
看到客户的进展情况真的很高兴，但是实际潜入代码是不同的。所以

929
01:36:10,119 --> 01:36:12,960
所以我真的很感谢你，德拉丹。

930
01:36:12,960 --> 01:36:13,779
是的。

931
01:36:13,779 --> 01:36:16,319
是的。

932
01:36:16,319 --> 01:36:19,840
谢谢你打电话给我。

933
01:36:19,840 --> 01:36:22,260
我们将邀请函发送给了您。

934
01:36:22,260 --> 01:36:25,279
随时加入。

935
01:36:25,279 --> 01:36:27,840
我们有一群渴望在那里学习的人。

936
01:36:27,840 --> 01:36:31,099
因此，如果您想回答一些问题，

937
01:36:31,099 --> 01:36:33,119
总是欢迎您。

938
01:36:33,119 --> 01:36:33,659
凉爽的。

939
01:36:33,659 --> 01:36:35,500
我会加入。

940
01:36:35,500 --> 01:36:39,019
对于观众，对于学习小组的人来说，

941
01:36:39,020 --> 01:36:45,420
将在周三继续进行第七周，研究轨道集中在垂直树上。我们将

942
01:36:45,420 --> 01:36:52,380
在一个会话中有三个甚至三个扬声器涵盖垂直树主题，所以不要

943
01:36:52,380 --> 01:37:00,860
错过了星期三。下周，我们将从泰克（Tecku）中解释共识层

944
01:37:00,859 --> 01:37:04,519
客户。因此，在龙执行部分之后，我们将拥有

945
01:37:04,579 --> 01:37:10,159
共识。啊，是的，很棒。是的，真的

946
01:37:10,159 --> 01:37:14,420
感谢它。我们有很好的见解，Dragan和我

947
01:37:14,420 --> 01:37:16,159
希望在研究小组中见到您。

948
01:37:19,539 --> 01:37:22,819
我很高兴提供帮助。是的，非常感谢。

949
01:37:24,399 --> 01:37:25,819
祝你有美好的一天。再见。

950
01:37:26,619 --> 01:37:27,899
再见，大家。

951
01:38:00,859 --> 01:38:30,839
谢谢。

