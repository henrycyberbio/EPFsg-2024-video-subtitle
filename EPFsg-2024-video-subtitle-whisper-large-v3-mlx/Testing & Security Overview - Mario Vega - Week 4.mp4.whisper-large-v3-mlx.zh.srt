1
00:00:30,000 --> 00:00:59,980
谢谢。

2
00:01:30,000 --> 00:01:40,000
¶¶

3
00:01:40,000 --> 00:01:50,000
¶¶

4
00:01:50,000 --> 00:02:00,000
¶¶

5
00:02:00,000 --> 00:02:10,000
¶¶

6
00:02:10,000 --> 00:02:20,000
¶¶

7
00:02:20,000 --> 00:02:49,979
我不知道。

8
00:02:50,000 --> 00:03:19,979
谢谢。

9
00:04:20,000 --> 00:04:49,980
谢谢。

10
00:04:50,000 --> 00:05:19,980
谢谢。

11
00:05:20,000 --> 00:05:39,160
大家好，希望您能听到我的声音。

12
00:05:39,160 --> 00:05:44,819
我今天没有相机，所以让我知道它是否还不错。

13
00:05:44,819 --> 00:05:45,819
是的，谢谢。

14
00:05:45,819 --> 00:05:56,219
欢迎来到我们EPF研究小组的第四周，UH涵盖执行介绍后UH

15
00:05:56,219 --> 00:06:03,339
共识层，现在我们将深入研究我们讨论的所有这些实际测试

16
00:06:03,339 --> 00:06:10,779
嗯，这对许多人来说非常重要，测试听起来像是什么

17
00:06:10,779 --> 00:06:15,019
奇怪的是为什么我们为什么要关心它就像开发的一部分，但这是

18
00:06:15,019 --> 00:06:17,519
它实际上是整个以太坊中最重要的部分之一，

19
00:06:17,959 --> 00:06:20,680
我会说的与我们之前讨论的主题一样重要，

20
00:06:20,799 --> 00:06:25,899
因为，正如我们所说，这是阻止整个网络腹部浮出水的原因。

21
00:06:26,439 --> 00:06:33,159
在本周的会谈中，我们有最好的人讨论此主题，

22
00:06:33,319 --> 00:06:38,240
这是我们来自EF测试和安全团队的同事Mario Vega，

23
00:06:38,240 --> 00:06:45,400
我相信，像2021年秋天以来一直从事测试的人

24
00:06:46,000 --> 00:06:47,780
合并前一年。

25
00:06:47,780 --> 00:06:52,860
在第一年，他对许多测试基础设施进行了大修，

26
00:06:53,199 --> 00:06:56,500
这有助于合并实际发生。

27
00:06:57,040 --> 00:07:02,160
直到今天，他还是所有测试背后的主要力量之一

28
00:07:02,160 --> 00:07:04,259
升级和努力工作等等。

29
00:07:04,259 --> 00:07:08,659
所以，是的，我今天很高兴今天在这里有Mario。

30
00:07:08,980 --> 00:07:10,579
你能听到我吗？

31
00:07:14,680 --> 00:07:15,939
你们能听到我的声音吗？

32
00:07:16,639 --> 00:07:17,779
是的，一切都很好。

33
00:07:18,300 --> 00:07:19,839
是的，非常感谢您加入。

34
00:07:20,079 --> 00:07:23,180
您可以在Harrison按钮中共享幻灯片。

35
00:07:24,399 --> 00:07:25,839
只给我一秒钟。

36
00:07:28,399 --> 00:07:31,120
是的，对于每个人都在听，现在加入的人，

37
00:07:31,120 --> 00:07:36,120
请在研究小组不和谐中使用第四周。

38
00:07:37,800 --> 00:07:42,540
我们刚刚为本周的演讲打开了一个线程，

39
00:07:42,540 --> 00:07:44,600
因此，您可以在那里提出问题。

40
00:07:44,600 --> 00:07:46,759
在谈话期间随时问任何事情，

41
00:07:46,759 --> 00:07:50,120
我们将尝试将其回答

42
00:07:50,120 --> 00:07:52,259
要么在线程中，

43
00:07:52,259 --> 00:07:55,720
否则我们将直接问马里奥。

44
00:07:56,980 --> 00:07:57,899
所以，是的。

45
00:08:01,120 --> 00:08:05,280
是的，我们得到了幻灯片。惊人的。

46
00:08:05,280 --> 00:08:08,280
那起作用吗？看起来还可以吗？

47
00:08:08,280 --> 00:08:09,280
是啊是啊。

48
00:08:09,280 --> 00:08:10,280
好吧，让我...

49
00:08:10,280 --> 00:08:12,459
是的，当然。

50
00:08:12,459 --> 00:08:16,340
如果您在右边寻找它，只需单击幻灯片。

51
00:08:16,340 --> 00:08:17,340
是的。

52
00:08:17,340 --> 00:08:18,340
大按钮。

53
00:08:18,340 --> 00:08:19,340
是的，你去了。

54
00:08:19,340 --> 00:08:20,340
是的，那个。你去。

55
00:08:20,340 --> 00:08:21,340
惊人的。太感谢了。

56
00:08:21,340 --> 00:08:23,340
舞台是你的。前进。

57
00:08:23,340 --> 00:08:29,360
完美的。是的，感谢您的演讲。我叫马里奥·维加（Mario Vega）。我来自

58
00:08:29,360 --> 00:08:39,360
EF。我在EF测试团队中工作。我主要专注于开发测试和功能，

59
00:08:39,360 --> 00:08:45,440
以太坊用来实际工作的整个测试设置的功能测试部分

60
00:08:45,440 --> 00:08:54,159
适当地。所以我要挖掘自己的工作和一些同龄人的一点点

61
00:08:54,159 --> 00:09:01,600
在EF中，也主要是测试安全性，以及DevOps，其中一点点。

62
00:09:03,360 --> 00:09:05,079
是的，让我们开始。

63
00:09:05,299 --> 00:09:11,399
因此，我将要介绍的今天的主题，执行层测试如何完成？

64
00:09:12,039 --> 00:09:18,539
主要是EBM测试，这是链条共识的非常重要的部分。

65
00:09:18,539 --> 00:09:21,219
我们有两个主要存储库。

66
00:09:21,219 --> 00:09:24,500
一个是以太坊测试，另一个是

67
00:09:24,500 --> 00:09:27,839
另一个我们刚刚开始工作的

68
00:09:27,839 --> 00:09:30,299
它称为以太坊执行规格测试。

69
00:09:30,299 --> 00:09:33,159
我们会做一点。

70
00:09:33,159 --> 00:09:36,039
我也会做一些演示

71
00:09:36,039 --> 00:09:39,179
关于如何运行这些测试，它们如何工作

72
00:09:39,179 --> 00:09:44,179
他们的内在运作将非常非常好。

73
00:09:44,500 --> 00:09:47,099
，我要掩盖一点

74
00:09:47,100 --> 00:09:52,940
共识层测试，主要是定理共识规范，这是回购

75
00:09:52,940 --> 00:10:00,300
基本上做了一切。这是规格和测试的一种解决方案

76
00:10:00,300 --> 00:10:07,019
在此存储库中。我要仔细研究一下，而不是最细节，因为

77
00:10:08,460 --> 00:10:15,019
这不是我们目前工作的主要领域，我的意思是EF团队，测试团队。

78
00:10:15,019 --> 00:10:26,360
我将仔细研究跨层中断测试，这是一个非常重要的部分，因为我们有两个层，执行层和共识层部分。

79
00:10:26,360 --> 00:10:38,960
团队，测试团队主要在Hive上工作，但我们也有Devnets，Childworks和Testnet，这是DevOps团队的工作。

80
00:10:38,960 --> 00:10:41,980
我要掩盖一点，

81
00:10:41,980 --> 00:10:45,040
但是我们将在Hive上更深入一点，

82
00:10:45,040 --> 00:10:50,040
这是我最合作的。

83
00:10:50,240 --> 00:10:53,639
而且我们也会在其中做一些演示

84
00:10:53,639 --> 00:10:55,879
如何运行测试，如何工作，

85
00:10:55,879 --> 00:10:57,879
内在的工作和所有这些东西。

86
00:10:57,879 --> 00:11:00,500
最后，一点点安全，

87
00:11:01,580 --> 00:11:03,600
潜在的问题是什么，

88
00:11:03,600 --> 00:11:10,480
如果你们要找到安全问题，有什么回报？

89
00:11:10,759 --> 00:11:19,680
如果您正确披露并发现任何与安全有关的问题，您可以赚钱？

90
00:11:20,060 --> 00:11:22,759
那将是我们今天所涵盖的。

91
00:11:23,480 --> 00:11:31,420
以及在解决任何安全事件后，如何公开披露您的死亡。

92
00:11:33,600 --> 00:11:42,759
所以，是的，我们将从EVM测试开始，这是我不会说最简单的。

93
00:11:42,899 --> 00:11:48,279
它非常复杂，但是设置最直接。

94
00:11:49,580 --> 00:11:59,920
EVM测试，主要目的基本上只是试图验证每个以太坊执行客户端都遵守此规范。

95
00:11:59,919 --> 00:12:14,659
这是非常重要的，因为不遵守规范意味着如果对通过所有交易执行的内容尚无共识，则在链中具有正势。

96
00:12:14,659 --> 00:12:24,439
这是设置非常简单，对于即使测试基本上您都有相同的输入

97
00:12:24,439 --> 00:12:31,179
每个客户端，您必须注册每个客户都将获得与给定的确切输出相同的

98
00:12:31,179 --> 00:12:37,339
相同的环境预期和艰苦的激活规则将在

99
00:12:37,340 --> 00:12:47,420
一点。是的，我想涵盖这个重要的特征

100
00:12:47,420 --> 00:12:53,759
测试是因为这些是最多的，所以当我们最关注的事情

101
00:12:53,759 --> 00:13:02,500
为ABM编写我们的测试。第一个是预状态。我去

102
00:13:02,500 --> 00:13:08,259
回来一点，所以只需解释一下它如何变形的一点，以便区块链

103
00:13:08,980 --> 00:13:16,019
嗯，以太坊区块链包含uh状态，这是一切生活的地方

104
00:13:16,019 --> 00:13:20,899
包括以太坊区块链的一切

105
00:13:20,899 --> 00:13:27,460
包含智能合约，余额nonce uh smart合同的代码

106
00:13:27,460 --> 00:13:33,300
也是最重要的是智能合约的存储，因此每个智能合约

107
00:13:34,180 --> 00:13:39,860
至少包含代码和存储，这是非常重要的部分，因为当您编写您的

108
00:13:39,860 --> 00:13:47,460
智能合约um，您通常想保存一些将保留的信息

109
00:13:48,500 --> 00:13:52,740
即使在您启动智能合约的第一次交易之后，即使在此之后

110
00:13:52,740 --> 00:13:57,539
在接下来的交易中，您将需要访问上一张交易。

111
00:13:57,539 --> 00:14:01,299
因此，这是存储空间，这是区块链的非常重要的部分。

112
00:14:01,299 --> 00:14:11,539
当我们设置EVM测试时，这是测试中最关键的部分，

113
00:14:11,539 --> 00:14:17,379
例如，因为我们没有测试整个主网，因为它很大。

114
00:14:17,379 --> 00:14:21,220
您现在在Mainnet中拥有的，您有合同

115
00:14:21,220 --> 00:14:27,720
疯狂的存储空间，它们将使用的疯狂键值。

116
00:14:27,860 --> 00:14:35,440
例如，uniswap，他们使用大量存储存储每个用户的存储

117
00:14:35,440 --> 00:14:39,360
例如，每个令牌中的平衡，等等。

118
00:14:39,899 --> 00:14:46,019
但是对于最简单的测试，因此通常在我们编写EDM测试时，

119
00:14:46,019 --> 00:14:52,860
通常，我们只想专注于EVM执行的一小部分。

120
00:14:53,299 --> 00:14:55,399
因此，我们生成了预状态。

121
00:14:55,740 --> 00:15:01,659
在执行任何交易之前，我们肯定会知道的是预期的。

122
00:15:03,120 --> 00:15:04,399
这很重要。

123
00:15:04,620 --> 00:15:08,879
我将在以下幻灯片中进一步解释。

124
00:15:10,460 --> 00:15:11,319
但就是这样。

125
00:15:11,320 --> 00:15:20,580
是的，是的，它的另一个重要部分是环境，所以当您运行时

126
00:15:20,580 --> 00:15:26,900
您的交易您的交易在区块链中被首先包围

127
00:15:26,900 --> 00:15:34,000
交易，也是一个环境，该环境是该块包含大量信息的块

128
00:15:34,000 --> 00:15:37,580
这可能会影响您的交易结果。

129
00:15:38,299 --> 00:15:42,419
例如，您可以读取块的时间戳

130
00:15:42,419 --> 00:15:44,000
您目前正在执行

131
00:15:44,399 --> 00:15:46,700
或偏爱，这是来的

132
00:15:46,700 --> 00:15:53,259
从共识层中，给您一些伪随机性

133
00:15:53,259 --> 00:15:55,200
作为您合同的输入。

134
00:15:55,759 --> 00:15:58,340
另外，例如，块号非常重要。

135
00:15:59,340 --> 00:16:00,860
您也可以获取以前的块scaches，

136
00:16:00,860 --> 00:16:05,100
例如，总气体限制。

137
00:16:05,340 --> 00:16:07,980
如果要限制测试执行多少，

138
00:16:08,360 --> 00:16:11,659
您将设置越来越多的气体限制。

139
00:16:11,759 --> 00:16:14,720
我们有一些测试，我们在这里增加了这种气体

140
00:16:14,720 --> 00:16:16,899
数量很大

141
00:16:16,899 --> 00:16:19,120
只是因为我们想检查

142
00:16:19,120 --> 00:16:23,680
例如，如果任何合同需要太长执行。

143
00:16:24,639 --> 00:16:25,680
以及基本费用，

144
00:16:25,840 --> 00:16:28,019
因为基本费用非常重要

145
00:16:28,019 --> 00:16:37,340
因为即使您不执行需要大笔交易费用的东西，

146
00:16:37,559 --> 00:16:42,919
您仍然想确保每个客户都需要基本费用

147
00:16:42,919 --> 00:16:47,799
并计算您要测试的每笔交易的正确费用。

148
00:16:48,699 --> 00:16:51,000
另外，硬叉激活时间也非常重要

149
00:16:51,000 --> 00:16:55,939
因为当我们测试新叉时

150
00:16:55,940 --> 00:17:07,180
最常见的设置方案是，我们设置了一个环境，将来将在某些最终区块中激活叉子。

151
00:17:09,680 --> 00:17:12,100
我将举一个非常具体的例子。

152
00:17:12,220 --> 00:17:20,920
例如，对于块，您不应该在激活cancun fork之前运行块交易。

153
00:17:20,920 --> 00:17:28,200
它。因此，在此特定测试的环境中，我们将来设置了一个叉子激活时间，

154
00:17:28,200 --> 00:17:32,600
然后我们发送交易，例如，然后验证包含的块

155
00:17:32,600 --> 00:17:40,440
执行客户端正确拒绝了此交易。这只是一个小例子，

156
00:17:40,539 --> 00:17:47,519
但是，有很多方法可以测试许多有趣的组合和激活

157
00:17:47,519 --> 00:17:52,740
与此变量有关的方案。这就是为什么环境非常

158
00:17:52,859 --> 00:18:00,339
对于准备测试非常重要。第三个

159
00:18:00,400 --> 00:18:04,019
这是交易，对吗？是这基本上是最重要的，最重要的。

160
00:18:05,019 --> 00:18:08,639
如果您没有正在测试的交易，那么基本上您不会去

161
00:18:08,639 --> 00:18:14,759
执行任何操作。 EMASMART合同的每个执行都始于交易。

162
00:18:14,759 --> 00:18:20,039
因此，这是我们编写的测试中非常重要的部分。

163
00:18:20,960 --> 00:18:31,839
最有可能的是，当您撰写测试时，您将交易发送到智能合约，您知道它将执行一些重要的代码。

164
00:18:32,519 --> 00:18:39,579
您永远不会像交易一样发送只是为了将以太从一个帐户发送到另一个帐户，因为没有什么有趣的事情发生。

165
00:18:39,579 --> 00:18:45,119
但是，是的，您将在预状态和环境的帮助下建立

166
00:18:45,119 --> 00:18:51,139
您将建立一个有趣的交易，在此交易中执行

167
00:18:51,139 --> 00:18:53,619
将在区块链中引起有趣的东西。

168
00:18:53,619 --> 00:18:57,259
这就是您的测试的工作方式。

169
00:18:57,259 --> 00:19:01,819
我说交易和交易是因为我们有不同的测试。

170
00:19:01,819 --> 00:19:08,339
我要详细介绍一些细节，但基本上我们可以进行测试

171
00:19:08,339 --> 00:19:16,019
交易对我们来说很有趣，这是测试链中非常具体的EVM执行。

172
00:19:16,659 --> 00:19:23,299
而且我们还进行了一项测试，该测试的多项交易等于填充了许多交易

173
00:19:23,299 --> 00:19:27,859
交易。这是我们要测试完整的区块链功能的时候。

174
00:19:29,619 --> 00:19:37,459
最后，但同样重要的是邮政状态。当我们设计测试时，它非常

175
00:19:37,460 --> 00:19:43,200
非常重要的是，在设置了预言的环境交易之后，

176
00:19:43,420 --> 00:19:46,019
您还想确切知道您的期望

177
00:19:46,019 --> 00:19:50,220
发生在区块链的帐户中。

178
00:19:50,940 --> 00:19:52,759
因此，例如，如果您设置了智能合约

179
00:19:52,759 --> 00:19:55,660
智能合约应该写一些东西

180
00:19:55,660 --> 00:19:57,600
进入智能合约的存储，

181
00:19:57,600 --> 00:20:00,420
您期望零从零变为一个，

182
00:20:01,000 --> 00:20:03,860
然后，这是您将其放入邮政的地方。

183
00:20:03,859 --> 00:20:09,819
它包含您正在使用交易的所有有趣帐户的列表

184
00:20:09,819 --> 00:20:17,219
而且，交易执行后，您要检查的所有有趣的存储值。

185
00:20:18,819 --> 00:20:19,759
非常重要。

186
00:20:20,119 --> 00:20:22,939
确切地知道要寻找什么也很重要。

187
00:20:23,459 --> 00:20:29,819
当您编写测试时，除非您真的知道结果应该是什么，否则您不会编写良好的测试。

188
00:20:29,819 --> 00:20:38,379
这是设置的一部分，基本上是在执行结束时验证

189
00:20:38,379 --> 00:20:40,220
测试。

190
00:20:40,220 --> 00:20:47,179
我将详细介绍我们如何使用所有这些输入来生成一个

191
00:20:47,179 --> 00:20:53,039
测试以及我们如何在一点点对客户验证它。

192
00:20:53,039 --> 00:20:56,859
我不知道，马里奥，如果您到目前为止有任何疑问。

193
00:20:56,859 --> 00:21:00,019
如果没有，我可以继续。

194
00:21:04,019 --> 00:21:14,539
是的。好的。因此，我们在EVM测试中拥有的所有这些输入，除非

195
00:21:14,539 --> 00:21:20,619
我们有一些可以执行的。因此，这是一个称为测试填充的过程。所以一次

196
00:21:20,619 --> 00:21:22,719
我们已经写了所有的意见。

197
00:21:23,000 --> 00:21:25,959
我们有要执行的状态。

198
00:21:26,579 --> 00:21:31,339
我们拥有具有正确代码和要执行的所有内容的智能合约。

199
00:21:31,459 --> 00:21:40,979
我们仍然必须以某种方式应用状态过渡，这是您将预状态和交易转换为邮政的时刻。

200
00:21:41,919 --> 00:21:46,239
这是一个以许多不同方式完成的过程。

201
00:21:46,240 --> 00:21:49,480
但这很重要，因为

202
00:21:49,480 --> 00:21:53,640
当我们有测试时

203
00:21:53,640 --> 00:21:55,079
我们有测试源代码

204
00:21:55,079 --> 00:21:58,000
用json或python写的

205
00:21:58,000 --> 00:22:00,759
取决于您正在使用的存储库

206
00:22:00,759 --> 00:22:05,240
但是输出将永远是

207
00:22:05,240 --> 00:22:06,420
JSON输出

208
00:22:06,420 --> 00:22:07,799
那就是我们使用的

209
00:22:07,799 --> 00:22:11,779
每个客户都将消耗

210
00:22:11,779 --> 00:22:15,620
这是一个称为测试填充的过程

211
00:22:15,619 --> 00:22:24,899
将测试设计定义转换为每个客户中实际消耗和可验证的东西的过程。

212
00:22:26,019 --> 00:22:27,379
非常重要的过程。

213
00:22:27,839 --> 00:22:34,219
我将在以下幻灯片中解释一下它的专门完成方式，我们如何做。

214
00:22:34,220 --> 00:22:45,900
是的，嗯，更重要的是，嗯，填充过程与

215
00:22:45,900 --> 00:22:52,940
所有客户都可以执行的所有客户都可以执行的单元测试UM可以做

216
00:22:52,940 --> 00:22:59,339
他们自己的单元测试，这是您开发软件和

217
00:22:59,339 --> 00:23:06,859
以太坊客户确实使用单元测试来测试其执行客户和共识客户，

218
00:23:06,859 --> 00:23:15,179
但是我们填充的测试固定装置的重要质量是可以消费

219
00:23:15,179 --> 00:23:21,099
由任何客户。因此，我们一次生成一次测试，然后我们可以在所有客户端执行它

220
00:23:21,099 --> 00:23:26,699
并验证它们之间没有任何差异。这是非常

221
00:23:26,700 --> 00:23:33,420
保持共识运行很重要。如果我们依靠每一个的编写单元测试

222
00:23:33,420 --> 00:23:38,940
在客户中，单位测试肯定会有所不同。因此，当我们填写测试时

223
00:23:38,940 --> 00:23:45,740
我们创建固定装置，这也意味着我们确定执行客户端正在消耗

224
00:23:45,740 --> 00:23:51,019
完全相同的测试。这对于共识非常重要。

225
00:23:53,259 --> 00:24:03,019
好吧，是的，让我看看。是的，好吧

226
00:24:03,019 --> 00:24:09,420
这是一个小图，仅显示

227
00:24:09,420 --> 00:24:15,500
要点我们如何进行单个状态测试。

228
00:24:15,740 --> 00:24:22,460
在为EVM测试中的IN中，我们从我已经描述的内容开始

229
00:24:22,460 --> 00:24:28,059
预期您拥有所有智能合同，所有余额，代码和所需的存储

230
00:24:29,099 --> 00:24:34,779
为了进行测试，您将其与单个交易结合在一起

231
00:24:35,339 --> 00:24:43,579
A帐户源帐户目的地某些值可能为零或某物的值

232
00:24:43,579 --> 00:24:45,679
一些气体和一些数据。

233
00:24:46,740 --> 00:24:50,439
当您结合起来时，您将获得日期，

234
00:24:50,740 --> 00:24:54,259
这可能是创建新的智能合约，

235
00:24:54,919 --> 00:24:57,619
一些修改后的余额，一些新的或修改的余额，

236
00:24:58,000 --> 00:25:01,259
好吧，不是修改的代码，新代码或修改的，

237
00:25:02,039 --> 00:25:04,099
是的，这是不正确的。

238
00:25:04,460 --> 00:25:05,859
没有修改的代码，这是不可能的。

239
00:25:06,399 --> 00:25:09,119
是的，是的，就是这样。

240
00:25:09,119 --> 00:25:14,279
并出售中风和所有东西，

241
00:25:14,659 --> 00:25:16,519
您可以拥有一切。

242
00:25:16,639 --> 00:25:19,479
重要的是，在预状态下，

243
00:25:20,459 --> 00:25:24,279
您必须建立智能合同

244
00:25:24,279 --> 00:25:27,319
这会执行一些有趣的事情。

245
00:25:28,879 --> 00:25:31,859
这将是您交易的目的地。

246
00:25:32,019 --> 00:25:33,879
否则，它不会执行任何有意义的事情

247
00:25:33,879 --> 00:25:35,379
而且您并没有真正测试任何东西。

248
00:25:36,500 --> 00:25:38,199
另外，交易，例如

249
00:25:38,200 --> 00:25:43,860
如果有可能交易的目的地

250
00:25:43,860 --> 00:25:46,000
不是明智的合同，

251
00:25:46,180 --> 00:25:47,660
但是创建智能合约，

252
00:25:47,740 --> 00:25:48,600
这也是可能的。

253
00:25:48,880 --> 00:25:52,420
然后您投入此交易的数据

254
00:25:52,420 --> 00:25:55,700
以初始代码的方式执行。

255
00:25:55,700 --> 00:25:56,940
所以这也很有趣。

256
00:25:57,200 --> 00:26:02,019
因此，如果您可以放一些有趣的初始代码，

257
00:26:02,559 --> 00:26:04,720
这是另一种测试方式

258
00:26:04,720 --> 00:26:07,460
您的智能合约是以正确的方式创建的。

259
00:26:07,460 --> 00:26:10,440
还有修改的余额，

260
00:26:10,660 --> 00:26:13,000
新创建的代码在这里也很重要

261
00:26:13,000 --> 00:26:14,779
以及必要时修改的存储。

262
00:26:15,940 --> 00:26:20,039
最重要的是，我们使用所谓的舞台根

263
00:26:20,039 --> 00:26:21,019
进行此验证。

264
00:26:22,259 --> 00:26:25,840
正如我们之前所解释的那样，舞台根是

265
00:26:25,980 --> 00:26:28,700
国家是包含智能合约，一切，

266
00:26:29,299 --> 00:26:32,700
但是根就像这个加密计算

267
00:26:32,700 --> 00:26:36,720
施加并安全地提交了国家的所有内容

268
00:26:36,720 --> 00:26:43,299
单个数字，这是一个非常大的数字，基本上是32个字节的信息

269
00:26:43,299 --> 00:26:50,220
很难拥有两个不同的状态，这些状态将相同的UH变成相同的数字，这就是什么

270
00:26:50,220 --> 00:26:59,720
使UH区块链安全，因此鉴于这样的前提条件，我们可以假设如果两个

271
00:26:59,720 --> 00:27:06,279
执行客户端，我们给他们的预期与您也相同的交易相同

272
00:27:06,279 --> 00:27:11,279
您期望结束时具有相同的状态根差。

273
00:27:11,720 --> 00:27:13,440
如果比较两个执行客户端

274
00:27:13,440 --> 00:27:14,839
它们给了您两个不同的状态根，

275
00:27:14,839 --> 00:27:19,379
这意味着其中一个，或者也许是测试也是不正确的。

276
00:27:20,680 --> 00:27:21,779
这就是

277
00:27:21,779 --> 00:27:24,379
这是测试Devian的最简单方法。

278
00:27:29,019 --> 00:27:34,019
我们也有模糊的差分状态测试，非常相似。

279
00:27:34,019 --> 00:27:42,799
相似的。主要区别是我们有一个称为fuzzyevm的工具，

280
00:27:42,799 --> 00:27:49,319
由Goethereum客户的开发人员之一撰写。而这种工作的方式是

281
00:27:49,319 --> 00:28:00,460
我们没有拥有未知的智能合约，我们旨在达到一些特定的代码

282
00:28:00,460 --> 00:28:07,740
执行客户端中的路径。在这种情况下，烦恼以代码的方式出现

283
00:28:08,299 --> 00:28:18,539
包含。因此，您将代码大惊

284
00:28:18,539 --> 00:28:23,259
然后，您创建了一个特定目的地的交易，是该代码，

285
00:28:23,259 --> 00:28:27,779
就是那个智能合同。

286
00:28:27,779 --> 00:28:30,900
然后因为我们不知道

287
00:28:32,319 --> 00:28:34,680
该合同的结果将是什么

288
00:28:34,680 --> 00:28:39,180
因为它是福斯，它将具有非常随机的

289
00:28:39,180 --> 00:28:41,079
或随机行为。

290
00:28:41,079 --> 00:28:42,740
您可能会设置存储空间

291
00:28:42,740 --> 00:28:44,599
您不希望它设定。

292
00:28:44,599 --> 00:28:46,379
我们验证这种测试的方式

293
00:28:46,379 --> 00:28:50,259
是我们通过舞台路线

294
00:28:50,259 --> 00:28:52,859
我们将其比较不同的客户。

295
00:28:53,259 --> 00:28:56,559
因此，如果我们有相同的第一张智能合约，

296
00:28:56,559 --> 00:28:59,279
相同的交易，同一预状态，

297
00:28:59,279 --> 00:29:01,740
我们得到了不同的州路线

298
00:29:01,740 --> 00:29:04,940
在两个不同的EVM客户端，

299
00:29:04,940 --> 00:29:07,940
这意味着有一个错误，有问题。

300
00:29:07,940 --> 00:29:10,339
然后您可以验证它，然后确切查看

301
00:29:11,720 --> 00:29:15,160
通过检查执行的痕迹

302
00:29:15,160 --> 00:29:17,140
确切知道发生了什么，

303
00:29:17,140 --> 00:29:20,460
然后，您可以通过这种方式找到错误。

304
00:29:23,259 --> 00:29:34,259
嗯，是的，我们也进行了UH区块链区块链测试，因此以前的基于我们的区块链测试

305
00:29:34,259 --> 00:29:39,759
像预状态一样，我们有一次交易，我们有一个非常具体的执行

306
00:29:39,759 --> 00:29:47,500
发生了，我们也可以进行完整的块测试，这意味着您也喜欢

307
00:29:47,500 --> 00:29:52,879
智能合约均衡代码和搜索以及其他任何东西，然后将它们放入

308
00:29:52,880 --> 00:29:59,920
您将使用实例化区块链的创世纪。然后，您开始喂食块，

309
00:30:00,220 --> 00:30:06,460
每个都有交易和标题值，还包括构成块的更多信息。

310
00:30:06,840 --> 00:30:12,980
然后，您开始将整个块馈入执行客户端。然后你期望

311
00:30:12,980 --> 00:30:21,540
在一个或两个或多个块之后，您希望客户，如果您的验证结果

312
00:30:21,539 --> 00:30:25,859
是您进食测试的每个块，

313
00:30:26,019 --> 00:30:28,799
您在测试中设计的应该是正确的，

314
00:30:29,059 --> 00:30:32,180
那么期望是执行客户端

315
00:30:32,180 --> 00:30:34,599
消耗所有这些块

316
00:30:34,599 --> 00:30:40,420
然后您检查执行客户端的连锁头，

317
00:30:40,759 --> 00:30:44,339
您必须在这里找到您期望的块。

318
00:30:45,079 --> 00:30:48,920
如果出于某种原因，请在此图中说，

319
00:30:48,920 --> 00:30:52,480
第二块被认为是无效的

320
00:30:52,480 --> 00:30:54,539
由一个执行客户之一

321
00:30:54,539 --> 00:30:57,080
因为他们在某处的检查有故障。

322
00:30:57,720 --> 00:30:59,519
这意味着连锁头

323
00:30:59,519 --> 00:31:01,140
不会对应于第二个块

324
00:31:01,140 --> 00:31:02,840
然后您会遇到错误。

325
00:31:04,980 --> 00:31:05,960
这很重要

326
00:31:05,960 --> 00:31:10,000
因为不是我们检查的一切

327
00:31:10,000 --> 00:31:12,700
在执行上，客户端是EVM执行的一部分。

328
00:31:12,700 --> 00:31:14,720
我们还检查其他值

329
00:31:14,720 --> 00:31:18,880
这是执行先前块的结果。

330
00:31:18,880 --> 00:31:22,880
例如，1559年，这是基本费用，

331
00:31:23,400 --> 00:31:25,860
您有块的基本费用，

332
00:31:26,279 --> 00:31:29,900
这是根据先前的交易计算的

333
00:31:29,900 --> 00:31:31,079
上一个块。

334
00:31:31,740 --> 00:31:34,259
所以如果有一些客户

335
00:31:34,259 --> 00:31:38,120
计算错误的5059，基本费用，

336
00:31:38,920 --> 00:31:43,480
例如，您将在这里的某个地方得到拒绝。

337
00:31:43,480 --> 00:31:46,460
然后您的连锁头将不匹配

338
00:31:46,460 --> 00:31:49,000
到测试的最后一个块，

339
00:31:49,400 --> 00:31:52,640
然后，您会发现一个错误。

340
00:31:53,740 --> 00:31:55,920
然后，您还检查发布日期，

341
00:31:56,200 --> 00:31:57,900
新的智能合约，修改后的余额，

342
00:31:58,019 --> 00:31:59,920
新代码，修改的存储，所有内容。

343
00:32:00,299 --> 00:32:01,720
您检查一切都到位

344
00:32:01,720 --> 00:32:06,660
因为即使在正确消耗所有块之后

345
00:32:06,660 --> 00:32:09,120
到末端块，

346
00:32:09,740 --> 00:32:11,579
您仍然可以在某个地方有一些错误

347
00:32:11,579 --> 00:32:14,819
出于某种原因存储的地方

348
00:32:14,819 --> 00:32:19,099
无法从执行行正确响应。

349
00:32:19,339 --> 00:32:24,599
非常非常常见

350
00:32:24,599 --> 00:32:26,779
因为通常在检查链头时，

351
00:32:27,019 --> 00:32:28,879
您还检查了状态根，

352
00:32:29,199 --> 00:32:31,939
这意味着描述性承诺

353
00:32:31,939 --> 00:32:33,139
我们之前谈到了。

354
00:32:33,919 --> 00:32:36,279
这意味着您的存储空间正确。

355
00:32:36,460 --> 00:32:39,579
因此，这些检查只是理智检查，

356
00:32:39,579 --> 00:32:40,199
额外的支票。

357
00:32:40,200 --> 00:32:42,340
但是，是的，基本要旨是

358
00:32:42,340 --> 00:32:44,400
所有的块被消耗

359
00:32:44,400 --> 00:32:45,640
因为客户是正确的

360
00:32:45,640 --> 00:32:59,640
我们还有其他检查方式

361
00:32:59,640 --> 00:33:02,680
这是您设计考试

362
00:33:02,680 --> 00:33:06,120
在某个时候有一个无效的块

363
00:33:06,120 --> 00:33:09,580
例如，让我们以榜样

364
00:33:09,579 --> 00:33:11,439
在1559年再次

365
00:33:11,799 --> 00:33:13,740
这是，假设你

366
00:33:13,740 --> 00:33:17,899
故意提出无效的价值

367
00:33:17,899 --> 00:33:20,559
进入块的基本费用

368
00:33:20,559 --> 00:33:22,639
然后你喂那个块

369
00:33:22,639 --> 00:33:24,199
给客户，

370
00:33:24,539 --> 00:33:27,439
那你期望客户

371
00:33:27,439 --> 00:33:28,659
拒绝这个块。

372
00:33:29,460 --> 00:33:30,599
所以会发生的是

373
00:33:30,599 --> 00:33:32,539
块被拒绝。

374
00:33:32,799 --> 00:33:33,480
那是一张支票。

375
00:33:34,000 --> 00:33:36,279
然后您回到客户

376
00:33:36,279 --> 00:33:37,039
你说，好吧，

377
00:33:37,039 --> 00:33:40,680
我给你的最后一个街区是什么？

378
00:33:41,480 --> 00:33:42,559
那是正确的。

379
00:33:42,920 --> 00:33:44,319
然后您再次检查

380
00:33:44,319 --> 00:33:45,799
因为在这种情况下，它是第二个块。

381
00:33:46,000 --> 00:33:46,899
那是最后一个街区。

382
00:33:47,460 --> 00:33:49,700
然后，您检查帖子和所有内容。

383
00:33:51,259 --> 00:33:53,519
在这里，帖子变得很重要

384
00:33:53,519 --> 00:33:57,680
因为如果您喂养一个无效的块，

385
00:33:57,779 --> 00:34:01,399
您期望邮政

386
00:34:01,399 --> 00:34:04,039
或居住在客户的合同

387
00:34:04,039 --> 00:34:06,379
不属于无效块。

388
00:34:06,380 --> 00:34:09,760
因此，在这种情况下，此检查实际上更为重要。

389
00:34:11,280 --> 00:34:17,140
确切了解客户是如何失败也非常重要。

390
00:34:18,320 --> 00:34:31,440
当您设计这些负面测试之一时，您完全确定客户可能会失败，这一点非常重要。

391
00:34:31,440 --> 00:34:40,320
例如，如果您正在设计1559的测试，并且要放置一个无效的

392
00:34:40,320 --> 00:34:47,780
基本费用中的值，但您忘记使用此修改值更新块舱口

393
00:34:47,780 --> 00:34:53,619
有了这个修改的值，这意味着um客户仍将正确

394
00:34:53,619 --> 00:35:00,639
正确拒绝您的块，但不是因为您修改的基本费用值

395
00:35:00,639 --> 00:35:02,299
而是因为块哈希。

396
00:35:02,659 --> 00:35:04,359
这是一个无效的测试

397
00:35:04,359 --> 00:35:07,519
因为您没有确定其他每个字段，所以

398
00:35:07,920 --> 00:35:10,539
您正在测试的是正确的。

399
00:35:11,279 --> 00:35:11,879
所以，如果有的话，

400
00:35:13,019 --> 00:35:15,279
因此，这在说考试时非常重要

401
00:35:15,279 --> 00:35:17,460
而且您必须始终确保。

402
00:35:17,460 --> 00:35:22,460
这是很容易溜进这里很容易的东西

403
00:35:22,460 --> 00:35:24,599
写测试

404
00:35:24,599 --> 00:35:27,699
然后您认为您正确编写了测试

405
00:35:27,699 --> 00:35:29,699
然后稍后意识到，

406
00:35:29,699 --> 00:35:34,339
好吧，我没有改变这个，客户正在通过测试，

407
00:35:34,599 --> 00:35:38,619
但是我没有发现某个地方的错

408
00:35:38,619 --> 00:35:41,179
因为客户仍然拒绝了块

409
00:35:41,179 --> 00:35:44,239
因为我的块没有正确设计。

410
00:35:44,539 --> 00:35:45,980
我的测试未正确设计。

411
00:35:49,059 --> 00:35:49,619
是的。

412
00:35:52,259 --> 00:35:55,019
到目前为止有任何问题吗？

413
00:35:55,019 --> 00:36:00,719
正在进行讨论。

414
00:36:00,719 --> 00:36:05,099
也许，伙计们，如果您想问一个问题，我会给您一秒钟。

415
00:36:05,099 --> 00:36:06,780
但是否则很清楚。

416
00:36:06,780 --> 00:36:07,780
非常感谢，马里奥。

417
00:36:07,780 --> 00:36:08,780
这很棒。

418
00:36:08,780 --> 00:36:14,900
人们正在讨论我能回答的一些事情。

419
00:36:14,900 --> 00:36:15,900
是的。

420
00:36:15,900 --> 00:36:19,840
我想我们稍后会提出问题。

421
00:36:19,840 --> 00:36:21,840
好的。

422
00:36:21,840 --> 00:36:23,500
好的。

423
00:36:23,500 --> 00:36:24,500
凉爽的。

424
00:36:24,500 --> 00:36:33,880
好的，现在要进行测试的实际测试填充部分。

425
00:36:33,880 --> 00:36:39,360
我们将从拥有的第一个存储库开始。

426
00:36:39,360 --> 00:36:46,320
这是自以太坊成立以来已经存在的以太坊测试库，近九个

427
00:36:46,320 --> 00:36:47,880
几年前。

428
00:36:47,880 --> 00:36:57,500
这是以太坊社区生产的第一个测试框架。

429
00:36:57,500 --> 00:37:06,619
基本上，测试的源文件是简单的JSON文件或YAML，这是

430
00:37:06,619 --> 00:37:08,220
源代码。

431
00:37:08,220 --> 00:37:16,360
这是您设计预状态，存储，代码，智能合约的部分

432
00:37:16,360 --> 00:37:17,700
你把它放在那里的一切。

433
00:37:17,699 --> 00:37:22,899
这一切都进入了JSON文件或YAML文件。

434
00:37:23,899 --> 00:37:26,439
它提供非常简单的参数化

435
00:37:26,439 --> 00:37:30,619
从某种意义上说，您可以设置多个交易

436
00:37:30,619 --> 00:37:33,199
要在同一预状态的顶部操作，

437
00:37:33,679 --> 00:37:36,500
然后您期望有不同的结果

438
00:37:36,500 --> 00:37:37,480
取决于交易。

439
00:37:38,399 --> 00:37:40,119
然后您也可以检查所有

440
00:37:40,119 --> 00:37:44,339
以紧凑的JSON格式。

441
00:37:44,340 --> 00:37:49,240
这些测试以C ++编写。

442
00:37:50,300 --> 00:37:53,640
抱歉，测试填充剂称为重新测试。

443
00:37:55,680 --> 00:37:57,220
它用C ++编写。

444
00:37:59,600 --> 00:38:04,000
基本上是您的JSON输入，是什么重新测试，

445
00:38:04,920 --> 00:38:08,039
您已经重新测试了它，然后将其调用，

446
00:38:08,460 --> 00:38:10,059
然后它消耗了JSON。

447
00:38:10,059 --> 00:38:16,599
它打电话给它实际填充它，然后最后您有一个

448
00:38:16,599 --> 00:38:21,159
每个客户都可以消耗的固定装置，然后您可以检查

449
00:38:21,159 --> 00:38:27,019
任何客户中的任何一个无效

450
00:38:28,860 --> 00:38:36,599
而且我们有较新的执行幽灵，这刚刚开发了

451
00:38:36,599 --> 00:38:40,279
去年和上一年的过程。

452
00:38:41,119 --> 00:38:44,199
主要区别在于我们具有Python源代码。

453
00:38:44,779 --> 00:38:49,900
因此，测试的来源是您定义预状态和所有内容的地方。

454
00:38:50,360 --> 00:38:51,279
这一切都在Python中。

455
00:38:51,799 --> 00:38:57,759
它提供了简单至复杂的参数化，因为它是由Pytest供电的。

456
00:38:58,360 --> 00:39:03,980
因此，我们所有的PYTest工具都可以使用，以进行不同的参数化

457
00:39:03,980 --> 00:39:04,820
不同的测试。

458
00:39:05,800 --> 00:39:08,340
这允许很大的灵活性

459
00:39:08,340 --> 00:39:11,320
而且非常有效

460
00:39:11,320 --> 00:39:14,619
仅写单个输入

461
00:39:14,619 --> 00:39:16,260
然后你只通过

462
00:39:16,260 --> 00:39:17,300
很多参数，

463
00:39:17,940 --> 00:39:19,240
很多价值观

464
00:39:19,240 --> 00:39:20,240
用于参数化。

465
00:39:20,400 --> 00:39:21,780
它将为您产生大量测试。

466
00:39:22,159 --> 00:39:23,820
真的很方便。

467
00:39:25,820 --> 00:39:27,599
它会变得非常复杂。

468
00:39:28,199 --> 00:39:30,079
因此，我们仍在定义

469
00:39:30,420 --> 00:39:31,539
我们还在那时

470
00:39:31,539 --> 00:39:32,300
我们在哪里定义

471
00:39:32,300 --> 00:39:36,100
我们希望测试有多少复杂性。

472
00:39:37,840 --> 00:39:43,120
因此，这是一个非常不错的框架。

473
00:39:44,260 --> 00:39:47,600
不利的一面是，正如重新测试一样

474
00:39:47,780 --> 00:39:52,140
这仍然需要实际的客户实施

475
00:39:52,140 --> 00:39:55,720
能够填写测试

476
00:39:55,720 --> 00:39:57,120
由于过渡函数。

477
00:39:58,519 --> 00:40:00,580
这只是因为我们没有

478
00:40:00,579 --> 00:40:03,880
到目前为止，在Python中实现的过渡函数，

479
00:40:03,880 --> 00:40:06,819
但是正在进行的工作

480
00:40:06,819 --> 00:40:12,139
整个Python规范

481
00:40:12,139 --> 00:40:16,199
用称为收益的脚本编写，

482
00:40:16,360 --> 00:40:20,139
这是以太坊执行层规格。

483
00:40:21,279 --> 00:40:23,059
这将来会

484
00:40:23,199 --> 00:40:26,900
将被用作实际客户代表，

485
00:40:27,900 --> 00:40:28,920
但不是今天。

486
00:40:30,579 --> 00:40:33,880
好的。

487
00:40:33,880 --> 00:40:39,139
这就是执行规范测试的内在工作。

488
00:40:39,139 --> 00:40:44,579
在重新测试和执行规格测试中，这都是非常相似的。

489
00:40:44,579 --> 00:40:50,460
因此，我将介绍它在内部的工作方式。

490
00:40:50,460 --> 00:40:52,019
实际上，这很简单。

491
00:40:52,019 --> 00:40:59,119
正如我之前所说，这是框架，它从一些Python测试开始。

492
00:40:59,119 --> 00:41:09,179
此测试您可以为每个EIP创建一个或几个EIP的测试，也可以

493
00:41:09,179 --> 00:41:12,820
例如，为许多叉子写许多。

494
00:41:12,820 --> 00:41:17,719
我们现在正在工作的方式是我们有不同的文件夹

495
00:41:17,719 --> 00:41:20,579
测试现场测试，每个叉子一个。

496
00:41:20,579 --> 00:41:26,900
叉子所以例如，我们从Frontier开始，然后一直到坎昆和坎昆

497
00:41:26,900 --> 00:41:34,099
目前包含所有48404测试，所有标签根合同测试和所有测试

498
00:41:34,099 --> 00:41:39,059
所有这一切都很好地组织了嗯，这是我真正喜欢的东西

499
00:41:39,059 --> 00:41:45,219
在您的存储库中，您就开始了您的一个，从python测试开始

500
00:41:45,219 --> 00:41:54,639
您写所有的预状态，交易，实际上已经写了参数化

501
00:41:54,639 --> 00:41:55,639
或一切。

502
00:41:55,639 --> 00:42:01,919
然后，当您执行此操作时，执行此操作，它使用的是填充命令

503
00:42:01,919 --> 00:42:05,379
我们有这个存储库。

504
00:42:05,379 --> 00:42:09,959
您将填充命令指定为您目前要执行的测试，并且

505
00:42:09,959 --> 00:42:13,659
然后它将进入，执行Python代码。

506
00:42:13,659 --> 00:42:17,099
重要的部分是它具有两个依赖关系，三个。

507
00:42:17,519 --> 00:42:19,500
底部有点不重要，

508
00:42:19,619 --> 00:42:21,219
但是顶部的两个是

509
00:42:21,920 --> 00:42:23,699
尤其是顶部非常重要。

510
00:42:24,339 --> 00:42:25,420
因此，当您填写测试时

511
00:42:25,420 --> 00:42:30,279
然后，您要达到要执行交易的地步，

512
00:42:30,819 --> 00:42:33,159
但是您不知道该怎么做，因为您正在运行Python，

513
00:42:33,259 --> 00:42:37,079
您没有执行客户端的实际逻辑，

514
00:42:37,199 --> 00:42:42,079
您要做的是催生这个Go Ethereum子命令，

515
00:42:42,079 --> 00:42:44,679
子命令，称为EVM。

516
00:42:44,679 --> 00:42:49,239
然后EVM过渡实际上是EVM TA10。

517
00:42:49,239 --> 00:42:52,759
您对此命令的提供只是所有预状态

518
00:42:53,739 --> 00:42:56,039
以及交易和环境，

519
00:42:56,039 --> 00:43:00,239
然后它将吐出结果

520
00:43:00,239 --> 00:43:01,739
执行是

521
00:43:01,739 --> 00:43:03,840
包括执行每个交易

522
00:43:03,840 --> 00:43:05,059
你给了它。

523
00:43:06,900 --> 00:43:10,360
这很重要，因为它是一个来回的

524
00:43:10,360 --> 00:43:14,099
过程，进食测试，如果您有一个测试

525
00:43:14,099 --> 00:43:18,380
执行10个块，您将调用此EVM

526
00:43:18,380 --> 00:43:20,420
过渡工具10次。

527
00:43:23,740 --> 00:43:24,900
这非常有效。

528
00:43:24,900 --> 00:43:28,280
它不是...

529
00:43:28,280 --> 00:43:32,940
但是我们有更多的解决方案来实现它

530
00:43:32,940 --> 00:43:36,380
甚至更有效，因为我们基本上致电

531
00:43:36,380 --> 00:43:38,660
一次，两次或三次

532
00:43:38,660 --> 00:43:39,619
每个测试。

533
00:43:39,619 --> 00:43:41,840
因此，它变得非常消耗，

534
00:43:42,079 --> 00:43:43,079
CPU消耗相当多。

535
00:43:44,940 --> 00:43:47,340
我们拥有的第二个依赖性

536
00:43:47,340 --> 00:43:48,820
是坚固的。

537
00:43:50,599 --> 00:43:52,500
而且这是不那么

538
00:43:52,500 --> 00:43:54,059
因为我们的大多数测试

539
00:43:54,059 --> 00:43:55,840
在我们的框架内，

540
00:43:56,099 --> 00:43:58,480
我们有每个opcode

541
00:43:58,480 --> 00:43:59,780
EVM拥有的。

542
00:44:01,019 --> 00:44:03,500
所以你真的不需要

543
00:44:03,500 --> 00:44:04,140
写坚固。

544
00:44:04,139 --> 00:44:09,299
坚固性是写智能合约的出色语言。

545
00:44:09,480 --> 00:44:13,440
但是我们的问题是我们通常必须集中精力

546
00:44:13,440 --> 00:44:16,099
在我们正在测试的单一opcodes上。

547
00:44:16,900 --> 00:44:22,019
因此，在坚固性进行一些优化的情况下

548
00:44:22,019 --> 00:44:25,139
我们期望在字节码中看到的

549
00:44:25,659 --> 00:44:27,859
这陷入了智能合同，这不是很好。

550
00:44:27,860 --> 00:44:34,099
因为如果它优化了一些非常重要的操作码

551
00:44:34,099 --> 00:44:35,260
我们实际上正在测试，

552
00:44:35,840 --> 00:44:36,820
当我们填写该测试时，

553
00:44:36,920 --> 00:44:39,519
这将使测试不可靠。

554
00:44:39,740 --> 00:44:40,680
根本不工作

555
00:44:40,680 --> 00:44:43,480
因为您要测试的操作码不存在。

556
00:44:43,840 --> 00:44:44,480
它没有执行。

557
00:44:44,820 --> 00:44:45,559
没关系。

558
00:44:46,780 --> 00:44:51,700
因此，我们只有在我们的代码非常复杂时就使用坚固

559
00:44:51,700 --> 00:44:55,120
我们无法处理字节码写作。

560
00:44:55,780 --> 00:44:57,280
而且它实际上不是字节上的写作。

561
00:44:57,280 --> 00:45:01,140
我会在源代码中显示一个示例吗？

562
00:45:01,440 --> 00:45:05,100
只是让你们看看我们如何写这篇文章。

563
00:45:05,840 --> 00:45:08,620
但是，是的，我们越来越少地使用它。

564
00:45:09,660 --> 00:45:13,420
我们也有另一个输入是EIPS，

565
00:45:14,160 --> 00:45:15,580
存储库实际上。

566
00:45:17,740 --> 00:45:21,060
这是规范的主要来源

567
00:45:21,060 --> 00:45:22,720
我们用来编写测试。

568
00:45:23,360 --> 00:45:25,660
因此，每当我们写测试时，

569
00:45:25,659 --> 00:45:28,679
我们不去Goetherium的代码，

570
00:45:28,779 --> 00:45:29,899
我们去规格。

571
00:45:30,699 --> 00:45:33,359
由此，我们取出了测试用例。

572
00:45:33,839 --> 00:45:36,279
实际上，我们从规范中写下它们。

573
00:45:36,460 --> 00:45:42,859
因此，保留EIP的想法非常重要

574
00:45:42,859 --> 00:45:47,359
在测试的源代码中。

575
00:45:48,319 --> 00:45:52,019
我们在这里这样做的方式是，我们也

576
00:45:52,480 --> 00:45:54,399
好吧，一个是测试人员，测试作者。

577
00:45:54,400 --> 00:46:02,220
他们进入EIP，正在复制或带来或任何公式，

578
00:46:02,380 --> 00:46:08,619
无论那里描述了什么，但它们也带来了校验和EIP的版本。

579
00:46:09,700 --> 00:46:14,920
这很重要，因为在任何叉子的开发过程中，

580
00:46:15,200 --> 00:46:19,300
EIP不时改变确实很常见。

581
00:46:19,300 --> 00:46:29,300
因此，这就像一种安全的措施，我们用来确保，好吧，我们从EIP或EIP中汲取了此逻辑或信息。

582
00:46:29,880 --> 00:46:33,580
我们确定我们正在研究这个新表达式吗？

583
00:46:33,980 --> 00:46:42,080
因为这样，EIP就会更改，然后执行客户端进行并实现新版本，我们的测试开始失败。

584
00:46:42,519 --> 00:46:45,440
他们来找我们说，你写了什么？

585
00:46:45,440 --> 00:46:49,780
然后，我们有一个证明我们为EAP撰写的证据，

586
00:46:50,559 --> 00:46:51,639
但是在以前的版本中。

587
00:46:52,159 --> 00:46:54,780
因此，这些过程只是为了更新

588
00:46:54,780 --> 00:46:55,820
对于最新版本，

589
00:46:55,920 --> 00:46:57,300
但是我们在这里有失败的安全

590
00:46:57,300 --> 00:46:59,880
只是为了确保我们正在写

591
00:46:59,880 --> 00:47:01,659
对于某些版本的EAP。

592
00:47:03,920 --> 00:47:07,300
是的，执行填充命令后，

593
00:47:08,000 --> 00:47:08,860
我们得到输出。

594
00:47:09,280 --> 00:47:10,900
这是重要的部分。

595
00:47:11,800 --> 00:47:12,860
这些是固定装置。

596
00:47:12,860 --> 00:47:14,960
这很简单。

597
00:47:14,960 --> 00:47:18,119
这不是很简单的JSON文件，但是非常可读。

598
00:47:20,500 --> 00:47:22,360
JSON文件中没有什么复杂的。

599
00:47:22,519 --> 00:47:24,679
基本上只是测试的输出。

600
00:47:25,460 --> 00:47:26,720
还有两种口味。

601
00:47:27,159 --> 00:47:29,659
这是国家测试，是三种口味，

602
00:47:29,920 --> 00:47:34,000
这是我在这里描述的第一个。

603
00:47:34,840 --> 00:47:37,780
国家测试，我们对此有一种特定格式，

604
00:47:38,500 --> 00:47:41,280
我们有另一种特定于此的格式。

605
00:47:41,280 --> 00:47:47,420
第三格式是区块链格式相同的格式，但我们用来消耗的格式

606
00:47:47,420 --> 00:47:54,500
在Hive中，这是我将在演示文稿中进一步解释的工具，是的

607
00:47:54,500 --> 00:47:59,280
这里重要的部分是这是对客户的实际输入，这就是我们测试的方式

608
00:47:59,280 --> 00:48:07,400
客户是因为客户去了并消耗了这个JSON，并且如果发现某些东西就是

609
00:48:07,400 --> 00:48:13,280
它不能消费或消耗它时，发现了一个不同的结果，这意味着有一个

610
00:48:13,280 --> 00:48:17,300
差异有一个地方有一个错误，这就是我们找到错误的方式

611
00:48:17,300 --> 00:48:24,599
在测试的EVM部分中，我将进一步解释

612
00:48:24,599 --> 00:48:32,119
嗯，在有关蜂巢的演讲中，但是我们为什么需要它的要旨是因为

613
00:48:32,119 --> 00:48:36,239
总是有两种消费块的方法

614
00:48:36,239 --> 00:48:38,819
在每个执行客户端中。

615
00:48:38,940 --> 00:48:41,839
所以一种是原始格式。

616
00:48:41,839 --> 00:48:44,139
您有块，实际块，

617
00:48:44,239 --> 00:48:48,460
它形成为RLP，这是一种编码方法。

618
00:48:49,019 --> 00:48:52,380
这是通过对等网络广播的。

619
00:48:52,519 --> 00:48:54,279
因此，当您同步时，这就是您得到的。

620
00:48:55,179 --> 00:48:58,339
但是在另一种情况下，当我们使用蜂巢时，

621
00:48:58,340 --> 00:49:03,420
我们通过引擎API喂食执行客户端，

622
00:49:03,620 --> 00:49:08,760
这是引擎API基本上只是一种通信方法

623
00:49:08,760 --> 00:49:11,820
在执行客户端和共识层之间。

624
00:49:12,880 --> 00:49:17,220
因此，当实际以太坊区块链运行时，

625
00:49:17,700 --> 00:49:19,840
我们正在运行共识客户端，

626
00:49:20,100 --> 00:49:23,420
它将指令还给执行客户端。

627
00:49:23,420 --> 00:49:28,539
因此这些说明是以引擎API指令的形式

628
00:49:28,539 --> 00:49:30,460
这就是我们在这里测试的

629
00:49:30,460 --> 00:49:32,380
因此，当我们填写测试时

630
00:49:32,380 --> 00:49:37,019
高格式包含实际的发动机API指令

631
00:49:37,019 --> 00:49:39,579
这些将来自共识客户

632
00:49:39,579 --> 00:49:46,320
因此，我们可以确定这种特定的测试方案

633
00:49:46,320 --> 00:49:51,700
即将被测试，好像它在实际区块链上运行

634
00:49:51,699 --> 00:50:00,579
考虑到主网非常非常大的事实带来的区别

635
00:50:00,579 --> 00:50:06,119
从状态和我们填写的所有测试中，它们都是非常非常小的状态

636
00:50:06,119 --> 00:50:14,119
因为否则它将不可管理，但或多或​​少是同一件事。

637
00:50:14,119 --> 00:50:25,460
好的。所以，是的。我想对我们如何真正填写测试进行一些演示。让

638
00:50:25,460 --> 00:50:32,920
我去实际存储库。顺便说一句，您还能看到我的屏幕吗？

639
00:50:32,920 --> 00:50:36,359
是的，一切都很好。

640
00:50:36,360 --> 00:50:45,559
好吧，完美。这是执行镜头存储库，并且记录在非常完美。我们

641
00:50:45,559 --> 00:50:54,920
在这里有这个文档页面，你们可以来看看。首先，我们需要三件事

642
00:50:56,120 --> 00:51:02,440
运行这个。好吧，以及您需要安装的python的疟原虫。您需要Python 3.10，

643
00:51:02,440 --> 00:51:13,179
我认为是3.10，我们还需要编译EVM和坚固性，所以我不是

644
00:51:13,179 --> 00:51:19,320
我不会介绍如何编译去以太坊，或者你可以

645
00:51:19,320 --> 00:51:23,139
假设您要去读书我去以太坊的存储库去了

646
00:51:23,139 --> 00:51:28,200
您可以将其编译，但是是的，第一种方法是您来

647
00:51:28,199 --> 00:51:33,839
此存储库，然后您可以克隆整个存储库，而只是git克隆

648
00:51:33,839 --> 00:51:42,059
这个，您可以在您的PC中获得此副本，让我向您展示

649
00:51:42,059 --> 00:51:51,419
存储库是的，是的，这是

650
00:51:51,420 --> 00:51:53,340
存储库由两个组成。

651
00:51:53,700 --> 00:51:56,139
让我就在那里。

652
00:51:57,659 --> 00:52:00,180
存储库，让我删除此。

653
00:52:01,420 --> 00:52:04,980
我们有两个部分的部分。

654
00:52:05,320 --> 00:52:09,099
第一个是框架的源代码。

655
00:52:10,220 --> 00:52:13,019
因此，您在来源中找到的所有内容，

656
00:52:13,019 --> 00:52:18,579
它属于我们用来填写测试的代码。

657
00:52:18,579 --> 00:52:21,699
这里没有针对以太坊区块链的测试。

658
00:52:22,739 --> 00:52:25,079
然后第二部分是测试，

659
00:52:25,679 --> 00:52:26,699
也在根目录中。

660
00:52:27,219 --> 00:52:28,500
您可以在这里开始看到

661
00:52:28,500 --> 00:52:31,179
您实际上开始看到一些硬叉。

662
00:52:31,880 --> 00:52:33,799
所以我们有每一个硬叉

663
00:52:33,799 --> 00:52:35,360
直到Cancun在这里为止。

664
00:52:35,980 --> 00:52:37,460
我们从Frontier开始。

665
00:52:38,340 --> 00:52:41,000
然后宅基地，拜占庭，伊斯坦布尔，

666
00:52:42,519 --> 00:52:44,779
教区，婚姻或巴黎，

667
00:52:44,780 --> 00:52:51,760
上海和我跳过了伦敦和柏林，但是，是的，你明白了。

668
00:52:52,180 --> 00:52:58,740
因此，如果您进入这些文件夹中的任何一个，则可以看到我们已经实施的每个测试。

669
00:52:59,320 --> 00:53:07,900
只要考虑到自上海以来这个存储库就开始活跃。

670
00:53:08,120 --> 00:53:10,500
因此，对于上海，是的，您将看到每个AIP。

671
00:53:10,500 --> 00:53:17,559
但是，例如，对于柏林，您不会看到很多，因为柏林来到柏林时并不活跃。

672
00:53:18,059 --> 00:53:20,860
因此，您将看不到所有完整的测试。

673
00:53:21,260 --> 00:53:24,059
这些会在以太坊测试存储库中找到它们。

674
00:53:25,179 --> 00:53:29,840
是的，让我们看看我能想到的最简单的测试。

675
00:53:30,739 --> 00:53:33,500
让我们去参加其中一项测试。

676
00:53:35,320 --> 00:53:39,780
是的，让我们从顶部开始。

677
00:53:40,500 --> 00:53:43,800
我们在这里编写的每个测试都使用pytest。

678
00:53:43,800 --> 00:53:48,019
这是我们用来填写测试的框架。

679
00:53:48,019 --> 00:53:52,539
我们使用Pytest为我们提供的许多功能。

680
00:53:52,539 --> 00:53:56,000
然后，您可以看到我们需要写

681
00:53:56,000 --> 00:53:59,300
我们要提供的每个测试的功能。

682
00:53:59,300 --> 00:54:03,860
在这种情况下，我们有一个非常简单的测试，称为TestDup。

683
00:54:03,860 --> 00:54:07,720
它的目的是，如这里所述

684
00:54:07,840 --> 00:54:10,340
是测试dup升级，

685
00:54:10,840 --> 00:54:15,059
这是DBM中存在的最简单的升级之一。

686
00:54:15,960 --> 00:54:18,120
它测试DUP 1至16。

687
00:54:18,820 --> 00:54:23,120
因此，它将为每个DUP升级生成一个测试。

688
00:54:23,740 --> 00:54:26,280
是的，您可以在这里很好地看到您的方式，

689
00:54:26,840 --> 00:54:32,539
您有，您可以看到实际含义

690
00:54:32,539 --> 00:54:35,940
每个升级。

691
00:54:36,779 --> 00:54:39,000
但是，是的，这个测试功能，

692
00:54:39,099 --> 00:54:40,719
它生成一个状态，

693
00:54:41,099 --> 00:54:42,940
我们之前谈论的那个

694
00:54:43,159 --> 00:54:43,880
第一个。

695
00:54:44,360 --> 00:54:46,820
原因是

696
00:54:46,820 --> 00:54:48,759
这纯粹是EVM测试。

697
00:54:48,960 --> 00:54:51,420
因此您可以将所有内容抽象

698
00:54:51,420 --> 00:54:52,699
那在街区

699
00:54:52,699 --> 00:54:56,739
而且您只能呆在

700
00:54:56,739 --> 00:54:57,619
和EVM执行

701
00:54:57,619 --> 00:54:58,699
然后你得到这个测试

702
00:54:58,699 --> 00:54:59,619
因为这是最简单的。

703
00:54:59,619 --> 00:55:02,320
您不需要外面任何东西。

704
00:55:02,539 --> 00:55:09,900
测试配音命令um，这是当您确定哪个时要牢记的主要事情

705
00:55:10,699 --> 00:55:16,779
您要使用哪种格式进行测试，是的，您得到了一个环境，您得到了

706
00:55:16,779 --> 00:55:21,340
pre this是我们一直在谈论的品种，所以您要做的第一件事就是

707
00:55:21,340 --> 00:55:26,619
是的，您必须有一个常见的测试地址，这是我们所有交易的来源

708
00:55:26,619 --> 00:55:27,440
我们写的。

709
00:55:28,239 --> 00:55:31,699
而且，它还将包含所有代码，

710
00:55:31,799 --> 00:55:32,639
但这并不是在这里填写。

711
00:55:33,039 --> 00:55:36,699
因此，在这一点上，我们仅设置一个测试地址，

712
00:55:36,859 --> 00:55:37,920
这是交易的来源，

713
00:55:38,119 --> 00:55:40,799
我们将有无限的平衡

714
00:55:40,799 --> 00:55:42,900
因为这将是来源

715
00:55:42,900 --> 00:55:44,199
我们发送的所有交易。

716
00:55:44,679 --> 00:55:46,739
所以它必须有东西，对吗？

717
00:55:48,219 --> 00:55:50,559
然后我们定义帐户，

718
00:55:50,559 --> 00:55:59,860
我们将要使用要使用的代码的帐户。这是主要的

719
00:55:59,860 --> 00:56:07,420
交易将发送到的帐户，然后将开始，我们将开始

720
00:56:07,420 --> 00:56:13,820
在其上创建代码，这就是这样。让我看看还有其他。好吧，是的。

721
00:56:14,400 --> 00:56:19,099
是的，如您所见，这是生成此代码的三个部分。

722
00:56:19,099 --> 00:56:21,199
所以第一部分是

723
00:56:21,199 --> 00:56:23,259
我们将创建

724
00:56:23,259 --> 00:56:25,699
11

725
725
00：56：25,699-> 00：56：27,400

726
00:56:25,699 --> 00:56:27,400
10，从0到

727
00:56:27,400 --> 00:56:29,500
10，没有

728
00:56:29,500 --> 00:56:31,559
0x10，是16

729
00:56:31,559 --> 00:56:33,179
推送命令

730
00:56:33,179 --> 00:56:35,380
所以这很容易，只是

731
00:56:35,380 --> 00:56:36,360
推送命令是

732
00:56:36,360 --> 00:56:39,699
基本上只是推东西

733
00:56:39,699 --> 00:56:41,460
进入EVMS堆栈

734
00:56:41,460 --> 00:56:43,880
是的，EVMS堆栈计算机

735
00:56:43,880 --> 00:56:45,839
然后您使用

736
00:56:45,839 --> 00:56:47,059
很多东西的堆栈

737
00:56:47,059 --> 00:56:48,400
所以主

738
00:56:49,099 --> 00:56:54,500
您将要使用的EVM操作码至少是一些推送命令。

739
00:56:55,059 --> 00:56:56,199
因此，在这种情况下，我们正在使用它们。

740
00:56:56,860 --> 00:57:03,319
我们使用的是最简单的，它只是将一个字节推入堆栈。

741
00:57:04,659 --> 00:57:09,679
该堆栈由32个字节元素组成。

742
00:57:09,679 --> 00:57:11,759
但是在这种情况下，我们只是在推动一个字节。

743
00:57:11,760 --> 00:57:19,640
因此，将是31个零，31个零字节，然后是一个字节，这是由此定义的。

744
00:57:20,320 --> 00:57:25,260
而且，如果您知道Python，您现在就知道我们将收集所有这些。

745
00:57:26,220 --> 00:57:32,740
我们将将此数组或列表收集到要去此处的字节代码中。

746
00:57:33,520 --> 00:57:39,900
之后，我们将提出或正在进行测试的代码，

747
00:57:39,900 --> 00:57:43,400
定义此变量。

748
00:57:43,559 --> 00:57:44,619
这个变量很特别

749
00:57:44,619 --> 00:57:48,240
因为我们将其定义为测试的参数，所以

750
00:57:48,460 --> 00:57:49,200
正如您在这里看到的。

751
00:57:49,340 --> 00:57:50,700
而且这很重要

752
00:57:50,700 --> 00:57:54,000
因为这是正在参数化的。

753
00:57:54,440 --> 00:57:57,260
这是最重要的装饰器之一

754
00:57:57,260 --> 00:57:59,500
我们从最终使用。

755
00:58:00,880 --> 00:58:04,400
基本上只需使用此参数

756
00:58:04,400 --> 00:58:06,220
这将在这里使用

757
00:58:06,219 --> 00:58:10,419
然后每次为此运行此功能。

758
00:58:11,119 --> 00:58:14,659
因此，此变量的价值将改变

759
00:58:14,659 --> 00:58:18,199
在每个迭代中，都执行此功能。

760
00:58:19,279 --> 00:58:23,879
因此，第一次迭代将使用dub1，

761
00:58:24,099 --> 00:58:26,099
第二，dub2，依此类推。

762
00:58:26,739 --> 00:58:32,779
这将更改执行字节码的哪个值。

763
00:58:33,459 --> 00:58:36,000
因此，它将改变结果。

764
00:58:36,219 --> 00:58:38,819
测试。

765
00:58:40,139 --> 00:58:44,139
最后，我们要使用另一个

766
00:58:44,139 --> 00:58:47,779
我们使用的最重要的Opcodes

767
00:58:48,619 --> 00:58:50,719
这是SSStore。

768
00:58:50,719 --> 00:58:55,659
SSStore基本上是我们最常用的OpCode

769
00:58:55,659 --> 00:58:59,199
因为这是我们保存东西的方式

770
00:58:59,199 --> 00:59:01,859
进入我们正在执行的合同的存储。

771
00:59:01,860 --> 00:59:05,820
如果我们在测试中的任何地方都不使用此操作码，

772
00:59:06,380 --> 00:59:10,099
这意味着我们正在测试其他东西，

773
00:59:10,200 --> 00:59:11,019
像错误之类的东西

774
00:59:11,300 --> 00:59:15,500
或者我们基本上已经写了一个无效的测试。

775
00:59:16,480 --> 00:59:19,059
在这种情况下，我们正在做的是，就像

776
00:59:19,059 --> 00:59:22,160
我们已经把所有这些东西都放在堆栈中了，

777
00:59:22,280 --> 00:59:24,680
在EVM执行的堆栈中。

778
00:59:25,400 --> 00:59:28,000
然后，最后一步只是为了保存它们。

779
00:59:28,460 --> 00:59:29,440
这就是我们在这里做的。

780
00:59:29,440 --> 00:59:34,240
我们只将一个字节推入堆栈，

781
00:59:34,480 --> 00:59:37,700
我们将在这里保存此值

782
00:59:37,700 --> 00:59:40,320
我们以前推了。

783
00:59:41,200 --> 00:59:42,900
显然，然后存储它。

784
00:59:43,659 --> 00:59:45,940
我们将为每个堆栈项目做到这一点

785
00:59:45,940 --> 00:59:48,099
我们拥有的，这是一个。

786
00:59:48,240 --> 00:59:49,480
不，是一样的。

787
00:59:49,960 --> 00:59:53,000
是的，这将被存储

788
00:59:53,000 --> 00:59:54,079
当我们执行代码时。

789
00:59:55,760 --> 00:59:58,700
最后，我们设置了帐户，

790
00:59:58,699 --> 01:00:01,460
具有其代码，地址和所有内容。

791
01:00:02,000 --> 01:00:03,919
因此，我们准备将其放入预状态中，

792
01:00:04,279 --> 01:00:08,000
这意味着当我们执行此测试时

793
01:00:08,000 --> 01:00:10,599
客户会消耗此测试，

794
01:00:11,079 --> 01:00:13,619
它将找到包含该帐户的预状态。

795
01:00:14,199 --> 01:00:14,960
所以这很重要

796
01:00:14,960 --> 01:00:17,980
因为这是要执行交易的方式

797
01:00:17,980 --> 01:00:19,980
这是交易的目的地，

798
01:00:20,139 --> 01:00:21,219
正如您在这里看到的。

799
01:00:21,439 --> 01:00:21,960
是的，到底是。

800
01:00:22,539 --> 01:00:25,599
因此，我们在此测试中进行的交易

801
01:00:25,599 --> 01:00:26,399
是单个交易。

802
01:00:26,400 --> 01:00:29,639
这在这里唯一重要

803
01:00:29,639 --> 01:00:32,680
是我们将其发送到帐户

804
01:00:32,680 --> 01:00:35,240
我们放入所写的代码。

805
01:00:38,780 --> 01:00:40,900
加上所有信息，但这与此无关。

806
01:00:42,220 --> 01:00:44,700
是的，基本上，最后，最后，

807
01:00:45,240 --> 01:00:47,260
我们要设定的最后一件事

808
01:00:47,260 --> 01:00:50,380
是发布日期，

809
01:00:50,840 --> 01:00:52,639
这是我们要检查的

810
01:00:52,639 --> 01:00:59,500
这是在执行交易后发生的。

811
01:01:01,000 --> 01:01:04,859
基本上，它只是期望堆栈项目

812
01:01:04,859 --> 01:01:07,599
我们在这里说的是正确的位置。

813
01:01:08,199 --> 01:01:10,559
如果您阅读了描述，您将发现其工作原理。

814
01:01:11,440 --> 01:01:14,400
但是，是的，这基本上是最后一步。

815
01:01:14,400 --> 01:01:16,179
下一步只是填充测试。

816
01:01:17,199 --> 01:01:21,259
这里会发生什么，我们将填补状态

817
01:01:21,260 --> 01:01:24,680
使用我们之前设置的所有成分。

818
01:01:25,200 --> 01:01:27,220
这将为我们提供一个固定装置。

819
01:01:27,980 --> 01:01:30,500
因此，最简单的方法就是这样做

820
01:01:30,500 --> 01:01:34,000
是我们运行填充命令。

821
01:01:35,000 --> 01:01:36,800
因此，我们在哪里很重要。

822
01:01:37,080 --> 01:01:40,220
因此，测试边境升级测试测试下划线Dub.py。

823
01:01:40,420 --> 01:01:41,260
让我们这样做。

824
01:01:41,840 --> 01:01:45,720
填充叉子坎昆，假设。

825
01:01:45,719 --> 01:01:47,539
和测试

826
01:01:47,539 --> 01:01:49,799
边境

827
01:01:49,799 --> 01:01:51,679
是什么

828
01:01:51,679 --> 01:01:53,739
升级和测试

829
01:01:53,739 --> 01:01:54,759
下划线配音

830
01:01:54,759 --> 01:01:58,480
你去

831
01:01:58,480 --> 01:02:01,019
你去

832
01:02:01,019 --> 01:02:02,699
如您所见

833
01:02:02,699 --> 01:02:05,019
我们产生了大量的测试

834
01:02:05,019 --> 01:02:07,239
48是

835
01:02:07,239 --> 01:02:09,079
我会有点解释

836
01:02:09,079 --> 01:02:11,559
所以这意味着

837
01:02:11,559 --> 01:02:13,519
我们在这里进行的每个测试

838
01:02:13,519 --> 01:02:14,919
这

839
01:02:14,920 --> 01:02:18,159
在这种情况下，执行客户端

840
01:02:18,159 --> 01:02:20,500
因为我们正在用Geth填充此过渡工具，所以

841
01:02:20,880 --> 01:02:23,260
我们在这里没有测试任何其他客户。

842
01:02:23,360 --> 01:02:27,039
我们只是在使用Geth告诉我们结果应该是什么。

843
01:02:27,519 --> 01:02:29,119
但是我们在这里有一个安全的措施。

844
01:02:29,220 --> 01:02:30,900
因此，如果我们正确设计或测试，

845
01:02:31,139 --> 01:02:34,579
这意味着我们放在这里，这是有道理的。

846
01:02:35,619 --> 01:02:39,139
因此，如果我们修改了这一点，可以说，

847
01:02:40,159 --> 01:02:44,440
让我们将其保存到其他东西，例如20岁之类的东西。

848
01:02:44,920 --> 01:02:48,079
让我们再次运行它，看看会发生什么。

849
01:02:49,440 --> 01:02:50,260
你去。

850
01:02:50,760 --> 01:02:53,079
是的，不是...

851
01:02:54,119 --> 01:02:56,019
是的，我把这个非常非常大。

852
01:02:56,420 --> 01:02:58,159
所以这里就是

853
01:02:58,159 --> 01:03:00,559
我们在帖子中放置的一切

854
01:03:00,559 --> 01:03:02,599
对我们来说真的很重要

855
01:03:02,599 --> 01:03:06,159
我们正在使用的执行客户端填写测试

856
01:03:06,159 --> 01:03:07,460
实际上是理智的。

857
01:03:07,920 --> 01:03:10,619
否则，它将继续生成测试

858
01:03:10,619 --> 01:03:13,280
这将被我们的客户消费

859
01:03:13,280 --> 01:03:18,380
但这将会失败，因为我们用来填写测试的执行客户端

860
01:03:18,380 --> 01:03:24,640
是错误的，所以让我们回到原件，以确保我们再次填写测试

861
01:03:24,640 --> 01:03:33,700
而且您可以走了，嗯，这是什么结果，所以我们现在有了一个新的新文件夹，让我们

862
01:03:33,700 --> 01:03:41,220
看到的是，您去了，所以我们有一个称为这是输出的文件夹，这是

863
01:03:41,219 --> 01:03:49,339
固定装置输出。您会看到这些是我们在这里期望的三种格式。

864
01:03:49,779 --> 01:03:53,579
因此，第一个是区块链测试，是客户消费的测试，

865
01:03:54,279 --> 01:03:59,099
高格式和状态格式。让我们打开其中一个只是为了看看它们的外观。

866
01:03:59,099 --> 01:04:08,599
你去。

867
01:04:09,099 --> 01:04:10,579
所以，是的，一切都在这里。

868
01:04:10,860 --> 01:04:12,400
这是JSON输出。

869
01:04:13,139 --> 01:04:17,699
在这里真的很好，我们有测试的名称，正是我们执行的。

870
01:04:18,599 --> 01:04:19,739
这是国家测试。

871
01:04:19,739 --> 01:04:22,539
这意味着我们在此测试中只有一项交易。

872
01:04:23,019 --> 01:04:24,739
您可以在这里看到它。

873
01:04:25,400 --> 01:04:26,380
我们在这里有交易。

874
01:04:26,500 --> 01:04:28,099
您拥有交易的所有属性。

875
01:04:28,099 --> 01:04:30,819
您还拥有预状态和环境。

876
01:04:31,119 --> 01:04:33,139
因此，在这种情况下，您可以看到环境包含

877
01:04:33,139 --> 01:04:35,759
包括块的简单信息，

878
01:04:36,079 --> 01:04:39,699
环境将是什么，即区块。

879
01:04:41,079 --> 01:04:43,739
您可以看到数字，时间步骤以及所有这些内容，

880
01:04:43,799 --> 01:04:44,360
和基本费用。

881
01:04:44,799 --> 01:04:46,480
您还可以看到，更重要的是

882
01:04:47,380 --> 01:04:53,079
你们还记得我们将代码保存到的地址吗？

883
01:04:53,199 --> 01:04:53,960
就在这里。

884
01:04:54,360 --> 01:04:56,299
因此，我们有100号地址。

885
01:04:56,300 --> 01:05:03,260
它。我们在这里有代码，这是我们在此处使用此奇特代码生成的代码。

886
01:05:05,260 --> 01:05:11,180
这就是执行的原因，因为两个目的地，所有交易，

887
01:05:11,180 --> 01:05:17,980
这是完全相同的地址。然后交易转到这里，执行所有这些，然后我们

888
01:05:17,980 --> 01:05:23,340
验证该文件中也是该帖子。您可以看到，重要的一件事是

889
01:05:23,340 --> 01:05:30,059
在状态测试格式中，我们没有准确验证，特别是存储的每个键，

890
01:05:30,059 --> 01:05:38,460
但是我们验证了哈希，状态根。这就是使我们通过交易的通行证或失败的原因

891
01:05:38,460 --> 01:05:48,460
测试或状态测试，对不起，当执行客户端消耗时。这只是一个

892
01:05:48,460 --> 01:05:52,980
测试，但您可以看到我们在同一文件中有许多测试

893
01:05:52,980 --> 01:05:59,800
dub1，dub2，dub3等等，因此总计应该像16次测试i

894
01:05:59,800 --> 01:06:06,920
是的，你去了，是的，这基本上就是这样的要点

895
01:06:06,920 --> 01:06:12,400
框架工作，我鼓励每个人都去看看，这确实是

896
01:06:12,400 --> 01:06:16,960
写这项测试很有趣，如果您知道python，那就在Python

897
01:06:16,960 --> 01:06:25,760
使用这个非常简单，是的，让我回到演示文稿

898
01:06:28,480 --> 01:06:37,599
是的，好吧，我们还有其他两个工具非常重要的工具，这是挑剔的UH EVM UM

899
01:06:37,599 --> 01:06:42,000
当前在执行幽灵上，我们不是首先生成测试，这是由远端完成的

900
01:06:42,000 --> 01:06:44,559
这是由GO团队的Marius撰写的。

901
01:06:45,159 --> 01:06:46,000
他写了这个工具。

902
01:06:46,440 --> 01:06:48,519
这是另一个工具的陪伴，

903
01:06:48,639 --> 01:06:51,300
生成FOSS代码。

904
01:06:51,719 --> 01:06:53,539
然后，您使用GO EVM实验室，

905
01:06:53,599 --> 01:06:56,860
这是您用于一个输入的工具，

906
01:06:57,079 --> 01:07:00,539
然后您运行此输入

907
01:07:00,539 --> 01:07:01,880
与许多不同的客户。

908
01:07:02,480 --> 01:07:03,739
然后，您检查差异。

909
01:07:06,460 --> 01:07:07,820
它产生了很多错误，

910
01:07:08,099 --> 01:07:08,980
这真的很有用

911
01:07:08,980 --> 01:07:11,920
因为当您编写功能测试时，

912
01:07:12,000 --> 01:07:16,159
真的很难想到您可以想到的每种边缘情况。

913
01:07:16,159 --> 01:07:21,619
因此，此工具是我们使用执行规格测试编写的非常好的陪伴。

914
01:07:24,219 --> 01:07:28,639
另一个重要的部分是执行AP测试。

915
01:07:29,199 --> 01:07:32,139
这是在此存储库中完成的。

916
01:07:34,340 --> 01:07:35,960
让我快速告诉你。

917
01:07:35,960 --> 01:07:43,519
基本上，您用于查询执行客户端的所有执行API，

918
01:07:43,599 --> 01:07:45,920
例如，获取一个块，获取交易，发送交易，

919
01:07:46,360 --> 01:07:49,539
所有这些内容，都在此存储库中列出。

920
01:07:50,179 --> 01:07:52,820
让我快速告诉您它的外观。

921
01:07:53,240 --> 01:07:55,679
因此，我们有这个存储库，然后您进行了测试。

922
01:07:56,240 --> 01:08:03,960
然后，您可以看到每个RPC指令都有一两个测试。

923
01:08:03,960 --> 01:08:07,619
指令因此，例如它强调了调用，然后您可以去这里查看和

924
01:08:07,619 --> 01:08:11,639
每一个都像一个输入，然后期望这是非常

925
01:08:11,639 --> 01:08:17,079
简单所有的人都有这样的先决条件，这就是链

926
01:08:17,079 --> 01:08:23,340
因为如果您期望固定

927
01:08:23,340 --> 01:08:30,319
结果您必须拥有一个创世纪链等等

928
01:08:30,319 --> 01:08:33,619
你去。

929
01:08:33,619 --> 01:08:36,279
共识层测试。

930
01:08:36,279 --> 01:08:43,500
这一切都是在共识规范存储库中完成的。

931
01:08:43,500 --> 01:08:51,000
这是针对测试的，这与执行规范测试的想法非常相似，

932
01:08:51,000 --> 01:08:59,000
这是您的输出是客户可以消费的固定装置。

933
01:08:59,000 --> 01:09:05,119
主要区别之一是，由于您包含实际规范

934
01:09:05,119 --> 01:09:09,000
在同一存储库中，您没有任何依赖关系。

935
01:09:09,000 --> 01:09:12,739
您不依赖任何共识层客户端。

936
01:09:12,739 --> 01:09:17,600
因此，这是非常有帮助的，因为您有测试，有规格，

937
01:09:17,600 --> 01:09:20,159
在同一存储库中的所有内容。

938
01:09:20,159 --> 01:09:21,420
这非常非常花哨。

939
01:09:21,420 --> 01:09:26,260
让我向您展示这部分。

940
01:09:32,760 --> 01:09:33,420
所以，是的。

941
01:09:34,300 --> 01:09:37,319
如果您进入共识规范，则进入测试，

942
01:09:37,600 --> 01:09:43,659
您可以进入这里，查看所有可以输出的格式

943
01:09:43,659 --> 01:09:44,560
来自此存储库。

944
01:09:44,960 --> 01:09:48,000
这些是测试不同事物的许多不同格式

945
01:09:48,000 --> 01:09:49,600
共识层。

946
01:09:49,600 --> 01:09:56,460
这比我们仅生成区块链测试的执行规范生成的要多得多

947
01:09:56,460 --> 01:10:01,660
格式和状态有望改变我们将引入更多格式

948
01:10:01,660 --> 01:10:06,840
是的，是的，您可以看到使用此测试可以生成的大量格式是

949
01:10:06,840 --> 01:10:13,320
非常有用，因为您可以非常细粒度测试它的每一层

950
01:10:13,320 --> 01:10:18,440
基本上就像单位测试共识层的每个方面，这是非常有效的

951
01:10:18,439 --> 01:10:27,619
还。我建议进入这里，进入这个存储库，并给予此

952
01:10:27,619 --> 01:10:32,659
阅读，因为这也许不是那么简单，但是

953
01:10:32,659 --> 01:10:38,099
理解如何填充该测试。

954
01:10:38,199 --> 01:10:48,019
因此，进入后期的最后一部分

955
01:10:48,020 --> 01:10:57,120
演示文稿，我们分别对执行层和共识层进行测试，但我们也

956
01:10:57,120 --> 01:11:03,460
进行一些测试，即横层测试，这一点非常重要的是要知道一切

957
01:11:03,460 --> 01:11:10,340
适合它称为端到端测试，它基本上只是从创世纪建立链条

958
01:11:10,340 --> 01:11:16,400
到某个时候，然后验证所有互动的一切都正确地发生在

959
01:11:16,399 --> 01:11:21,439
执行和共识客户。我们对此有不同的测试，对此进行测试推文。

960
01:11:21,439 --> 01:11:26,239
我只会提及其中的一些，因为否则它将是一个非常非常长的

961
01:11:26,239 --> 01:11:31,599
推介会。因此，我们有Hive，这是我个人关注的主要工具，

962
01:11:31,599 --> 01:11:36,719
房间测试团队的重点是

963
01:11:36,719 --> 01:11:43,839
DevOps团队，并与其他公司结合。所以我们有主张，

964
01:11:43,840 --> 01:11:53,119
基本上，这只是我们可以用来给它输入的工具，然后期望一些预期的

965
01:11:53,119 --> 01:12:01,360
输出并断言在任何链中的输出都是正确的。它是蜂巢链，

966
01:12:01,360 --> 01:12:06,400
DEVNET，测试网，甚至是主网。这很重要，您可以用

967
01:12:06,399 --> 01:12:08,819
断言是非常好的工具。

968
01:12:09,239 --> 01:12:11,679
我们还有峰度包，

969
01:12:12,099 --> 01:12:13,679
是由峰度小组开发的。

970
01:12:14,259 --> 01:12:15,939
这是一个非常非常好的工具，

971
01:12:15,939 --> 01:12:19,519
允许做简单的事情

972
01:12:19,519 --> 01:12:23,960
从只产生自己的当地以太链链，

973
01:12:24,099 --> 01:12:26,000
由执行客户端组成

974
01:12:26,000 --> 01:12:27,279
和共识客户，

975
01:12:27,460 --> 01:12:30,939
或直到启动Shadowforks，

976
01:12:31,779 --> 01:12:33,879
我将在一点点解释这一点。

977
01:12:33,920 --> 01:12:35,259
这是一个非常非常好的包装。

978
01:12:35,260 --> 01:12:41,420
如果您想快速运行一些东西，这就是工具之一，我建议这样做

979
01:12:41,420 --> 01:12:50,480
要去嗯，是的，我要去更多的蜂巢，因为这是一种工具之一

980
01:12:50,480 --> 01:13:00,180
我与之合作的um是的，基本上是蜂巢是一个为您提供测试人员的框架

981
01:13:00,180 --> 01:13:03,260
产卵测试的一种方式

982
01:13:03,260 --> 01:13:05,400
并在测试中产生客户，

983
01:13:06,320 --> 01:13:09,140
即执行客户和共识客户。

984
01:13:09,640 --> 01:13:13,159
因此您可以创建测试的测试

985
01:13:13,159 --> 01:13:15,680
而且您有一些非常具体的事情。

986
01:13:15,740 --> 01:13:19,400
例如，您想测试存款

987
01:13:19,400 --> 01:13:21,119
在共识数据链中。

988
01:13:21,579 --> 01:13:22,960
因此，您开始考试

989
01:13:22,960 --> 01:13:26,079
然后您启动一个执行客户端。

990
01:13:26,240 --> 01:13:29,500
对不起，您首先开始共识客户端，

991
01:13:29,500 --> 01:13:31,720
然后您启动执行客户端

992
01:13:31,720 --> 01:13:33,060
你把它们放在一起

993
01:13:33,060 --> 01:13:35,119
您发起了一些存款

994
01:13:35,119 --> 01:13:36,539
进入共识客户

995
01:13:36,539 --> 01:13:38,060
然后您期待一些东西

996
01:13:38,060 --> 01:13:39,579
在测试结束时

997
01:13:39,579 --> 01:13:40,920
如果一切都正确

998
01:13:40,920 --> 01:13:43,960
您指示测试正确完成

999
01:13:43,960 --> 01:13:45,020
并通过

1000
01:13:45,020 --> 01:13:46,520
然后你总结

1001
01:13:46,520 --> 01:13:49,039
这是一个非常好的框架

1002
01:13:49,039 --> 01:13:51,920
做非常

1003
01:13:51,920 --> 01:13:54,979
非常功能和特定的测试

1004
01:13:54,979 --> 01:13:57,180
你必须牢记

1005
01:13:57,180 --> 01:13:58,460
正是您要测试的

1006
01:13:58,460 --> 01:14:00,899
当您滚动并编写模拟器时。

1007
01:14:01,579 --> 01:14:02,779
它的工作方式是，

1008
01:14:02,899 --> 01:14:04,199
让我看看我是否有幻灯片，是的。

1009
01:14:04,380 --> 01:14:07,659
它的工作方式是我们拥有Hive Server，

1010
01:14:07,920 --> 01:14:09,819
这是主要的编排

1011
01:14:09,819 --> 01:14:11,779
在我们在此过程中运行的一切

1012
01:14:12,420 --> 01:14:13,800
但是您也有模拟器。

1013
01:14:14,420 --> 01:14:17,300
模拟器的工作是知道该怎么办

1014
01:14:17,300 --> 01:14:20,779
关于何时开始测试的

1015
01:14:21,020 --> 01:14:22,739
何时结束它，何时启动客户端，

1016
01:14:22,739 --> 01:14:25,380
何时结束客户，等等。

1017
01:14:25,380 --> 01:14:28,500
因此，第一步是您构建Hive Server，

1018
01:14:29,039 --> 01:14:31,020
我会稍微展示。

1019
01:14:31,079 --> 01:14:31,779
我有一个演示。

1020
01:14:32,100 --> 01:14:33,319
真的很快。

1021
01:14:34,060 --> 01:14:36,260
然后您启动蜂巢服务器，

1022
01:14:36,720 --> 01:14:41,039
然后您告诉蜂巢服务器启动给定的模拟器，

1023
01:14:41,500 --> 01:14:45,140
它将继续并启动一个Docker容器

1024
01:14:45,140 --> 01:14:45,960
使用模拟器。

1025
01:14:46,600 --> 01:14:48,600
基本上，模拟器只是另一个程序

1026
01:14:48,600 --> 01:14:50,039
其中包含所有说明

1027
01:14:50,039 --> 01:14:51,420
关于如何运行此测试。

1028
01:14:51,819 --> 01:14:53,380
因此，模拟器开始，

1029
01:14:53,380 --> 01:14:59,659
模拟器知道它是由Hive运行的，然后继续进行并做事，

1030
01:15:00,180 --> 01:15:05,440
它开始测试，启动客户端，然后执行一些计算和事物，

1031
01:15:05,800 --> 01:15:11,060
然后它结束客户端，或结束测试，或中止测试，或失败或通过测试，

1032
01:15:11,619 --> 01:15:17,520
然后基本上就是这样。一个模拟器可以一次启动许多测试，

1033
01:15:17,520 --> 01:15:21,580
同时，它也可以同时启动许多客户，

1034
01:15:21,680 --> 01:15:25,420
它可以协调许多不同的情况

1035
01:15:25,420 --> 01:15:30,020
为了执行和共识客户端执行。

1036
01:15:31,740 --> 01:15:34,780
好事是您不必担心

1037
01:15:34,780 --> 01:15:38,680
在模拟器中有关您的启动方式。

1038
01:15:39,040 --> 01:15:40,560
例如，假设，好的，

1039
01:15:40,600 --> 01:15:42,160
我想启动一个执行客户端，

1040
01:15:42,680 --> 01:15:43,680
但是我不知道该如何开始

1041
01:15:43,680 --> 01:15:45,660
因为去以太坊和nethermine

1042
01:15:45,660 --> 01:15:47,100
以不同的方式开始。

1043
01:15:47,520 --> 01:15:52,140
例如，我们每个都有docker图像，

1044
01:15:52,140 --> 01:15:55,780
但是即使如此，您也有喜欢参数，

1045
01:15:55,780 --> 01:15:58,340
例如，GO定理具有不同的参数

1046
01:15:58,340 --> 01:16:02,280
有关如何指定创世纪文件或其他任何内容，

1047
01:16:02,280 --> 01:16:04,220
与Nethermine相比。

1048
01:16:04,220 --> 01:16:06,860
因此，蜂巢服务器的目标之一

1049
01:16:06,860 --> 01:16:08,380
是为了抽象所有这些。

1050
01:16:08,380 --> 01:16:12,480
因此，您启动模拟器，Hive告诉您，

1051
01:16:12,480 --> 01:16:14,680
好吧，你有定理，nethermine，

1052
01:16:14,680 --> 01:16:17,300
Pzu和其他，以及模拟器

1053
01:16:17,520 --> 01:16:21,100
进入说，好吧，让我们开始使用它。

1054
01:16:21,100 --> 01:16:22,480
然后开始使用定理

1055
01:16:22,480 --> 01:16:25,340
所有参数已经为您设置了。

1056
01:16:25,340 --> 01:16:28,340
然后您可以专注于测试

1057
01:16:28,340 --> 01:16:32,460
对于该特定的执行客户端。

1058
01:16:32,460 --> 01:16:35,460
蜂巢服务器将启动执行

1059
01:16:35,460 --> 01:16:37,020
或为您提供共识客户。

1060
01:16:37,020 --> 01:16:39,240
但是好事是从模拟中，

1061
01:16:39,240 --> 01:16:41,740
您可以与两个Hive Server通信

1062
01:16:41,740 --> 01:16:42,900
为了启动更多客户，

1063
01:16:42,900 --> 01:16:46,020
或者您可以与执行客户端进行通信

1064
01:16:46,020 --> 01:16:47,380
或直接共识客户端。

1065
01:16:48,080 --> 01:16:49,460
所以这是一个非常好的方法

1066
01:16:49,460 --> 01:16:50,880
只是抽象

1067
01:16:50,880 --> 01:16:52,220
您有很多东西。

1068
01:16:53,000 --> 01:16:53,720
测试作者

1069
01:16:53,720 --> 01:16:55,400
只专注于

1070
01:16:55,400 --> 01:16:57,540
测试实际的事情

1071
01:16:57,540 --> 01:16:59,760
在客户的形象中。

1072
01:17:02,440 --> 01:17:03,840
我们有很多模拟器

1073
01:17:03,840 --> 01:17:07,000
对于蜂巢。

1074
01:17:07,520 --> 01:17:09,820
他们都在戈兰

1075
01:17:09,820 --> 01:17:11,180
它们都包含

1076
01:17:11,180 --> 01:17:13,180
在蜂巢存储库中

1077
01:17:13,340 --> 01:17:14,100
但这是可能的

1078
01:17:14,100 --> 01:17:20,340
用所需的任何语言编写任何模拟器。

1079
01:17:21,380 --> 01:17:25,800
这是为了，我们还有一个python的图书馆，

1080
01:17:25,920 --> 01:17:29,060
尚未出来，

1081
01:17:30,060 --> 01:17:31,440
而且还有一些工作要做，

1082
01:17:32,020 --> 01:17:33,340
还有一些工作要做。

1083
01:17:33,980 --> 01:17:36,980
但是，是的，就目前而言，只有在Golang上。

1084
01:17:37,320 --> 01:17:39,440
如您所见，这是所有模拟器

1085
01:17:39,440 --> 01:17:42,579
至少在高级分支机构上

1086
01:17:42,579 --> 01:17:44,239
被包含在蜂巢中。

1087
01:17:45,079 --> 01:17:46,260
我们有不同的东西。

1088
01:17:46,380 --> 01:17:48,000
例如，我们有点对点，

1089
01:17:48,220 --> 01:17:51,619
就像在他们之间传达执行客户端的方式一样。

1090
01:17:51,619 --> 01:17:57,100
因此，该模拟器与测试通信的这一部分有关。

1091
01:17:57,779 --> 01:18:00,619
只需启动客户，彼此交流，

1092
01:18:00,680 --> 01:18:02,720
并验证这种沟通发生了

1093
01:18:02,720 --> 01:18:04,119
这是正确和成功的。

1094
01:18:05,000 --> 01:18:07,079
我们也有以太坊的正常

1095
01:18:07,340 --> 01:18:10,380
其中包含许多不同的东西，

1096
01:18:10,380 --> 01:18:12,659
即RPC

1097
01:18:12,659 --> 01:18:14,619
RPC紧凑型是

1098
01:18:14,619 --> 01:18:16,739
如果你还记得

1099
01:18:16,739 --> 01:18:18,659
另一页

1100
01:18:18,659 --> 01:18:20,480
我们看到了执行

1101
01:18:20,480 --> 01:18:22,560
应用是，这东西在这里

1102
01:18:22,560 --> 01:18:24,500
它进入该存储库

1103
01:18:24,500 --> 01:18:26,600
并收集每个

1104
01:18:26,600 --> 01:18:27,980
这些文件

1105
01:18:27,980 --> 01:18:30,680
然后通过RPC执行它们

1106
01:18:30,680 --> 01:18:31,880
在运行的客户端

1107
01:18:31,880 --> 01:18:34,260
使用我们仅的方法

1108
01:18:34,260 --> 01:18:36,819
看到，所以这很重要

1109
01:18:36,819 --> 01:18:38,819
用于消费

1110
01:18:38,819 --> 01:18:39,500
这

1111
01:18:39,500 --> 01:18:44,500
在这些测试中，仅用于RPC战斗。

1112
01:18:45,600 --> 01:18:47,399
但是我们还有更多的东西。

1113
01:18:47,399 --> 01:18:50,180
例如，我们有共识。

1114
01:18:50,180 --> 01:18:53,600
这将负载以太坊测试的测试

1115
01:18:53,600 --> 01:18:56,899
然后将它们传递到客户中，验证它们。

1116
01:18:56,899 --> 01:18:58,340
我们也有引擎API。

1117
01:18:58,340 --> 01:19:00,199
这很重要，因为它测试

1118
01:19:00,199 --> 01:19:03,340
共识客户的沟通

1119
01:19:03,340 --> 01:19:06,899
通过引擎API进入执行客户端，

1120
01:19:06,899 --> 01:19:10,059
在执行API中在此处定义。

1121
01:19:10,059 --> 01:19:12,339
该模拟器的重要部分

1122
01:19:12,339 --> 01:19:15,599
是它不使用共识客户端。

1123
01:19:15,599 --> 01:19:18,139
原因是它要测试

1124
01:19:18,139 --> 01:19:21,319
一些非常具体的引擎API命令序列

1125
01:19:22,339 --> 01:19:26,399
以及一些非常具体的创世纪特性。

1126
01:19:26,399 --> 01:19:30,079
所以我们这样做的方式

1127
01:19:31,219 --> 01:19:34,059
没有共识客户的中断，

1128
01:19:34,060 --> 01:19:39,060
是通过生成模拟共识客户端，

1129
01:19:39,180 --> 01:19:42,440
基本上只是引擎API调用

1130
01:19:42,440 --> 01:19:43,940
我们完全需要。

1131
01:19:44,800 --> 01:19:47,960
我们还有GraphQl，它是测试GraphQl。

1132
01:19:47,960 --> 01:19:50,880
PYSPEC基本上是执行幽灵。

1133
01:19:50,880 --> 01:19:53,740
它们都在这里被消耗掉了，还进行了一些同步测试。

1134
01:19:55,340 --> 01:19:58,880
而且，但也非常重要的是F2。

1135
01:19:58,880 --> 01:20:02,160
这是一个旧的名字，不要介意。

1136
01:20:02,159 --> 01:20:12,739
这包含共识层和执行层之间的所有中断测试。

1137
01:20:12,739 --> 01:20:21,619
因此，实际上，这个模拟器在此处确实会同时产生共识客户端和执行客户端。

1138
01:20:21,619 --> 01:20:26,979
它的目的只是测试一些正在发生的特定情况，例如在傻瓜中，

1139
01:20:26,979 --> 01:20:29,459
您有斑点，斑点发送斑点，

1140
01:20:29,719 --> 01:20:31,019
并做斑点的事情，

1141
01:20:31,500 --> 01:20:33,899
并验证共识客户

1142
01:20:33,899 --> 01:20:36,199
执行客户的行为以预期的方式行事

1143
01:20:36,199 --> 01:20:39,199
当这些斑点被送入其中时。

1144
01:20:39,859 --> 01:20:42,819
它非常好，因为它策划了这两种事情，

1145
01:20:43,019 --> 01:20:45,119
执行客户端和共识客户端

1146
01:20:45,119 --> 01:20:46,019
同时。

1147
01:20:46,599 --> 01:20:48,839
看到它是如何工作的，真是太好了。

1148
01:20:50,199 --> 01:20:51,500
让我看看。

1149
01:20:52,139 --> 01:20:52,439
还有什么？

1150
01:20:52,939 --> 01:20:53,939
一个小的组件门户，

1151
01:20:54,379 --> 01:20:56,259
更多的模拟器，不同的实现。

1152
01:20:56,260 --> 01:21:01,800
这是一种不同的实现，它使用了不同的以太坊客户端，但这是同一想法

1153
01:21:02,920 --> 01:21:04,920
是的

1154
01:21:06,400 --> 01:21:13,300
是的，好吧，所以让我迅速让我只是想展示它的运行方式

1155
01:21:13,880 --> 01:21:15,880
真的很简单

1156
01:21:16,600 --> 01:21:21,360
重要部分之一是您首先必须一如既往地克隆存储库

1157
01:21:22,480 --> 01:21:25,060
只需在这里进入蜂巢中的蜂巢

1158
01:21:25,060 --> 01:21:36,400
git克隆，将其克隆到本地主机中，然后假设您已经安装了Golan，

1159
01:21:36,400 --> 01:21:42,460
您可以去构建它，然后您将建造Hive，这是在这里可执行的。

1160
01:21:42,460 --> 01:21:52,680
那在那里。因此，此可执行文件与此服务器有关

1161
01:21:52,680 --> 01:21:58,860
一切基本上都是一个非常精美的码头容器实例化器，

1162
01:21:58,860 --> 01:22:05,500
乐队的角色是角色，所以让我们来进行一个简单的测试，我想我

1163
01:22:05,500 --> 01:22:12,380
在该地区有一些东西，是的，让我们进行一个简单的测试

1164
01:22:12,380 --> 01:22:22,039
只是执行客户端和共识客户端的TestNet测试，让我

1165
01:22:22,039 --> 01:22:31,420
我希望还不错，所以我们要使用hive命令是

1166
01:22:31,420 --> 01:22:36,640
我们要使用蜂巢命令，我们将指示它使用三个

1167
01:22:36,640 --> 01:22:41,020
不同的客户端，因此第一个客户端是NetDerMind客户端

1168
01:22:41,020 --> 01:22:43,380
我们要使用的执行客户端。

1169
01:22:43,380 --> 01:22:47,920
第二，第三个客户都是

1170
01:22:47,920 --> 01:22:49,480
共识层的

1171
01:22:49,480 --> 01:22:54,480
但是他们有两个不同的责任。

1172
01:22:55,980 --> 01:22:59,700
Hive需要一个信标节点和验证器客户端

1173
01:22:59,700 --> 01:23:01,960
要为共识层部分运行。

1174
01:23:01,960 --> 01:23:03,780
这就是我们在这里指定的地方，

1175
01:23:03,780 --> 01:23:05,440
在这种情况下是棱镜，

1176
01:23:05,440 --> 01:23:07,520
我们正在使用信标节点，

1177
01:23:07,520 --> 01:23:09,660
只是棱镜的标准节点部分，

1178
01:23:09,659 --> 01:23:11,380
然后验证器客户端，

1179
01:23:11,380 --> 01:23:14,439
验证者客户的一部分。

1180
01:23:14,439 --> 01:23:16,779
然后，我们将指定一个模拟器，

1181
01:23:16,779 --> 01:23:18,279
这是这里的标志。

1182
01:23:19,359 --> 01:23:21,979
然后我们将它将其用于Tenkun，

1183
01:23:21,979 --> 01:23:25,059
这是我们拥有的最新模拟器。

1184
01:23:25,059 --> 01:23:28,819
我们将仅限于一个

1185
01:23:28,819 --> 01:23:33,439
让我看看，测试，不，我。

1186
01:23:33,439 --> 01:23:38,439
好吧，如果您想知道实际测试的名称

1187
01:23:38,439 --> 01:23:43,559
我们正在运行的测试，您可以进入模拟器，例如，让我们开始

1188
01:23:43,559 --> 01:23:51,559
add2，让我们去Dencun，让我们看看套房。您实际上可以在这里看它

1189
01:23:51,559 --> 01:23:56,279
将列出当前在此上进行的所有所有测试

1190
01:23:56,279 --> 01:24:03,399
模拟器，让我们去找最简单的dencun testnet。

1191
01:24:03,399 --> 01:24:09,639
它。您会看到，这里的每个测试用例都会有您的特定共同行

1192
01:24:09,639 --> 01:24:16,699
可以复制糊。让我这样做。这个破折号并不重要。这可以删除。

1193
01:24:17,359 --> 01:24:23,659
让我们在这里复制粘贴。让我们点击Enter以查看会发生什么。第一件事

1194
01:24:23,659 --> 01:24:29,159
这样做的是，好的，一个蜂巢开始，它构建了一种称为高代理的东西。

1195
01:24:29,159 --> 01:24:37,159
这并不重要，基本上就像执行客户端与共识客户端和Hive服务器之间的中介一样。

1196
01:24:37,159 --> 01:24:45,159
它在这里建造的第二件事是，我无法暂停它，好吧，第二件事是构建的是执行客户端。

1197
01:24:45,159 --> 01:24:48,159
您可以看到在这里建造了Nethermind，并且可以正确构建。

1198
01:24:48,159 --> 01:24:53,019
建立客户很重要

1199
01:24:53,019 --> 01:24:55,139
因为你知道那座建筑物

1200
01:24:55,139 --> 01:24:57,220
会给你最新版本

1201
01:24:57,220 --> 01:24:59,059
我们正在尝试测试。

1202
01:24:59,260 --> 01:25:00,159
因此，在这种情况下，

1203
01:25:00,199 --> 01:25:02,380
我们正在拉动最新的大师。

1204
01:25:02,779 --> 01:25:04,439
因此，它也可能包含错误

1205
01:25:04,439 --> 01:25:06,119
因为这不是发布

1206
01:25:06,220 --> 01:25:06,760
这是主人。

1207
01:25:07,159 --> 01:25:08,380
所以有东西，

1208
01:25:08,579 --> 01:25:11,079
显然在每个客户的主分支

1209
01:25:11,079 --> 01:25:13,420
可以包含错误，

1210
01:25:13,659 --> 01:25:15,199
但这是蜂巢的目的

1211
01:25:15,199 --> 01:25:17,159
捕获这些错误。

1212
01:25:17,159 --> 01:25:21,319
因此，这里重要的是使用最新的主人。

1213
01:25:21,319 --> 01:25:25,059
构建的下一件事情是同一件事

1214
01:25:25,059 --> 01:25:27,899
对于共识客户，共识层，对不起。

1215
01:25:27,899 --> 01:25:30,039
我们正在使用Prism，Bitcoin节点，

1216
01:25:30,039 --> 01:25:33,059
棱镜，迟来的主张，同样的事情。

1217
01:25:33,059 --> 01:25:35,220
我们正在使用最新的主人，这不是版本，

1218
01:25:35,220 --> 01:25:39,519
这是更新的东西，基本上只是一个beta版本。

1219
01:25:39,519 --> 01:25:42,920
因此，这可能会有错误。

1220
01:25:42,920 --> 01:25:46,079
最后，我们将构建模拟器。

1221
01:25:46,079 --> 01:25:49,399
因此，此处的模拟器是我们指定的模拟器，

1222
01:25:49,399 --> 01:25:53,439
但是这里使用的这个标志，这是极限，

1223
01:25:53,439 --> 01:25:57,180
这是进入模拟器的标志。

1224
01:25:57,180 --> 01:26:00,359
因此，我们将标志传递到模拟器中以告诉它，

1225
01:26:00,359 --> 01:26:04,500
请不要进行其他任何特定测试。

1226
01:26:04,500 --> 01:26:06,600
所以它不会运行整个模拟器

1227
01:26:06,600 --> 01:26:10,619
以及该模拟器测试的直接能力

1228
01:26:10,619 --> 01:26:13,279
它只是将进行一次一次测试。

1229
01:26:13,279 --> 01:26:14,420
现在它正在运行，

1230
01:26:14,420 --> 01:26:17,939
而且您可以看到它开始了几件事

1231
01:26:17,939 --> 01:26:20,439
目前正在运行

1232
01:26:20,439 --> 01:26:22,519
因为它是在后台做的。

1233
01:26:22,519 --> 01:26:26,039
但是我们现在可以看到的，这很愚蠢

1234
01:26:26,039 --> 01:26:29,619
是我们所有这些东西都在Docker中运行。

1235
01:26:29,619 --> 01:26:32,259
因此您可以看到我们已经产生了

1236
01:26:32,259 --> 01:26:34,300
两个不同的执行客户端

1237
01:26:34,300 --> 01:26:38,479
以及两个不同的验证者和Baconaut客户

1238
01:26:38,479 --> 01:26:39,719
对于意识层。

1239
01:26:39,719 --> 01:26:42,899
这是因为这是一个完整的测试网

1240
01:26:42,899 --> 01:26:44,139
我们正在使用的

1241
01:26:44,139 --> 01:26:46,379
通常，共识客户需要

1242
01:26:46,379 --> 01:26:51,039
至少一个同伴知道一切都一样，对吗？

1243
01:26:51,039 --> 01:26:52,000
因为否则，

1244
01:26:53,799 --> 01:26:56,199
如果您没有任何单个对等点可以连接到

1245
01:26:56,199 --> 01:26:59,719
这意味着正在发生错误的事情。

1246
01:26:59,719 --> 01:27:03,639
因此，在这种情况下，我们实例化了两双所有内容

1247
01:27:03,639 --> 01:27:06,839
并让模拟器做这件事。

1248
01:27:06,839 --> 01:27:10,219
然后我们实际上可以进入文件。

1249
01:27:10,220 --> 01:27:14,320
我们可以使用一个模拟器日志文件来查看。

1250
01:27:14,320 --> 01:27:18,560
其中的主要输出是锁

1251
01:27:20,500 --> 01:27:21,340
在工作区。

1252
01:27:21,340 --> 01:27:25,900
因此，在您的本地主机中，在您拥有的高文件夹中

1253
01:27:25,900 --> 01:27:28,039
当您运行工作区时，

1254
01:27:28,039 --> 01:27:30,159
您将看到此锁目录。

1255
01:27:30,159 --> 01:27:32,039
如果你去这里，

1256
01:27:32,039 --> 01:27:35,039
您将看到实际模拟器的输出。

1257
01:27:35,039 --> 01:27:37,140
因此，您将看到正在发生的一切

1258
01:27:37,140 --> 01:27:40,300
在模拟器中，它正在运行什么，正在做什么，

1259
01:27:40,300 --> 01:27:43,500
它要求什么，您将在这里看到的所有内容。

1260
01:27:43,500 --> 01:27:44,820
这只是一个创世纪文件，

1261
01:27:44,820 --> 01:27:48,200
但是然后您可以在这里看到链条正在发展。

1262
01:27:48,200 --> 01:27:50,800
因此，您可以看到模拟器，

1263
01:27:50,800 --> 01:27:55,680
它所做的工作之一就是保持跟踪

1264
01:27:55,680 --> 01:27:56,820
正在发生的一切。

1265
01:27:56,820 --> 01:27:58,079
因此，它保持跟踪的第一件事

1266
01:27:58,079 --> 01:28:00,380
是链实际上正在发展。

1267
01:28:00,380 --> 01:28:02,619
因此您可以看到我们正在跳跃

1268
01:28:02,619 --> 01:28:04,420
从一个插槽到下一个插槽。

1269
01:28:04,420 --> 01:28:07,000
因此，四个，五个链条正在变化，

1270
01:28:07,000 --> 01:28:08,640
头链正在改变。

1271
01:28:08,640 --> 01:28:11,239
这意味着正在生产块。

1272
01:28:11,239 --> 01:28:12,479
同时，

1273
01:28:12,479 --> 01:28:14,779
也在背景中进行了很多测试，

1274
01:28:14,779 --> 01:28:17,079
这是发送块交易，

1275
01:28:17,079 --> 01:28:19,640
验证那些进入内部的块交易

1276
01:28:19,640 --> 01:28:21,180
一切都很好。

1277
01:28:22,579 --> 01:28:24,119
这是，我认为这是一项漫长的任务

1278
01:28:24,119 --> 01:28:26,359
因为要等待最终确定。

1279
01:28:26,359 --> 01:28:29,640
因此，我们将其包裹在那里进行演示。

1280
01:28:29,640 --> 01:28:31,340
否则将花费太长时间。

1281
01:28:32,859 --> 01:28:36,199
但是，是的，基本上就是这样，

1282
01:28:36,199 --> 01:28:37,659
让我取消这个。

1283
01:28:40,059 --> 01:28:42,159
我认为还剩五分钟。

1284
01:28:44,359 --> 01:28:47,800
还有什么问题

1285
01:28:47,800 --> 01:28:50,479
还是我应该继续前进？

1286
01:28:50,479 --> 01:28:53,519
是的，让我们稍等一下，我想

1287
01:28:53,519 --> 01:28:55,300
因为很多，马里奥。

1288
01:28:55,300 --> 01:28:57,960
非常感谢您，顺便说一句，这太神奇了。

1289
01:28:57,960 --> 01:29:01,760
我喜欢现场会议和一切，真的很棒。

1290
01:29:01,760 --> 01:29:03,239
是的，回到那，实际上，

1291
01:29:03,239 --> 01:29:05,840
我想问一个有趣的问题

1292
01:29:05,840 --> 01:29:10,360
因为执行规范测试将其作为依赖项，所以

1293
01:29:10,360 --> 01:29:13,239
获得执行环境。

1294
01:29:13,239 --> 01:29:14,840
所以问题就像，

1295
01:29:14,840 --> 01:29:16,940
你稍微谈到了一点

1296
01:29:16,940 --> 01:29:18,520
但是也许如果你能详细说明，

1297
01:29:18,520 --> 01:29:21,279
所以像我们一样

1298
01:29:21,279 --> 01:29:23,659
我想我们不认为Get中没有错误，

1299
01:29:23,659 --> 01:29:24,840
所以就像你如何识别

1300
01:29:24,840 --> 01:29:27,420
如果依赖关系实际上存在错误

1301
01:29:27,420 --> 01:29:29,720
是的，我们如何处理？

1302
01:29:29,720 --> 01:29:32,720
是的，理想情况下，理想的情况

1303
01:29:32,720 --> 01:29:35,779
是我们不依靠获得，这就是事实。

1304
01:29:35,840 --> 01:29:48,840
因此，作为解决方法，我们正在努力拥有另一个执行客户端，该客户端只是面向规格，这被称为“ else execution Specs repo”。

1305
01:29:48,840 --> 01:30:04,840
理想情况下，我们不应该使用GET，但是现在到目前为止，我们确实取决于GET，原因和原因不是不是这并不是什么大不了的，因为我们通常还验证了发布日期的结果。

1306
01:30:04,840 --> 01:30:09,880
因此，当我们编写测试时，我们必须非常小心

1307
01:30:09,880 --> 01:30:14,440
我们期望我们唯一不详细介绍的是汽油消耗，因为它确实是

1308
01:30:14,440 --> 01:30:21,319
棘手的测试中，它可以使UM呈误报，并且会产生很多噪音

1309
01:30:21,319 --> 01:30:26,520
但是其他东西是存储的钥匙，我们实际上所有的值

1310
01:30:27,159 --> 01:30:34,039
当我们从Geth得到回应时，请验证它们，所以Box没有太多余地

1311
01:30:34,039 --> 01:30:36,359
影响我们。

1312
01:30:36,880 --> 01:30:40,119
我们不时发现错误

1313
01:30:40,119 --> 01:30:42,140
当我们填写测试时，然后进行报告。

1314
01:30:42,260 --> 01:30:44,939
我们必须等到GET主题修复这些

1315
01:30:44,939 --> 01:30:48,460
让我们能够生成测试。

1316
01:30:49,239 --> 01:30:50,979
在其他极少数情况下，

1317
01:30:50,979 --> 01:30:55,399
我们已经生成了完整的测试。

1318
01:30:55,819 --> 01:30:56,960
我们有固定装置，

1319
01:30:57,260 --> 01:30:59,739
然后我们去其他客户运行，

1320
01:31:00,000 --> 01:31:01,199
然后我们有一个错误。

1321
01:31:01,199 --> 01:31:07,380
然后有时候大多数情况下，这是另一个客户的错误，但有时

1322
01:31:07,380 --> 01:31:14,019
过去，我们在Geth发现了另一个客户发现的错误，所以是的

1323
01:31:14,019 --> 01:31:19,659
到目前为止，这是一个逐步的过程，它将在将来变得更好，但是到目前为止

1324
01:31:19,659 --> 01:31:24,859
在某些地方，我们必须非常小心我们在哪里。

1325
01:31:24,859 --> 01:31:32,219
验证我们让我们通过的东西。例如，正如我说的那样，气体极限非常棘手

1326
01:31:32,219 --> 01:31:36,380
这是我们让其他客户为我们验证的东西。但是，是的。

1327
01:31:38,939 --> 01:31:47,659
太棒了，感谢您的解释。另一个问题是对EIP作者的更多建议，

1328
01:31:47,659 --> 01:31:52,779
例如，谁对RPC方法进行了一些更改，而RPC方法不需要更改状态

1329
01:31:52,779 --> 01:31:57,579
过渡或任何事物，例如在RPC响应中添加一些额外数据，

1330
01:31:57,579 --> 01:32:02,219
是什么方法来比较不同实现的输出，

1331
01:32:02,219 --> 01:32:07,420
例如，它没有太多的开销？

1332
01:32:08,859 --> 01:32:11,099
因此，如果我正确理解，

1333
01:32:15,179 --> 01:32:20,779
因此，RPC是您可以测试的东西而无需编写测试

1334
01:32:20,779 --> 01:32:21,559
我们刚刚描述的。

1335
01:32:21,960 --> 01:32:23,579
因此，对于这种情况，

1336
01:32:24,019 --> 01:32:25,899
您将进入执行API库，

1337
01:32:26,619 --> 01:32:31,359
这是我刚刚瞥了一眼的一部分，

1338
01:32:31,359 --> 01:32:36,099
这是RPC测试的所在地。

1339
01:32:36,759 --> 01:32:39,079
那些RPC测试，

1340
01:32:39,519 --> 01:32:41,340
他们非常非常独立，

1341
01:32:41,460 --> 01:32:43,179
很小且易于编写。

1342
01:32:44,319 --> 01:32:46,479
对于那些特定类型的VAP，

1343
01:32:46,559 --> 01:32:50,380
我建议进入执行APIS存储库

1344
01:32:50,380 --> 01:32:54,400
只要让它看一下，让它看一下测试，我们在这里测试的内容。

1345
01:32:54,779 --> 01:32:58,180
因此，如果您有一些内容可以介绍以太坊客户的RPC，

1346
01:32:58,739 --> 01:33:02,260
我认为这是执行API存储库的起点。

1347
01:33:03,260 --> 01:33:04,800
好吧，很棒。太感谢了。

1348
01:33:06,279 --> 01:33:11,400
是的，一个问题，回到您的榜样，您做过的演示，

1349
01:33:11,880 --> 01:33:17,840
这是对opcodes的测试，即48个测试用例，

1350
01:33:17,840 --> 01:33:19,619
就像每个OpCode三个。

1351
01:33:19,619 --> 01:33:24,480
那么我们那里有48例测试用例的情况是什么？

1352
01:33:24,800 --> 01:33:25,180
确实。

1353
01:33:25,340 --> 01:33:28,340
所以我们有16个opcodes，

1354
01:33:28,520 --> 01:33:29,659
但是对于每个中的每一个

1355
01:33:29,840 --> 01:33:31,880
我们生成了三种测试格式。

1356
01:33:32,380 --> 01:33:33,340
因此，状态测试格式，

1357
01:33:33,699 --> 01:33:34,720
区块链测试格式，

1358
01:33:34,920 --> 01:33:37,560
和区块链测试蜂巢格式。

1359
01:33:38,140 --> 01:33:41,020
因此，每种格式都有自己的目的。

1360
01:33:41,300 --> 01:33:42,520
国家测试非常独立，

1361
01:33:42,800 --> 01:33:46,739
在预状态中只有一笔交易，

1362
01:33:46,739 --> 01:33:48,939
淘汰状态根，检查就是这样。

1363
01:33:49,420 --> 01:33:50,719
区块链测试，

1364
01:33:50,719 --> 01:33:53,079
客户消费的东西，他们可以消费，

1365
01:33:53,179 --> 01:33:54,880
只需检查块标头，一切

1366
01:33:54,880 --> 01:33:56,599
通过。最后，炒作测试，

1367
01:33:56,880 --> 01:33:58,939
其中包含一切，就像一切一样

1368
01:33:58,939 --> 01:34:01,019
好像来了

1369
01:34:01,019 --> 01:34:03,019
从共识层。就是这样

1370
01:34:03,019 --> 01:34:04,619
为什么我们有三种不同的测试格式

1371
01:34:04,619 --> 01:34:06,880
消费和生成。

1372
01:34:07,819 --> 01:34:08,300
我得到它。

1373
01:34:09,300 --> 01:34:11,340
所有格式都很酷。

1374
01:34:11,559 --> 01:34:11,699
惊人的。

1375
01:34:13,659 --> 01:34:13,920
是的。

1376
01:34:13,920 --> 01:34:18,359
是的，还有一个问题，也许我们可以将它们结合在一起。

1377
01:34:19,300 --> 01:34:24,119
您发现在EL或CL中测试的最复杂的是什么？

1378
01:34:24,239 --> 01:34:25,060
最重的是什么？

1379
01:34:25,480 --> 01:34:28,659
以及运行所有这些测试实际需要多少时间

1380
01:34:28,760 --> 01:34:30,940
例如，测试计数器工作吗？

1381
01:34:33,039 --> 01:34:35,859
我会说这确实取决于。

1382
01:34:36,480 --> 01:34:38,739
因此，对于第一个问题，最复杂的是什么？

1383
01:34:38,739 --> 01:34:43,739
我认为互操作性尚未解决。

1384
01:34:43,920 --> 01:34:51,840
它。在我看来，这是最复杂的部分。 EVM部分也很复杂，

1385
01:34:51,840 --> 01:34:56,300
但是它以其自己的方式，当您有很多细微差别时，

1386
01:34:56,300 --> 01:35:01,539
编写EVM测试，总是会发生，哦，我忘记了这个想法

1387
01:35:01,539 --> 01:35:07,460
这种副作用在其他地方的副作用，并影响了我的测试。所以是你

1388
01:35:07,460 --> 01:35:12,859
真的，您必须知道EM的所有内容，但这就像一个来回

1389
01:35:12,859 --> 01:35:14,979
然后去检查和规格，

1390
01:35:14,979 --> 01:35:16,420
黄纸和一切。

1391
01:35:16,420 --> 01:35:18,559
因此，这是一个非常非常漫长的过程。

1392
01:35:18,559 --> 01:35:21,380
就像它真的很棒，因为它很有意义。

1393
01:35:21,380 --> 01:35:23,880
完成EVM测试后，完成并完成

1394
01:35:23,880 --> 01:35:25,939
它起作用真的很好，因为您知道

1395
01:35:25,939 --> 01:35:28,979
一切都是正确的，但确实很复杂。

1396
01:35:28,979 --> 01:35:30,719
这是耗时的。

1397
01:35:32,119 --> 01:35:35,079
另一部分，它需要多少？

1398
01:35:35,079 --> 01:35:35,939
这需要很多。

1399
01:35:35,939 --> 01:35:38,739
因此，根据软件的不同

1400
01:35:38,739 --> 01:35:41,139
我们正在运行的硬件，

1401
01:35:41,140 --> 01:35:43,900
共识测试，EVM测试的问题，

1402
01:35:43,980 --> 01:35:47,060
是每个测试实例化一个完整的客户端吗？

1403
01:35:47,380 --> 01:35:50,460
然后将其提供给输入，然后将输出规格。

1404
01:35:50,680 --> 01:35:51,760
所以这很耗时。

1405
01:35:52,240 --> 01:35:55,420
所以我认为最多有10,000个或测试

1406
01:35:55,420 --> 01:35:56,600
在以太坊测试存储库中。

1407
01:35:57,200 --> 01:35:59,880
在新的执行规范中，只有5,000个。

1408
01:36:00,900 --> 01:36:03,700
因此，这需要少得多，我们可以并行化。

1409
01:36:04,360 --> 01:36:07,720
所以我没有这个数字，但是上次我测试了它，

1410
01:36:07,720 --> 01:36:11,000
这没有那么长，也许是五分钟到10分钟，

1411
01:36:11,000 --> 01:36:13,220
或对执行幽灵的东西并行化

1412
01:36:13,220 --> 01:36:14,979
如果您的硬件肥胖。

1413
01:36:15,359 --> 01:36:16,619
否则，这将需要很长时间。

1414
01:36:17,420 --> 01:36:17,600
但是，是的。

1415
01:36:19,960 --> 01:36:20,779
好吧，非常感谢。

1416
01:36:21,000 --> 01:36:21,760
那很有趣。

1417
01:36:22,760 --> 01:36:24,859
是的，下一个问题是关于

1418
01:36:24,859 --> 01:36:28,399
您如何将错误传达给客户团队？

1419
01:36:28,920 --> 01:36:30,600
我想从你的角度有所不同

1420
01:36:30,600 --> 01:36:32,140
作为一个测试团队，

1421
01:36:32,239 --> 01:36:34,880
但您也提到我们会得到

1422
01:36:34,880 --> 01:36:36,300
对于bug赏金部分，

1423
01:36:36,460 --> 01:36:38,699
所以也许我会让你陷入困境。

1424
01:36:39,479 --> 01:36:40,720
这很重要。

1425
01:36:41,000 --> 01:36:47,880
如果我们发现某些东西

1426
01:36:47,880 --> 01:36:52,760
影响任何实时网络，这将是我们必须非常谨慎的事情

1427
01:36:53,399 --> 01:36:58,920
通常，当我们开发新叉时，例如，我们开始

1428
01:36:58,920 --> 01:37:04,359
坎昆的开始，这真的很容易，就像提交问题和某些东西一样，因为

1429
01:37:05,000 --> 01:37:10,920
那时没有坎昆的现场网络，所以这并不重要，但是近距离

1430
01:37:10,920 --> 01:37:15,819
我们可以在任何现场网络中发布坎昆，

1431
01:37:15,819 --> 01:37:18,020
我们必须变得越谨慎

1432
01:37:18,020 --> 01:37:19,980
当我们提交问题时。

1433
01:37:20,579 --> 01:37:22,680
到了我们只交流这个的地步

1434
01:37:22,680 --> 01:37:23,840
给特定的开发人员

1435
01:37:23,840 --> 01:37:27,140
我们进行特定的沟通

1436
01:37:27,140 --> 01:37:29,859
而且有特殊的处理

1437
01:37:29,859 --> 01:37:31,500
你必须照顾

1438
01:37:31,500 --> 01:37:33,119
当我们提交一些东西时

1439
01:37:33,119 --> 01:37:35,659
这可能对现场网络有害。

1440
01:37:37,140 --> 01:37:37,180
是的。

1441
01:37:40,920 --> 01:37:44,079
凉爽，凉爽，凉爽。

1442
01:37:44,079 --> 01:37:45,079
惊人的。

1443
01:37:45,079 --> 01:37:46,079
太感谢了。

1444
01:37:46,079 --> 01:37:48,079
我认为我们没有问题。

1445
01:37:48,079 --> 01:37:52,480
如果没有，请随时问。

1446
01:37:52,480 --> 01:37:53,800
我们随着时间的流逝。

1447
01:37:53,800 --> 01:37:55,140
我们应该把它结合起来。

1448
01:37:55,140 --> 01:37:58,159
实际上，我还有更多幻灯片。

1449
01:37:58,159 --> 01:38:00,800
我可以飞过它们。

1450
01:38:00,800 --> 01:38:02,420
感到自由。

1451
01:38:02,420 --> 01:38:05,460
我们都很高兴追随。

1452
01:38:05,460 --> 01:38:06,460
每个人都很兴奋。

1453
01:38:06,460 --> 01:38:08,119
因此，请随时使用我们的时间。

1454
01:38:08,119 --> 01:38:09,480
请注意自己的时间。

1455
01:38:09,479 --> 01:38:12,500
但是，我确定您可以接受多少。

1456
01:38:12,500 --> 01:38:13,219
没问题。

1457
01:38:13,219 --> 01:38:15,019
不，让我们继续前进。

1458
01:38:15,439 --> 01:38:17,659
我将飞过幻灯片。

1459
01:38:19,879 --> 01:38:23,939
是的，在我以前解释过的其他一切之后，

1460
01:38:24,159 --> 01:38:29,199
我们还有另一种使用测试方法可以使用

1461
01:38:29,399 --> 01:38:31,859
这是实时测试网。

1462
01:38:32,139 --> 01:38:34,599
我们有Devnets，Shadowrub叉，

1463
01:38:34,639 --> 01:38:37,139
和所有发生的公共Devnets

1464
01:38:37,140 --> 01:38:40,579
在主网发布之前。

1465
01:38:41,660 --> 01:38:44,400
因此，对于坎昆来说，主网将在三天内出现。

1466
01:38:44,480 --> 01:38:45,940
因此，所有这些已经过去了。

1467
01:38:46,420 --> 01:38:50,520
我们有许多这些不同的测试网络的迭代。

1468
01:38:51,039 --> 01:38:52,200
第一个是Devnet。

1469
01:38:52,579 --> 01:38:56,860
就像是，我们经营着一条小链

1470
01:38:56,860 --> 01:38:59,480
有了客户的所有组合，

1471
01:39:00,020 --> 01:39:03,800
但这是一个非常有限的客户。

1472
01:39:03,800 --> 01:39:06,920
因此，我们每个链节点很少。

1473
01:39:07,140 --> 01:39:16,060
这样做的目的是测试新的概念证明。

1474
01:39:16,800 --> 01:39:19,240
例如，在斑点的一开始，

1475
01:39:19,360 --> 01:39:21,360
我认为这差不多两年前

1476
01:39:22,200 --> 01:39:23,860
DEVNets是第一个方法。

1477
01:39:24,160 --> 01:39:27,060
您实施最低限度，

1478
01:39:27,700 --> 01:39:30,180
每个客户的概念证明的功能，

1479
01:39:30,280 --> 01:39:32,400
然后，您启动了一个DEVNET。

1480
01:39:32,980 --> 01:39:35,880
然后您将东西发送到链条

1481
01:39:35,880 --> 01:39:38,840
并查看其行为方式，并验证其行为。

1482
01:39:39,539 --> 01:39:42,119
显然，这就是

1483
01:39:42,260 --> 01:39:45,119
当软件还没有准备好生产时。

1484
01:39:45,440 --> 01:39:47,319
所以这些都是非常短暂的

1485
01:39:47,319 --> 01:39:51,619
通常他们会掉下来，然后退出同步

1486
01:39:51,619 --> 01:39:53,180
发生了很多坏事，

1487
01:39:53,380 --> 01:39:55,119
但这就是他们的目的。

1488
01:39:56,020 --> 01:39:58,199
我们使用的另一件事是Shadowforks。

1489
01:39:58,199 --> 01:39:59,840
这是一个非常聪明的实施

1490
01:39:59,840 --> 01:40:02,020
Devops团队提出了。

1491
01:40:02,020 --> 01:40:06,320
基本上，您有一个Mainnet的克隆，

1492
01:40:06,820 --> 01:40:09,300
但是在有限的节点上，

1493
01:40:09,480 --> 01:40:13,080
您可以配置它们以尽早激活即将到来的叉子。

1494
01:40:13,680 --> 01:40:14,900
因此，例如，在坎昆的情况下

1495
01:40:15,240 --> 01:40:17,040
我们同步一切，

1496
01:40:17,760 --> 01:40:21,120
但是这个阴影开始发生

1497
01:40:21,120 --> 01:40:24,700
我认为去年6月初。

1498
01:40:24,840 --> 01:40:27,120
所以我们正在经营的客户

1499
01:40:27,120 --> 01:40:31,020
被配置为2023年6月20日。

1500
01:40:31,020 --> 01:40:33,340
继续坎昆。

1501
01:40:33,640 --> 01:40:35,260
然后你同步

1502
01:40:35,260 --> 01:40:36,640
然后您等待叉子发生。

1503
01:40:37,080 --> 01:40:37,880
您验证事情。

1504
01:40:38,300 --> 01:40:40,300
而这真是太好了

1505
01:40:40,300 --> 01:40:43,180
是你仍然可以交流

1506
01:40:43,180 --> 01:40:45,300
到现有节点。

1507
01:40:45,300 --> 01:40:46,660
这样你就可以得到交易

1508
01:40:46,660 --> 01:40:47,740
来自实时网络。

1509
01:40:47,900 --> 01:40:49,500
因此，当您进行测试时

1510
01:40:49,500 --> 01:40:50,400
您的新功能，

1511
01:40:50,680 --> 01:40:52,720
您仍在获得一些信息，

1512
01:40:52,880 --> 01:40:53,440
一些交易

1513
01:40:53,440 --> 01:40:55,660
来自实际活动

1514
01:40:55,660 --> 01:40:56,400
在主网中。

1515
01:40:57,940 --> 01:40:59,200
这是一种非常好的测试方式

1516
01:40:59,200 --> 01:41:00,400
主要带有斑点。

1517
01:41:00,399 --> 01:41:01,699
这被很多使用了。

1518
01:41:02,619 --> 01:41:04,259
最后，公共测试网，

1519
01:41:04,559 --> 01:41:08,479
已经被贬低了。

1520
01:41:09,199 --> 01:41:11,219
我们有西波利和霍尔斯基。

1521
01:41:11,599 --> 01:41:16,079
他们都有不同的目的。

1522
01:41:17,279 --> 01:41:21,699
是的，大多数情况下是为了使应用程序

1523
01:41:21,859 --> 01:41:24,899
让他们能够测试他们的实现

1524
01:41:24,899 --> 01:41:29,819
关于叉子的新功能。

1525
01:41:30,399 --> 01:41:35,839
是的，我将通过以太坊安全迅速前进。

1526
01:41:37,039 --> 01:41:42,960
以太坊基金会有一个以太坊安全组织。

1527
01:41:43,139 --> 01:41:46,099
他们非常致力于所有这些特定问题。

1528
01:41:47,500 --> 01:41:48,439
主要是他们测试。

1529
01:41:48,859 --> 01:41:52,639
他们还执行测试，例如

1530
01:41:52,960 --> 01:41:55,099
这些攻击和所有这些东西的分析，

1531
01:41:55,319 --> 01:41:58,079
那个复杂的东西成为安全问题。

1532
01:41:58,079 --> 01:42:03,079
他们是最适合回应的人

1533
01:42:03,359 --> 01:42:05,979
关于安全性的大多数问题。

1534
01:42:05,979 --> 01:42:08,340
但是我要仔细研究一下。

1535
01:42:10,579 --> 01:42:13,640
可能出错的主要事情

1536
01:42:13,640 --> 01:42:15,260
例如，在包含层侧

1537
01:42:15,260 --> 01:42:20,260
当客户确实这样做时，会使一个块无效

1538
01:42:22,220 --> 01:42:26,439
这完全符合以太坊规范，

1539
01:42:26,439 --> 01:42:29,079
这意味着我有正确的障碍，

1540
01:42:29,319 --> 01:42:30,879
然后是我的客户，出于某种原因，

1541
01:42:31,059 --> 01:42:32,399
认为这是不正确的，

1542
01:42:32,579 --> 01:42:33,799
然后它只是拒绝它。

1543
01:42:34,199 --> 01:42:37,079
这意味着所有运行该客户的人，

1544
01:42:37,199 --> 01:42:37,719
那个特定的客户，

1545
01:42:37,779 --> 01:42:39,819
将与网络不同步

1546
01:42:39,819 --> 01:42:41,239
并进入叉子。

1547
01:42:42,899 --> 01:42:44,059
有很多变量，

1548
01:42:44,539 --> 01:42:45,979
很多事情会发生

1549
01:42:45,979 --> 01:42:49,899
取决于分布的重量

1550
01:42:49,899 --> 01:42:53,319
关于有多少人经营那个实际客户。

1551
01:42:54,319 --> 01:42:55,819
我不会详细介绍，

1552
01:42:55,819 --> 01:42:58,719
但这是可能的事情之一。

1553
01:43:00,059 --> 01:43:01,799
另外，发生的另一件事，

1554
01:43:02,019 --> 01:43:03,799
所以你有有效的

1555
01:43:04,139 --> 01:43:05,840
老实说，这有点糟糕。

1556
01:43:06,460 --> 01:43:09,139
这是您的客户收到积压的时候

1557
01:43:09,139 --> 01:43:10,099
那是无效的，

1558
01:43:10,659 --> 01:43:12,639
您将其传递给有效。

1559
01:43:12,779 --> 01:43:16,039
这更糟，因为您正在验证某些东西

1560
01:43:16,039 --> 01:43:17,380
这是出于规格，

1561
01:43:17,539 --> 01:43:18,340
这很冒险。

1562
01:43:19,359 --> 01:43:22,519
这是我们特别注意的

1563
01:43:22,519 --> 01:43:24,179
当我们设计测试时

1564
01:43:24,180 --> 01:43:26,460
在测试存储库中。

1565
01:43:27,420 --> 01:43:30,020
另外，另一个例子是拒绝服务

1566
01:43:30,020 --> 01:43:31,520
在块执行期间。

1567
01:43:32,200 --> 01:43:34,400
如果客户只是进行交易或块

1568
01:43:34,400 --> 01:43:36,860
而且执行需要很多时间，

1569
01:43:37,240 --> 01:43:39,579
这也可以被视为拒绝服务。

1570
01:43:40,600 --> 01:43:43,600
这是我们可能存在的另一个可能的安全问题。

1571
01:43:44,740 --> 01:43:46,079
在共识层侧，

1572
01:43:46,600 --> 01:43:51,880
不同的是，取决于故障节点

1573
01:43:51,880 --> 01:43:53,820
例如，你有

1574
01:43:53,819 --> 01:43:58,659
您有不到行为的客户不到32％

1575
01:43:58,659 --> 01:44:00,579
然后他们不关注

1576
01:44:00,579 --> 01:44:03,539
定理共识规范出于任何原因。

1577
01:44:05,639 --> 01:44:10,739
少于32％的情况最少。

1578
01:44:11,179 --> 01:44:12,739
所以你可能会错过老虎机

1579
01:44:12,739 --> 01:44:16,299
您的连锁店会错过一些车站。

1580
01:44:16,699 --> 01:44:20,219
您会看到一些打ic，但是什么都不会发生。

1581
01:44:20,599 --> 01:44:21,859
链条仍将最终确定。

1582
01:44:21,859 --> 01:44:24,139
因此，一切都好像什么都没发生。

1583
01:44:25,019 --> 01:44:28,439
如果您有33％或以上的大多数百分比，

1584
01:44:29,199 --> 01:44:31,439
如果客户失败，您可能会导致

1585
01:44:31,679 --> 01:44:33,059
您可能会导致延迟最终性。

1586
01:44:33,279 --> 01:44:35,039
所以发生的是链，

1587
01:44:35,039 --> 01:44:38,960
如果有分裂和33％的客户

1588
01:44:38,960 --> 01:44:39,880
穿过这条路线，

1589
01:44:40,399 --> 01:44:43,460
这意味着主链不会最终确定。

1590
01:44:44,420 --> 01:44:47,759
所以这很糟糕，但是非常可恢复。

1591
01:44:48,079 --> 01:44:50,539
它不如其他人那么糟糕。

1592
01:44:50,539 --> 01:44:53,560
50％或以上，您可以破坏叉子选择

1593
01:44:53,560 --> 01:44:56,720
这意味着您有50％的节点

1594
01:44:56,720 --> 01:45:01,100
那么您将破坏客户的行为

1595
01:45:01,100 --> 01:45:03,840
以及客户如何选择遵循哪个链

1596
01:45:03,840 --> 01:45:07,699
取决于大多数客户是什么

1597
01:45:07,699 --> 01:45:10,600
而且您拥有最后一个也是最令人关注的

1598
01:45:10,600 --> 01:45:14,600
是66％或更多的错误客户

1599
01:45:14,600 --> 01:45:18,180
这意味着您拥有较高的客户

1600
01:45:18,180 --> 01:45:19,699
由于同样的事情而失败

1601
01:45:19,699 --> 01:45:21,920
这意味着他们可以最终确定链条。

1602
01:45:21,920 --> 01:45:24,739
这是我们能找到的最冒险的行为

1603
01:45:24,739 --> 01:45:26,679
在与安全有关的问题中。

1604
01:45:28,079 --> 01:45:29,099
这很糟糕。

1605
01:45:30,099 --> 01:45:34,319
它可能需要某种干预。

1606
01:45:35,179 --> 01:45:38,559
目前，我认为我没有能力解释

1607
01:45:38,559 --> 01:45:40,920
在这种情况下会发生什么

1608
01:45:41,059 --> 01:45:44,380
但这是我们始终必须考虑的事情之一。

1609
01:45:45,319 --> 01:45:49,559
这就是为什么我们在任何之前进行大量测试的原因

1610
01:45:49,560 --> 01:45:56,039
即使考虑启动域名，如果你们喜欢

1611
01:45:56,039 --> 01:46:04,920
您喜欢你们喜欢安全的人，您需要寻找安全

1612
01:46:04,920 --> 01:46:09,039
软件中的担忧这是您可以发光的地方

1613
01:46:09,039 --> 01:46:13,920
赏金赏金定理黑暗，然后如果您发现，您可以得到一个不错的赏金

1614
01:46:13,920 --> 01:46:20,159
可以清楚并且确实可以破坏实时网络的东西。

1615
01:46:21,520 --> 01:46:27,279
为了获得所有公众的例子，过去发生的以前的公开披露，

1616
01:46:27,279 --> 01:46:34,399
您可以进入此存储库，其中包含具有实际记录的安全问题

1617
01:46:34,399 --> 01:46:41,039
碰巧的是，过去曾透露过的，但这可能不是因为有赏金

1618
01:46:41,039 --> 01:46:47,359
他们被私下披露。这张幻灯片的主要鼓励是

1619
01:46:47,359 --> 01:46:52,800
不要尝试，如果您发现自己认为被干扰的东西，请进入这里，您会收到赏金

1620
01:46:53,439 --> 01:47:01,600
而且您不会以任何方式损害网络。所以就像白帽

1621
01:47:01,600 --> 01:47:08,960
情况。基本上就是这样，这就是我的演讲。如有任何问题

1622
01:47:08,960 --> 01:47:13,119
这些是我的手柄，Twitter，github。

1623
01:47:13,119 --> 01:47:17,319
如果你们有兴趣测试，那就打我。

1624
01:47:17,319 --> 01:47:19,640
如果您有问题，我会回答更多问题。

1625
01:47:19,640 --> 01:47:27,000
再次非常感谢，马里奥。

1626
01:47:27,000 --> 01:47:28,239
很棒的东西。

1627
01:47:28,239 --> 01:47:35,399
是的，让我检查我们是否有一些结束问题，

1628
01:47:35,399 --> 01:47:38,720
但是我认为我们很好，伙计，因为我们大约15分钟了，

1629
01:47:38,720 --> 01:47:44,880
而且，您为我们致力了很多美好的时光

1630
01:47:44,880 --> 01:47:51,360
还必须再次查看演示文稿，以捕捉那里的所有细节，嗯，这很激烈

1631
01:47:51,360 --> 01:47:58,880
这很长，所以我真的很感谢你的时间嗯，真的很棒，是的，是的，非常感谢

1632
01:47:58,880 --> 01:48:10,319
我也学到了很多。也许如果您可以指出想要学习并开始贡献的人

1633
01:48:10,319 --> 01:48:13,600
以某种有意义的方式，您指出的一个地方是什么？

1634
01:48:15,520 --> 01:48:21,279
我们需要在您在本演示文稿中看到的任何存储库中的帮助。任何

1635
01:48:21,279 --> 01:48:24,560
最能使您的兴趣引起您的兴趣，我认为这是您可以开始的最好的地方。

1636
01:48:24,560 --> 01:48:26,520
但是，欢迎一切。

1637
01:48:27,300 --> 01:48:29,680
您也可以开始，所有存储库都有

1638
01:48:30,220 --> 01:48:35,680
通常，出版问题具有第一个好问题标签。

1639
01:48:35,900 --> 01:48:38,300
那是每个存储库中开始的地方。

1640
01:48:38,300 --> 01:48:41,520
我会确保，因为我们有执行幽灵

1641
01:48:41,520 --> 01:48:45,800
我们坚持，我将确保此后，

1642
01:48:45,940 --> 01:48:48,740
我们将尝试考虑许多第一个好的新问题

1643
01:48:48,740 --> 01:48:50,580
将它们设置在执行幽灵中

1644
01:48:50,580 --> 01:48:52,320
如果您想去那里，或者您也有

1645
01:48:52,319 --> 01:48:55,759
因此，我将确保新事物弹出。

1646
01:48:57,119 --> 01:48:57,519
惊人的。

1647
01:48:57,859 --> 01:48:58,019
是的。

1648
01:48:58,380 --> 01:48:59,599
是的，再次非常感谢。

1649
01:49:00,219 --> 01:49:04,599
像马里奥在APSG的马里奥串联一样，真是太好了。

1650
01:49:05,000 --> 01:49:06,699
所以很有趣。

1651
01:49:07,299 --> 01:49:09,619
而且我认为，是的，我们会努力工作。

1652
01:49:09,719 --> 01:49:13,619
是的，也一样，您在Discord服务器中。

1653
01:49:14,019 --> 01:49:18,920
因此，如果人们在那里打扰您，请原谅。

1654
01:49:19,099 --> 01:49:21,000
但是我想他们可能会有一些额外的问题。

1655
01:49:21,259 --> 01:49:22,139
是的，非常感谢。

1656
01:49:22,319 --> 01:49:28,059
再次。是的，非常感谢您所有一直关注的人问问题。

1657
01:49:28,380 --> 01:49:35,059
一直是一个激烈的人。所以下周我会见大家。是的。

1658
01:49:36,059 --> 01:49:36,799
Ciao。谢谢。

1659
01:49:37,679 --> 01:49:40,139
祝你有美好的一天。再次非常感谢。再见。

1660
01:50:22,319 --> 01:50:48,279
谢谢。

