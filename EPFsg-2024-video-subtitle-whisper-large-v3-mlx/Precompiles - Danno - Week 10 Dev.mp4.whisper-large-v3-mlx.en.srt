1
00:00:30,000 --> 00:00:59,980
 Thank you.

2
00:01:00,000 --> 00:01:29,980
 Thank you.

3
00:01:30,000 --> 00:01:59,000
 ¶¶

4
00:02:00,000 --> 00:02:26,439
 All right.

5
00:02:26,439 --> 00:02:30,560
 Welcome back to the Ethereum Protocol Fellowship Study Group.

6
00:02:31,079 --> 00:02:37,020
 We are here in our final week, week 10, on the development track.

7
00:02:37,979 --> 00:02:44,939
 It's been a good couple of months here learning all about Ethereum and diving into different topics here.

8
00:02:45,479 --> 00:02:50,400
 Today on our final development track talk, we'll be speaking with Dano from Basu,

9
00:02:50,699 --> 00:02:53,520
 and he'll be talking about precompile.

10
00:02:53,520 --> 00:02:55,740
 So I'll go ahead and pass it off to Mario.

11
00:02:56,200 --> 00:02:58,820
 You can give Dano a little bit more of a proper introduction,

12
00:02:59,060 --> 00:03:00,620
 and then you can take it away, Dano.

13
00:03:02,080 --> 00:03:04,280
 Hello, everyone. Welcome here, Dano.

14
00:03:04,320 --> 00:03:05,800
 Thank you so much for joining us today.

15
00:03:06,400 --> 00:03:08,060
 And yeah, it's our very last week,

16
00:03:08,300 --> 00:03:10,660
 our last talk on the development track,

17
00:03:10,920 --> 00:03:12,719
 and we have a very special guest for this

18
00:03:12,719 --> 00:03:16,740
 because Dano has been a developer for, well, decades now.

19
00:03:17,060 --> 00:03:21,160
 He's really one of the OG Java developers in the Ethereum ecosystem.

20
00:03:21,159 --> 00:03:25,079
 and while I've been doing my little research,

21
00:03:25,199 --> 00:03:27,079
 I found out that he's been working,

22
00:03:27,479 --> 00:03:29,719
 he had a whole career before starting Ethereum,

23
00:03:30,259 --> 00:03:32,319
 working in Google, in Oracle,

24
00:03:32,659 --> 00:03:37,240
 and even publishing a book on front-end in Java,

25
00:03:37,500 --> 00:03:38,500
 if I'm correct, right?

26
00:03:39,340 --> 00:03:40,939
 Yeah, you did your research.

27
00:03:42,180 --> 00:03:44,240
 Yeah, I wanted to tell you about you.

28
00:03:44,240 --> 00:03:47,120
 And yes, it's been a project since 2013

29
00:03:47,120 --> 00:03:49,120
 and then during Ethereum in 2018,

30
00:03:49,120 --> 00:03:51,659
 which doesn't seem that long ago,

31
00:03:51,759 --> 00:03:55,439
 but it's been like six years of working in the core Ethereum

32
00:03:55,439 --> 00:03:57,640
 on the Hyperledger client,

33
00:03:58,080 --> 00:04:00,680
 Bessu client, which is the Java implementation.

34
00:04:01,159 --> 00:04:05,099
 So, and today it's focused in this specialty,

35
00:04:05,700 --> 00:04:07,920
 pre-compiles their integration clients

36
00:04:07,920 --> 00:04:12,180
 and how the clients use them.

37
00:04:12,659 --> 00:04:13,460
 Yeah, very excited.

38
00:04:13,460 --> 00:04:14,960
 Thank you so much again for being here.

39
00:04:15,719 --> 00:04:17,540
 And yeah, the stage is yours.

40
00:04:17,540 --> 00:04:22,660
 feel free to share the screen and go ahead and start.

41
00:04:22,660 --> 00:04:26,020
 So yeah, we're here to talk about pre-images. Just kidding,

42
00:04:26,020 --> 00:04:29,860
 we're here to talk about pre-compiles. But it's interesting, Mario brought up

43
00:04:30,660 --> 00:04:34,900
 that I had a full career before I got involved in Ethereum. It was some of that that actually

44
00:04:34,900 --> 00:04:41,620
 brought me into blockchain. I used to be a Java desktop front-end UI developer back before the web

45
00:04:41,620 --> 00:04:46,980
 completely dominated everything. At one point, the Swing UI library was the top-used library

46
00:04:46,980 --> 00:04:52,660
 and enterprises. So one of the things that was being added late in the life of the Java desktop

47
00:04:52,660 --> 00:04:59,120
 was this toolkit called JavaFX. And they had this new revolutionary layout engine called a,

48
00:04:59,600 --> 00:05:03,300
 well it's not revolutionary to a lot of people, but to Java it was, called a scene graph where

49
00:05:03,300 --> 00:05:08,500
 you can just put components here and draw lines between them. You don't have to put stuff into

50
00:05:08,500 --> 00:05:14,540
 a grid and match anything up. You can just draw graphs. So I found a graph layout library because

51
00:05:14,540 --> 00:05:19,980
 my job used graph layouts. And I wanted to put it in JavaFX. And I wanted to play with this,

52
00:05:19,980 --> 00:05:25,840
 these fancy graph layouts. And I really needed some interesting data to get interesting real

53
00:05:25,840 --> 00:05:31,120
 world graphs from. And this is about the time Bitcoin had just hit its first thousand dollar

54
00:05:31,120 --> 00:05:36,300
 peak. And so I've been reading up on Bitcoin and the UTXOs are just very natural,

55
00:05:36,860 --> 00:05:41,860
 acyclic directed graphs with really interesting data on it. So I had this ready and I got really

56
00:05:41,860 --> 00:05:47,740
 lucky I happened to stumble across the Mt. Gox doing its big pyramid split during its bankruptcy,

57
00:05:48,180 --> 00:05:51,879
 did some YouTube videos, and that just took me right down to the deep rabbit hole

58
00:05:51,879 --> 00:05:58,540
 of doing blockchain. And I switched over to doing Ethereum full-time. I spent three years at Google

59
00:05:58,540 --> 00:06:04,040
 thinking it's a nice place. I can get blockchain out of my head. Didn't work. Didn't work one bit.

60
00:06:04,780 --> 00:06:09,240
 So when ConsenSys called me and asked me, hey, do you want to work on a Java Ethereum client? I was

61
00:06:09,240 --> 00:06:13,780
 like, oh yes, I absolutely do. So that's, you know, that's how you get in, just little things

62
00:06:13,780 --> 00:06:19,300
 get you interested. And there are so many nerd snipes in Ethereum that's just crazy. So many

63
00:06:19,300 --> 00:06:23,780
 things that are being applied and so many techniques that can be used from older systems.

64
00:06:24,460 --> 00:06:28,740
 So today, what I'm going to be talking about is pre-compiles. And that probably,

65
00:06:29,259 --> 00:06:32,939
 to a lot of people, sounds like an incredibly boring subject. You know, we're going to talk

66
00:06:32,939 --> 00:06:38,519
 about how you execute, you know, hash functions and all that other stuff. And that's not actually

67
00:06:38,519 --> 00:06:42,120
 what I'm going to talk much about. I'm going to talk about how pre-compiles, I view them

68
00:06:42,120 --> 00:06:46,419
 as EVM's escape hatch to do interesting things outside

69
00:06:46,419 --> 00:06:50,379
 of the EVM, and yet still keep things deterministic and provable within

70
00:06:50,379 --> 00:06:54,439
 a blockchain context. And we're going to look at how Mainnet does it, and we're going to look

71
00:06:54,439 --> 00:06:57,879
 at some of the ways how Layer 2s do it, and how

72
00:06:57,879 --> 00:07:02,459
 Layer 1s use it to interact with their systems. And I didn't have time to write

73
00:07:02,459 --> 00:07:06,199
 up slides for this, but there's a really rich area on how pre-compiles are going to be used

74
00:07:06,199 --> 00:07:09,039
 for more exotic things like fully homomorphic encryption

75
00:07:09,039 --> 00:07:12,839
 and AI large language model integrations.

76
00:07:14,560 --> 00:07:17,399
 So let me get to my screen.

77
00:07:19,079 --> 00:07:20,360
 So here's a brief agenda.

78
00:07:20,420 --> 00:07:22,319
 Like I said, this is not a cryptography presentation.

79
00:07:22,539 --> 00:07:23,560
 I am not a cryptographer.

80
00:07:24,219 --> 00:07:26,480
 I know what these cryptographic algorithms do.

81
00:07:26,620 --> 00:07:28,240
 I know as a developer how I would use them,

82
00:07:28,620 --> 00:07:32,159
 but I have no idea how Galois field is generated

83
00:07:32,159 --> 00:07:34,639
 and how to prove that ZK systems

84
00:07:34,639 --> 00:07:35,879
 actually do what they claim to do.

85
00:07:36,199 --> 00:07:48,839
 But I know how to use them. And that's really as a developer in Ethereum and any cryptocurrency in any crypto spaces, it's going to be almost impossible to know literally how literally everything works.

86
00:07:49,199 --> 00:07:58,500
 But what you really need to know is what it does, why it does it, and who the experts are to talk to if you're going to try to do something exotic.

87
00:07:59,740 --> 00:08:02,899
 So we're going to talk first about what pre-compiles are and the main examples.

88
00:08:02,899 --> 00:08:07,419
 tables. We're going to dive into how they work. Then we're going to talk about use outside

89
00:08:07,419 --> 00:08:11,239
 of Ethereum main net. Finally, I'm going to wrap up with a few future developments of

90
00:08:11,239 --> 00:08:14,659
 what's actually coming in main net and L2s. So, we'll go there.

91
00:08:14,659 --> 00:08:20,159
 So, when I talk about precompiles, though, I'm really talking about three different kinds

92
00:08:20,159 --> 00:08:25,659
 of contracts. Precompiles are what started the whole precompile thing. There are tasks

93
00:08:25,659 --> 00:08:31,000
 you could do in EVM, but they're too expensive and too slow to do in EVM. Massive amounts

94
00:08:31,000 --> 00:08:34,940
 of bit twiddling, like the Kachak hash that requires a lot of bit twiddling. You could do

95
00:08:34,940 --> 00:08:40,559
 that in the EVM. It's going to cost you, I don't know, millions of gas to do. And there are much

96
00:08:40,559 --> 00:08:45,279
 more efficient and much more optimized implementations of Kachak that use fancy compiler,

97
00:08:46,639 --> 00:08:52,799
 fancy processor instructions like SSE and whatever the current iteration of SSE is on the Intel chips

98
00:08:52,799 --> 00:08:58,879
 and whatever the equivalents on the ARM chips are. They can do Kachak hashing just really,

99
00:08:58,879 --> 00:09:04,100
 really fast. So that's why they exist. So we can take stuff that has a well-known input A,

100
00:09:04,159 --> 00:09:08,679
 gives input DB, and do it very efficiently and very fast. Now it's interesting I mentioned

101
00:09:08,679 --> 00:09:13,340
 Kachak. There is no Kachak precompile. Kachak is the one example of a cryptographic primitive

102
00:09:13,340 --> 00:09:19,759
 that has an opcode. It's in a 20 block, the hex 20 block, and it's probably going to be the only

103
00:09:19,759 --> 00:09:24,600
 thing in the hex 20 block. I foresee all future crypto things coming in through precompiles

104
00:09:24,600 --> 00:09:26,460
 because they're just generally too expensive for opcodes.

105
00:09:27,759 --> 00:09:30,580
 The second kind of a precompile is a system contract.

106
00:09:31,040 --> 00:09:32,700
 We don't see this in Ethereum mainnet.

107
00:09:33,080 --> 00:09:34,500
 We see this mostly in layer twos,

108
00:09:34,740 --> 00:09:37,440
 and we see this in alt VMs, alt layer ones.

109
00:09:38,220 --> 00:09:40,420
 These are the kinds of system contracts

110
00:09:40,420 --> 00:09:42,420
 that take something in EVM

111
00:09:42,420 --> 00:09:43,639
 and they do something in a different layer

112
00:09:43,639 --> 00:09:45,460
 or in a foreign system in the blockchain

113
00:09:45,460 --> 00:09:47,220
 that aren't exactly EVM,

114
00:09:47,519 --> 00:09:48,680
 and they come back and do stuff.

115
00:09:49,240 --> 00:09:51,360
 So you wouldn't want to worry about

116
00:09:51,360 --> 00:09:53,080
 connecting with your disk storage.

117
00:09:54,000 --> 00:10:03,160
 You have, you know, you have your regular contract storage, but there's things you might need to store network communications with L2 that you would farm out to the L2 node software to run.

118
00:10:03,480 --> 00:10:06,360
 And those are done through what I call system contracts because they break layers.

119
00:10:06,360 --> 00:10:13,340
 And that's what distinguishes a pre-compile from a system contract is that they escape the sandbox and do things the EVM should not do.

120
00:10:14,200 --> 00:10:18,320
 And finally, there's kind of something in between these called pre-deployed contracts.

121
00:10:18,320 --> 00:10:25,920
 um pre-deployed contracts use techniques to break layers but at the core they're really just um evm

122
00:10:25,920 --> 00:10:31,520
 code that is pre-deployed to genesis or might come in as part of a fork and they're put at specific

123
00:10:31,520 --> 00:10:37,400
 addresses and the addresses they exist at um might be you know special in name it's not something you

124
00:10:37,400 --> 00:10:41,740
 could cryptographically deploy to sometimes they are but these pre-deployed contracts they just

125
00:10:41,740 --> 00:10:47,960
 show up and they're used and um they come as part of the genesis file or as part of a hard fork and

126
00:10:47,960 --> 00:10:51,080
 And there's even like a fourth miner case where you just deploy a contract and rely

127
00:10:51,080 --> 00:10:56,480
 on some of these techniques, but we'll get to that later in the presentation.

128
00:10:56,480 --> 00:11:05,500
 So as of Cancun today, here are the nine pre-compiles that exist on Ethereum mainnet.

129
00:11:05,500 --> 00:11:07,120
 And they exist at the low numbers.

130
00:11:07,120 --> 00:11:10,379
 I list these as 0x01.

131
00:11:10,379 --> 00:11:15,280
 Really it's 0x3100s and then 01.

132
00:11:15,279 --> 00:11:18,519
 So if you call these in the address, there will be a lot of zeros in it.

133
00:11:18,519 --> 00:11:23,459
 And it's kind of convenient when you're doing EVM calls, because you can just push one to

134
00:11:23,459 --> 00:11:27,659
 bring it in, rather than doing a push 20 with a lot of zeros to bring in the address.

135
00:11:27,659 --> 00:11:31,500
 So it makes it fairly efficient to call these.

136
00:11:31,500 --> 00:11:35,659
 So the first four were brought in at Genesis.

137
00:11:35,659 --> 00:11:40,100
 The next one of them was brought in by, four of them are brought in Byzantium.

138
00:11:40,100 --> 00:11:44,879
 One of them was brought in Istanbul, and one of them was brought in Cancun.

139
00:11:44,879 --> 00:11:50,320
 The performance brought into Genesis were really essential to the foundations of Ethereum to make it work.

140
00:11:50,759 --> 00:11:52,439
 The first one is called EC-RECOVER.

141
00:11:53,240 --> 00:11:59,100
 And what it does is it takes a hash, a commitment, makes a hash commitment out of it if it's too large.

142
00:11:59,500 --> 00:12:00,919
 No, it just takes a 32-byte commit.

143
00:12:01,019 --> 00:12:01,840
 You have to hash it yourself.

144
00:12:02,759 --> 00:12:03,799
 So it takes a message.

145
00:12:04,759 --> 00:12:10,139
 It performs the SECP-256-K1 signature recovery on it if it was a signature.

146
00:12:10,379 --> 00:12:11,700
 Yeah, it's just recovery.

147
00:12:12,159 --> 00:12:14,779
 So you need the commitment, and you need the signature piece.

148
00:12:14,879 --> 00:12:19,039
 it's a way to take commitments and create Ethereum addresses out of it.

149
00:12:19,039 --> 00:12:22,159
 Because it does an extra step, which is it chops off the top 12 bytes,

150
00:12:22,159 --> 00:12:25,279
 it only gives you the lower 20 bytes for an Ethereum address.

151
00:12:25,279 --> 00:12:33,679
 Precompile number two, it's SHA-2-256, it's the precursor to Kachak.

152
00:12:33,679 --> 00:12:39,519
 And it's a hash, you go over large amounts of data, and you compress it,

153
00:12:39,519 --> 00:12:41,919
 and you get the same amount of data.

154
00:12:41,919 --> 00:12:47,659
 data, and you compress it, and you get the hash out of it. So that's one hash algorithm that is

155
00:12:47,659 --> 00:12:54,679
 used in Ethereum. RIPMD160 is a hash algorithm, not used in Ethereum, but it is used in Bitcoin.

156
00:12:55,120 --> 00:12:59,659
 It's used in Ethereum, and it exists as a pre-compile. But RIPMD is used in some instances

157
00:12:59,659 --> 00:13:04,259
 of Bitcoin, and so it's put there in compatibility in case we needed to verify Bitcoin signatures.

158
00:13:05,459 --> 00:13:10,480
 Not terribly used a lot, although it's not zero. It's one of the least used ones out there.

159
00:13:10,480 --> 00:13:13,279
 I think it's the second least used pre-compile on mainnet.

160
00:13:13,720 --> 00:13:15,200
 And the fourth one is identity.

161
00:13:15,740 --> 00:13:20,259
 This is also one that is ripe for removal because there's more efficient ways to do it.

162
00:13:20,379 --> 00:13:22,820
 Identity, all it does is it just copies the input to the output.

163
00:13:24,159 --> 00:13:28,480
 So it was one way that you could copy memory into different parts of memory.

164
00:13:29,080 --> 00:13:32,060
 We now have mCopyOp code, which does this really efficiently.

165
00:13:32,820 --> 00:13:35,320
 So the identity is not truly needed anymore.

166
00:13:35,320 --> 00:13:42,120
 So as Ethereum grew, I figured out we needed more and more cryptographic primitives.

167
00:13:43,560 --> 00:13:50,520
 05 is mod exp, modular exponentiation. This is a function that I think is used in a lot of

168
00:13:50,520 --> 00:13:58,600
 RSA signatures, but it's also used as a primitive in a lot of other cryptographic systems. And it

169
00:13:58,600 --> 00:14:03,000
 does what it does, it does modular exponentiation. You take a number, you take it to a certain

170
00:14:03,000 --> 00:14:07,720
 exponent and you take a modulus but these are like really large numbers they're not stuff that you

171
00:14:07,720 --> 00:14:16,919
 would do by hand um we're talking 256-bit 1024-bit solutions um the next three is a group of related

172
00:14:16,919 --> 00:14:24,440
 um pre-compiles um and these are used for um not the standard form of bls it's used but it is a

173
00:14:24,440 --> 00:14:30,840
 lesser weaker form of bls can be used for these um these are um addition multiplication and pairing

174
00:14:30,840 --> 00:14:38,160
 of a curve it's called alt bn 128 I've heard it's also called bn 254 there's lots of names of it

175
00:14:38,160 --> 00:14:46,120
 but it's a it's a 256 version bit version of some of the primitives used in bls and so a lot of

176
00:14:46,120 --> 00:14:51,019
 people will use this for aggregated signatures and there's some really involved not too involved

177
00:14:51,019 --> 00:14:55,280
 but there's a processes where you can take the various signatures put them together and you can

178
00:14:55,280 --> 00:15:00,480
 get one small signature out of it and you can verify that and I'm not really up on a lot of

179
00:15:00,480 --> 00:15:04,980
 the math on that. Like I said, not a cryptography talk, but those are the three primitives that you

180
00:15:04,980 --> 00:15:17,940
 would need to do such BLS in 256 bits. The BLS signatures used in the consensus layer do not

181
00:15:17,940 --> 00:15:27,240
 use this. They use a different curve, BLS 12384 or something, but they are not this. There's a

182
00:15:27,240 --> 00:15:31,919
 proposal to bring them in in Prague, and I think I'll cover it. I may have that on another slide,

183
00:15:32,039 --> 00:15:39,980
 but I'll cover it there. So this was in Byzantium. This was back in 2018. The next precompile that

184
00:15:39,980 --> 00:15:47,779
 was added in 2020 was the Blake2bf function, and this is one I think is the least used precompile

185
00:15:47,779 --> 00:15:53,299
 out there, and the hope was that this would be used for things like zkcache and other zk systems

186
00:15:53,299 --> 00:15:55,879
 because it used the Blake compression algorithm,

187
00:15:56,039 --> 00:15:58,099
 and it was thought that just the F function will be sufficient.

188
00:15:58,919 --> 00:16:04,379
 And this is an example of, I would argue this is a process fail,

189
00:16:04,799 --> 00:16:08,259
 but it's hard to say this was a necessary fail for us to learn from it.

190
00:16:08,939 --> 00:16:10,579
 There was some interest to get it in.

191
00:16:10,859 --> 00:16:13,019
 A champion came in and really pushed it forward,

192
00:16:13,719 --> 00:16:16,000
 but there wasn't really any live demand for it,

193
00:16:16,120 --> 00:16:17,399
 and demand never really developed

194
00:16:17,399 --> 00:16:19,559
 because it didn't quite have all of the pieces in there

195
00:16:19,559 --> 00:16:25,339
 because it wasn't quite ready to verify some of the zcache stuff out there.

196
00:16:26,839 --> 00:16:30,979
 So it's unfortunately, if we just did the Blake2 hash algorithm,

197
00:16:31,059 --> 00:16:33,259
 we'd be in a much better place than if we just had the f function.

198
00:16:33,779 --> 00:16:35,839
 But there was reasons why they thought we just needed the f function

199
00:16:35,839 --> 00:16:36,919
 and we could compile it together.

200
00:16:38,019 --> 00:16:41,000
 So kind of an unfortunate story.

201
00:16:42,119 --> 00:16:46,379
 And the last one was added just a couple of months ago.

202
00:16:46,459 --> 00:16:48,619
 I think it's been a couple of months that we've had the cancun fork.

203
00:16:48,620 --> 00:16:57,000
 and that is the kzd points evaluation and this is where it it's got some zk implications in it's

204
00:16:57,000 --> 00:17:02,519
 got some vector commitment implications it's it's really it's an essential one but unless you're

205
00:17:02,519 --> 00:17:09,059
 using blobs it's really hard to explain really what it does but the short answer is it's used

206
00:17:09,059 --> 00:17:14,940
 in blob proving that you have a certain field element in a blob that may or may not exist

207
00:17:14,940 --> 00:17:18,240
 it goes entirely into the 4844.

208
00:17:18,240 --> 00:17:21,700
 There's probably different presentation of 4844 that goes more deeper into it.

209
00:17:21,700 --> 00:17:26,500
 But as far as its role as a precompile, I think it shows an excellent example

210
00:17:26,500 --> 00:17:31,519
 of a precompile that does very specialized computation that is very inefficient in

211
00:17:31,519 --> 00:17:36,140
 EVM, but very well understood and well implemented in an extra library.

212
00:17:37,700 --> 00:17:39,759
 If you want summaries of these, there is a website,

213
00:17:39,759 --> 00:17:44,559
 EVM Codes, in a precompile's page that gives a lot of the summary

214
00:17:44,940 --> 00:17:49,660
 of all of these current pre-compiles do they have a prog page yet they don't have a product

215
00:17:49,660 --> 00:17:55,100
 page yet so i can't show you the um the proposed ones coming afterwards um but this has you know

216
00:17:55,100 --> 00:18:02,460
 all of the details into a lot of the various features that go into it um so let's go back to

217
00:18:04,860 --> 00:18:07,500
 uh k view two bar

218
00:18:07,500 --> 00:18:18,700
 So, when the EVM implements a pre-compile it's pretty simple.

219
00:18:21,339 --> 00:18:25,500
 The pre-compile just looks like any other contract it looks exactly like you're calling anything

220
00:18:25,500 --> 00:18:30,299
 else and this is actually part of the subtle design genius of a pre-compile it looks like

221
00:18:30,299 --> 00:18:34,140
 you're calling another EVM contract but what happens you don't know you don't care about

222
00:18:34,140 --> 00:18:38,700
 you put the data in you get the data back it could be native it could be evm it just magically works

223
00:18:39,980 --> 00:18:46,540
 um and another essential feature of pre-compiles is that the gas cost is calculated entirely upon

224
00:18:46,540 --> 00:18:52,060
 the input data not on the actual executed gas which presents some challenges um if you pick

225
00:18:52,060 --> 00:18:56,380
 a particularly bad implementation of the pre-compile it's less efficient you can

226
00:18:56,380 --> 00:19:01,660
 slow down your vm but all the class costing is based entirely off of what it sees in the input

227
00:19:01,660 --> 00:19:05,920
 it. And the return data is put in the return buffer or to output memory, depending upon how

228
00:19:05,920 --> 00:19:12,259
 you do the specific call. And it looks just exactly like any other contract call you would

229
00:19:12,259 --> 00:19:17,200
 have out there. A couple of things, though, is that currently none of the proposed pre-compiles

230
00:19:17,200 --> 00:19:24,680
 do deeper calls. They don't spawn further EVM calls. That's when Design Space has been explored

231
00:19:24,680 --> 00:19:30,140
 and rejected for, I think, 3074 initially started as pre-compiles, and they rejected that and went

232
00:19:30,140 --> 00:19:32,520
 it's Opcos, because that just felt a little weird.

233
00:19:32,520 --> 00:19:34,300
 So typically, pre-compiled contracts

234
00:19:34,300 --> 00:19:36,900
 will just do stuff within themselves

235
00:19:36,900 --> 00:19:39,259
 and play on their own sandbox and return.

236
00:19:39,259 --> 00:19:40,640
 It's not often that they're gonna interact

237
00:19:40,640 --> 00:19:43,520
 with the existing EVM environment,

238
00:19:43,520 --> 00:19:45,960
 and that presents security risks specifically.

239
00:19:48,160 --> 00:19:50,320
 So, how are?

240
00:19:51,700 --> 00:19:54,560
 So here's a deep example of what the ECE

241
00:19:54,560 --> 00:19:56,680
 recovered pre-compile looks like.

242
00:19:56,680 --> 00:19:59,040
 So the input is specified it's fixed to be,

243
00:20:00,140 --> 00:20:06,700
 128 bytes. And you got the commit hash, you got the V value, the R value, and the S value. And

244
00:20:06,700 --> 00:20:12,440
 if you know a bit about EC-DSA, these will make a lot of sense to you. The commit hash is it,

245
00:20:13,200 --> 00:20:19,000
 EC-RECOVER only actually encrypts small amounts of data. So you would hash it down and encrypt

246
00:20:19,000 --> 00:20:25,060
 that data. The V is actually something called a recovery ID, and it's encoded in 27 and 28 for

247
00:20:25,059 --> 00:20:32,919
 historical reasons. But when you reverse, when you verify a signature, you get one of four values.

248
00:20:33,039 --> 00:20:37,460
 You get a value at negative infinity, at positive infinity, and then you get two different ones

249
00:20:37,460 --> 00:20:44,419
 at various points on the curve. This recover ID tells us which one to use to recover for the

250
00:20:44,419 --> 00:20:50,119
 address. And when you have your private key and you sign it, it'll wind up in one of those two,

251
00:20:50,159 --> 00:20:53,440
 and you don't really know which one it's going to be until you do the signature. So that's why

252
00:20:53,440 --> 00:20:58,880
 bring that with it so the recovery id comes with the signature and we can verify it in one go other

253
00:20:58,880 --> 00:21:02,720
 systems just say we'll just try all of them and if one of them matches you're good but that's

254
00:21:02,720 --> 00:21:08,799
 incredibly inefficient um and then the r value which is the value that you're encoding and the

255
00:21:08,799 --> 00:21:14,480
 s value is some secret it's through the calculated values one part's calculated one part secret you

256
00:21:14,480 --> 00:21:19,600
 get one of these values reuse them you can ruin your key um the short answer is use a library

257
00:21:19,599 --> 00:21:24,639
 to extract and use these um or get someone who is an expert on this to verify the code you write

258
00:21:26,159 --> 00:21:32,879
 the return of course is just the lower 220 bytes of the 256 public key hash so it extracts the

259
00:21:32,879 --> 00:21:39,119
 address and then it can check hashes it i think and then returns the lower 20 bytes of the hash

260
00:21:39,119 --> 00:21:46,639
 of the hash so then it's it's not a true um ecdsa key recovery it does it in a very ethereum centric

261
00:21:46,640 --> 00:21:47,980
 in Ethereum-focused way.

262
00:21:48,100 --> 00:21:49,280
 And it serves Ethereum well,

263
00:21:49,320 --> 00:21:51,540
 because this is really focused on,

264
00:21:51,759 --> 00:21:53,100
 did your address sign this value?

265
00:21:53,580 --> 00:21:54,940
 So it really serves its purpose well.

266
00:21:56,220 --> 00:21:57,980
 The gas cost for this is $3,000,

267
00:21:57,980 --> 00:21:58,920
 no matter what you do.

268
00:21:59,020 --> 00:22:00,020
 So it's a fixed increase.

269
00:22:00,600 --> 00:22:03,660
 But if we looked at some of the other contracts,

270
00:22:04,400 --> 00:22:06,120
 we can see some of them have variable datas.

271
00:22:07,300 --> 00:22:09,840
 For example, ModXP is the most complex one.

272
00:22:09,920 --> 00:22:12,020
 In fact, it's been revised by another EVM.

273
00:22:13,000 --> 00:22:15,480
 But some of the more simple ones are like EC pairing.

274
00:22:16,220 --> 00:22:17,180
 How many pairs?

275
00:22:17,299 --> 00:22:18,720
 Okay, you take this and you multiply it.

276
00:22:18,779 --> 00:22:19,640
 That's what your cost is.

277
00:22:20,420 --> 00:22:23,620
 Blake 2F, how much data are you hashing?

278
00:22:24,039 --> 00:22:25,380
 That's how much we're going to charge you.

279
00:22:27,240 --> 00:22:32,279
 And actually, Blake 2F is a bad example because you, again, do small amounts.

280
00:22:32,420 --> 00:22:33,860
 Shot 256 is a better example.

281
00:22:34,279 --> 00:22:35,819
 How much data are you hashing?

282
00:22:36,180 --> 00:22:37,420
 And that's what we're going to charge you.

283
00:22:38,960 --> 00:22:41,539
 Everything else here tends to have a fixed input size.

284
00:22:41,539 --> 00:22:45,399
 and that gets into some of the design considerations.

285
00:22:50,019 --> 00:22:51,659
 So that gets into some design issues

286
00:22:51,659 --> 00:22:53,259
 of when you're designing a pre-compile

287
00:22:53,259 --> 00:22:54,139
 and these are some of the things

288
00:22:54,139 --> 00:22:56,379
 that have presented problems to clients before

289
00:22:56,379 --> 00:22:59,079
 and to have delayed pre-compiles from being implemented.

290
00:22:59,839 --> 00:23:00,899
 The first thing you need to do

291
00:23:00,899 --> 00:23:02,460
 if you're going to propose a pre-compile

292
00:23:02,460 --> 00:23:03,099
 is you need to make sure

293
00:23:03,099 --> 00:23:04,619
 all boundary conditions are specified.

294
00:23:06,279 --> 00:23:07,159
 People are going to come,

295
00:23:07,200 --> 00:23:08,079
 it's not just the testers

296
00:23:08,079 --> 00:23:09,460
 that are going to come in and try and break this.

297
00:23:09,639 --> 00:23:11,059
 Everyone's going to come in and try and break this.

298
00:23:11,539 --> 00:23:18,639
 Because there's, you know, attack strategies that involve in forking networks and causing problems in different forks.

299
00:23:19,559 --> 00:23:24,639
 Some of this is data, so it's mostly a proof of stake, a proof of work primary attack.

300
00:23:24,920 --> 00:23:33,099
 But even a proof of stake, it causes, you know, causing the different clients to diverge on their system is pretty bad.

301
00:23:33,200 --> 00:23:36,980
 So you need to make sure all boundary conditions are specified and they have a very specific way that they're going to be handled.

302
00:23:36,980 --> 00:23:43,200
 A second concern is that when you charge gas, you should make sure all gas scales with effort.

303
00:23:44,019 --> 00:23:52,700
 Examples of this would be like the SHA-256, the MADI-XP, and the pairing checks.

304
00:23:53,660 --> 00:23:59,200
 The more difficult it is to get an answer, you should charge more gas for that.

305
00:23:59,980 --> 00:24:01,440
 One of those is execution.

306
00:24:01,799 --> 00:24:03,279
 Algorithms can hide some of these problems.

307
00:24:03,279 --> 00:24:08,079
 uh moddxp um has been you know there's been solutions we found to make sure everyone is

308
00:24:08,079 --> 00:24:11,759
 under the current curve but there are some assumptions it's like well why would you

309
00:24:11,759 --> 00:24:17,180
 ever want to do an even modulus that's kind of a dumb thing so all cryptography uses odd moduluses

310
00:24:17,180 --> 00:24:21,619
 um except that you know it's not always cryptographers that are trying to cause

311
00:24:21,619 --> 00:24:28,059
 crazy things to happen um this is an issue also in things like um uh rsa signatures

312
00:24:28,059 --> 00:24:32,000
 But another thing is you want to have it also scale with the input.

313
00:24:32,539 --> 00:24:37,500
 So if you have a fixed amount of data, you want to make sure that your execution doesn't require parsing of all the data.

314
00:24:38,279 --> 00:24:42,819
 So if someone passes in a megabyte of data, it doesn't blow up the execution of the precompile.

315
00:24:43,759 --> 00:24:47,700
 The amount of data you pass in, you should always charge gas for each byte that comes in.

316
00:24:47,759 --> 00:24:50,440
 And if it's a variable amount, then your gas needs to be variable.

317
00:24:50,440 --> 00:24:58,880
 Now, I think that finally, the last example of a worst case is that you should account for the worst case.

318
00:25:00,000 --> 00:25:04,600
 It's tempting just to cost it for the typical case to make sure that everyone gets a fair use.

319
00:25:04,660 --> 00:25:10,900
 It's like, you know, you're only going to use moddxp for odd moduluses, and you're only going to do it for within a certain range.

320
00:25:11,380 --> 00:25:17,380
 But some people are going to use absurdly large numbers, and they're going to use even moduluses, just for no other reason than to try and troll the chain.

321
00:25:17,380 --> 00:25:20,060
 This happened back in DebCon2 in Shanghai.

322
00:25:20,820 --> 00:25:22,060
 There are people that were trolling the chain.

323
00:25:22,420 --> 00:25:23,280
 Some people do it for fun.

324
00:25:23,360 --> 00:25:24,200
 Some people do it for money.

325
00:25:24,660 --> 00:25:28,020
 But you should just expect in anything that you design in a protocol layer

326
00:25:28,020 --> 00:25:32,040
 that people are going to try and attack it regardless of their motivation.

327
00:25:32,180 --> 00:25:33,580
 It's something that you need to be prepared to handle

328
00:25:33,580 --> 00:25:35,520
 and something that you need to be prepared to implement.

329
00:25:37,220 --> 00:25:39,620
 So let's dive into some of the questions about how it's implemented.

330
00:25:39,620 --> 00:25:45,160
 I see some of the questions coming in some of the chat room.

331
00:25:45,160 --> 00:25:52,440
 So, so one of the questions is, actually, this is going to be on the next slide, implementation

332
00:25:52,440 --> 00:25:53,440
 strategies.

333
00:25:53,440 --> 00:25:56,180
 I'll go and answer this really quick.

334
00:25:56,180 --> 00:25:59,840
 One question is referring to basis or precompile codes implemented inside the Java virtual

335
00:25:59,840 --> 00:26:00,840
 machine.

336
00:26:00,840 --> 00:26:03,840
 Are they being done in another process the Java virtual machine is calling?

337
00:26:03,840 --> 00:26:05,140
 Kind of.

338
00:26:05,140 --> 00:26:10,080
 Some precompiles are done in Java, if they're like, like the identity is really simple.

339
00:26:10,080 --> 00:26:14,580
 But some of the more expensive ones like ECDSA, we don't call it to it in the process.

340
00:26:14,579 --> 00:26:17,659
 But we do bring in a different library into Java.

341
00:26:18,359 --> 00:26:24,919
 We actually, in Basu, we use the Bitcoin, Bitcoin D, there's a library that Bitcoin D uses.

342
00:26:25,079 --> 00:26:33,799
 And it's got some, there's something about the K curve that provides for some really fast calculation of it that, you know, again, I don't fully understand the math.

343
00:26:33,799 --> 00:26:34,679
 I just know it's faster.

344
00:26:35,099 --> 00:26:36,519
 So we bring that solution in.

345
00:26:36,559 --> 00:26:38,919
 It's just something fundamental about the way that they implement the algorithm.

346
00:26:39,399 --> 00:26:41,019
 And that gets us faster time on calculating it.

347
00:26:41,059 --> 00:26:42,259
 I think all clients use this.

348
00:26:42,259 --> 00:26:49,559
 If they don't use the specific piece of software from Bitcoin D, at the very least, they use the algorithms there to make it faster.

349
00:26:50,599 --> 00:26:55,059
 So both things are done, implemented either in raw Java or use an external library.

350
00:26:55,460 --> 00:26:58,900
 We don't have the bit where we go out to a separate process to execute it.

351
00:26:59,359 --> 00:27:02,960
 I think that's more some of the more exotic design approaches out there.

352
00:27:07,640 --> 00:27:10,839
 And if that gets reported on a pre-compile, what's the plan of action?

353
00:27:10,839 --> 00:27:13,259
 I'll come to that question at the end.

354
00:27:13,339 --> 00:27:14,500
 That is an excellent question from Rahul.

355
00:27:14,659 --> 00:27:16,379
 So let's mark that for it

356
00:27:16,379 --> 00:27:17,759
 and we get into Q&A session.

357
00:27:18,939 --> 00:27:19,959
 So let's look at a brief

358
00:27:19,959 --> 00:27:20,659
 of how it's implemented.

359
00:27:21,079 --> 00:27:22,959
 I found in the four major clients

360
00:27:22,959 --> 00:27:23,579
 that are out there,

361
00:27:24,519 --> 00:27:25,980
 for Aragon, I'm kind of punting

362
00:27:25,980 --> 00:27:27,199
 because Aragon, when it comes

363
00:27:27,199 --> 00:27:29,539
 to non-data storage things,

364
00:27:29,639 --> 00:27:31,419
 is mostly Geth under the covers currently.

365
00:27:32,079 --> 00:27:33,079
 They're working on bringing in

366
00:27:33,079 --> 00:27:33,879
 something called Silkworm,

367
00:27:34,059 --> 00:27:36,079
 but that's not production level yet.

368
00:27:36,539 --> 00:27:37,879
 So, you know, there's some interesting

369
00:27:37,879 --> 00:27:38,919
 things going on in Aragon.

370
00:27:39,319 --> 00:27:40,259
 But for now, they're going

371
00:27:40,259 --> 00:27:42,640
 it mostly reflected in the way geth works.

372
00:27:42,640 --> 00:27:44,420
 Starting out in BASU,

373
00:27:44,420 --> 00:27:46,279
 BASU implements all of these in

374
00:27:46,279 --> 00:27:49,700
 the Java package based on EVM pre-compile.

375
00:27:49,700 --> 00:27:52,640
 You can see all the different pre-compiles we have out there.

376
00:27:52,640 --> 00:27:56,000
 So let's ID pre-compile contracts pretty simple one.

377
00:27:56,000 --> 00:27:57,619
 It has a simple interfaces,

378
00:27:57,619 --> 00:27:58,940
 what's the gas requirement,

379
00:27:58,940 --> 00:28:00,500
 and how do you compute the pre-compile?

380
00:28:00,500 --> 00:28:02,180
 It's pretty simple stuff.

381
00:28:02,180 --> 00:28:04,819
 Here, this is the most simple pre-compile we have out there,

382
00:28:04,819 --> 00:28:07,460
 you just copy it. Of course it's Java,

383
00:28:07,460 --> 00:28:09,000
 it's Hyperledger where there's lots of

384
00:28:09,000 --> 00:28:12,299
 boilerplate and Java-isms, and it's done in a very Java way.

385
00:28:13,160 --> 00:28:15,059
 Now, if you want to see it done in a very Go way,

386
00:28:16,160 --> 00:28:20,920
 we have Get's approach to it, which suddenly is not found.

387
00:28:20,960 --> 00:28:21,660
 This is so awesome.

388
00:28:23,839 --> 00:28:25,000
 Core VM contracts.

389
00:28:25,000 --> 00:28:26,279
 Did they just move this?

390
00:28:28,880 --> 00:28:35,119
 Core VM contracts.

391
00:28:35,720 --> 00:28:37,740
 It must be a particular branch that they got rid of.

392
00:28:37,740 --> 00:28:41,680
 So core VM contracts, here they have all of their pre-compiles implemented.

393
00:28:42,740 --> 00:28:53,620
 And you also see in Go's code, in Geth's code, how they separate it based on the various generations of when they might use these contracts, whether it's Byzantium, Istanbul, Berlin, Cancun.

394
00:28:53,720 --> 00:29:01,099
 And they bring in some of the PROG pre-compiles that are also being brought in with the BLS signatures that are needed.

395
00:29:01,099 --> 00:29:09,019
 and go is a bit simpler it's very get this very much more go-like in the way that they handle it

396
00:29:09,019 --> 00:29:17,639
 um they define a structure here's some constants they define their methods on the structure that's

397
00:29:17,639 --> 00:29:21,500
 big that's not what i'm looking for and they implement an interface you know in this case

398
00:29:21,500 --> 00:29:26,779
 it's required gas and then it'll actually run it it's the same thing you get the bytes you get the

399
00:29:26,779 --> 00:29:32,539
 gas and mod exp is probably the most complex one to calculate the gas cost for um you get into

400
00:29:32,539 --> 00:29:40,299
 other ones required gas it just returns a fixed value for example for the bm-256 add it's always

401
00:29:40,299 --> 00:29:45,859
 the same value because we're always adding two things and um it gets to run there is a separate

402
00:29:45,859 --> 00:29:52,920
 library that they use for their bm stuff um and again it does you know it's implemented in go

403
00:29:52,920 --> 00:29:55,759
 The VM libraries in Go are good enough.

404
00:29:55,759 --> 00:30:00,759
 In doing it in Java, we farm out to a Rust library,

405
00:30:01,039 --> 00:30:03,500
 because it's faster, primarily.

406
00:30:03,500 --> 00:30:04,400
 When you do bit twiddling,

407
00:30:04,400 --> 00:30:06,960
 you don't want to do bit twiddling in Go.

408
00:30:06,960 --> 00:30:10,200
 Nethermind, they have a pre-compile CS,

409
00:30:10,200 --> 00:30:15,160
 so let's go to, let's see,

410
00:30:17,560 --> 00:30:19,500
 EC Recover's probably a good one.

411
00:30:19,500 --> 00:30:21,080
 But again, they have the same similar approach.

412
00:30:21,079 --> 00:30:23,240
 They store it in a very C-sharp way.

413
00:30:23,740 --> 00:30:25,379
 They need to store their address as metadata.

414
00:30:26,199 --> 00:30:28,519
 You calculate the gas cost, the base cast cost.

415
00:30:29,099 --> 00:30:29,779
 You run it.

416
00:30:30,039 --> 00:30:30,859
 You execute the data.

417
00:30:31,579 --> 00:30:34,759
 So in main net, a lot of these precompiles are just kind of boring

418
00:30:34,759 --> 00:30:38,679
 because they're just doing boring math that we need to have done efficiently.

419
00:30:40,539 --> 00:30:46,199
 Let's do the ECU recovery here in ref to show a very similar type situation.

420
00:30:46,619 --> 00:30:48,460
 You have the actual function that does it.

421
00:30:51,079 --> 00:30:53,099
 Do they have the gas cost in here?

422
00:30:55,059 --> 00:30:58,240
 They have gas limit, the gas costing.

423
00:31:00,240 --> 00:31:02,799
 Yeah, REF does a slightly different approach.

424
00:31:02,960 --> 00:31:08,119
 They include the gas usage with the output.

425
00:31:09,000 --> 00:31:12,539
 So they have the results of how much gas costs, and they actually output bytes.

426
00:31:12,919 --> 00:31:13,980
 So they do it in one go.

427
00:31:14,079 --> 00:31:16,439
 Some of us split it up into two steps.

428
00:31:16,519 --> 00:31:17,679
 Some of us do it in one go.

429
00:31:18,159 --> 00:31:19,659
 And that has some design implications.

430
00:31:19,660 --> 00:31:29,600
 If you can tell from the gas that they don't have enough gas to execute this gigantic modd xp before you even try to execute it, you need to just say, hey, there's not enough gas.

431
00:31:29,660 --> 00:31:32,200
 I'm not even going to try. Consume all the gas and return.

432
00:31:32,800 --> 00:31:37,420
 Otherwise, that's a security attack if you can force people to waste effort when you don't have enough gas.

433
00:31:37,920 --> 00:31:48,019
 And that's something that's pretty well trodden paths in some of the security auditors and researchers who go through and fuzz and figure these things out.

434
00:31:48,019 --> 00:31:53,559
 So it's pretty well understood that you check your gas before you do anything expensive.

435
00:31:53,639 --> 00:31:55,960
 And there's multiple ways to get that wrong.

436
00:31:56,359 --> 00:31:57,980
 And that's something auditors always look at.

437
00:31:58,759 --> 00:32:01,480
 So like I said, implementation strategies, you can do it with native code.

438
00:32:01,819 --> 00:32:06,859
 If it is fast enough for implementation, if you want faster code, typically you'll go to a custom written library.

439
00:32:06,859 --> 00:32:15,419
 that they really, I mean, the ECDSA code for the 256K1 curve,

440
00:32:15,740 --> 00:32:19,500
 they have written Intel and ARM machine code

441
00:32:19,500 --> 00:32:22,119
 to try and get this as blazing fast as possible.

442
00:32:22,119 --> 00:32:23,819
 Because in Bitcoin, it makes sense for them

443
00:32:23,819 --> 00:32:27,099
 because that is their singular longest path

444
00:32:27,099 --> 00:32:28,259
 is validating these hashes.

445
00:32:28,379 --> 00:32:29,919
 That is the most expensive part of Bitcoin.

446
00:32:30,500 --> 00:32:31,799
 So it makes a lot of sense for them

447
00:32:31,799 --> 00:32:35,639
 to just go crazy in implementing it and optimizing it.

448
00:32:35,640 --> 00:32:37,320
 And we just got to reap the benefits.

449
00:32:37,420 --> 00:32:38,180
 It's pretty awesome there.

450
00:32:41,800 --> 00:32:43,060
 So a question from Kira.

451
00:32:43,200 --> 00:32:48,100
 Can you discuss some specific ways in which precompiles reduce gaskots compared to implementing similar functionalities in pure solidity?

452
00:32:48,780 --> 00:32:51,240
 Any code optimization that's most commonly used in precompiles?

453
00:32:52,100 --> 00:33:01,860
 So probably the biggest thing in implementing it is why a lot of these cryptographic things are done outside of EVM.

454
00:33:01,859 --> 00:33:07,259
 is because the EVM is a 256-bit stack machine.

455
00:33:08,000 --> 00:33:09,919
 Every word that goes on there is 256 bits,

456
00:33:10,000 --> 00:33:11,339
 but some of these operations are fine,

457
00:33:11,859 --> 00:33:14,659
 like in Kachak in particular, use smaller bits,

458
00:33:14,740 --> 00:33:18,500
 or they have definitions that are really pliable

459
00:33:18,500 --> 00:33:22,039
 to vector operations, single input, no,

460
00:33:24,099 --> 00:33:26,299
 multiple instructions, single data, single,

461
00:33:26,679 --> 00:33:31,500
 multiple data, single instruction.

462
00:33:31,859 --> 00:33:36,919
 S-I-M-D. Got to go back to my undergrad classes to get that out.

463
00:33:37,439 --> 00:33:41,159
 But they're really amenable to being put in vector optimizations.

464
00:33:42,059 --> 00:33:50,039
 And then some of these, like the mod EXP, they need to use a variable width number that could potentially go up to completely unbound sizes of numbers.

465
00:33:50,899 --> 00:33:55,199
 That's one class of bugs that the Geth famously found.

466
00:33:55,740 --> 00:34:01,240
 When they were fuzzing Geth, it goes biggest number if you use absurdly large numbers.

467
00:34:01,240 --> 00:34:06,779
 I mean, even larger than what you would think is absurdly large numbers in some of their libraries, you could segfault go.

468
00:34:08,119 --> 00:34:12,579
 And I think a particular bug they found is from that they were able to lever that.

469
00:34:13,000 --> 00:34:24,659
 And then if they could put a RSA signature certificate and they claimed that one of their fields was that large and they put the number in that was that large, it would segfault it.

470
00:34:24,659 --> 00:34:27,779
 So from some of these, you know, fuzzing efforts,

471
00:34:27,899 --> 00:34:31,420
 they figured out a way to take down SSL servers just because they're trying to

472
00:34:31,420 --> 00:34:32,960
 fuzz their geth implementation. So there's,

473
00:34:33,339 --> 00:34:36,000
 that was a pretty big win from, from geth.

474
00:34:39,500 --> 00:34:43,539
 And so, yeah, so that's it for, for precompile contracts.

475
00:34:43,659 --> 00:34:48,920
 I'm doing this for the purpose of, of, of efficiency,

476
00:34:48,920 --> 00:34:51,980
 but the biggest reason why you wouldn't want to do it in EVM code is because

477
00:34:51,980 --> 00:34:54,079
 it's much faster to do it natively.

478
00:34:54,079 --> 00:35:02,880
 When you're building blocks and when you're trying to find MEV solutions, you want to do this absolutely as fast as possible.

479
00:35:03,579 --> 00:35:05,679
 So not only is it faster, but it's also cheaper in gas.

480
00:35:05,679 --> 00:35:09,039
 Almost every single one of these precompiles, they're defined.

481
00:35:09,960 --> 00:35:14,420
 They have a very efficient, very hard-to-achieve gas cost to do in EVM.

482
00:35:14,539 --> 00:35:19,860
 I don't think any of these, you could code an EVM version of these that would beat the gas cost that's scheduled here.

483
00:35:19,860 --> 00:35:24,940
 And the gas cost is meant to mirror the actual machine execution cost of executing those.

484
00:35:27,420 --> 00:35:30,860
 So the next thing I want to talk about is system contracts.

485
00:35:33,240 --> 00:35:37,660
 I'd like to take this Star Wars quote and twist it because it's kind of true.

486
00:35:38,280 --> 00:35:42,780
 System contracts are pathway to many capabilities that some consider to be unaligned.

487
00:35:43,400 --> 00:35:48,200
 Some of these things done in system contracts will never see the light of day in mainnet because it's not sufficiently pure.

488
00:35:49,119 --> 00:35:50,319
 Pure might be the wrong word.

489
00:35:50,939 --> 00:35:53,099
 But it's doing things that Mainnet doesn't need to do

490
00:35:53,099 --> 00:35:54,339
 and Mainnet doesn't want to do.

491
00:35:54,639 --> 00:35:56,739
 But it's doing things that some of these Layer 2s

492
00:35:56,739 --> 00:35:58,519
 and all Layer 1s have to do.

493
00:35:58,599 --> 00:36:00,299
 There's no other efficient way to do it.

494
00:36:02,159 --> 00:36:03,500
 So what are system contracts?

495
00:36:03,599 --> 00:36:04,299
 Where are these being used?

496
00:36:04,859 --> 00:36:06,219
 A lot of the typical uses for these

497
00:36:06,219 --> 00:36:07,980
 are for accessing L1 and L2 bridging.

498
00:36:08,899 --> 00:36:10,960
 Arbitrum, Optimism, and the various ZK chains

499
00:36:10,960 --> 00:36:12,480
 use these system contracts.

500
00:36:12,619 --> 00:36:15,239
 Some of them use a hybrid pre-deployed contract

501
00:36:15,239 --> 00:36:16,119
 or deployed contract,

502
00:36:16,119 --> 00:36:19,139
 and they use events to signal into it.

503
00:36:20,279 --> 00:36:21,059
 But these contracts,

504
00:36:21,199 --> 00:36:23,400
 Arbitrum uses a direct native implementation

505
00:36:23,400 --> 00:36:25,239
 of these contracts, even specify it and go it.

506
00:36:25,299 --> 00:36:28,500
 They got some fancy compiler stuff to work with that.

507
00:36:30,079 --> 00:36:31,579
 And there's a spelling error on this.

508
00:36:31,659 --> 00:36:32,440
 You know I wrote this.

509
00:36:32,559 --> 00:36:33,519
 I know that's spelled wrong.

510
00:36:34,119 --> 00:36:36,059
 I'll fix this when I bring the slides out later.

511
00:36:37,179 --> 00:36:38,739
 But layer one, layer two bridging,

512
00:36:38,799 --> 00:36:40,539
 there's a lot of issues with maintaining the bridge

513
00:36:40,539 --> 00:36:41,460
 from layer one, layer two.

514
00:36:41,460 --> 00:36:43,159
 That can really only be done

515
00:36:43,159 --> 00:36:45,460
 from authorized from within the EVM.

516
00:36:45,460 --> 00:36:49,539
 we can only be acted on outside the EVM in the L2 node software.

517
00:36:50,079 --> 00:36:51,780
 So this is what I consider those system contracts,

518
00:36:51,880 --> 00:36:54,920
 even the ones that are done entirely in EVM and signal through events,

519
00:36:55,260 --> 00:36:57,480
 I consider those system contracts just a different variety.

520
00:36:57,639 --> 00:36:58,920
 And I can put them in the pre-compile scan.

521
00:37:00,240 --> 00:37:02,840
 Another reason you might want to do that is you might want to host,

522
00:37:03,059 --> 00:37:05,159
 access foreign chain services.

523
00:37:05,760 --> 00:37:08,480
 Three examples that I have here are Moonbeam.

524
00:37:09,139 --> 00:37:11,780
 Moonbeam is an EVM implementation on top of Polkadot.

525
00:37:11,780 --> 00:37:19,000
 Aurora. Aurora is an EVM implementation on top of Near. And Hedera. And Hedera has implemented

526
00:37:19,000 --> 00:37:23,760
 a smart contract service, but underneath the smart contract service, Hedera has a very different

527
00:37:23,760 --> 00:37:28,760
 token system and accounting system. So the system contracts can be used in these instances

528
00:37:28,760 --> 00:37:33,440
 to access the native tokens in their systems as their native tokens, or do native actions

529
00:37:33,440 --> 00:37:42,400
 on their accounts as needed um see moonbeams um pretty compiled contracts i mean it's it's

530
00:37:42,400 --> 00:37:46,800
 used a way to get to substrates and there's lots of things that are very polka dot specific that

531
00:37:46,800 --> 00:37:53,119
 you might want to um go in and do that related to polka dot um because polka dot's famous for things

532
00:37:53,119 --> 00:38:00,079
 like um it's got it's dow voting features in there it's got its own uh token um moonbeams implemented

533
00:38:00,079 --> 00:38:05,639
 it its own token system, relaying things between the different chains, cross-chain communication.

534
00:38:06,599 --> 00:38:11,719
 And these are accessed via pre-compiled contracts in Moonbeam. So it looks like you're calling just

535
00:38:11,719 --> 00:38:17,440
 another EVM contract, but we're actually escaping the EVM, and we're going in and we're using

536
00:38:17,440 --> 00:38:24,639
 features from other host systems that are not typical to EVM. I think Near's got mostly the

537
00:38:24,639 --> 00:38:30,739
 same sort of things that they're doing on there. Again, they canonize the existing smart contracts

538
00:38:30,739 --> 00:38:36,099
 that exist there. And then they bring in all the other sorts of things that they would need to do

539
00:38:36,099 --> 00:38:43,339
 into NEAR. They're specific to the way that Aurora integrates with NEAR. They have their own.

540
00:38:43,559 --> 00:38:48,920
 And what's interesting about the way that NEAR does it is their addresses don't map to the

541
00:38:48,920 --> 00:38:54,420
 pre-compile addresses. They have specific reasons why these addresses serve here. They don't use

542
00:38:54,420 --> 00:38:58,460
 create or create2 to bring these or create transactions, but they have their own mechanisms

543
00:38:58,460 --> 00:39:02,159
 to determine what the address is. And this is just how it happens to map onto Ethereum.

544
00:39:03,760 --> 00:39:09,380
 And Hedera, they have their, one of the big things they have is a token service.

545
00:39:09,980 --> 00:39:14,980
 They have their own native tokens and Hedera wants to expose it so they look like ERC-20 tokens.

546
00:39:14,980 --> 00:39:19,320
 So this is, you know, one part of the contract where you treat the token service normally.

547
00:39:19,880 --> 00:39:32,539
 And there is another set of pre-compiled contracts that exist at the addresses of where the Hedera tokens would be that booster this into this contract and then go into and do all their specialized Hedera stuff.

548
00:39:33,519 --> 00:39:35,400
 And they also expose it here.

549
00:39:35,679 --> 00:39:44,179
 There are some things that are very Hedera specific that you can still go into this contract if you need things that, you know, they got token fee system that Ethereum will never add.

550
00:39:44,179 --> 00:39:46,739
 but this token fee system is baked into Hedera.

551
00:39:47,339 --> 00:39:49,319
 So this provides an escape hatch when you access it

552
00:39:49,319 --> 00:39:51,099
 as though it's a system contract

553
00:39:51,099 --> 00:39:52,519
 to get into these features

554
00:39:52,519 --> 00:39:54,759
 without having to change the nature of Ethereum.

555
00:39:56,559 --> 00:39:58,879
 And the final thing, I mentioned this earlier,

556
00:39:59,440 --> 00:40:00,919
 a couple of names worth mentioning

557
00:40:00,919 --> 00:40:03,199
 are Phoenix and Ritual.

558
00:40:03,299 --> 00:40:03,719
 And I'm sure there's,

559
00:40:03,779 --> 00:40:05,599
 I think there's a few other FAT people out there

560
00:40:05,599 --> 00:40:06,859
 and there's other AI models,

561
00:40:06,919 --> 00:40:09,440
 but those are the two names that came to mind

562
00:40:09,440 --> 00:40:11,799
 that had interactions with them before.

563
00:40:11,800 --> 00:40:22,120
 But they're going to be using pre-compiles to access things that are completely foreign to host chains, and they're completely foreign to Layer 1s and Layer 2s.

564
00:40:22,640 --> 00:40:25,340
 Fully homomorphic encryption is really neat.

565
00:40:25,480 --> 00:40:26,480
 You can encrypt a number.

566
00:40:26,900 --> 00:40:28,019
 You can encrypt another number.

567
00:40:28,380 --> 00:40:37,180
 From this encrypted data, you can do an operation that says add these two numbers together, and you have no idea what the result is unless you have the key that can decrypt it.

568
00:40:37,340 --> 00:40:40,280
 So you can have everyone put in all these numbers.

569
00:40:41,200 --> 00:40:42,880
 You can say, like, you're doing a Dutch auction.

570
00:40:43,660 --> 00:40:49,240
 Everyone can put in their bid, and then you can do comparisons against each other to figure out what the clearing point is.

571
00:40:49,240 --> 00:40:52,580
 And then you can reveal that number, and nobody knows what your bids are.

572
00:40:53,340 --> 00:40:59,300
 The downside to this is, in addition to being lattice-based math that is really a bit twiddly and difficult in EVM,

573
00:40:59,940 --> 00:41:08,460
 the data can be kilobytes and megabytes large to do some of these features that they need to do in the fully homomorphic encryption.

574
00:41:09,199 --> 00:41:13,699
 I think it's also quantum safe, which is another neat feature, but you can't pass around megabytes of data.

575
00:41:13,900 --> 00:41:18,380
 So they're going to, you know, they're going to handle it their own way, but they're going to use pre-compile contracts to access that.

576
00:41:18,460 --> 00:41:24,699
 And that's like an entirely different service that you wouldn't want to put in the EVM, but you can still manipulate it through a pre-compile contract.

577
00:41:25,619 --> 00:41:27,679
 Ritual, I don't know as much about what they're planning.

578
00:41:27,679 --> 00:41:31,380
 I don't think it's quite as firmed up, but they're planning, proposing on doing the same things.

579
00:41:31,380 --> 00:41:37,240
 you could take some information, you could have an AI model, and you could say, you know,

580
00:41:37,340 --> 00:41:41,340
 with this prompt, what do I get out of it? Whether you're asking for, you know, a large language

581
00:41:41,340 --> 00:41:46,519
 model, or whether you're asking for like some sort of a financial projection, or some other AI

582
00:41:46,519 --> 00:41:50,119
 thing that you might want from it. Those are things you would not want to put typically,

583
00:41:50,380 --> 00:41:55,420
 there's no way you could put an LLM in EVM and run it in a reasonable amount of time,

584
00:41:55,519 --> 00:41:59,559
 just the matrix math you would do there. And you couldn't store it in the EVM efficiently.

585
00:42:00,079 --> 00:42:04,460
 So they're going to have a system where people are going to go out and execute it and put it on there and batch for it.

586
00:42:04,460 --> 00:42:05,779
 And there's going to be some ways to check it.

587
00:42:06,440 --> 00:42:08,860
 And the way they're going to access that is through pre-compiled contracts.

588
00:42:09,059 --> 00:42:15,659
 Again, pre-compiled contracts are the escape hatch to do things that you would never dream of doing in EVM because it's the wrong place to do it.

589
00:42:15,840 --> 00:42:20,759
 But you need to get access to things on chain if you want to have crypto economic incentives about it.

590
00:42:20,760 --> 00:42:34,380
 So it's how you can bridge these two areas and still have the power of FHE or AI models, and yet still come back in and still add those features in and still have the crypto economic incentives.

591
00:42:36,900 --> 00:42:44,800
 So talking about L2s, in addition to EVM codes, another one of the sites that I love to look at to get information about this is rollup.codes.

592
00:42:44,800 --> 00:42:48,540
 This is a service that Limechain put together, worked with them before.

593
00:42:48,539 --> 00:42:51,500
 They're great guys and girls, ladies.

594
00:42:51,840 --> 00:42:52,880
 Sorry, I got the words wrong.

595
00:42:52,980 --> 00:42:54,679
 But they're a great bunch of engineers to work with.

596
00:42:55,019 --> 00:42:56,099
 And they put all this together.

597
00:42:56,900 --> 00:42:58,940
 And right now, this just focuses on L2s.

598
00:42:59,119 --> 00:43:03,159
 But you can get all the information on the various system contracts that come in L2s.

599
00:43:03,619 --> 00:43:06,539
 Because, you know, Arbitrum has a small amount of them.

600
00:43:08,199 --> 00:43:10,019
 And it's interesting, you can link in here.

601
00:43:10,099 --> 00:43:11,400
 They link into the actual implementation.

602
00:43:12,139 --> 00:43:14,719
 So Arbitrum does their system contracts in Go.

603
00:43:15,699 --> 00:43:18,320
 Or you can go back to, you know, Optimus.

604
00:43:18,320 --> 00:43:20,220
 and we'll use the canonical optimism chain

605
00:43:20,220 --> 00:43:21,760
 to show some of these.

606
00:43:22,480 --> 00:43:24,640
 They have, you know, quite a few more,

607
00:43:25,300 --> 00:43:27,280
 and they do their own special things,

608
00:43:27,860 --> 00:43:29,660
 like L2, L1 message passer.

609
00:43:31,380 --> 00:43:32,740
 Again, these links have died.

610
00:43:34,539 --> 00:43:36,240
 Packages, contracts, bedrock.

611
00:43:41,320 --> 00:43:43,820
 Move to source, L2, yeah, they moved it around.

612
00:43:45,019 --> 00:43:46,460
 So L2 to one message passer,

613
00:43:46,460 --> 00:44:02,159
 And here you can see that they've implemented these, and this is worth probably a little bit of a drill down on it, and that this is a very viable approach to do your system contract integrations.

614
00:44:02,920 --> 00:44:08,980
 This is all implemented in EVM, and I don't think they have specific code to implement this specifically.

615
00:44:09,679 --> 00:44:11,380
 This is probably a boring one to look at.

616
00:44:11,380 --> 00:44:15,619
 you want to go to some more universal stuff.

617
00:44:16,340 --> 00:44:19,140
 But like, so, you know, their base vVault,

618
00:44:19,940 --> 00:44:23,140
 it refers to vVault and i7 version.

619
00:44:23,760 --> 00:44:25,000
 So let's go back to the universal

620
00:44:25,000 --> 00:44:27,760
 and go into their vVault code.

621
00:44:28,780 --> 00:44:31,220
 And, you know, all the stuff that you would do

622
00:44:31,220 --> 00:44:32,820
 is expressed in solidity.

623
00:44:33,280 --> 00:44:35,099
 But what they do is they will emit events

624
00:44:35,099 --> 00:44:36,980
 and this will signal to the L2 node

625
00:44:36,980 --> 00:44:38,460
 a withdrawal has been done.

626
00:44:38,460 --> 00:44:43,579
 And so you localize some of your security model within the EVM itself.

627
00:44:44,300 --> 00:44:50,980
 And if a particular event comes from a particular address, you just have trust that it's actually what's supposed to happen.

628
00:44:51,599 --> 00:44:53,679
 You've got to trust that the EVM does what it says it does.

629
00:44:54,199 --> 00:44:58,940
 And so based on that information, you would then do all of your bookkeeping on your side to change the various states.

630
00:44:59,480 --> 00:45:01,240
 And then these are communicated via events.

631
00:45:01,239 --> 00:45:04,599
 and zket EVMs tend to do this a lot too

632
00:45:04,599 --> 00:45:07,039
 for a lot of their signaling.

633
00:45:08,399 --> 00:45:10,519
 Let's see, one of the more vanilla ones.

634
00:45:11,379 --> 00:45:14,119
 I think Polygon links to their code here.

635
00:45:15,319 --> 00:45:16,479
 And Polygon is interesting.

636
00:45:16,599 --> 00:45:17,719
 It's another interesting design choice.

637
00:45:17,859 --> 00:45:19,599
 It's all in one giant contract.

638
00:45:20,659 --> 00:45:23,799
 But again, here you'll see that there's going to be

639
00:45:23,799 --> 00:45:29,919
 and they got a lot of their events here

640
00:45:29,920 --> 00:45:32,519
 of how they're communicating back and forth,

641
00:45:32,659 --> 00:45:33,559
 claims and bridgings.

642
00:45:34,720 --> 00:45:42,519
 And again, it focuses on using the emit

643
00:45:42,519 --> 00:45:43,960
 to calculate the information.

644
00:45:46,659 --> 00:45:49,519
 So, you know, things they'll do, L2, L1 communications,

645
00:45:49,960 --> 00:45:52,159
 managing their money and their fee vaults,

646
00:45:52,340 --> 00:45:54,360
 bridging, of course, is part of this implicitly.

647
00:45:54,740 --> 00:45:57,519
 Security admin tasks, if you manage your rights

648
00:45:57,519 --> 00:45:59,240
 to your L2 stuff to various addresses,

649
00:45:59,239 --> 00:46:05,279
 they'll use the system contracts to update that might be stored in in in the uh in the evm state

650
00:46:05,279 --> 00:46:09,779
 it might be stored in the l2 node state but it's it goes through an ev through a pre-compile system

651
00:46:09,779 --> 00:46:15,319
 contract um but what's interesting is some things are doing is that chain info queries are also

652
00:46:15,319 --> 00:46:18,879
 being done through pre-compiles and this is something that i kind of wish layer one would

653
00:46:18,879 --> 00:46:22,639
 start moving towards rather than creating a new op code every time you have a new blob base v

654
00:46:22,639 --> 00:46:26,379
 or some other chain-specific data,

655
00:46:27,759 --> 00:46:29,239
 they go through smart,

656
00:46:29,379 --> 00:46:31,000
 they do go through pre-compilers

657
00:46:31,000 --> 00:46:32,679
 because, you know,

658
00:46:32,699 --> 00:46:33,839
 that would make all of the opcodes

659
00:46:33,839 --> 00:46:35,379
 very, very difficult to use

660
00:46:35,379 --> 00:46:36,819
 because every system

661
00:46:36,819 --> 00:46:38,400
 would have their own custom opcode

662
00:46:38,400 --> 00:46:40,599
 and there's no way Solidity and Viper

663
00:46:40,599 --> 00:46:41,539
 and everyone else

664
00:46:41,539 --> 00:46:42,480
 would support all those features.

665
00:46:43,799 --> 00:46:46,139
 So a lot of these kind of duplicate

666
00:46:46,139 --> 00:46:47,879
 what goes on in the 30 to 40 chain.

667
00:46:48,599 --> 00:46:50,239
 And some of these are new,

668
00:46:50,420 --> 00:46:52,059
 unique things specific to the way

669
00:46:52,059 --> 00:46:54,079
 that the various L2s work

670
00:46:54,079 --> 00:46:55,980
 because the notion of your L2 block

671
00:46:55,980 --> 00:46:57,179
 and your L1 block being different

672
00:46:57,179 --> 00:46:58,440
 is something that's completely foreign

673
00:46:58,440 --> 00:46:59,779
 to Ethereum mainnet.

674
00:47:01,960 --> 00:47:03,820
 Now, in going through this,

675
00:47:03,940 --> 00:47:05,480
 you can see some notable design choices

676
00:47:05,480 --> 00:47:06,840
 in the way the L2 contracts

677
00:47:06,840 --> 00:47:07,619
 handle their precompiles

678
00:47:07,619 --> 00:47:09,039
 versus the way Ethereum mainnet wants.

679
00:47:09,820 --> 00:47:10,719
 Almost universally,

680
00:47:10,980 --> 00:47:12,900
 all things that are not Ethereum mainnet,

681
00:47:13,579 --> 00:47:15,299
 especially when they're in layer twos,

682
00:47:15,719 --> 00:47:17,219
 is that they're using the Solidity API

683
00:47:17,219 --> 00:47:18,659
 for the precompiled access.

684
00:47:19,299 --> 00:47:21,079
 In mainnet, each address does one thing

685
00:47:21,079 --> 00:47:21,960
 and it does one thing only,

686
00:47:21,960 --> 00:47:31,320
 it does one thing well but if we did that for um pre-compiles and um yeah i'll get that that's a

687
00:47:31,320 --> 00:47:34,760
 good question is there eaps for new pre-compiles that are currently being considered i'll come back

688
00:47:34,760 --> 00:47:41,960
 back to that q a that's a great question um but as far as um if we have one pre-compile for each

689
00:47:41,960 --> 00:47:44,599
 address there would be like thousands of pre-compiles hundreds of thousands of free

690
00:47:44,599 --> 00:47:48,599
 compiles in some of these layer two systems and it'd be hard to figure out what's going on with

691
00:47:48,599 --> 00:47:53,119
 it. And a lot of these contract developers are used to understanding and reading the Solidity

692
00:47:53,119 --> 00:47:57,559
 documentation to figure out what's supposed to be going on with it. So it's kind of become,

693
00:47:58,019 --> 00:48:03,299
 Solidity ABI has kind of become a default interface for messaging between the two layers.

694
00:48:03,860 --> 00:48:10,079
 And this begs the question, maybe we need an ERC to canonize a Solidity ABI separate from Solidity.

695
00:48:10,619 --> 00:48:15,460
 I don't know how Solidity would feel about it, but it's being used in Viper, it's being used in

696
00:48:15,460 --> 00:48:21,079
 lots of different places, I think it's worth elevating it to its own standard that is separate.

697
00:48:21,980 --> 00:48:27,019
 But there's also some mixed API decisions in how they implement it. Some Layer 2s use multiple

698
00:48:27,019 --> 00:48:33,699
 contracts. Some ZK systems use one giant contract to do everything. That's just how far you split

699
00:48:33,699 --> 00:48:38,519
 it apart. There's no real consistency on that. And at the end of the day, it's the design

700
00:48:38,519 --> 00:48:43,539
 preference on how you like to do that as the implementer. There's a mixed permanence in some

701
00:48:43,539 --> 00:48:49,139
 these contracts. Some operate through proxies, and some are fixed deployment. Again, there's

702
00:48:49,139 --> 00:48:53,679
 preferences to how you want to expose your security risks on that. There's also mixed

703
00:48:53,679 --> 00:48:59,519
 implementation strategies. Some chains implement their system contracts directly in the node

704
00:48:59,519 --> 00:49:06,759
 software, and some implement it in mixed solidity and mixed of the L2 node software, responding to

705
00:49:06,759 --> 00:49:12,639
 events that are coming out of the solidity. Both of these are valid strategies if you were to

706
00:49:12,639 --> 00:49:16,960
 design one of these, or you're involved in designing these, you might want to consider

707
00:49:16,960 --> 00:49:22,539
 between both of them. And also, there's a mixed approach to how they deploy the addresses.

708
00:49:23,219 --> 00:49:31,099
 Some of them use consecutive addresses. Arbitrum uses very low numbers. Optimism uses 4200,

709
00:49:31,639 --> 00:49:37,519
 bunch of zeros into theirs. And some systems use create-to-drivens. They'll just create the

710
00:49:37,519 --> 00:49:41,739
 contract, and when they deploy it, wherever the create-to-contract puts it at, or the create-to-one

711
00:49:41,739 --> 00:49:42,799
 contract, that's what it is.

712
00:49:42,879 --> 00:49:46,579
 They're going to use create2 because it has much more repeatable deployment semantics

713
00:49:46,579 --> 00:49:47,539
 based off the address.

714
00:49:48,839 --> 00:49:53,539
 But if you use consecutive addresses, you have the advantage of making the address obviously

715
00:49:53,539 --> 00:49:57,339
 a system contract, whereas when it's a create2-driven, you'd really have to know that that address

716
00:49:57,339 --> 00:50:00,659
 when you're working with it is the address you're working at when you look at it.

717
00:50:00,659 --> 00:50:05,239
 Because when you look at calling in the code an optimism address or an arbitrary address,

718
00:50:05,279 --> 00:50:08,339
 it's really obvious that there's no cryptographic key.

719
00:50:08,559 --> 00:50:11,299
 The odds of it getting one that looks just as much like that.

720
00:50:11,739 --> 00:50:18,899
 it's recognizable it's very low you know all all addresses are equally difficult to get but you're

721
00:50:18,899 --> 00:50:23,539
 predominantly going to get ones that are a mix of numbers all across so large sequences of zeros

722
00:50:23,539 --> 00:50:31,559
 really hard to get so that's one advantage there another use of system contracts as i mentioned is

723
00:50:31,559 --> 00:50:37,119
 foreign host chain services um alt l once will use this to access their tokens um moonbeam aurora

724
00:50:37,119 --> 00:50:41,839
 hedera all have proxies to their alt l1 token systems um they have and they kind of make them

725
00:50:41,839 --> 00:50:46,960
 work within um the ethereum standards um so that people can come in with their defi stuff and do

726
00:50:46,960 --> 00:50:50,799
 defy things with them but still at the end of the day it's a polka dot or it's a near or it's

727
00:50:50,799 --> 00:50:57,839
 a hedera token um uh this is i think i didn't finish writing this slide completely some they

728
00:50:57,839 --> 00:51:02,319
 have access to account tools and systems that they might need to do on their different account models

729
00:51:02,320 --> 00:51:09,360
 Moonbeam and Polkadot famously have voting and messaging across various all the one layers

730
00:51:09,360 --> 00:51:19,600
 that they could go to talk to other communications. And zk also exposes features zk sync has a

731
00:51:19,600 --> 00:51:25,440
 class of storage it's immutable and they access this through through through pre compiles

732
00:51:25,440 --> 00:51:27,940
 Because they don't really have an opcode to access this.

733
00:51:29,960 --> 00:51:32,840
 Foreign host chain services.

734
00:51:33,740 --> 00:51:43,079
 So when I'm talking about a foreign host chain, I'm talking about a blockchain that is not an EVM blockchain in its first day.

735
00:51:43,579 --> 00:51:50,079
 So if you take like Avalanche or Celo, those are basically EVM chains with customizations built onto it.

736
00:51:50,079 --> 00:51:58,440
 But if you were to take like a Cardano, a Solana, a Near, a Polkadot, those were built up without the EVM in mind.

737
00:51:58,639 --> 00:52:00,639
 And they do their own things and they have their own decisions.

738
00:52:00,739 --> 00:52:02,420
 So those are what I consider to be a foreign host.

739
00:52:03,139 --> 00:52:10,259
 And so what some of these chains have done, at least in the case of Polkadot and Near and Hedera,

740
00:52:10,779 --> 00:52:16,920
 is they brought in a system so that you can run EVM there and store their stuff on their chain and access it through EVM.

741
00:52:16,920 --> 00:52:20,800
 but that's not what they're intended, you know, what they were built on.

742
00:52:21,079 --> 00:52:24,039
 So you're taking one EVM system, you're going to a different EVM system.

743
00:52:24,139 --> 00:52:27,240
 It's kind of a foreign system. It's not the, it's like, you know,

744
00:52:27,320 --> 00:52:29,980
 having a Linux subsystem inside windows.

745
00:52:30,400 --> 00:52:32,780
 When you call it some of the window stuff, it's a bit different.

746
00:52:33,500 --> 00:52:35,559
 So that's kind of, you know, why I consider, you know,

747
00:52:35,599 --> 00:52:38,940
 a foreign host access is it basically got one operating system calling a

748
00:52:38,940 --> 00:52:41,340
 different operating system within the same process.

749
00:52:41,680 --> 00:52:44,159
 And so there's, there's issues that come in there,

750
00:52:44,159 --> 00:52:45,659
 which I think are on the next slide.

751
00:52:45,659 --> 00:52:49,399
 Did it answer your question about what is meant by a foreign host chain?

752
00:52:53,519 --> 00:52:56,079
 And some of these foreign hosts, they have things,

753
00:52:56,159 --> 00:52:59,059
 they were built on the premise of things that Ethereum wasn't building on.

754
00:52:59,139 --> 00:53:02,659
 Polkadot wanted to be like a layer zero that had communication across the chains.

755
00:53:03,019 --> 00:53:04,539
 Cosmos is one that I missed out.

756
00:53:05,579 --> 00:53:08,339
 They, you know, have this inner chain communication protocols.

757
00:53:09,079 --> 00:53:13,679
 So they would have access to a lot of their systems through the precompile.

758
00:53:13,679 --> 00:53:18,039
 So you do things that were just not meant to be done in the EVF, and you access those through pre-compiles.

759
00:53:19,519 --> 00:53:25,279
 So one big thing to worry about when you do system calls is there is a security model that you need to be aware of.

760
00:53:26,059 --> 00:53:31,819
 The biggest thing to note is that the pre-compiles don't share Ethereum's memory model.

761
00:53:31,980 --> 00:53:32,899
 What do I mean by this?

762
00:53:33,819 --> 00:53:38,779
 So in Ethereum, each contract has its own set of contract storage.

763
00:53:39,639 --> 00:53:43,059
 And only that contract can access it.

764
00:53:43,059 --> 00:53:45,719
 but you added another layer called a delegate call.

765
00:53:45,799 --> 00:53:50,219
 And what that allows is for you as though another contract has your memory

766
00:53:50,219 --> 00:53:53,059
 model to act on your memory model as though it's you.

767
00:53:53,559 --> 00:53:55,059
 And that's the power of delegate calls.

768
00:53:55,139 --> 00:53:58,799
 And that's really how proxy contracts work is a proxy contract will deploy.

769
00:53:58,920 --> 00:54:02,519
 It'll have memory there, but then a delegate calls out to other, other,

770
00:54:02,940 --> 00:54:04,659
 another contract that may just be very,

771
00:54:04,880 --> 00:54:08,219
 it or versions of this where you fix bugs or add new features,

772
00:54:08,219 --> 00:54:10,019
 but the memory model stays the same.

773
00:54:10,019 --> 00:54:14,440
 So you'll call out to a contract that implements your V1 or your V2 or your V3.

774
00:54:14,539 --> 00:54:15,179
 You'll upgrade it.

775
00:54:15,559 --> 00:54:18,179
 But the memory stays in the proxy contract.

776
00:54:18,719 --> 00:54:21,039
 So with these delegate calls, you're not accessing the memory.

777
00:54:21,780 --> 00:54:22,619
 You have your own memory.

778
00:54:22,759 --> 00:54:27,820
 And also things like the sender address and the local address are maintained across these calls.

779
00:54:28,559 --> 00:54:33,940
 Now, if you're not aware of that, what you might do is when you get a call coming into the system, you might say, well, who's calling me?

780
00:54:34,239 --> 00:54:36,480
 And you might ask, you know, who's the sender and who's the address?

781
00:54:36,480 --> 00:54:38,380
 And you might do things as though it's them.

782
00:54:40,019 --> 00:54:42,300
 They have, you know, hackers are clever.

783
00:54:42,860 --> 00:54:45,019
 They found ways to abuse this through the delegate call.

784
00:54:45,559 --> 00:54:47,960
 And it's typically through other contracts that do callbacks.

785
00:54:48,579 --> 00:54:52,860
 And they'll, you know, they'll do a delegate call to something as a callback or the callback.

786
00:54:52,960 --> 00:54:54,739
 They don't invoke the delegate call that it comes from the parent.

787
00:54:55,320 --> 00:55:00,059
 And in short, what happens is they can impersonate people, make it look like someone that they're not.

788
00:55:00,219 --> 00:55:05,039
 And it's not perfect, but they can use techniques to what they've done.

789
00:55:05,039 --> 00:55:11,679
 and this is pretty famous in um hedera had one we're not purely famous but hedera was hacked

790
00:55:11,679 --> 00:55:15,539
 by this and i'm not sure if moonbeam and near were if they just went through the um

791
00:55:15,539 --> 00:55:21,139
 or if they went through the uh a security disclosure on this but they were able to drain

792
00:55:21,139 --> 00:55:27,320
 um uniswap style dexes of their liquidity into some of these contracts they deploy for contracts

793
00:55:27,320 --> 00:55:33,259
 for uh for callbacks um and because and the reason this has worked in these foreign chain

794
00:55:33,260 --> 00:55:38,600
 systems but not in EVM-based systems is because the memory model is different. Now, the solution

795
00:55:38,600 --> 00:55:43,600
 to this is simple. It's to ban delegate call-ins to the system pre-compile. The way you do that

796
00:55:43,600 --> 00:55:47,440
 is you check that the address of the contract you deployed is the address of what you think it is.

797
00:55:48,220 --> 00:55:52,740
 So when you deploy a contract in your constructor, you will save your address into your immutable

798
00:55:52,740 --> 00:55:58,420
 data. In modern versions of Solidity, that's copied into the actual code that is deployed

799
00:55:58,420 --> 00:56:03,060
 with the contract, so that's an immutable feature of that code. So you can detect if you're being

800
00:56:03,059 --> 00:56:07,579
 called this delegate call or not, and you can say, no, I refuse to do that call. And when you control

801
00:56:07,579 --> 00:56:11,279
 the node software, you can do similar checks without having to burn in the address into it,

802
00:56:11,299 --> 00:56:13,799
 but you can check and make sure if I'm being delegate called. And if you're being delegate

803
00:56:13,799 --> 00:56:18,460
 called, you can just refuse the system contract. And that's what Moonbeam does for their system

804
00:56:18,460 --> 00:56:22,940
 contracts. That's what NIR does. And that's now what Hedera does to ensure that these aren't there.

805
00:56:22,940 --> 00:56:35,940
 Another issue, EVM chains, as far as pre-compiles, mostly those involve solidity bugs, and it's not really because of the system.

806
00:56:35,940 --> 00:56:43,940
 Any hacks that have been involved in the EVM chains are not because of the EVM implementation per se, as much as it is the code.

807
00:56:43,940 --> 00:56:46,940
 What's notable about this, why I call this out, is because it exploits it.

808
00:56:46,940 --> 00:56:50,380
 that there is a foreign chain underneath it, an EVM chain,

809
00:56:50,380 --> 00:56:53,179
 trying to act like an EVM, but it's not quite an EVM.

810
00:56:53,179 --> 00:56:55,820
 And they were able to use the slight differences

811
00:56:55,820 --> 00:56:58,539
 between the two to exploit it.

812
00:56:58,539 --> 00:57:00,619
 And so when you do these implementations,

813
00:57:00,619 --> 00:57:02,139
 you need to keep this in mind and make sure

814
00:57:02,139 --> 00:57:05,539
 that any of the differences are blocked out.

815
00:57:05,539 --> 00:57:07,860
 The biggest thing it can do is band delegate calls.

816
00:57:07,860 --> 00:57:10,380
 But the next thing you need to be aware of

817
00:57:10,380 --> 00:57:12,380
 is the way reverts work.

818
00:57:12,380 --> 00:57:15,139
 So someone might be able to call your system contract

819
00:57:15,139 --> 00:57:16,539
 and you might commit data.

820
00:57:16,539 --> 00:57:18,159
 And then later on it might be reverted.

821
00:57:18,820 --> 00:57:23,420
 If your wrap call is reverted, you need to make sure that your system contract changes are also reverted.

822
00:57:23,820 --> 00:57:27,699
 I'm not sure, I'm not aware of any in the wild exploits of this yet,

823
00:57:27,699 --> 00:57:32,940
 because I think everyone who's been implementing this has been painfully aware of how reverts work

824
00:57:32,940 --> 00:57:36,719
 and have built their systems so that any calls will be reverted,

825
00:57:36,800 --> 00:57:39,460
 if they're reverted within a scope will not have lingering side effects.

826
00:57:39,940 --> 00:57:44,420
 But this is, again, another thing when you build system contracts that you need to be aware of.

827
00:57:44,420 --> 00:57:47,659
 and if it fully implements the EVM model,

828
00:57:47,659 --> 00:57:50,420
 then you're fine.

829
00:57:50,420 --> 00:57:52,340
 But if it doesn't fully implement the EVM model,

830
00:57:52,340 --> 00:57:53,420
 you need to take steps to ensure

831
00:57:53,420 --> 00:57:55,920
 that if your system call gets reverted,

832
00:57:55,920 --> 00:57:57,880
 that the side effects don't linger.

833
00:57:57,880 --> 00:57:59,639
 And that's kind of the subtle genius

834
00:57:59,639 --> 00:58:03,000
 of optimism solution to this,

835
00:58:03,000 --> 00:58:04,800
 where they write the stuff in Solidity,

836
00:58:04,800 --> 00:58:06,139
 they emit events,

837
00:58:06,139 --> 00:58:07,599
 and then based on those emitted events,

838
00:58:07,599 --> 00:58:09,720
 they do the actions in the L2 node.

839
00:58:09,720 --> 00:58:10,820
 Because the way the EVM works,

840
00:58:10,820 --> 00:58:12,700
 if you have to revert something,

841
00:58:12,700 --> 00:58:14,340
 all of the events get reverted too.

842
00:58:14,420 --> 00:58:19,940
 um so it's it's kind of you know you keep it as simple as possible um it just subtly works great

843
00:58:19,940 --> 00:58:22,900
 so that's one of the one of the genius things about optimism why they've never had to worry

844
00:58:22,900 --> 00:58:30,820
 about this is because they use the evm as much as possible so one last thing i want to talk about

845
00:58:31,380 --> 00:58:35,139
 as far as the future of the evm apart from new contracts coming in

846
00:58:35,139 --> 00:58:41,860
 is there's this notion of an idea called a progressive pre-compile um why is that not linked

847
00:58:44,420 --> 00:58:46,380
 Here we go.

848
00:58:48,940 --> 00:58:50,340
 I'm using an old version of this.

849
00:58:53,440 --> 00:58:55,240
 So before I get to progressive pre-compiles,

850
00:58:55,300 --> 00:58:57,480
 I'm going to talk about some of the features of pre-compiles.

851
00:58:58,159 --> 00:58:59,440
 Generally speaking on mainnet,

852
00:58:59,539 --> 00:59:01,559
 there's resistance to adding new mainnet pre-compiles.

853
00:59:02,039 --> 00:59:03,340
 The testing surface is high,

854
00:59:03,579 --> 00:59:06,860
 and the problem is we have to carry them on forever.

855
00:59:07,200 --> 00:59:10,500
 The experiences we had with Lake2 and with RipeMD

856
00:59:10,500 --> 00:59:12,300
 make us hesitant to add things on there.

857
00:59:12,300 --> 00:59:13,139
 We're going to have to maintain forever

858
00:59:13,139 --> 00:59:14,360
 all the chances someone might use it.

859
00:59:14,420 --> 00:59:17,800
 So that's why BLS with it's nine separate functions,

860
00:59:17,800 --> 00:59:18,900
 it has been kind of a sticking point,

861
00:59:18,900 --> 00:59:22,180
 code's been ready since 2020 or 2021,

862
00:59:23,380 --> 00:59:26,180
 but it hasn't been implemented yet

863
00:59:26,180 --> 00:59:27,280
 because the need hasn't been there,

864
00:59:27,280 --> 00:59:29,559
 but because it's been implemented in the consensus layer

865
00:59:29,559 --> 00:59:31,800
 and we need to verify these BLS signatures,

866
00:59:31,800 --> 00:59:32,840
 that's why it's being brought in

867
00:59:32,840 --> 00:59:34,380
 is there's a compelling need.

868
00:59:34,380 --> 00:59:35,940
 And it's a very high level of compelling need.

869
00:59:35,940 --> 00:59:37,820
 That's the level of need that we would need

870
00:59:37,820 --> 00:59:40,980
 to bring in a pre-compile into main net.

871
00:59:40,980 --> 00:59:43,360
 It's either essential to the feature or it's basically

872
00:59:43,360 --> 00:59:48,640
 it's got to be essential to some other feature it can't stand on its own so like one thing

873
00:59:50,079 --> 00:59:54,220
 um that is working to solve some of this is there's a call called roll call it's all the

874
00:59:54,220 --> 00:59:57,160
 roll-ups the layer twos get together and they talk about some of their standards issues

875
00:59:58,360 --> 01:00:01,660
 um and want to make sure that they're aligned on things that they should align on without you know

876
01:00:01,660 --> 01:00:05,740
 having to make everyone work on the same item but one of the things that's falling out of this is

877
01:00:05,740 --> 01:00:11,559
 their early collaboration is they're standardizing what the sccp-256-r1 pre-compile might look like

878
01:00:11,559 --> 01:00:13,619
 and they're standardizing on an address,

879
01:00:13,840 --> 01:00:15,539
 and they're standardizing on an interface

880
01:00:15,539 --> 01:00:18,820
 so that this exists across L2 precompiles.

881
01:00:20,119 --> 01:00:22,980
 And the upside is if an L2 gets it wrong,

882
01:00:23,599 --> 01:00:25,480
 it's only the L2 that has to live with it forever,

883
01:00:25,639 --> 01:00:26,360
 not mainnet.

884
01:00:26,860 --> 01:00:28,579
 If one or two L2s implement it,

885
01:00:28,860 --> 01:00:29,920
 but if they get it right,

886
01:00:30,360 --> 01:00:31,659
 all the L2s will implement it,

887
01:00:31,659 --> 01:00:34,559
 and it will then come into mainnet

888
01:00:34,559 --> 01:00:35,699
 because it's been proven.

889
01:00:36,279 --> 01:00:38,599
 And this is some of the core developers

890
01:00:38,599 --> 01:00:40,920
 on core Ethereum Layer 1,

891
01:00:40,920 --> 01:00:44,980
 engineering efforts, they really want to go with this approach where things that

892
01:00:44,980 --> 01:00:49,180
 might come into the EVM are first prototyped on layer two, and then when they're proven

893
01:00:49,180 --> 01:00:53,019
 successful and proven stable, then they come into layer one if layer one needs it.

894
01:00:53,980 --> 01:00:58,420
 So this is an example, I think, of how the future pre-compiles coming into main net is going to

895
01:00:58,420 --> 01:01:03,579
 look, is we're going to be adopting, for the most part, layer two pre-compiles, or we're going to

896
01:01:03,579 --> 01:01:09,860
 be implementing layer one pre-compiles that are essential to features like Verkle or Blobs. And

897
01:01:09,860 --> 01:01:13,340
 Blobs was the most recent one added, the KZG precompile,

898
01:01:13,599 --> 01:01:14,700
 because that was essential to it.

899
01:01:15,559 --> 01:01:17,700
 One other thing that's probably going to be helping precompiles

900
01:01:17,700 --> 01:01:20,220
 is an EVM feature on the horizon called EVM Max.

901
01:01:20,760 --> 01:01:22,740
 And the Max stands for Modular Math Extensions.

902
01:01:26,280 --> 01:01:26,640
 Modular...

903
01:01:26,640 --> 01:01:27,500
 I probably got that wrong.

904
01:01:27,579 --> 01:01:28,820
 It was late at night when I wrote this.

905
01:01:30,420 --> 01:01:31,880
 But it's modular exponentiation.

906
01:01:32,519 --> 01:01:35,460
 So it provides a lot of features to do modular math,

907
01:01:35,460 --> 01:01:37,500
 modular add, modular divide,

908
01:01:37,500 --> 01:01:42,900
 that is essential to the way that the EC-DSA style curves work.

909
01:01:43,960 --> 01:01:48,139
 And so aspirationally, their goal is to make sure that these things are within 2x the gas cost

910
01:01:48,139 --> 01:01:52,500
 of what you might make a normal precompile costed with if you do it natively.

911
01:01:53,000 --> 01:02:02,179
 And because almost the entirety of the difficulty is handled in the modular math in these extensions,

912
01:02:02,880 --> 01:02:06,199
 it's very reasonable because moving bits around to move the answer around and pack it up,

913
01:02:06,199 --> 01:02:07,439
 That's not terribly expensive.

914
01:02:08,019 --> 01:02:19,339
 The real expense comes in doing these 384-bit modular divisions of all the numbers that are very expensive to do in plain old EVM.

915
01:02:19,399 --> 01:02:26,119
 So this also should reduce the need for precompiles because you can reasonably bring in your random curves.

916
01:02:26,579 --> 01:02:33,359
 You can reasonably bring in your random new features that are being done in elliptic curve type situations.

917
01:02:33,360 --> 01:02:37,019
 and you can do it specifically for what you need and you can optimize it.

918
01:02:37,519 --> 01:02:40,400
 And that's going to solve a lot of problems.

919
01:02:40,460 --> 01:02:44,340
 But that also opens up the next possibility, which is on the next arithmetic extension.

920
01:02:44,500 --> 01:02:46,039
 Okay, modular arithmetic extension.

921
01:02:46,240 --> 01:02:48,620
 Yeah, that's what it was for.

922
01:02:51,539 --> 01:02:55,240
 But what's really coming up in the future is something called progressive pre-compiles.

923
01:02:55,920 --> 01:02:57,480
 So this is a quasi-proposal.

924
01:02:57,800 --> 01:03:01,920
 Here's the link to the Ethereum magicians thread.

925
01:03:01,920 --> 01:03:08,900
 and uh the idea here is you write whatever you're going to do and you write it in evm

926
01:03:08,900 --> 01:03:13,780
 and you nail it down you get it absolutely right you say this is the contract that we're going to

927
01:03:13,780 --> 01:03:18,500
 do and so you would canonize that contract you would use techniques like create two to make

928
01:03:18,500 --> 01:03:24,220
 sure it always gets proposed at the same address um and what you would do is your node software

929
01:03:24,220 --> 01:03:28,700
 would either use that evm code or they would implement it natively and get faster on it

930
01:03:28,699 --> 01:03:45,059
 So if we had EVM-Max out there and we had an EVM-Max version of SCCP-256-R1, or if we need to have R2 or any of the other different size curves, we need FIPS compliance, we need to implement some random curve out there, we would canonize it in EVM.

931
01:03:45,719 --> 01:03:52,960
 So what's great about it is if you don't want to spend the time to write a native implementation, you just run the EVM version and you just get it for free.

932
01:03:53,059 --> 01:03:54,079
 You just bring the contract in.

933
01:03:54,079 --> 01:03:58,759
 But if you need the speed, you can implement it locally and get the speed up.

934
01:03:59,460 --> 01:04:02,179
 Now, one of the things that's an open question is how to handle gas.

935
01:04:03,019 --> 01:04:05,659
 If you do it native, you're going to want to be able to charge less for it.

936
01:04:05,840 --> 01:04:08,299
 But how we're going to signal that in the chains and how we're going to handle that

937
01:04:08,299 --> 01:04:09,719
 has not been figured out.

938
01:04:10,119 --> 01:04:12,319
 And to really get this to work, we need to ship EVMX.

939
01:04:12,420 --> 01:04:13,739
 That's really, I think, it's going to unlock it.

940
01:04:14,599 --> 01:04:17,759
 Now, one of the things that I think proves out this model that is viable

941
01:04:17,759 --> 01:04:20,779
 is how clients have chosen to implement EIP-4788.

942
01:04:20,780 --> 01:04:23,600
 and this is where we're bringing the beacon block route

943
01:04:23,600 --> 01:04:27,380
 and we're putting it into the storage of smart contracts.

944
01:04:29,160 --> 01:04:30,320
 Geth and Reth go simple.

945
01:04:30,460 --> 01:04:31,740
 They just execute the contract.

946
01:04:32,120 --> 01:04:33,400
 And at the beginning of the block,

947
01:04:33,720 --> 01:04:34,680
 they create a transaction,

948
01:04:35,000 --> 01:04:36,900
 they point it at the contract

949
01:04:36,900 --> 01:04:38,019
 and they just execute it.

950
01:04:38,400 --> 01:04:39,680
 And the side effects are going to be fine.

951
01:04:40,080 --> 01:04:41,120
 They don't charge for gas.

952
01:04:41,240 --> 01:04:42,740
 They just let it run and do whatever it needs.

953
01:04:43,340 --> 01:04:44,800
 And they literally use the contract.

954
01:04:45,420 --> 01:04:47,300
 So it's a great example of how this works

955
01:04:47,300 --> 01:04:47,920
 is that you might do,

956
01:04:48,300 --> 01:04:50,560
 you know, that you can have the contract there.

957
01:04:50,780 --> 01:04:53,940
 Based with Nethermine though, they do it differently.

958
01:04:53,940 --> 01:04:55,720
 First, they look and see if the contract exists,

959
01:04:55,720 --> 01:04:56,980
 and if the contract exists,

960
01:04:56,980 --> 01:04:59,740
 then they just write the data directly to storage.

961
01:04:59,740 --> 01:05:01,080
 Go into the EVM layer,

962
01:05:01,080 --> 01:05:02,740
 they don't go to the execution,

963
01:05:02,740 --> 01:05:04,820
 they just do what the contract does and they have

964
01:05:04,820 --> 01:05:07,720
 the same side effects as though you implement it locally.

965
01:05:07,720 --> 01:05:11,100
 I think this is an important proof of concept of

966
01:05:11,100 --> 01:05:12,840
 how progressive pre-compiles might work

967
01:05:12,840 --> 01:05:15,420
 and how they can exist in both worlds.

968
01:05:15,420 --> 01:05:18,780
 If your chain software wants to optimize it,

969
01:05:18,780 --> 01:05:20,360
 go ahead and optimize it as long as

970
01:05:20,360 --> 01:05:22,240
 all the side effects are the same.

971
01:05:22,240 --> 01:05:23,559
 And if you don't want to optimize it,

972
01:05:23,559 --> 01:05:25,340
 or you don't have time to optimize it,

973
01:05:25,340 --> 01:05:28,519
 just bring the EVM code in, and it works just the same.

974
01:05:28,519 --> 01:05:29,680
 And I think this is, you know,

975
01:05:29,680 --> 01:05:33,120
 possibly how future pre-compiles might show up in the EVM.

976
01:05:33,120 --> 01:05:34,860
 We don't have to go through ACD.

977
01:05:34,860 --> 01:05:37,220
 It's just going to be an implementation detail

978
01:05:37,220 --> 01:05:39,039
 that the clients will choose to implement.

979
01:05:39,039 --> 01:05:40,120
 If there is a really, you know,

980
01:05:40,120 --> 01:05:43,980
 like some 384 K2 curve that we need to support,

981
01:05:43,980 --> 01:05:44,820
 I'm just making that up.

982
01:05:44,820 --> 01:05:46,840
 I don't know if that's a real curve.

983
01:05:46,840 --> 01:05:48,280
 You know, you could write an EVM max

984
01:05:48,280 --> 01:05:49,740
 that would do all the math for you.

985
01:05:49,739 --> 01:05:52,939
 And if you don't have time to embed it, you just make sure it's on the chain, it gets executed.

986
01:05:53,479 --> 01:05:58,019
 But if you really need to get the performance, you spend the time in the clients and you ship it as you're ready.

987
01:05:58,119 --> 01:06:02,199
 You don't have to wait for a fork to implement this pre-compile and get the performance gains.

988
01:06:02,339 --> 01:06:12,879
 And that was actually kind of in the way original design approaches that they were going to handle smart contracts in Ethereum was that the gas costs on a contract, the more it executed, the cheaper it gets.

989
01:06:13,279 --> 01:06:17,199
 The theory is it would incentivize the clients to implement some of these native contracts.

990
01:06:17,199 --> 01:06:28,039
 That idea was ultimately pitched, but the core of it's kind of there, and that stuff that you need to go faster, you can just write faster, because the contract to the hash is fixed and immutable and never going to change.

991
01:06:30,199 --> 01:06:40,079
 So that's a quick summary of all of the things that are coming in the future, and not all of them, but some of the highlights of what I see in the future of pre-compiles.

992
01:06:41,199 --> 01:06:43,639
 Great, so now I have time for any questions.

993
01:06:47,199 --> 01:06:52,199
 Let's go back to Rahul's.

994
01:06:52,199 --> 01:06:55,539
 Rahul asked earlier in the presentation,

995
01:06:55,539 --> 01:06:58,960
 if a bug gets reported in a pre-compile on a client or multiple,

996
01:06:58,960 --> 01:07:00,159
 what is the plan of action?

997
01:07:00,159 --> 01:07:02,399
 Does it get patched in an update?

998
01:07:02,399 --> 01:07:05,219
 Bugs have been found in pre-compiles before.

999
01:07:05,219 --> 01:07:06,819
 The core devs on main net,

1000
01:07:06,819 --> 01:07:08,399
 and I assume you're asking on main net,

1001
01:07:08,399 --> 01:07:10,419
 because if it's optimism or arbitrary,

1002
01:07:10,419 --> 01:07:12,019
 I really can't speak for their process,

1003
01:07:12,019 --> 01:07:13,419
 but they have a much tighter team

1004
01:07:13,419 --> 01:07:15,119
 and they have a much tighter way to fix it.

1005
01:07:15,119 --> 01:07:16,899
 What's different for main net is you've got

1006
01:07:16,900 --> 01:07:19,740
 at least four different teams, four to six teams,

1007
01:07:19,740 --> 01:07:21,960
 that you need to communicate these changes to

1008
01:07:21,960 --> 01:07:24,420
 and get the information to in a secure fashion

1009
01:07:24,420 --> 01:07:25,700
 and get it shipped out.

1010
01:07:25,700 --> 01:07:27,119
 Now, if there's a bug in a pre-compile,

1011
01:07:27,119 --> 01:07:29,180
 typically it's only gonna be one client

1012
01:07:29,180 --> 01:07:30,380
 that's gonna have the bug.

1013
01:07:30,380 --> 01:07:33,099
 Maybe two if they're sharing a library, two or three,

1014
01:07:33,099 --> 01:07:34,940
 but it's typically gonna be one or two bug,

1015
01:07:34,940 --> 01:07:36,360
 one or two clients.

1016
01:07:36,360 --> 01:07:38,220
 We have a secure chat where we're all on it

1017
01:07:38,220 --> 01:07:40,320
 and we talk about our bugs

1018
01:07:40,320 --> 01:07:42,099
 and we talk about what happened.

1019
01:07:42,099 --> 01:07:43,860
 And from that information,

1020
01:07:43,860 --> 01:07:45,280
 we tend to look at our own software

1021
01:07:45,280 --> 01:07:46,740
 if it's just someone else has a bug

1022
01:07:46,739 --> 01:07:49,119
 it makes sure we're not getting into the same issues

1023
01:07:49,119 --> 01:07:50,239
 if we're not set up the same way.

1024
01:07:50,239 --> 01:07:51,739
 And there's been a couple of times where I've, you know,

1025
01:07:51,739 --> 01:07:54,159
 someone said, we made this mistake because, you know,

1026
01:07:54,159 --> 01:07:55,079
 this caused it happened.

1027
01:07:55,079 --> 01:07:55,919
 I looked at our code it's like,

1028
01:07:55,919 --> 01:07:57,459
 oh, we kind of do the same thing.

1029
01:07:57,459 --> 01:07:59,739
 So we adopted their solution and vice versa.

1030
01:07:59,739 --> 01:08:01,759
 There's stuff that base is done that, you know,

1031
01:08:01,759 --> 01:08:05,199
 we got burned on and it made other clients be more attentive

1032
01:08:05,199 --> 01:08:08,379
 to some of the things that, that they would need to fix.

1033
01:08:08,379 --> 01:08:09,959
 So, and this is more than just pre-compile.

1034
01:08:09,959 --> 01:08:12,119
 We actually have it for all of EVM as well,

1035
01:08:12,119 --> 01:08:12,959
 but there's, there's a,

1036
01:08:12,959 --> 01:08:14,279
 there's a group where we'll talk about,

1037
01:08:14,279 --> 01:08:15,959
 we'll disclose the bug.

1038
01:08:15,960 --> 01:08:18,520
 we'll ship a patch out, we'll ship a new version,

1039
01:08:19,260 --> 01:08:22,100
 and either within that version, if it's truly urgent

1040
01:08:22,100 --> 01:08:23,880
 and you need to, you know, wave the red flag,

1041
01:08:23,980 --> 01:08:24,899
 hey, you need to update it now,

1042
01:08:25,960 --> 01:08:27,560
 you know, we'll give one of those patches out.

1043
01:08:28,079 --> 01:08:30,140
 But if we don't know if any, if we found it ourselves

1044
01:08:30,140 --> 01:08:31,859
 and we're fairly certain it's trying to exploit it,

1045
01:08:32,319 --> 01:08:35,199
 we'll ship it in a version, a version or a couple versions later,

1046
01:08:35,500 --> 01:08:37,260
 we'll announce, you know, the details of the bug.

1047
01:08:37,800 --> 01:08:39,359
 There's a number of bugs that this group has found

1048
01:08:39,359 --> 01:08:40,819
 that we haven't fully disclosed yet,

1049
01:08:40,899 --> 01:08:42,140
 even though they've been patched for months.

1050
01:08:43,000 --> 01:08:45,020
 And, you know, there's no reason to give people ideas

1051
01:08:45,020 --> 01:08:46,440
 is on necessarily where it'll look

1052
01:08:46,440 --> 01:08:49,120
 until we're sure that everything is sorted out.

1053
01:08:49,120 --> 01:08:50,600
 But if it is, and then the wild bug,

1054
01:08:50,600 --> 01:08:52,960
 we will fix it as fast as possible.

1055
01:08:52,960 --> 01:08:54,740
 I think Geth's last consensus break

1056
01:08:54,740 --> 01:08:57,440
 had to do with them optimizing their,

1057
01:08:57,440 --> 01:08:59,180
 I think it was their copy,

1058
01:08:59,180 --> 01:09:00,760
 when it pre-compiles,

1059
01:09:00,760 --> 01:09:04,020
 across different versions had different side effects.

1060
01:09:04,020 --> 01:09:05,580
 One of them was out of spec,

1061
01:09:05,580 --> 01:09:09,840
 and it was just like three or four years ago.

1062
01:09:09,840 --> 01:09:11,120
 But as far as bugs and pre-compiles,

1063
01:09:11,120 --> 01:09:13,060
 it's been a while since we've had anything

1064
01:09:13,060 --> 01:09:15,340
 it's been in main net.

1065
01:09:15,340 --> 01:09:17,620
 Typically, we try and shake these out in test nets or dev

1066
01:09:17,620 --> 01:09:20,220
 nets, and we get really aggressive and really crazy

1067
01:09:20,220 --> 01:09:22,920
 in the way we fuzz them and the things

1068
01:09:22,920 --> 01:09:24,160
 we try and do to break them.

1069
01:09:26,740 --> 01:09:29,940
 OK, were there other questions?

1070
01:09:32,940 --> 01:09:34,300
 Is there an EFU for new free compiles

1071
01:09:34,300 --> 01:09:35,800
 that are currently being considered?

1072
01:09:35,800 --> 01:09:38,760
 That's one worth discussing.

1073
01:09:38,760 --> 01:09:50,100
 The current BLS EIP, I think, 257.

1074
01:09:50,100 --> 01:09:58,640
 3527, is that the number?

1075
01:09:58,640 --> 01:10:04,720
 No, what was it?

1076
01:10:04,720 --> 01:10:05,640
 Oh, here's four, yeah.

1077
01:10:06,180 --> 01:10:09,039
 25, 37, pre-confile for BLS 12, 381.

1078
01:10:10,260 --> 01:10:13,440
 72, 12, that's actually a RIP, not an EIP.

1079
01:10:13,780 --> 01:10:19,539
 So I'm going to EIP 25, 37 is the first one.

1080
01:10:20,220 --> 01:10:25,320
 This is bringing in the G1 and the G2 math,

1081
01:10:25,320 --> 01:10:31,039
 the three basic things that you need for BLS in the various groups.

1082
01:10:31,039 --> 01:10:36,579
 um then you have a pairing you need a map um mapping from g2 to g1 and fp and

1083
01:10:36,579 --> 01:10:40,600
 bunch of moon math i don't understand i just know that it works and does the magic thing

1084
01:10:40,600 --> 01:10:44,739
 so this is probably the biggest one this is one that's currently scheduled to go into prog

1085
01:10:44,739 --> 01:10:50,579
 of all the ones in that list this is the one that's most likely to ship um the next one is 7212

1086
01:10:50,579 --> 01:10:54,399
 um will that show up here will it redirect us

1087
01:10:54,399 --> 01:11:02,739
 this is yeah actually this started out as an eip and it's going to become a rip

1088
01:11:02,739 --> 01:11:06,259
 because it's going to be shipped on the roll-up so it's got does it have the address yet

1089
01:11:06,259 --> 01:11:16,420
 um p256 verify so this one is doing the r curve what's notable about the r curve

1090
01:11:16,420 --> 01:11:21,539
 is this is used in consumer hardware.

1091
01:11:22,119 --> 01:11:23,140
 It's FIPS compatible.

1092
01:11:24,399 --> 01:11:26,500
 So do I have my YubiKey?

1093
01:11:27,760 --> 01:11:28,940
 But if you have those YubiKees,

1094
01:11:29,039 --> 01:11:30,039
 those little things that you touch,

1095
01:11:30,100 --> 01:11:34,260
 those nubbies that you put into the side of your computer

1096
01:11:34,260 --> 01:11:35,340
 that touch the preview there,

1097
01:11:35,579 --> 01:11:36,600
 that have the hardware keys,

1098
01:11:37,060 --> 01:11:38,779
 there's lots of consumer-grade keys for these.

1099
01:11:38,840 --> 01:11:42,060
 I think web, not web auth,

1100
01:11:42,560 --> 01:11:45,680
 the new web keys that Google and Facebook

1101
01:11:45,680 --> 01:11:47,360
 and GitHub are trying to push on you.

1102
01:11:47,820 --> 01:11:49,440
 The store the cryptographic keys on your phone,

1103
01:11:49,500 --> 01:11:50,300
 your computer system,

1104
01:11:50,400 --> 01:11:51,460
 so you don't have to manage your passwords.

1105
01:11:52,079 --> 01:11:53,240
 Those use the R key.

1106
01:11:53,440 --> 01:11:54,840
 And I've seen that there are some Rolex

1107
01:11:54,840 --> 01:11:55,740
 that have demo code

1108
01:11:55,740 --> 01:11:57,600
 of how they can use these validations

1109
01:11:57,600 --> 01:12:00,880
 to actually unlock account abstraction tasks.

1110
01:12:01,200 --> 01:12:02,520
 So you could have an AA account

1111
01:12:02,520 --> 01:12:04,200
 that could be driven by an R key

1112
01:12:04,200 --> 01:12:06,100
 and that R key that could actually be

1113
01:12:06,100 --> 01:12:10,600
 on a consumer grade YubiKey type device

1114
01:12:10,600 --> 01:12:11,180
 that would hold that.

1115
01:12:11,180 --> 01:12:19,980
 um eip 7545 is another example of one that's going to be brought in um because of um another

1116
01:12:19,980 --> 01:12:23,400
 feature requires it that's going to be the vertical proof verification pre-compile we're

1117
01:12:23,400 --> 01:12:27,600
 probably going to bring that in in osaka as the current thinking um that'll give it room to change

1118
01:12:27,600 --> 01:12:31,560
 if it needs to to support vertical if we bring it in prog that might lock us into things and

1119
01:12:31,560 --> 01:12:36,820
 into vertical that might want to change so that's going to come in with a vertical in um osaka

1120
01:12:36,819 --> 01:12:38,179
 most likely.

1121
01:12:38,960 --> 01:12:40,539
 And EIP-5988,

1122
01:12:40,859 --> 01:12:42,099
 that's the most controversial

1123
01:12:42,099 --> 01:12:43,500
 of these four

1124
01:12:43,500 --> 01:12:44,259
 that's being brought in,

1125
01:12:44,299 --> 01:12:45,920
 but it's also another important one,

1126
01:12:46,319 --> 01:12:47,840
 and that's the Poseidon hash function.

1127
01:12:48,479 --> 01:12:50,219
 And that gets into some ZK stuff.

1128
01:12:50,340 --> 01:12:53,579
 ZK is really unhappy

1129
01:12:53,579 --> 01:12:55,219
 performance-wise

1130
01:12:55,219 --> 01:12:56,279
 when it's asked to do

1131
01:12:56,279 --> 01:12:57,880
 a Kachak hash or a SHA hash.

1132
01:12:58,840 --> 01:13:00,039
 Bit twiddling is not something

1133
01:13:00,039 --> 01:13:01,179
 that ZK-proof systems

1134
01:13:01,179 --> 01:13:02,799
 are terribly good at.

1135
01:13:03,259 --> 01:13:04,039
 There's ways to do it,

1136
01:13:04,079 --> 01:13:04,960
 but it's kind of expensive.

1137
01:13:04,960 --> 01:13:11,119
 Poseidon is a hash function that is based off of elliptic curves. I don't know exactly how it works,

1138
01:13:11,680 --> 01:13:18,880
 but the big outside is that it can be implemented with the logic inside of a zk-proof

1139
01:13:18,880 --> 01:13:23,760
 much, much more efficiently, because the way it gets to its hash is much more friendly to the

1140
01:13:23,760 --> 01:13:29,600
 way zk-systems work. They're using the same elliptic curve-like things to get the curves

1141
01:13:29,600 --> 01:13:37,520
 done so yeah that answers care is yeah Poseidon hash is it's kind of a it uses elliptic curves

1142
01:13:37,520 --> 01:13:43,520
 I don't think it does ecdsa per se but it is very very friendly to the way current zk systems work

1143
01:13:49,039 --> 01:13:52,720
 do imp do pre-compiles have any impact on network congestion

1144
01:13:53,680 --> 01:13:58,079
 not directly the only way they might have impact on network congestion is if you're passing a large

1145
01:13:58,079 --> 01:14:02,239
 amount of data on the pre-compile and there's ready protocol hedges to keep that from having

1146
01:14:02,239 --> 01:14:10,640
 too much of an impact um famously geth won't gossip any transaction over 128k um it there's

1147
01:14:10,640 --> 01:14:15,119
 ways to get stuff larger than that but it's it's kind of a pain in the neck so the transaction size

1148
01:14:15,119 --> 01:14:20,640
 limits are there there's also gas costing that we're charging on the um on the payload of a

1149
01:14:20,640 --> 01:14:26,319
 transaction bringing large amounts of data so as far as having a large pre-compile call that

1150
01:14:26,319 --> 01:14:29,159
 that wouldn't necessarily cause any network congestion.

1151
01:14:29,159 --> 01:14:31,319
 That's really where the network would be hit.

1152
01:14:31,319 --> 01:14:33,359
 It doesn't, you know, it's, there's better ways

1153
01:14:33,359 --> 01:14:35,340
 to cause network congestion problems

1154
01:14:35,340 --> 01:14:37,479
 than by abusing pre-compiles.

1155
01:14:37,479 --> 01:14:39,460
 Abusing pre-compiles are how you would

1156
01:14:39,460 --> 01:14:41,359
 cause execution slowdowns.

1157
01:14:41,359 --> 01:14:43,639
 And we put a lot of effort into making sure

1158
01:14:44,500 --> 01:14:46,840
 that any ways that you could abuse it

1159
01:14:46,840 --> 01:14:50,579
 are less efficient than just doing a bunch of chat calls.

1160
01:14:51,380 --> 01:14:54,319
 That's probably, or that's the hardest thing to optimize

1161
01:14:54,319 --> 01:14:57,159
 because it's already a very optimized operation.

1162
01:14:57,159 --> 01:14:58,840
 So as long as anything that we can do

1163
01:14:58,840 --> 01:15:03,359
 is more efficient than a chat call,

1164
01:15:03,359 --> 01:15:05,880
 then it's it's solved a lot of our problems.

1165
01:15:13,439 --> 01:15:17,819
 Is that it for the pre-compile questions?

1166
01:15:19,279 --> 01:15:22,599
 Okay, I addressed the one about Java code and Bayesu.

1167
01:15:24,319 --> 01:15:26,319
 cool um any other questions

1168
01:15:31,439 --> 01:15:38,559
 okay thank you so much um yeah uh regarding pretty miles maybe i wanted to ask if you can

1169
01:15:38,559 --> 01:15:46,079
 elaborate a bit what are the what are the issues with adding a pre-compile uh you we have these

1170
01:15:46,079 --> 01:15:50,960
 proposals you you went went over uh so yeah what are the other challenges that you see like for

1171
01:15:50,960 --> 01:15:53,340
 for example, but you meant, but we'll say then,

1172
01:15:53,340 --> 01:15:57,779
 but I hear the problem is that it would enshrine only like one set of

1173
01:15:57,779 --> 01:16:02,960
 parameters for the hash, which is not used by other chains and so on.

1174
01:16:04,020 --> 01:16:06,380
 So yeah, what are, what are the challenges? I think,

1175
01:16:06,500 --> 01:16:08,720
 I think these pre-compiles, what is the complexity?

1176
01:16:11,260 --> 01:16:15,460
 Right. So, I mean, we can kind of see that in ECDSA.

1177
01:16:15,600 --> 01:16:17,039
 We don't have an ECDSA pre-compile.

1178
01:16:17,039 --> 01:16:21,359
 That was the original pitch of 2537 of the BLS.

1179
01:16:22,039 --> 01:16:25,640
 And the first implementation was to bring in the BLS things.

1180
01:16:26,220 --> 01:16:34,819
 Writing a very generic hash function that could be parameterized, it has a huge test surface as far as performance.

1181
01:16:35,140 --> 01:16:43,260
 And the experience we had with ModDXP, we're kind of shy to bringing in things with huge unknown and unscalable performance issues.

1182
01:16:43,439 --> 01:16:45,619
 It's just a great opportunity to cause security issues.

1183
01:16:45,619 --> 01:16:49,159
 So that's why when we bring in specific pre-compiles, we would like specific curves.

1184
01:16:49,779 --> 01:16:54,920
 And this is why I'm very bullish on the progressive pre-compile and EVM-Max,

1185
01:16:55,039 --> 01:16:58,599
 because it seems like Poseidon could be implemented using EVM-Max.

1186
01:16:59,239 --> 01:17:02,779
 And you could have a contract that implements my curves parameters,

1187
01:17:03,019 --> 01:17:05,500
 or you could have a contract that implements your curves parameters,

1188
01:17:05,779 --> 01:17:07,619
 and you can bring those in on equal terms.

1189
01:17:08,140 --> 01:17:10,680
 So that is, you know, one of the concerns with bringing in Poseidon is, you know,

1190
01:17:10,739 --> 01:17:12,659
 what parameters do we bring in?

1191
01:17:12,659 --> 01:17:17,859
 is everyone okay with those parameters and does that suit your particular zk system is that going

1192
01:17:17,859 --> 01:17:22,899
 to be something that's going to work for you or is it going to be you know do you need the 257

1193
01:17:22,899 --> 01:17:26,340
 byte version the 200 i don't know what these parameters are but these are the types of things

1194
01:17:26,340 --> 01:17:32,500
 that when i look into the various uh um cryptographic things there's just all sorts

1195
01:17:32,500 --> 01:17:37,139
 of little little knobs and things you can tweak that the cryptographers um know exactly why they

1196
01:17:37,139 --> 01:17:41,460
 need it and they know exactly why they need that number um so and they're they're really you know

1197
01:17:41,460 --> 01:17:44,760
 They really want to have what exactly they need in there for high-performance reasons.

1198
01:17:45,500 --> 01:17:47,600
 But we can't, when we do a precompile,

1199
01:17:47,980 --> 01:17:52,079
 have a huge open system that is difficult to test the surface of

1200
01:17:52,079 --> 01:17:56,560
 because that's going to put significant risks in main net.

1201
01:17:56,960 --> 01:18:00,319
 Now, if you want to try that on L2, nothing's stopping you

1202
01:18:00,319 --> 01:18:04,520
 because only the L2 will be at fault if things go really –

1203
01:18:04,520 --> 01:18:07,800
 fault's probably not the right word, but only L2 will be at risk.

1204
01:18:08,239 --> 01:18:10,039
 If there is a bug in the precompile,

1205
01:18:10,039 --> 01:18:11,399
 it's going to be a lot easier within an L2.

1206
01:18:11,460 --> 01:18:13,980
 to fix that and bring it in right now

1207
01:18:13,980 --> 01:18:15,939
 because they all have that security council.

1208
01:18:16,180 --> 01:18:18,380
 Even in no training wheels mode,

1209
01:18:18,439 --> 01:18:19,939
 there's like an opportunity to bring in,

1210
01:18:20,020 --> 01:18:22,439
 you know, these keys to shut everything down.

1211
01:18:22,800 --> 01:18:23,739
 Can't do that on main net.

1212
01:18:24,220 --> 01:18:25,779
 If something bad gets shipped on main net,

1213
01:18:25,840 --> 01:18:26,720
 it's going to be there forever.

1214
01:18:27,960 --> 01:18:29,800
 So that's, I think, where a lot of the hesitancy

1215
01:18:29,800 --> 01:18:32,000
 to bring in pre-compiles comes in

1216
01:18:32,000 --> 01:18:34,680
 is that a lot of these are a one-way door.

1217
01:18:35,399 --> 01:18:36,480
 And if we get it wrong,

1218
01:18:37,000 --> 01:18:40,199
 picking up the pieces from a broken pre-compile

1219
01:18:40,199 --> 01:18:41,060
 is going to be very difficult.

1220
01:18:41,460 --> 01:18:48,739
 Right, so is there, was there ever any discussion about removing pre-compiles?

1221
01:18:48,739 --> 01:18:53,699
 Like for example, the identity that you mentioned in the beginning, which is like the ineffective

1222
01:18:53,699 --> 01:18:55,420
 memory copy, yeah?

1223
01:18:55,420 --> 01:18:58,619
 Yeah, there is discussion of removing pre-compiles.

1224
01:18:58,619 --> 01:19:00,920
 The big reason is it would simplify client software.

1225
01:19:00,920 --> 01:19:05,720
 I think the three ones most at risk of being removed are, like you mentioned, the identity,

1226
01:19:05,720 --> 01:19:07,640
 the WRIP MD, and the Blake function.

1227
01:19:07,640 --> 01:19:12,920
 And those are based on one of the justifications is that they have low it's almost zero uses.

1228
01:19:12,920 --> 01:19:16,160
 And in some stretches of blocks, they do have zero uses.

1229
01:19:16,160 --> 01:19:19,400
 So there's been talk of removing these, but I think what's more likely going to happen

1230
01:19:19,400 --> 01:19:26,140
 instead of removing them is they might instead migrate to a contract.

1231
01:19:26,140 --> 01:19:31,600
 If we could do ripe MD in a reasonably sized EVM contract, I could see us migrating that

1232
01:19:31,600 --> 01:19:36,720
 to a fixed contract that you would then execute and gas prices would appropriately go up.

1233
01:19:36,720 --> 01:19:39,000
 The same thing with the Blake function,

1234
01:19:39,000 --> 01:19:41,240
 migrate it to a contract that the prices

1235
01:19:41,240 --> 01:19:42,960
 would then appropriately go up.

1236
01:19:42,960 --> 01:19:46,340
 Identity, there's actually bytecode out there that does it,

1237
01:19:46,340 --> 01:19:48,480
 you know, gas prices go up on it.

1238
01:19:48,480 --> 01:19:50,680
 But I mean, when it comes to stuff like some of these,

1239
01:19:50,680 --> 01:19:51,860
 like some of these things,

1240
01:19:51,860 --> 01:19:54,539
 you just don't use them in new operations.

1241
01:19:54,539 --> 01:19:59,000
 And unless you're doing auditor,

1242
01:19:59,000 --> 01:20:00,699
 un-recommended things with your calls,

1243
01:20:00,699 --> 01:20:02,240
 if you're doing like gas limited calls

1244
01:20:02,240 --> 01:20:05,000
 or relying on certain stipend returns for the calls,

1245
01:20:05,000 --> 01:20:08,779
 then rising the prices are on some of these pre-compiles,

1246
01:20:08,779 --> 01:20:10,960
 the solution is send in more gas.

1247
01:20:12,600 --> 01:20:14,859
 So the downsides of those, isn't that bad.

1248
01:20:14,859 --> 01:20:16,340
 And what it does is it moves the logic

1249
01:20:16,340 --> 01:20:19,380
 out of the client code, moves it into the EVM,

1250
01:20:19,380 --> 01:20:21,359
 and it, you know, it solves a lot of problems.

1251
01:20:21,359 --> 01:20:23,460
 It's just, it's just another EVM program.

1252
01:20:27,239 --> 01:20:28,260
 Okay, awesome.

1253
01:20:28,260 --> 01:20:30,460
 Yeah, thank you so much, Dana.

1254
01:20:30,460 --> 01:20:34,119
 I have one question unrelated to pre-compiles

1255
01:20:34,119 --> 01:20:35,939
 more about like Bessu and Java,

1256
01:20:35,939 --> 01:20:40,439
 because I often read that there are new Java versions,

1257
01:20:40,439 --> 01:20:43,939
 like, you know, I can use the Java 23, 21,

1258
01:20:43,939 --> 01:20:45,460
 right now, I believe.

1259
01:20:45,460 --> 01:20:48,220
 So I'm wondering, like, what version Bessu uses

1260
01:20:48,220 --> 01:20:50,399
 and what are challenges in updating to new versions

1261
01:20:50,399 --> 01:20:52,680
 and what are potential benefits?

1262
01:20:52,680 --> 01:20:55,180
 So, yeah, so there's, Java's interesting in that

1263
01:20:55,180 --> 01:20:58,239
 it's a system that runs, you run your programs in,

1264
01:20:58,239 --> 01:21:00,239
 and you can upgrade the Java system underneath it

1265
01:21:00,239 --> 01:21:01,420
 almost always without problem.

1266
01:21:01,420 --> 01:21:03,059
 They do a lot of backwards compatibility.

1267
01:21:04,119 --> 01:21:07,979
 So right now, BASU compiles with Java 17.

1268
01:21:08,099 --> 01:21:09,659
 The code has to be in Java 17.

1269
01:21:10,260 --> 01:21:11,800
 And when we build it on the build server,

1270
01:21:11,920 --> 01:21:13,500
 Justin has it set up as a GitHub action.

1271
01:21:13,840 --> 01:21:15,779
 It uses the Java 17 compiler,

1272
01:21:15,880 --> 01:21:17,359
 and it compiles it to Java 17.

1273
01:21:17,800 --> 01:21:19,079
 But from that bytecode,

1274
01:21:19,079 --> 01:21:22,640
 you can change the system underneath it to run Java 21.

1275
01:21:24,000 --> 01:21:26,739
 And just by changing from Java 17 to Java 21,

1276
01:21:26,859 --> 01:21:28,359
 you get like a 20% speed increase.

1277
01:21:28,460 --> 01:21:29,579
 It's amazing the sum of the stuff

1278
01:21:29,579 --> 01:21:31,439
 that they've done with JIT technology.

1279
01:21:31,619 --> 01:21:32,800
 It's crazy stuff.

1280
01:21:34,119 --> 01:21:37,199
 So the problem is coming in upgrading.

1281
01:21:37,680 --> 01:21:40,079
 So we want to go from Java 17 to Java 21.

1282
01:21:40,199 --> 01:21:43,180
 That's something that's going to happen in basically within the next year,

1283
01:21:43,680 --> 01:21:45,840
 maybe a number of months. It's hard to tell.

1284
01:21:46,399 --> 01:21:50,079
 But we need to make sure that all of our, our tools support Java 21.

1285
01:21:50,699 --> 01:21:53,099
 Gradle is famous for, for lagging in their support.

1286
01:21:53,220 --> 01:21:56,000
 They're always about six months behind. You know,

1287
01:21:56,000 --> 01:21:58,599
 they don't support the most recent one I was getting always got to wait for a

1288
01:21:58,599 --> 01:22:00,340
 little bit. So our build tooling needs to support it.

1289
01:22:00,340 --> 01:22:04,699
 And then some of our libraries that we use need to support it.

1290
01:22:04,699 --> 01:22:07,220
 One that's currently about to be fixed,

1291
01:22:07,220 --> 01:22:10,000
 web3j had some incompatibilities

1292
01:22:10,000 --> 01:22:11,360
 with the newer version of Gradle.

1293
01:22:11,360 --> 01:22:13,360
 So we had to use an older version of Gradle

1294
01:22:13,360 --> 01:22:15,020
 that didn't support 21.

1295
01:22:15,020 --> 01:22:16,440
 This is mostly, you know, just, you know,

1296
01:22:16,440 --> 01:22:19,140
 good old build engineering, software engineering issues.

1297
01:22:19,140 --> 01:22:20,319
 When you want to upgrade a version,

1298
01:22:20,319 --> 01:22:22,480
 it's you got to make sure the entire tangle

1299
01:22:22,480 --> 01:22:25,279
 of dependencies you have can support Java 21.

1300
01:22:25,279 --> 01:22:27,380
 A lot of the tools we're using, we're using tools that are,

1301
01:22:27,380 --> 01:22:29,980
 you know, we try to stay away from tools that are,

1302
01:22:29,979 --> 01:22:33,000
 have become ossified and never changed.

1303
01:22:33,000 --> 01:22:35,259
 So we tend to remove those when we find those.

1304
01:22:36,500 --> 01:22:40,059
 GCOCO, which is a build tool we use

1305
01:22:40,059 --> 01:22:43,119
 to judge coverage on our tests,

1306
01:22:43,119 --> 01:22:44,599
 they're pretty good about keeping that up to date.

1307
01:22:44,599 --> 01:22:47,019
 So that's another one we upgrade Gradle.

1308
01:22:47,019 --> 01:22:49,139
 So upgrading it to Java 21 is something

1309
01:22:49,139 --> 01:22:53,039
 that's gonna be happening here in the short term.

1310
01:22:53,039 --> 01:22:55,039
 Now, Java is kind of an interesting beast.

1311
01:22:55,039 --> 01:22:58,000
 Not every release is supported for long-term.

1312
01:22:58,000 --> 01:23:05,840
 The pattern that they have decided to adopt is like every four releases is what's called a long-term release.

1313
01:23:06,560 --> 01:23:14,199
 So there's newer versions of Java 17 being supported, but Java 18, 19, and 20, those versions have had their last release for the most part.

1314
01:23:14,979 --> 01:23:18,319
 Java 21 is another one of those versions that will get more repeated support.

1315
01:23:18,979 --> 01:23:22,100
 So Java 21 will be supported for a number of years.

1316
01:23:22,100 --> 01:23:30,260
 So a lot of projects, what they do, what Base has been doing for a while, is we will target one of the long-term support releases, either the current or the previous one.

1317
01:23:30,940 --> 01:23:33,300
 And while we're on the previous one, we'll migrate to the current one.

1318
01:23:33,860 --> 01:23:35,880
 So before that was Java 11.

1319
01:23:36,900 --> 01:23:41,660
 And so we did a migration from Java 11 to Java 17 a couple years ago.

1320
01:23:41,980 --> 01:23:42,980
 And it's been a couple years.

1321
01:23:43,039 --> 01:23:44,840
 And now we're going to do one from Java 17 to 21.

1322
01:23:45,320 --> 01:23:47,160
 In a couple years, we'll go to Java 21 and 25.

1323
01:23:47,159 --> 01:23:58,579
 And what's exciting about upgrading to new versions of Java, which is something you don't really see in Solidity that much, but you get to use new language features and new things that just generally make things faster.

1324
01:23:58,760 --> 01:24:05,079
 Like, we have this library called immutables, but there's a new feature called records in Java 17 that we can use to replace it.

1325
01:24:05,619 --> 01:24:16,239
 In Java 21, there is a new binary access layer to native libraries that shouldn't be much easier for us to bring in arbitrary libraries by using Java 21.

1326
01:24:17,159 --> 01:24:18,279
 it's not there in Java 17.

1327
01:24:18,619 --> 01:24:19,960
 So it just unlocks new features.

1328
01:24:20,760 --> 01:24:21,680
 And this, you know, this is,

1329
01:24:22,099 --> 01:24:24,920
 when people talk about ossifying EVM,

1330
01:24:26,539 --> 01:24:28,699
 you know, Java's been doing virtual machines

1331
01:24:28,699 --> 01:24:29,619
 since the 20th century.

1332
01:24:30,579 --> 01:24:31,819
 EVM is another virtual machine.

1333
01:24:32,000 --> 01:24:33,500
 I like to try and apply some of the lessons

1334
01:24:33,500 --> 01:24:34,739
 and some of the best practices learned

1335
01:24:34,739 --> 01:24:36,399
 and avoid some of the worst practices.

1336
01:24:36,659 --> 01:24:38,380
 You know, we've seen mistakes made in Java.

1337
01:24:38,920 --> 01:24:41,239
 So we've mostly avoided some of those in the EVM.

1338
01:24:41,800 --> 01:24:44,479
 But it adopts some of those best practices in EVM.

1339
01:24:44,479 --> 01:24:48,139
 One of those, we don't have time to dig into this in this talk,

1340
01:24:48,139 --> 01:24:52,659
 one of those that I feel passionately about is the EVM object format.

1341
01:24:52,659 --> 01:24:55,819
 And that does a simple change, which is takes the EVM code,

1342
01:24:55,819 --> 01:24:57,679
 writes a container format for it,

1343
01:24:57,679 --> 01:25:01,359
 does the minimal amount of change to support that container format.

1344
01:25:01,359 --> 01:25:05,419
 And that gives us ways so that Layer 2s can compatibly experiment in EVM,

1345
01:25:05,419 --> 01:25:09,299
 signal that they're experimenting, and do exciting things.

1346
01:25:09,299 --> 01:25:14,359
 And it basically keeps the core EVM the same, it just puts a package around it.

1347
01:25:14,359 --> 01:25:16,819
 And that's what the JVM has done with its class format.

1348
01:25:17,019 --> 01:25:18,979
 It's always had a container for its class format.

1349
01:25:19,479 --> 01:25:24,880
 And it puts signals in its class file that says, hey, I was compiled with Java 7.

1350
01:25:25,259 --> 01:25:26,179
 Can you support me?

1351
01:25:26,460 --> 01:25:27,739
 I was compiled with Java 8.

1352
01:25:27,859 --> 01:25:28,639
 Can you support me?

1353
01:25:29,579 --> 01:25:39,479
 And literally it's been written, there's code that has been written all the way back in Java 1.0 and in the betas that still runs and executes in the JVM.

1354
01:25:39,739 --> 01:25:43,679
 Because the execution sees that and it executes it.

1355
01:25:43,680 --> 01:25:54,800
 Now, some of the things that gets us in trouble, and why I don't necessarily want to do that in the EVM to support just as big, thick history as Java does, is some things are forever.

1356
01:25:54,920 --> 01:25:57,220
 There's code in there that they just can't get rid of.

1357
01:25:57,980 --> 01:26:01,860
 So it's not always, you know, we can't just, you know, do a new version every time you do a hard fork.

1358
01:26:01,980 --> 01:26:05,119
 That's not necessarily a viable container version thing.

1359
01:26:07,039 --> 01:26:10,360
 But that also, they've introduced some things that are much more complex than needed.

1360
01:26:10,359 --> 01:26:16,839
 The complexity in some of the Java stuff, I think, is a testament to why keeping things simple in EVM is important.

1361
01:26:17,880 --> 01:26:21,259
 Because, you know, there used to be this saying that, oh, Macs never get viruses.

1362
01:26:21,460 --> 01:26:22,239
 They never get Trojans.

1363
01:26:23,000 --> 01:26:29,659
 There was a bug in some of the it was it violated the spec of the Java VM.

1364
01:26:30,239 --> 01:26:34,179
 But the Java implementation, you could do some things to confuse the type checking on there.

1365
01:26:34,199 --> 01:26:37,099
 And you could escape and you could do things to escape the sandbox.

1366
01:26:37,100 --> 01:26:43,920
 And so from a Java applet at the time systems were configured to just install and run, you could install a Trojan on your system.

1367
01:26:44,079 --> 01:26:46,700
 People, their Macs would get owned because they're running Java applets.

1368
01:26:47,380 --> 01:26:51,320
 You'll notice that Java applets don't exist anymore. Flash doesn't exist anymore.

1369
01:26:51,900 --> 01:27:00,500
 As a category, those sorts of things that can do system level things have been expunged from most systems.

1370
01:27:00,760 --> 01:27:04,520
 So that's why, you know, my talk in system contracts is very limited in what you do.

1371
01:27:04,520 --> 01:27:06,220
 and you need to be careful of the security

1372
01:27:06,220 --> 01:27:08,260
 because there's things that have been violated

1373
01:27:08,260 --> 01:27:08,920
 because of that.

1374
01:27:12,880 --> 01:27:14,560
 Thank you so much for that.

1375
01:27:14,660 --> 01:27:19,820
 It's very interesting from your OG senior Java perspective

1376
01:27:19,820 --> 01:27:24,180
 and the bridge to the EVM, the LTS releases.

1377
01:27:24,360 --> 01:27:24,760
 It's very interesting.

1378
01:27:24,860 --> 01:27:25,340
 Thank you so much.

1379
01:27:27,180 --> 01:27:31,160
 We have one more question here before we wrap up from Discord.

1380
01:27:31,900 --> 01:27:34,440
 What's the process of defending Gasco?

1381
01:27:34,520 --> 01:27:35,160
 for pre-compile.

1382
01:27:35,260 --> 01:27:37,820
 So you mentioned that you always counter

1383
01:27:37,820 --> 01:27:42,140
 the worst-case scenario for pricing the compile.

1384
01:27:42,380 --> 01:27:47,740
 How do we even arrive at this gas price?

1385
01:27:48,200 --> 01:27:49,480
 That's an excellent question.

1386
01:27:50,980 --> 01:27:52,860
 And it's changed over the years.

1387
01:27:53,940 --> 01:27:57,340
 But ultimately, you come up with a few implementations

1388
01:27:57,340 --> 01:27:58,300
 on the various clients.

1389
01:27:58,960 --> 01:28:00,280
 You make sure the clients implement it.

1390
01:28:00,740 --> 01:28:02,580
 And you'll have one client that will be the lead,

1391
01:28:02,579 --> 01:28:04,640
 and they'll get their estimations on the gas.

1392
01:28:05,180 --> 01:28:07,180
 But what you'll do is you'll get all of the typical

1393
01:28:07,180 --> 01:28:08,119
 and worst-case usages,

1394
01:28:08,239 --> 01:28:09,220
 and you'll get them in a tight loop.

1395
01:28:09,680 --> 01:28:11,920
 And you'll figure out how much benchmark,

1396
01:28:12,239 --> 01:28:13,640
 you know, wall clock time it takes

1397
01:28:13,640 --> 01:28:17,680
 to execute these compilers, these pre-compiles.

1398
01:28:18,399 --> 01:28:19,979
 So you'll figure out what the real actual

1399
01:28:19,979 --> 01:28:22,420
 wall clock time of these to execute is.

1400
01:28:22,939 --> 01:28:25,420
 And you might compare it with a benchmark on a system

1401
01:28:25,420 --> 01:28:27,340
 to give, like, a comparison.

1402
01:28:27,960 --> 01:28:29,760
 But I think one of the more effective ways

1403
01:28:29,760 --> 01:28:31,260
 it's happened, and this was for the,

1404
01:28:31,260 --> 01:28:37,220
 Mod EXP, when they were rationalizing their prices, they just picked a mega gas per second

1405
01:28:37,220 --> 01:28:40,920
 standard that it should execute out of the air. I think at the time it was 30 or 35,

1406
01:28:41,659 --> 01:28:46,159
 maybe it was 25. The number's gone up over the years. I think 25 was the initial goal.

1407
01:28:46,720 --> 01:28:53,380
 I think the BLSs were calculated against 35 mega gas as the goal. So if you take this pre-compile,

1408
01:28:53,380 --> 01:28:57,640
 you execute it in a tight loop, you give it the worst possible answers, it's going to burn about

1409
01:28:57,640 --> 01:29:02,119
 35 million gas per second on it. So the premise being that the worst thing you can do with it

1410
01:29:02,680 --> 01:29:10,119
 is to do that. And the goal is to make it so that Kachak has the worst solution for that.

1411
01:29:10,780 --> 01:29:15,420
 So, I mean, if we're going to, we're talking about repricing BLS based off of the old numbers,

1412
01:29:15,660 --> 01:29:19,800
 because everyone's performance on their VMs has gone up since then. So we're probably going to

1413
01:29:19,800 --> 01:29:26,380
 look at a new number, I don't know if it's going to be 40 or 60 or 80 megagas. But it means that

1414
01:29:26,380 --> 01:29:29,680
 The cost of the precompile is going to necessarily go up, unfortunately.

1415
01:29:30,539 --> 01:29:35,500
 But the goal there is to make sure that if they use it as a denial-of-service attack,

1416
01:29:35,600 --> 01:29:39,760
 that it is not the most efficient way to cause a denial-of-service attack in Ethereum.

1417
01:29:40,119 --> 01:29:46,260
 It's going to cost you money in gas, and there's going to be more efficient operations to cause it to slow down.

1418
01:29:46,960 --> 01:29:51,819
 And I know there's been a lot of talk on base that they have this dream of being gigagas,

1419
01:29:51,819 --> 01:29:55,239
 and this is going to be one of the tough battles

1420
01:29:55,239 --> 01:29:56,899
 is to figure out how to deal with pre-compiles.

1421
01:29:57,699 --> 01:29:59,259
 But I think the battle to gigagas

1422
01:29:59,259 --> 01:30:01,479
 is going to be conquered with tools like concurrency

1423
01:30:01,479 --> 01:30:05,119
 to solve it, not more than just parallelization.

1424
01:30:05,579 --> 01:30:07,319
 I think there's a lot of concurrency ideas

1425
01:30:07,319 --> 01:30:08,239
 that need to be brought in

1426
01:30:08,239 --> 01:30:10,059
 that are well-known in the operating systems

1427
01:30:10,059 --> 01:30:11,960
 that we just need to bring into the EVM

1428
01:30:11,960 --> 01:30:14,579
 to construct our chain

1429
01:30:14,579 --> 01:30:16,899
 so that we can execute in a concurrent fashion

1430
01:30:16,899 --> 01:30:18,639
 the blocks and build the blocks concurrently

1431
01:30:18,640 --> 01:30:37,640
 So that we can get that giga gas number on because none of the pre compiles execute on a giga gas level. They're all, they all have various you know some of them have like you know hundreds of mega gas, and some of them aren't so that's going to be like one of the barriers to hit reliable giga gas.

1432
01:30:37,640 --> 01:30:40,940
 That's very interesting.

1433
01:30:40,940 --> 01:30:43,180
 Thank you so much, Dano.

1434
01:30:43,180 --> 01:30:50,020
 I haven't realized that there might be even a problem with pricing for, I mean, huge problem

1435
01:30:50,020 --> 01:30:55,039
 even have performant enough client to be able to handle those giga gas numbers, but it's

1436
01:30:55,039 --> 01:30:56,380
 very interesting insight.

1437
01:30:56,380 --> 01:30:58,060
 Yeah, thanks so much.

1438
01:30:58,060 --> 01:30:59,200
 Yeah, we are out of time.

1439
01:30:59,200 --> 01:31:01,560
 I think we can wrap up here.

1440
01:31:01,560 --> 01:31:03,600
 But it was really great.

1441
01:31:03,600 --> 01:31:04,600
 Thank you so much, Dano.

1442
01:31:04,600 --> 01:31:06,840
 Appreciate it so much.

1443
01:31:06,840 --> 01:31:12,680
 learned a lot today for sure and it's been it's been it's been a great great journey

1444
01:31:13,960 --> 01:31:21,000
 thank you so much for joining us today great thanks awesome thanks thanks dano and for

1445
01:31:21,000 --> 01:31:28,039
 everyone watching we'll see you on wednesday for our final research track session with francesco

1446
01:31:28,039 --> 01:31:32,000
 on some consensus upgrades.

1447
01:31:34,000 --> 01:31:34,659
 Thanks, everyone.

1448
01:31:35,640 --> 01:31:36,960
 Thanks so much. Have a great day.

