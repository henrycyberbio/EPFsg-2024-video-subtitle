1
00:00:30,000 --> 00:00:59,980
谢谢。

2
00:01:00,000 --> 00:01:30,000
这

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:40,000
¶¶

10
00:02:40,000 --> 00:03:09,979
谢谢。

11
00:03:10,000 --> 00:03:39,979
谢谢。

12
00:04:10,000 --> 00:04:26,699
好的，欢迎回来，每个人，参加以太坊协议奖学金的另一届会议

13
00:04:26,699 --> 00:04:28,339
研究小组。

14
00:04:28,339 --> 00:04:35,959
这是研究轨道上的第七周，今天我们有三位客人，Ignacio，

15
00:04:35,959 --> 00:04:42,199
以太坊基金会州立大学队的吉拉姆和乔什在这里谈论

16
00:04:42,199 --> 00:04:47,719
该边缘主要由升级到Verkle树组成。

17
00:04:47,719 --> 00:04:52,779
所以，是的，我不知道，马里奥，您想在这里如何进行此介绍

18
00:04:52,779 --> 00:04:54,139
他们，但是祝你好运。

19
00:04:55,419 --> 00:04:56,539
是的，非常感谢。

20
00:04:56,539 --> 00:04:58,859
非常感谢，伙计们，今天加入了我们。

21
00:04:59,179 --> 00:05:00,779
是的，介绍非常沉重。

22
00:05:01,019 --> 00:05:03,519
我可能不会花太多时间在上面。

23
00:05:03,519 --> 00:05:07,579
我只想欢迎大家参加本周的研究轨道。

24
00:05:08,639 --> 00:05:12,879
处女座树是非常有趣的话题，目前正在发生非常重要的话题。

25
00:05:12,959 --> 00:05:21,199
如果您没有内部的密码学和处女座树的背景，这很难掌握。

26
00:05:21,539 --> 00:05:26,299
因此，今天我们有三位发言人来介绍他们的这项研究部分。

27
00:05:26,300 --> 00:05:34,300
是EF研究团队的乔什（Josh），但乔什（Josh）不仅仅是以太坊研究人员

28
00:05:34,300 --> 00:05:40,379
甚至在以前做很多很酷的事情，我相信他在Intel和Slack工作，还有很多有趣的事情

29
00:05:40,379 --> 00:05:45,819
项目。 Guillaume实际上来自Go Team，来自GO以太坊团队，因此他为

30
00:05:45,819 --> 00:05:53,819
获得，但主要是在此垂直树迁移过渡上起作用，而Ignacio来自

31
00:05:53,819 --> 00:06:00,300
但是，这项研究也是关于Ignacio的有趣的uh，是他实际上

32
00:06:00,300 --> 00:06:08,139
在EPF课程三中遵循，所以他是UH成功的一个很好的例子

33
00:06:08,139 --> 00:06:14,379
EPF研究员是一直潜入以太坊的人

34
00:06:14,379 --> 00:06:20,300
现在听众中的许多人，今天他处于这些技术的最前沿，所以

35
00:06:20,300 --> 00:06:22,759
很荣幸让你在这里，你们所有人，

36
00:06:22,759 --> 00:06:26,319
我很高兴看到您的演讲。

37
00:06:26,319 --> 00:06:29,400
我希望我们能协调它。

38
00:06:29,400 --> 00:06:30,879
那么谁开始？

39
00:06:30,879 --> 00:06:31,840
谁会捡起它？

40
00:06:32,920 --> 00:06:34,980
我会开始的。

41
00:06:34,980 --> 00:06:36,240
好吧，继续。

42
00:06:36,240 --> 00:06:37,240
舞台是你的。

43
00:06:38,120 --> 00:06:39,040
好吧，谢谢。

44
00:06:41,639 --> 00:06:46,060
好吧，首先，感谢所有人在这里。

45
00:06:46,060 --> 00:06:47,660
我们很兴奋，更多的人

46
00:06:47,660 --> 00:06:49,180
对当地树有兴趣。

47
00:06:49,180 --> 00:06:54,180
因此，本演讲旨在成为一些

48
00:06:54,300 --> 00:06:57,740
假设该主题的技术介绍。

49
00:06:59,000 --> 00:07:02,240
我们不会指望每个人都能100％

50
00:07:02,240 --> 00:07:03,540
我们将显示的内容

51
00:07:03,540 --> 00:07:07,360
因为其中许多事情都很毛茸茸，所以

52
00:07:07,360 --> 00:07:11,800
如果您对此主题感兴趣，可能

53
00:07:11,800 --> 00:07:14,740
演讲后，您将回到这张幻灯片。

54
00:07:14,740 --> 00:07:25,000
因此，只是为了更多地谈论我们的团队，我们的团队由Guillaume组成，这是

55
00:07:25,000 --> 00:07:27,800
团队领导，也是客串团队的一部分。

56
00:07:27,800 --> 00:07:30,439
然后是Ignacio，就是我。

57
00:07:30,439 --> 00:07:39,000
然后，我们有Sjoch，这也可以帮助我们完成所有社区组织，呼叫，适中，

58
00:07:39,000 --> 00:07:40,660
并与其他团队互动

59
00:07:40,660 --> 00:07:45,040
因为垂直树的变化确实具有很大的影响。

60
00:07:45,040 --> 00:07:49,420
而且我们还有与大量工作有关的KEV

61
00:07:49,420 --> 00:07:50,660
在加密方面。

62
00:07:51,879 --> 00:07:55,579
我们还维护一个网站，该网站是垂直的。

63
00:07:55,579 --> 00:07:57,959
在哪里着陆页

64
00:07:57,959 --> 00:08:00,660
对于垂直树的变化，

65
00:08:00,660 --> 00:08:04,100
在哪里可以找到垂直树的内容，

66
00:08:04,100 --> 00:08:06,639
什么是动机，这是当前的任务

67
00:08:06,639 --> 00:08:10,979
我们和其他人正在工作。

68
00:08:10,979 --> 00:08:14,860
而且我们还有一些指向一些文章和视频的链接

69
00:08:14,860 --> 00:08:17,319
我们谈论处女座的地方。

70
00:08:20,659 --> 00:08:24,319
因此，让我们从变化的动力开始，

71
00:08:24,319 --> 00:08:28,019
这可能是尝试理解的正确方法

72
00:08:28,019 --> 00:08:30,360
协议中的任何更改，

73
00:08:31,279 --> 00:08:34,200
因为至少有很大的变化，

74
00:08:34,200 --> 00:08:43,560
它们通常植根于捍卫3D协议的重要值。

75
00:08:43,560 --> 00:08:51,700
因此，如果我们退后一步，考虑系统或应用程序，

76
00:08:51,700 --> 00:08:56,379
状态应用通常非常复杂。

77
00:08:56,379 --> 00:09:04,200
通常，系统的一部分是造成许多大挑战的原因，例如

78
00:09:04,200 --> 00:09:09,720
这就是如何有效地访问状态？

79
00:09:09,720 --> 00:09:14,200
您如何保存州？

80
00:09:14,200 --> 00:09:19,759
因为通常系统的状态是大多数值。

81
00:09:19,759 --> 00:09:25,600
因此，状态应用程序通常非常复杂。

82
00:09:25,600 --> 00:09:31,700
通常状态只会随时间而生长，这通常是痛苦，而创造的东西

83
00:09:31,700 --> 00:09:33,980
许多问题。

84
00:09:33,980 --> 00:09:41,759
而且，如果我们考虑状态对以太坊区块链的意义，那么重要的效果

85
00:09:41,759 --> 00:09:49,440
是他们对我们想要捍卫的一些核心价值施加了很大的压力。

86
00:09:49,440 --> 00:09:56,399
更具体，如果您想成为一个节点并验证块，不幸的是，您将

87
00:09:56,399 --> 00:10:03,480
首先需要下载所有网络状态，这有点大，因此需要

88
00:10:03,480 --> 00:10:11,899
一段时间。这意味着您当然也必须将其保存在某个地方，并从某些地方保存

89
00:10:11,899 --> 00:10:20,639
Guillaume在他的设置中告诉我的数字，您将需要大约1.5吨的磁盘

90
00:10:20,639 --> 00:10:30,259
空间。因此，可能有一个很好的建议是具有两型磁盘。要求

91
00:10:30,259 --> 00:10:34,139
只会随着时间而增加，这是非常不幸的。

92
00:10:34,139 --> 00:10:38,120
以及以太坊处理状态的方式

93
00:10:38,120 --> 00:10:42,879
不是CK友好，这也有点有些

94
00:10:42,879 --> 00:10:45,939
更加未来的变化

95
00:10:45,939 --> 00:10:48,019
我们想通过协议做出。

96
00:10:50,139 --> 00:10:55,139
因此，让我们考虑一下如何拥有一个更好的无状态世界。

97
00:10:55,139 --> 00:11:06,600
这里的理想目标是，每当节点想要加入网络时，

98
00:11:06,600 --> 00:11:09,360
同步所有州。

99
00:11:09,360 --> 00:11:17,199
这间接意味着您不需要大型磁盘来存储所有州。

100
00:11:17,199 --> 00:11:24,399
因此，主要想法是您下载执行客户端和共识客户端，

101
00:11:24,399 --> 00:11:30,799
配置所有内容，您加入网络，您可以尽快开始验证块

102
00:11:31,679 --> 00:11:41,199
不需要大磁盘。另外，进行此更改的一部分是试图使协议更多

103
00:11:41,199 --> 00:11:48,240
ck友好型，将来我们可以使用snark来创建计算证明，以验证该计算

104
00:11:48,240 --> 00:11:51,980
块执行已正确完成。

105
00:11:52,860 --> 00:11:57,860
因此，就像主要的想法是Virkle-Tree

106
00:11:59,580 --> 00:12:03,240
解决节点的存储问题。

107
00:12:03,240 --> 00:12:07,500
因此，至少无状态客户可以避免

108
00:12:09,180 --> 00:12:13,680
即使是以太坊状态的单独存储。

109
00:12:13,680 --> 00:12:16,320
在将来与Snarks一起

110
00:12:16,320 --> 00:12:25,200
节点甚至可以验证块有效而不是进行实际的计算证明

111
00:12:25,200 --> 00:12:32,400
自己执行。因此，这朝着尝试减少硬件要求的方向发展

112
00:12:32,400 --> 00:12:40,800
用于节点。它还简化了想要尝试建立无状态客户端的任何人，因为如果您

113
00:12:40,799 --> 00:12:45,319
如果您不知道如何处理大量状态，

114
00:12:45,319 --> 00:12:48,779
您没有所有这些有效方法的复杂性

115
00:12:48,779 --> 00:12:50,240
在其中存储东西，

116
00:12:50,240 --> 00:12:53,399
如何有效地访问这些数据以及所有这些数据。

117
00:12:53,399 --> 00:12:56,839
您可以简单地访问仅适用于内存的数据。

118
00:12:58,919 --> 00:13:00,939
这种变化也允许

119
00:13:00,939 --> 00:13:04,439
增加气体限制，这就像一个热门话题。

120
00:13:05,439 --> 00:13:08,279
这不是我们在垂直叉中做的事情，

121
00:13:08,279 --> 00:13:11,220
但这也许会被允许

122
00:13:11,220 --> 00:13:12,059
将来。

123
00:13:13,039 --> 00:13:14,480
最后，

124
00:13:17,120 --> 00:13:19,620
这种变化也可能在推动

125
00:13:19,620 --> 00:13:22,500
在不同节点的方向上

126
00:13:22,500 --> 00:13:25,879
可能具有不同的专业角色

127
00:13:25,879 --> 00:13:27,439
在协议中，

128
00:13:27,439 --> 00:13:30,579
可能会产生一些有趣的影响

129
00:13:30,579 --> 00:13:33,000
在淋巴结中的积分中。

130
00:13:34,439 --> 00:13:37,240
但是，是的，这更像是一个研究领域。

131
00:13:38,279 --> 00:13:49,839
因此，如果您想解释西兰花树的工作方式或一种单一的方式，

132
00:13:49,839 --> 00:13:57,019
解释这种变化的一种简单方法是西兰花树基本上引入了某些东西

133
00:13:57,019 --> 00:14:00,699
该协议中的新事物被称为执行证人。

134
00:14:00,700 --> 00:14:09,259
该执行证人基本上包含您需要验证块的所有数据。

135
00:14:09,259 --> 00:14:17,720
因此，今天您需要在验证块之前下载所有州的原因是

136
00:14:17,720 --> 00:14:23,960
每当您收到一个块时，假设您有一个块，那么这个块

137
00:14:23,960 --> 00:14:31,360
我有一项交易，我将10 ETH发送给Mario。

138
00:14:31,360 --> 00:14:37,519
因此，如果您想验证此块，这意味着您需要知道我的当前

139
00:14:37,519 --> 00:14:45,720
平衡是因为如果您没有那个，您将验证发送10个ETH是有效的

140
00:14:45,720 --> 00:14:47,500
交易，对吗？

141
00:14:47,500 --> 00:14:53,019
而且，由于您无法真正预测哪个将是下一个块中的交易，所以

142
00:14:53,899 --> 00:14:59,259
这基本上意味着您需要所有状态才能确保可以验证下一个块。

143
00:15:00,460 --> 00:15:09,820
因此，想法是，每当发生扣子推文时，您都可以收到一些额外的数据，

144
00:15:09,820 --> 00:15:15,899
除了被称为证人的街区，其中包含所有已访问的州

145
00:15:17,500 --> 00:15:24,779
在此块中，您需要验证该块的所有内容

146
00:15:24,779 --> 00:15:25,360
在这个证人中。

147
00:15:26,679 --> 00:15:28,600
这并不是一个新想法。

148
00:15:28,840 --> 00:15:34,059
这是以前已经探索过的东西。

149
00:15:34,059 --> 00:15:36,620
即使您也可以使用当前树来做到这一点。

150
00:15:37,379 --> 00:15:42,759
但是问题在于，您不能真正相信任何给您这些数据的人，因为

151
00:15:42,759 --> 00:15:47,379
这些数据可以是什么，对吗？

152
00:15:47,379 --> 00:15:51,419
我可以简单地发明我的平衡就是什么。

153
00:15:52,000 --> 00:15:55,320
如果您简单地相信此证人数据以验证该块，则

154
00:15:55,860 --> 00:16:01,059
您可能会得出一个错误的结论，即交易是正确的

155
00:16:01,059 --> 00:16:02,899
当不是。

156
00:16:03,500 --> 00:16:06,539
因此，需要的是加密证明

157
00:16:06,539 --> 00:16:08,399
这个证人数据是正确的，

158
00:16:09,620 --> 00:16:12,899
基本上类似于默克尔的证明。

159
00:16:12,899 --> 00:16:20,919
但是Verkle允许的是使此加密证明确实很小，因此完整

160
00:16:20,919 --> 00:16:26,340
见证大小足够小，可以使这个可行。

161
00:16:26,340 --> 00:16:34,139
另一个真正有趣的事情是，该证人还包含所有代码

162
00:16:34,139 --> 00:16:44,299
将需要执行合同，这对人们来说很奇怪，因为他们没有

163
00:16:44,299 --> 00:16:48,840
实际上知道合同代码并不真正存在于树上。

164
00:16:48,840 --> 00:16:55,860
是的，要验证一个块，您只需要余额和存储插槽即可。

165
00:16:55,860 --> 00:17:01,519
您实际上需要合同代码。

166
00:17:01,519 --> 00:17:07,900
因此，使以太坊的无状态听起来很有趣，但不幸的是，这并不是一个简单的

167
00:17:07,900 --> 00:17:09,779
任务。

168
00:17:09,779 --> 00:17:15,160
我们需要引入一个新的密码堆栈，我们需要引入一个新的数据结构，

169
00:17:15,160 --> 00:17:20,639
我们必须进行一些气体会计更改，我们必须从

170
00:17:20,639 --> 00:17:23,240
Merkle-Bartusza树到Berko树。

171
00:17:23,240 --> 00:17:29,299
因此，现在我们将更详细地探索所有这些要点。

172
00:17:29,299 --> 00:17:36,180
因此，让我们从密码学开始，这是最低层的东西。

173
00:17:36,180 --> 00:17:43,059
每当您考虑一些新的超级酷功能时，通常会发生在区块链中

174
00:17:43,059 --> 00:17:49,720
这似乎几乎是不可能的，您会发现有一个加密计划

175
00:17:49,720 --> 00:17:53,500
确实是使这种魔术发生的原因。

176
00:17:53,500 --> 00:18:03,259
在这种情况下，对于经纪人来说，魔术发生在这个加密证明中，证人是

177
00:18:03,259 --> 00:18:11,740
正确，让此证明尺寸真的很小。这是密码学允许的

178
00:18:11,740 --> 00:18:17,099
这是在经纪人中使用的，这实际上是允许该证人传播的原因

179
00:18:17,099 --> 00:18:22,219
它在每个块中，这是可以到达每个无状态客户端的东西。

180
00:18:23,240 --> 00:18:32,099
最终，这就是使以太坊继续成为无信任的原因

181
00:18:32,099 --> 00:18:38,659
协议，因此每个无状态客户端都可以在不信任任何其他方的情况下验证块。

182
00:18:39,839 --> 00:18:46,879
这是因为此加密证明确实使这个无状态客户端

183
00:18:46,880 --> 00:18:52,560
确保此数据是正确的，而不会信任具有完整状态的其他各方。

184
00:18:53,520 --> 00:19:00,080
加密的基本成分是向量承诺，内部产品参数，

185
00:19:00,080 --> 00:19:07,680
和多个防护措施。因此，接下来我们将谈论他们。但是在此之前，

186
00:19:07,680 --> 00:19:12,320
让我们尝试对我们今天在第3阶段使用的密码学进行复习。

187
00:19:12,319 --> 00:19:19,419
因此，今天，我们使用了所谓的默克尔·帕特里夏树（Merkle Patricia Tree）的东西，您可能已经听到了

188
00:19:19,419 --> 00:19:21,419
前。

189
00:19:21,419 --> 00:19:24,079
这里使用的那种密码学很简单。

190
00:19:24,079 --> 00:19:30,919
我们只需使用Sketchhack加密哈希功能。

191
00:19:30,919 --> 00:19:41,259
它的工作方式类似于默克尔树，但是我们有另一种结构

192
00:19:41,259 --> 00:19:43,539
具有不同的分支因子。

193
00:19:43,539 --> 00:19:46,539
因此，而不是两个分支因素，而是

194
00:19:46,539 --> 00:19:50,299
Merkle Patricia树的分支系数为16个，

195
00:19:50,299 --> 00:19:51,980
有此扩展节点，

196
00:19:51,980 --> 00:19:56,559
以及您从一个父母到孩子的观点的方式，

197
00:19:56,559 --> 00:20:01,279
您使用，哈希节点。

198
00:20:01,279 --> 00:20:05,660
因此，哈希是一种做事的方式

199
00:20:05,660 --> 00:20:07,220
内容介绍，

200
00:20:07,220 --> 00:20:10,579
这是区块链中非常深刻而重要的概念。

201
00:20:11,259 --> 00:20:18,220
因此，散列就像指示了每个节点的身份的指示。

202
00:20:19,819 --> 00:20:26,619
但是，就像TLDR一样，我们将凯奇克（Ketchak）用于默克尔·帕特里夏树（Merkle Patricia Tree）的密码学。

203
00:20:28,859 --> 00:20:37,259
在默克尔树上，我们停止使用凯奇克。我们使用称为向量承诺的东西。

204
00:20:37,259 --> 00:20:46,500
因此，这里的想法是我们有256个元素的向量。

205
00:20:46,500 --> 00:20:52,759
该向量的每个项目都是标量字段元素。

206
00:20:52,759 --> 00:20:59,680
因此，这可能是一个技术术语，但是您可以将其视为数字。

207
00:20:59,680 --> 00:21:01,519
好的？

208
00:21:01,519 --> 00:21:10,440
而且我们有一个提交功能，可让您提供此向量并接收什么

209
00:21:10,440 --> 00:21:12,859
我们称承诺。

210
00:21:12,859 --> 00:21:15,200
好的？

211
00:21:15,200 --> 00:21:21,240
从某种意义上说，这种承诺就像与哈希相似的东西。

212
00:21:21,240 --> 00:21:27,480
因此，有约束力的意思是，如果您更改有关向量的任何内容，则该承诺

213
00:21:27,480 --> 00:21:29,099
会改变。

214
00:21:29,099 --> 00:21:31,119
所以你不能真正伪造。

215
00:21:31,119 --> 00:21:37,000
承诺后，您可以找到另一个映射到相同承诺的向量。

216
00:21:37,000 --> 00:21:42,099
因此，这是一个非常重要的财产。

217
00:21:42,099 --> 00:21:48,519
您可以做的其他事情是您可以使用此证明并验证功能。

218
00:21:48,519 --> 00:21:57,819
因此，这些功能，证明函数基本上接收一个向量和索引，它将

219
00:21:57,819 --> 00:22:06,379
生成一个代表该索引上的元素是该元素的派

220
00:22:07,259 --> 00:22:16,379
指数。因此，基本上，您可以证明位置二的元素是10或其他。

221
00:22:17,899 --> 00:22:23,339
而且您还拥有此验证功能，该功能接收了向量的承诺，

222
00:22:23,339 --> 00:22:28,619
该索引，该指数中的声称价值，

223
00:22:29,319 --> 00:22:32,459
证明，它返回错误或真实

224
00:22:32,459 --> 00:22:37,299
取决于此证明是否正确

225
00:22:37,299 --> 00:22:39,720
该索引中的项目是该值。

226
00:22:41,220 --> 00:22:43,859
请注意，在此验证函数中，

227
00:22:44,179 --> 00:22:46,779
验证者需要的只是承诺。

228
00:22:47,599 --> 00:22:49,419
它不需要向量，

229
00:22:49,799 --> 00:22:52,359
哪个魔术发生了，好吗？

230
00:22:52,359 --> 00:22:59,240
因此，这里的魔术是您只能在向量中验证一个项目，只有承诺

231
00:22:59,240 --> 00:23:05,119
这证明它比拥有完整矢量要小得多，对吗？

232
00:23:05,119 --> 00:23:09,819
这是重点。

233
00:23:09,819 --> 00:23:17,740
更多地介绍了血腥的细节，此向量承诺和证明方案在下面使用

234
00:23:17,740 --> 00:23:24,140
我们在协议中引入的新椭圆曲线的设置称为BanderSnatch。

235
00:23:24,940 --> 00:23:30,700
我们还在顶部使用了另一个称为banderwagon的抽象来删除辅因子和

236
00:23:30,700 --> 00:23:41,180
使小组安全。该曲线的标量场是256、53位，基地为255

237
00:23:41,180 --> 00:23:47,580
位。这款椭圆曲线没有配对，这很好，因为它意味着较小的字段，

238
00:23:47,580 --> 00:23:55,980
因此，操作可以更有效。这是创建的bandersnatch曲线

239
00:23:55,980 --> 00:24:02,299
目的是成为VLS12-3-H1中所谓的嵌入曲线。

240
00:24:03,180 --> 00:24:08,940
因此，基本上，BandersNatch的基础场是VLS12-3-H1的标量场。

241
00:24:08,940 --> 00:24:24,100
这样做的原因是，如果您想使用VLS12-3-H1进行鼻涕，则意味着Bandersnatch中的椭圆形核心操作基本上是本地现场操作。

242
00:24:24,360 --> 00:24:28,940
因此，在电路中，您必须效仿效率低下的字段。

243
00:24:28,940 --> 00:24:38,000
这个内部产品参数是我们用于此向量的验证方案的样子

244
00:24:38,000 --> 00:24:43,160
我在上一个幻灯片中显示的开口。

245
00:24:43,160 --> 00:24:47,940
一个重要的属性是它不需要值得信赖的设置。

246
00:24:47,940 --> 00:24:54,600
因此，如果您将其与使用Blobs的KCG承诺进行比较，则需要一个值得信赖的设置，

247
00:24:54,599 --> 00:25:02,459
每当您进行竞争方案的配置时，都会增加额外的开销。

248
00:25:02,459 --> 00:25:07,199
我们不必为Brocol Trees做到这一点，这很好。

249
00:25:07,199 --> 00:25:14,019
我们使用额外的挑战方案，该方案称为多型，允许汇总

250
00:25:14,019 --> 00:25:17,719
一个单个开口。

251
00:25:17,719 --> 00:25:21,839
这确实很重要，因为它使其更短。

252
00:25:21,839 --> 00:25:29,259
因此，让我们现在进入数据结构，并尝试了解更多的virkle树

253
00:25:29,259 --> 00:25:31,500
数据结构有效。

254
00:25:31,500 --> 00:25:37,099
因此，定理协议的数据结构的更改基本上是切换

255
00:25:37,099 --> 00:25:41,000
从Markle Patricia树到Virkle树。

256
00:25:41,000 --> 00:25:46,659
Virkle树名称来自向量承诺和Markle树的混合。

257
00:25:46,659 --> 00:25:51,259
因此，希望现在这会更有意义。

258
00:25:51,259 --> 00:26:01,900
因此，如果您记得这些树木正在使用协议，我认为

259
00:26:01,900 --> 00:26:07,740
是一个非常好的图像，您可以看到，如果您看到

260
00:26:07,740 --> 00:26:13,019
块标头，这是世界状态树的状态根。

261
00:26:13,019 --> 00:26:17,220
基本上，这棵树是一棵树。

262
00:26:17,220 --> 00:26:25,319
因此，在叶节点中，我们有EOA帐户和智能合约帐户。

263
00:26:25,779 --> 00:26:29,680
因此，对于EOA帐户，您基本上具有节点和余额。

264
00:26:30,600 --> 00:26:41,660
但是对于智能合约，您还拥有存储根，这基本上是另一棵树的根，该根始于合同的所有存储插槽。

265
00:26:41,860 --> 00:26:45,500
这就是为什么我们说这就像一棵树。

266
00:26:47,220 --> 00:26:55,380
因此，对于当今协议中的状态存储来说，这是一种看起来的样子。

267
00:26:58,339 --> 00:27:04,500
这将改变。因此，首先要说的是我们将不再拥有这棵树。

268
00:27:05,059 --> 00:27:13,220
我们将有一棵树。因此，我们将拥有所有帐户和所有存储的余额

269
00:27:13,220 --> 00:27:18,819
所有合同的插槽全部在同一棵树中。因此，这是第一个大区别。

270
00:27:20,100 --> 00:27:26,019
另一个很大的区别是，树的形状也大不相同。

271
00:27:27,700 --> 00:27:34,019
我们在这里有一张我从一篇非常好的文章中拍摄的图像，我邀请所有人

272
00:27:34,019 --> 00:27:44,660
要更详细地阅读它，我在这里留下了链接。因此，要解释一下，我们基本上有

273
00:27:46,339 --> 00:27:51,539
两种节点。我们的内部节点的分支系数为256，

274
00:27:53,539 --> 00:27:59,139
这是另一个变化

275
00:27:59,140 --> 00:28:05,460
分支系数为16。因此，分支系数的增加允许树为

276
00:28:05,460 --> 00:28:11,360
较浅，这真的很好，因为那意味着如果您想到

277
00:28:11,360 --> 00:28:15,960
类比默克尔位置树的类比，默克尔位置树

278
00:28:15,960 --> 00:28:23,180
通常具有两个分支系数，因此您需要登录两个

279
00:28:23,180 --> 00:28:29,060
真正创建证据的元素，如果您的分支系数为256，则

280
00:28:29,059 --> 00:28:34,059
然后，您将登录基本256个元素。

281
00:28:34,179 --> 00:28:37,539
因此，这对尺寸要好得多。

282
00:28:40,919 --> 00:28:42,819
除了内部节点，

283
00:28:42,819 --> 00:28:47,819
我们有我们所说的扩展级承诺

284
00:28:47,859 --> 00:28:50,079
和后缀级别的承诺。

285
00:28:51,440 --> 00:28:56,440
基本上，这里的想法是三个键是32个字节。

286
00:28:56,440 --> 00:29:05,160
32字节，所以与今天相同。第一个31个字节定义了一个茎，这是一条路径

287
00:29:05,160 --> 00:29:13,320
对这一扩展级别的承诺。然后在每个叶节点中，每个值都有256个值。

288
00:29:13,319 --> 00:29:27,079
好的，因此基本上按键分组为256个值和我们的方式

289
00:29:27,079 --> 00:29:35,879
在叶子节点中对它们进行编码，与我在这里有此图像

290
00:29:35,879 --> 00:29:42,259
底部基本上我们确实喜欢这些元素的向量承诺

291
00:29:42,259 --> 00:29:54,660
要做一些真正棘手的构造，让两个向量真正存储256个值。和

292
00:29:54,660 --> 00:30:04,980
原因是，正如我之前所说，标量字段为253位，但不幸的是，

293
00:30:04,980 --> 00:30:13,779
我们存储的值是256位。因此，这意味着我们需要两个要素，两个

294
00:30:13,779 --> 00:30:23,380
每个元素的学者。但这也许是一个非常毛茸茸的细节。但我只是想解释

295
00:30:23,380 --> 00:30:33,299
为什么我们有两个向量存储256个值。因此，如果我们将Merkle Patricia树与

296
00:30:33,299 --> 00:30:40,579
使用垂直树以及这可能会影响证明大小。

297
00:30:40,579 --> 00:30:51,399
因此，如果您查看左侧图像，我从Vitalik的一篇文章中获取的图像，

298
00:30:51,399 --> 00:30:59,899
这里的事情是，尽管分支因素是16，但您有一个半味的

299
00:30:59,900 --> 00:31:07,500
树，您仍然需要所有节点数据才能真正创建一个证明。

300
00:31:07,500 --> 00:31:15,880
因为由于我们使用了哈希，因此您需要验证带有预期的节点字节

301
00:31:15,880 --> 00:31:24,540
哈希，您基本上需要哈希所有节点数据。

302
00:31:24,539 --> 00:31:30,680
这意味着即使分支实际上是16，也意味着在每个节点中

303
00:31:30,680 --> 00:31:35,339
多达16个值，这可能很大。

304
00:31:35,339 --> 00:31:45,399
对于垂直树，由于我们正在使用此向量承诺，因此您并不是您的确

305
00:31:45,399 --> 00:31:48,079
需要提供所有向量。

306
00:31:48,079 --> 00:31:55,539
如果您记得验证功能，只需要承诺，一个小的证明和索引

307
00:31:55,539 --> 00:31:59,759
和您要证明的价值，但实际上并不是其余的向量。

308
00:31:59,759 --> 00:32:05,579
所以这真的很好，因为这意味着我们正在制作这个分支因素

309
00:32:05,579 --> 00:32:11,619
更大，这并没有真正影响您如何证明单个元素的影响

310
00:32:11,619 --> 00:32:15,319
向量，或该节点。

311
00:32:15,319 --> 00:32:18,480
因此，这是为什么这件事起作用的核心。

312
00:32:20,960 --> 00:32:24,919
好吧，所以让我们跳起来再谈更多

313
00:32:24,919 --> 00:32:29,859
关于信息如何存储树的叶子。

314
00:32:30,720 --> 00:32:33,639
因此，如果您还记得树的叶子

315
00:32:33,639 --> 00:32:36,960
是256个元素的向量。

316
00:32:37,899 --> 00:32:42,720
因此，我们存储通常的平衡，节点，冷哈希，

317
00:32:42,720 --> 00:32:46,059
您知道，就像有关帐户的一般信息。

318
00:32:47,240 --> 00:32:49,700
对于智能合约，

319
00:32:50,059 --> 00:32:53,880
我们有更多的空间来存储一些额外的东西。

320
00:32:54,960 --> 00:32:56,279
在当前的EIP中，

321
00:32:56,620 --> 00:33:00,180
我们存储的是第一个64个存储插槽

322
00:33:00,180 --> 00:33:05,779
还有前128个冷块。

323
00:33:07,079 --> 00:33:10,380
我会解释一下很快的冷块，

324
00:33:10,539 --> 00:33:12,440
但是只要忍受我。

325
00:33:12,720 --> 00:33:22,600
因此，这个想法是我们所说的帐户标题，因此对应的叶子节点

326
00:33:22,600 --> 00:33:31,319
在一个帐户上，它具有与我们今天相同的信息。

327
00:33:31,319 --> 00:33:38,680
对于智能合约，我们利用此额外的空间来包装他们的可能信息

328
00:33:38,680 --> 00:33:48,220
这将被访问，这是呼叫开始的地方，呼叫的开始和

329
00:33:48,220 --> 00:33:58,320
第一个存储插槽，可能会在交易中使用一些概率。

330
00:33:58,320 --> 00:34:02,940
其余的存储插槽和其余的呼叫块仍然存储，但不是真的

331
00:34:02,940 --> 00:34:04,660
在帐户的提升节点中。

332
00:34:04,660 --> 00:34:12,820
存储在其他升降机中。我稍后会解释一下。所以，我在这里碰了一点

333
00:34:12,820 --> 00:34:19,139
冷块的概念。如果您还记得，在第一个幻灯片之一上，我告诉过你

334
00:34:19,700 --> 00:34:29,460
执行证人，除了余额和存储插槽外，还必须包括必要的代码

335
00:34:29,460 --> 00:34:39,780
验证块。因此，您应该知道合同的完整圈子

336
00:34:39,780 --> 00:34:47,300
代码是块的。因此，将代码分解是代码如何存储在树中的过程的一部分。

337
00:34:47,300 --> 00:35:02,800
这种工作方式是我们基本上分组，我们基本上将合同代码切成31分。

338
00:35:02,800 --> 00:35:05,600
字节组。

339
00:35:05,600 --> 00:35:13,080
因此，我们创建了一个32个字节的值，其中第一个字节是我们使用的特殊字节

340
00:35:13,079 --> 00:35:20,239
真正解决了我现在将在一分钟内解释的特定问题。

341
00:35:20,239 --> 00:35:26,940
但基本上，如果您查看此图像，您会看到32字节代码块

342
00:35:26,940 --> 00:35:32,599
第一个特殊字节，然后是代码的31个字节。

343
00:35:32,599 --> 00:35:40,719
下一个代码块具有此额外的字节和下一个31个字节，您要这样做直到结束

344
00:35:40,719 --> 00:35:48,399
控制代码。因此，如果您还记得，EVM中有一些说明

345
00:35:49,759 --> 00:35:58,319
需要多个字节。因此，例如，如果您执行两个指令，那意味着

346
00:35:59,439 --> 00:36:07,759
或推10或其他

347
00:36:07,760 --> 00:36:13,280
有些字节是一个大块的一部分，还有其他类似的字节，与

348
00:36:13,280 --> 00:36:20,560
在下一个块中，所以这个多余的字节基本上试图发出数字数量

349
00:36:22,160 --> 00:36:26,800
从一开始，从这个代码块实际上是一个以前的延续

350
00:36:29,360 --> 00:36:36,160
在上一块中按X指令，但这只是并不是那么复杂

351
00:36:36,159 --> 00:36:39,399
或至少比这更复杂。

352
00:36:43,079 --> 00:36:48,079
好吧，今天，每当您想访问某个状态时

353
00:36:48,359 --> 00:36:50,379
在树上，在标记潜在树中，

354
00:36:50,379 --> 00:36:52,539
您基本上使用k-check hash函数

355
00:36:52,539 --> 00:36:57,539
要计算该帐户的树键是什么，好吗？

356
00:36:59,759 --> 00:37:01,799
对于工件树，我们不使用k-check，

357
00:37:01,799 --> 00:37:04,000
同样，这不是零知识友好的

358
00:37:04,000 --> 00:37:09,440
这不是真的很友好，所以我们要真正使用凯奇克，我们使用的是

359
00:37:09,440 --> 00:37:15,360
这是一种基于椭圆形的哈希功能，称为人哈希

360
00:37:18,639 --> 00:37:24,960
基本上是通过这种定义来解释的，我在这里给出了一些颜色

361
00:37:24,960 --> 00:37:34,880
真正有助于理解。因此，这种工作的方法是我们有一个树密钥函数

362
00:37:34,880 --> 00:37:43,360
接收您要访问某种状态的帐户的地址。一些树索引值和

363
00:37:44,800 --> 00:37:50,000
一些子指数值。好的？这些树索引和子指数是您可能的名称

364
00:37:50,000 --> 00:37:59,039
这对您没有任何意义。但是在那里握住一秒钟。因此，此3K功能的工作方式

365
00:37:59,039 --> 00:38:10,000
它基本上是在做一个尺寸的向量的向量承诺。所以，我们有第一个

366
00:38:10,000 --> 00:38:15,760
元素是这个固定的数字。这是有原因的，但让我们将其作为固定数字。

367
00:38:15,760 --> 00:38:24,140
下一个项目是地址的最重要的16个字节。

368
00:38:24,140 --> 00:38:29,800
下一个是地址的16个最不重要的字节。

369
00:38:29,800 --> 00:38:32,800
我们在这里对树索引也这样做。

370
00:38:32,800 --> 00:38:33,640
好的？

371
00:38:33,640 --> 00:38:38,840
因此，这项承诺为我们带来了32字节的价值。

372
00:38:38,840 --> 00:38:42,280
我们基本上采用了前31个字节

373
00:38:42,280 --> 00:38:46,039
我们附加了子指数，这是一个单个字节。

374
00:38:46,039 --> 00:38:49,740
所以我们有一个32个字节树键，好吗？

375
00:38:50,440 --> 00:38:52,680
所以这是一个非常抽象的功能

376
00:38:52,680 --> 00:38:54,220
收到地址的

377
00:38:54,220 --> 00:38:56,460
与您要访问的状态有关

378
00:38:56,460 --> 00:38:59,260
这两个值，好吗？

379
00:38:59,780 --> 00:39:01,640
而且您有树钥匙。

380
00:39:03,900 --> 00:39:06,059
好吧，让我们走吧，让我们尝试一下

381
00:39:06,059 --> 00:39:07,019
在一个具体示例中。

382
00:39:07,019 --> 00:39:11,820
假设我们想知道一个帐户平衡的树密钥。

383
00:39:13,019 --> 00:39:16,699
好的，所以您要做的是您必须使用我们之前解释的此功能。

384
00:39:17,420 --> 00:39:21,980
您将地址放在这里，回应您想知道余额的地址。

385
00:39:22,780 --> 00:39:26,940
您将使用等于零的树索引，好的，这是定义。

386
00:39:27,980 --> 00:39:36,860
然后，您将想要的状态放在这里，如果是余额，则必须放置一个状态

387
00:39:36,860 --> 00:39:46,220
在这里可以，但是每个部分嗯

388
00:39:46,220 --> 00:39:53,420
子指数基本上是您要访问的向量中哪个索引的位置

389
00:39:53,420 --> 00:40:00,940
平衡的情况是，在NONCE的情况下，它是两个，您可以在IP中找到它

390
00:40:01,660 --> 00:40:06,300
然后您进行此计算，并且您可以棘手，并且可以在树上访问它，

391
00:40:06,300 --> 00:40:13,580
找到想要的东西。如果您还记得，在帐户标题中，我们还存储了这些特别的

392
00:40:14,140 --> 00:40:20,539
存储插槽和这些第一个冷块。因此，如果您想访问第一个

393
00:40:21,260 --> 00:40:28,539
存储插槽零，您基本上与此处相同，但是您放置了正确的索引

394
00:40:28,539 --> 00:40:31,840
这与这个特殊的冷块一样。

395
00:40:34,119 --> 00:40:37,840
对于第一个64中的其余存储插槽

396
00:40:37,840 --> 00:40:41,980
对于第一个128的其余冷块

397
00:40:41,980 --> 00:40:44,239
您必须进行其他计算，

398
00:40:45,099 --> 00:40:46,920
在IP中也解释了

399
00:40:48,480 --> 00:40:52,000
这为您提供了计算树索引的方法

400
00:40:53,119 --> 00:40:57,139
它是该存储插槽的Vindex。

401
00:40:57,139 --> 00:40:59,819
好的，冷块也一样。

402
00:40:59,819 --> 00:41:01,659
假设您想要冷藏

403
00:41:01,659 --> 00:41:04,619
我知道，1,000。

404
00:41:04,619 --> 00:41:06,519
因此，它基本上将1,000个

405
00:41:06,519 --> 00:41:08,900
您添加它是恒定的，

406
00:41:08,900 --> 00:41:10,379
您有此块ID。

407
00:41:11,519 --> 00:41:14,639
这样，您可以计算树索引

408
00:41:14,639 --> 00:41:17,059
和子指数，

409
00:41:17,059 --> 00:41:18,480
然后您执行树密钥功能

410
00:41:18,480 --> 00:41:20,359
我们在上一个幻灯片中解释了

411
00:41:20,359 --> 00:41:23,139
而且您得到了树钥匙，好吗？

412
00:41:23,139 --> 00:41:29,859
这可能是更复杂的部分，可能需要几分钟

413
00:41:29,859 --> 00:41:37,299
要消化它，请消化它，因此，如果听起来令人困惑，请不要担心。

414
00:41:37,299 --> 00:41:42,639
只需尝试稍后再回到这张幻灯片，希望这将是有道理的。

415
00:41:42,639 --> 00:41:49,679
将此常数添加到存储插槽和冷块的主要思想基本上是

416
00:41:49,679 --> 00:41:58,239
一种分区此地址的地址空间的方法，这样俩都不会重叠，

417
00:41:58,239 --> 00:42:05,359
好的？因为这实际上是一个很大的数字，基本上是这三个索引

418
00:42:05,359 --> 00:42:08,639
储存插槽和冷​​块并没有真正重叠。

419
00:42:11,679 --> 00:42:19,039
好的，所以现在我们将稍微切换主题并谈论气体会计。我认为

420
00:42:19,039 --> 00:42:22,340
Guillaume在这里，也许他想继续。

421
00:42:22,340 --> 00:42:24,880
是的，我不知道你们是否能听到我的声音。

422
00:42:24,880 --> 00:42:29,300
是的，我们可以听到您的声音，但是也许在我们在这里切换主题之前，

423
00:42:29,300 --> 00:42:34,300
这里的聊天中有几个问题，可能是...

424
00:42:34,300 --> 00:42:36,199
抱歉，在我们解决问题之前，

425
00:42:36,199 --> 00:42:39,739
我只是发表了一条评论，可以给上一张幻灯片。

426
00:42:39,739 --> 00:42:41,440
当然，太好了。

427
00:42:41,440 --> 00:42:43,000
是的，只是，是的，

428
00:42:43,000 --> 00:42:44,599
域存储偏移确实很大，

429
00:42:44,599 --> 00:42:47,880
但最重要的是，代码大小本身是有限的。

430
00:42:47,880 --> 00:42:49,680
我们想增加代码的大小，

431
00:42:49,680 --> 00:42:53,660
但是我们永远不会将其增加到主存储的大小

432
00:42:53,660 --> 00:42:55,160
抵消。

433
00:42:55,160 --> 00:42:57,599
好吧，基本上永远不应该发生冲突。

434
00:43:00,260 --> 00:43:00,880
知道了。

435
00:43:00,880 --> 00:43:01,380
谢谢。

436
00:43:07,480 --> 00:43:11,160
你愿意迅速穿过吗

437
00:43:11,160 --> 00:43:14,019
默克尔树的检索如何变化

438
00:43:14,019 --> 00:43:16,680
与默克尔树相比？

439
00:43:16,679 --> 00:43:20,679
问题就像计算额外承诺有什么好处

440
00:43:27,559 --> 00:43:33,239
嗯，您可能喜欢伯克树的性能与标记潜在树相比

441
00:43:34,919 --> 00:43:41,960
我相信，当您正确检索数据时，当您正确地检索数据时，嗯

442
00:43:41,960 --> 00:43:49,240
使用经纪人Tweez的密码学比进行哈希重得多。所以，做哈希

443
00:43:49,240 --> 00:43:57,159
在CPU中确实非常非常快，非常非常快。不幸的是，进行椭圆操作很多

444
00:43:57,159 --> 00:44:05,320
慢点。基本上，这是试图使经纪人的加密术的权衡取舍

445
00:44:05,320 --> 00:44:13,880
友好的蛇。因此，这基本上是一个权衡。我们已经做了很多工作来制造这一切

446
00:44:13,880 --> 00:44:20,600
加密实施尽可能快。但是，即使我们确实尝试做最好的事情

447
00:44:20,600 --> 00:44:27,559
它可能永远不会像默克尔·帕特里夏（Merkle Patricia）树那样快。

448
00:44:27,559 --> 00:44:33,639
因此，这基本上是一个决定的权衡。

449
00:44:33,639 --> 00:44:38,900
我们有一些好处，但我们必须支付一些费用。

450
00:44:38,900 --> 00:44:42,519
酷，这很有意义。

451
00:44:42,519 --> 00:44:46,360
马里奥，当我们在这里时，您现在还想遇到其他问题吗？

452
00:44:46,360 --> 00:44:53,400
有一个疑问，Verkult树实施是否具有隐藏属性

453
00:44:53,400 --> 00:45:03,079
是的承诺是否隐藏在这里是否适用，uh u n o n o n u n n uk n us taking uh binding属性

454
00:45:03,079 --> 00:45:08,760
并不是真的隐藏UH，因为隐藏没有意义，因为这一切国家都是公开的

455
00:45:09,480 --> 00:45:15,639
因此，承诺并不需要避免泄漏信息或或类似的UM

456
00:45:15,639 --> 00:45:22,599
是的，是的，是的，是的，是的，是的，谢谢，是的，我想我们可以

457
00:45:22,599 --> 00:45:31,159
现在继续前进。 Guillaume？是的，我不知道，我可以分享我的屏幕吗？我不知道它是否会起作用。

458
00:45:31,159 --> 00:45:44,319
是的，您在这里有现在的按钮。共享屏幕，好的，我想它会去

459
00:45:44,320 --> 00:45:52,960
分享我的整个屏幕哇，您也可以上传演示文稿，或者我的意思是它是一样的

460
00:45:52,960 --> 00:46:00,780
演示只是我的屏幕可能太大了，因为整个好吧，让我

461
00:46:00,780 --> 00:46:16,300
尝试。您会告诉我它是否有效。开始了。哦好的。开始了。好的。那起作用吗？

462
00:46:18,780 --> 00:46:20,700
是的。是的。完美的。

463
00:46:20,699 --> 00:46:31,980
它。所以我要谈论气体变化，因为我们改变了，好吧，我们变得非常沉重

464
00:46:31,980 --> 00:46:37,719
更改数据模型，应该很明显。所以问题是，我们如何更新气体

465
00:46:37,719 --> 00:46:49,559
反映这一点的模型？而第一个拥有的直觉是，我们不再试图

466
00:46:49,559 --> 00:46:57,480
减少IO的量，对吗？我们不再试图减少状态规模的增长，

467
00:46:57,539 --> 00:47:01,320
或至少更准确地说，这并不是说我们不是要实现这一目标，而是

468
00:47:01,320 --> 00:47:12,039
为了防止这种情况。这不是我们的主要重点。我们的主要重点是让证人

469
00:47:12,039 --> 00:47:17,519
毫无根据的客户下载并解开包装和执行尽可能小。

470
00:47:18,360 --> 00:47:21,279
当然，如果最重要的话，我们知道，我们可以

471
00:47:21,599 --> 00:47:28,199
标记状态增长并确保快速的IO，这更好。

472
00:47:28,519 --> 00:47:30,639
但这不再是主要问题。

473
00:47:32,739 --> 00:47:40,840
所以，是的，我们正在寻找的是确保

474
00:47:40,840 --> 00:47:46,120
是的，我们减少了所有的动作

475
00:47:46,120 --> 00:47:48,600
这会增加证人的规模

476
00:47:48,600 --> 00:47:49,900
喜欢阅读状态。

477
00:47:50,019 --> 00:47:51,120
每次阅读状态时，

478
00:47:51,200 --> 00:47:54,600
您需要证明您阅读的内容在那里

479
00:47:55,180 --> 00:47:59,180
并包含您声称包含的价值。

480
00:48:00,000 --> 00:48:02,039
因此，您需要将其添加到证人中，

481
00:48:02,240 --> 00:48:03,620
因此，您需要将其添加到块中，

482
00:48:04,059 --> 00:48:05,900
因此，您需要证明这一点。

483
00:48:06,180 --> 00:48:10,620
因此，这是一种会产生气体影响的动作，

484
00:48:10,619 --> 00:48:11,779
那将有天然气成本。

485
00:48:12,079 --> 00:48:13,639
写信给国家同样的事情

486
00:48:13,639 --> 00:48:17,619
因为你写信给国家

487
00:48:17,619 --> 00:48:21,819
这样可以更新根承诺。

488
00:48:22,119 --> 00:48:24,119
所以你需要以某种方式

489
00:48:25,139 --> 00:48:27,900
好吧，首先，您需要为此更新付费

490
00:48:27,900 --> 00:48:33,199
这样您就不会轻易地继续编写数据

491
00:48:33,199 --> 00:48:38,980
这将增加计算量

492
00:48:38,980 --> 00:48:41,199
不付钱。

493
00:48:42,280 --> 00:48:45,980
一件事，我的意思是，伊格纳西奥已经提到过，

494
00:48:46,260 --> 00:48:50,240
像现在一样，代码是树的一部分。

495
00:48:50,860 --> 00:48:53,639
那是因为当我们执行代码时，

496
00:48:54,559 --> 00:48:58,619
我们需要证明我们执行的代码

497
00:48:58,619 --> 00:48:59,800
也是国家的一部分，

498
00:48:59,860 --> 00:49:01,800
我们不执行一些随机代码

499
00:49:01,800 --> 00:49:03,440
那是来自无处的。

500
00:49:03,440 --> 00:49:13,780
因此，我们还需要更改来宾模型以说明执行的内容，因为

501
00:49:13,780 --> 00:49:19,360
被执行的是添加到证人中，并将使证人更大，因此

502
00:49:19,360 --> 00:49:20,599
块更大。

503
00:49:20,599 --> 00:49:25,500
因此，实际上有五个成本变化。

504
00:49:25,500 --> 00:49:31,740
我首先要说的一件事是使已经有什么区别

505
00:49:31,739 --> 00:49:38,839
已经访问而不是访问的是已经存在的东西

506
00:49:38,839 --> 00:49:41,659
在当前状态模型中，带有访问列表。

507
00:49:41,819 --> 00:49:47,219
因此，我们要重复使用此访问列表方案，因为一旦添加了东西

508
00:49:47,219 --> 00:49:49,379
对证人来说，证人不再成长。

509
00:49:49,619 --> 00:49:53,219
因此，这只是第一次必须支付高昂的成本。

510
00:49:53,500 --> 00:49:58,979
但是一旦将其添加到证人中，这只是记忆中阅读的问题

511
00:49:58,979 --> 00:49:59,359
缓存。

512
00:49:59,360 --> 00:50:03,019
因此，我们有一个现已存在于以太坊中的模型。

513
00:50:03,180 --> 00:50:04,620
它称为访问列表。

514
00:50:05,240 --> 00:50:08,820
因此，我们基本上采用相同的模型，然后改变成本。

515
00:50:09,940 --> 00:50:16,680
除了我们采用新树的一些模型，对吗？

516
00:50:16,860 --> 00:50:26,400
如果您还记得，我们有这种计算树中值的位置。

517
00:50:26,400 --> 00:50:30,440
这个想法是因为垂直节点宽度为256

518
00:50:30,440 --> 00:50:33,800
基本上是最后一个字节

519
00:50:33,800 --> 00:50:37,940
所有分组的值

520
00:50:37,940 --> 00:50:42,220
256块将是

521
00:50:42,220 --> 00:50:45,940
彼此旁边，每次

522
00:50:45,940 --> 00:50:50,480
我们要做的是每次我们访问其中一个小组

523
00:50:50,480 --> 00:50:54,099
我们将付费，例如巨额成本，但每一次

524
00:50:54,099 --> 00:51:01,279
小组中的个人叶子首次可以便宜得多，甚至更便宜

525
00:51:01,279 --> 00:51:07,559
第二次访问。到目前为止，我还没有谈论的另一个问题，直到现在

526
00:51:08,380 --> 00:51:16,219
是的，我们希望将访客模型适合新的存储模型。但与此同时

527
00:51:16,219 --> 00:51:22,259
我们不想打破可能尝试优化的每个应用程序

528
00:51:22,260 --> 00:51:27,080
给定的气体模型。因此，所有这些价值观，它们似乎都是随机的，但是它们已经

529
00:51:27,080 --> 00:51:33,000
实际上，从气体消耗角度来看，或多或少任何变化都没有改变，

530
00:51:33,420 --> 00:51:37,460
从EVM的角度来看。从客户的角度来看，这是完全不同的。

531
00:51:37,940 --> 00:51:44,740
但是从DAP的角度来看，它相当相似。它不是完美的，但是很近。

532
00:51:46,080 --> 00:51:51,420
是的，所以想法是我们摆脱了过去的所有旧冷藏成本

533
00:51:51,420 --> 00:51:56,420
使用访问列表，我们将其替换为此模型。

534
00:51:59,180 --> 00:52:02,760
是的，触发这些费用的事件是什么？

535
00:52:06,000 --> 00:52:08,860
好吧，每当您访问州本身时，

536
00:52:08,860 --> 00:52:10,659
因此，如果您存储，如果您加载，

537
00:52:11,500 --> 00:52:13,720
但是现在，如果您检查余额，

538
00:52:13,720 --> 00:52:17,820
这也意味着您必须进入树。

539
00:52:17,820 --> 00:52:20,139
我的意思是，好的，诚然，

540
00:52:20,139 --> 00:52:23,719
这就是您已经要做的，因此在这方面并没有太大变化。

541
00:52:24,900 --> 00:52:31,679
但是，是的，所以每次您访问州时，我应该说的话，

542
00:52:32,799 --> 00:52:39,779
您就像保持平衡，具有自我毁灭，使用代码副本一样，您将产生这些费用。

543
00:52:39,780 --> 00:52:50,720
改变的一件事是，我们不收取提款费用。

544
00:52:50,880 --> 00:52:52,420
需要添加提款。

545
00:52:52,540 --> 00:53:03,180
例如，我说取款，但也说denkun信标块根的预编译。

546
00:53:04,220 --> 00:53:05,840
实际上，系统合同，对不起。

547
00:53:05,840 --> 00:53:12,420
所有这些价值都添加到证人中，但没有人为他们付费，所以这些费用不会得到

548
00:53:12,420 --> 00:53:18,780
收费UM，这是同一回事，因为您支付了21 000燃气的前期费用来发送

549
00:53:18,780 --> 00:53:26,260
交易，我们不向UH收取这些费用，以发送和发送者和收件人

550
00:53:26,260 --> 00:53:32,920
交易中的一切，但其他所有内容都被收取，包括我们说的合同代码

551
00:53:32,920 --> 00:53:41,059
嗯，是的，就像我之前说过的那样，您只收费，嗯，第一次，对吗？

552
00:53:41,099 --> 00:53:44,500
因为那样，嗯，损坏就造成了。

553
00:53:44,579 --> 00:53:48,260
您将数据添加到证人中。

554
00:53:48,260 --> 00:53:53,760
因此，它变成了温暖的访问成本，就像从记忆中阅读的成本一样

555
00:53:53,760 --> 00:53:59,680
并且不从磁盘或，呃，呃，或者，呃，任何其他类似的操作加载。

556
00:53:59,679 --> 00:54:11,019
因此，是的，基本上，我不知道Inacio是否想在这里接管，但是我可以继续。

557
00:54:11,019 --> 00:54:13,579
我认为是的。

558
00:54:13,579 --> 00:54:21,659
是的，您有这个新的气体会计，您拥有所有新的加密货币，所有新的树格式，

559
00:54:21,659 --> 00:54:23,819
所有新协议。

560
00:54:23,819 --> 00:54:25,899
这是终点吗？

561
00:54:25,899 --> 00:54:27,480
不。

562
00:54:27,480 --> 00:54:30,559
因为我们需要转换状态。

563
00:54:30,559 --> 00:54:34,639
我们具有MPT格式的状态。

564
00:54:34,639 --> 00:54:37,139
有十亿个叶子。

565
00:54:37,139 --> 00:54:42,900
这就是200，好吧，现在更像300千兆字节。

566
00:54:42,900 --> 00:54:48,300
或至少到我们期望开始使用垂直树时。

567
00:54:48,300 --> 00:54:51,619
因此，我们必须以某种方式转换一切。

568
00:54:51,619 --> 00:54:59,500
这并不容易，因为我们必须这样做，因为我们使用不同的哈希模型来存储

569
00:54:59,500 --> 00:55:07,359
树上的数据，我们必须重新进行所有内容。我们一直在研究几种策略，

570
00:55:07,359 --> 00:55:14,259
其中一些人更加集中，有些人确实是分散的，但很重

571
00:55:14,260 --> 00:55:24,840
在计算上。我们定居在覆盖树上，这是您的方法，是的，所以您

572
00:55:24,840 --> 00:55:33,060
从叉子开始，就在叉子之前，您从MPT树开始，对吗？以及一切

573
00:55:33,260 --> 00:55:40,340
我不确定如何称呼它，就像绿蓝色是在

574
00:55:40,340 --> 00:55:47,059
叉子和紫色的一切都是我们的价值观，在叉子之后被写入州

575
00:55:47,059 --> 00:55:52,720
目前，我们就在叉子之前，所以没有紫色值，我们有这个迭代器

576
00:55:52,720 --> 00:55:59,579
随着时间的流逝，它会像迭代器的大步一样

577
00:55:59,579 --> 00:56:07,420
选择的给定值，以便大多数节点或至少您的平均节点可以遵循

578
00:56:07,420 --> 00:56:17,099
可以复制每个块的叶子很多，而不会缺少插槽，因此能够跟随网络。

579
00:56:17,980 --> 00:56:23,099
顺便说一句，那些怪异的红色三角形代表了，我忘了提到

580
00:56:25,019 --> 00:56:30,300
MPD树的内部节点。因此，红色三角形是内部节点，

581
00:56:30,300 --> 00:56:36,320
蓝绿色的正方形是叶子。

582
00:56:37,580 --> 00:56:39,060
因此，当叉子发生时，

583
00:56:39,360 --> 00:56:42,220
我们从新的垂直路线开始

584
00:56:42,220 --> 00:56:44,360
被认为是

585
00:56:45,260 --> 00:56:48,320
以抽象的方式

586
00:56:48,460 --> 00:56:50,760
它放在MPG树上。

587
00:56:51,900 --> 00:56:54,039
这条新的垂直路线

588
00:56:54,039 --> 00:56:56,539
就是所有写作最终的地方。

589
00:56:56,620 --> 00:56:59,440
因此，如果您为树编写新值，

590
00:56:59,440 --> 00:57:06,500
这是一个紫色的价值，它最终将在覆盖垂直树上，如果你嗯，哦，是的，

591
00:57:06,500 --> 00:57:15,340
最重要的是每个块迭代器移动n值，所以在这里n等于两个，所以绿色

592
00:57:15,340 --> 00:57:20,920
绿色箭头代表迭代器的头部，它扫了两片叶子

593
00:57:20,920 --> 00:57:27,320
移动或更精确地复制到垂直树中，现在我想寻找

594
00:57:27,320 --> 00:57:32,320
到目前在默克尔树上的粉红色广场，

595
00:57:33,740 --> 00:57:37,360
我们要做的是我们第一次尝试阅读

596
00:57:37,360 --> 00:57:40,700
从virkle树中，我们在那里找不到。

597
00:57:40,700 --> 00:57:45,700
因此，我们去默克尔树，只读，

598
00:57:46,800 --> 00:57:48,300
我们在那里找到它。

599
00:57:48,300 --> 00:57:52,700
我们继续这样，因此每个块的迭代器，

600
00:57:52,700 --> 00:57:55,680
迭代器继续复制值，

601
00:57:55,679 --> 00:57:57,579
例如，您可以看到

602
00:57:57,579 --> 00:58:02,579
过去在MPT中的一个值已被凝结，

603
00:58:03,799 --> 00:58:06,259
对不起，它没有被撞倒，

604
00:58:06,259 --> 00:58:08,739
这是为MPT复制的价值

605
00:58:08,739 --> 00:58:09,899
但是它被覆盖了，

606
00:58:09,899 --> 00:58:13,179
因此，MPT冻结了，它不会改变，

607
00:58:13,179 --> 00:58:16,699
但是价值观本身不断复制

608
00:58:16,699 --> 00:58:20,500
当然，除非他们覆盖该值的新版本。

609
00:58:20,500 --> 00:58:34,000
最终，或者至少在确定叉子块时，您有能力删除所有MPT内部节点。

610
00:58:34,119 --> 00:58:35,440
因此，您可以释放很多空间。

611
00:58:37,360 --> 00:58:42,320
很抱歉，我不知道幻灯片发生了什么，并在这里格式化。

612
00:58:42,320 --> 00:58:58,940
但是，想法是，当所有叶子（因为迭代器都不断进步时垂直树。

613
00:58:59,340 --> 00:59:02,039
因此，您有能力删除所有内部数据。

614
00:59:03,620 --> 00:59:11,180
还有一件事，就像这个模型有点简化，所以我并没有在这些幻灯片上真正代表它。

615
00:59:11,179 --> 00:59:21,759
但是您要知道的是，目前我代表MPT和

616
00:59:21,759 --> 00:59:24,299
垂直树的顺序相同，但不是。

617
00:59:24,379 --> 00:59:25,599
这只是一个简化。

618
00:59:28,059 --> 00:59:31,319
是的，这是该方法的要旨。

619
00:59:32,039 --> 00:59:38,379
问题是，我们如何设定迭代器的大步？

620
00:59:38,699 --> 00:59:40,679
我们有一些模型。

621
00:59:41,179 --> 00:59:46,079
基本上看来我们负担得起，

622
00:59:47,019 --> 00:59:48,460
我们想要的是

623
00:59:48,699 --> 00:59:52,179
这是我们复制多少叶子之间的权衡

624
00:59:52,179 --> 00:59:54,119
以及多少个机器

625
00:59:54,559 --> 00:59:58,079
我们对丢失的网络的哪一部分

626
00:59:58,079 --> 01:00:01,440
在过渡期间。

627
01:00:01,440 --> 01:00:05,539
当然，我们不能损失超过三分之一

628
01:00:05,539 --> 01:00:06,159
网络。

629
01:00:06,339 --> 01:00:07,219
那将是至关重要的。

630
01:00:07,219 --> 01:00:16,279
但是我们可以看到，已经有5,000片叶子，我们绝对不会损失太多。

631
01:00:16,459 --> 01:00:29,159
我们有能力损失超过20％的网络，并在两个月内完成过渡。

632
01:00:29,159 --> 01:00:34,119
所以我认为，鉴于我们已经完成了测试，

633
01:00:34,420 --> 01:00:40,500
我们很自在地每块做10,000片叶子。

634
01:00:40,500 --> 01:00:45,460
因此，我们可以在15天内进行转换，

635
01:00:46,319 --> 01:00:47,339
这还不错。

636
01:00:48,920 --> 01:00:52,139
但是，是的，最终，我们需要进行更多测试。

637
01:00:52,699 --> 01:00:55,319
我们甚至可能发现20,000片叶子还可以

638
01:00:55,320 --> 01:00:59,200
因为随着我们的发展

639
01:00:59,480 --> 01:01:01,039
连接到网络的机器

640
01:01:01,039 --> 01:01:02,160
越来越强大。

641
01:01:03,580 --> 01:01:05,400
但是，是的，这仍然是

642
01:01:05,580 --> 01:01:07,380
这不是一个悬而未决的问题，

643
01:01:07,600 --> 01:01:08,820
但这仍然是一个参数

644
01:01:08,820 --> 01:01:10,920
在叉子之前可以改变。

645
01:01:13,920 --> 01:01:14,400
正确的。

646
01:01:14,780 --> 01:01:16,380
因此，再次，Ignacio，

647
01:01:16,440 --> 01:01:18,260
我不知道您是否打算谈论这个，

648
01:01:18,260 --> 01:01:19,100
但是我可以做到。

649
01:01:20,700 --> 01:01:21,220
好的。

650
01:01:23,300 --> 01:01:24,740
所以就像我说的，

651
01:01:25,320 --> 01:01:29,080
对不起。

652
01:01:29,480 --> 01:01:29,620
是的。

653
01:01:31,840 --> 01:01:32,440
你好？

654
01:01:38,400 --> 01:01:39,700
好吧，我继续。

655
01:01:41,820 --> 01:01:45,340
因此，就像我说的那样，我们必须重新重新进行所有内容。

656
01:01:46,620 --> 01:01:49,559
但是问题是到目前为止

657
01:01:50,140 --> 01:01:52,559
不是每个人都存储了，

658
01:01:52,559 --> 01:02:00,039
实际上，大多数人都非常非常少，在其数据库中存储了所有关键哈希的前图。

659
01:02:00,920 --> 01:02:03,360
就像70 GB，或多或少。

660
01:02:04,420 --> 01:02:08,360
所以，是的，如果不需要的话，为什么要拿70千兆字节？

661
01:02:09,519 --> 01:02:12,639
问题在于，您必须进行过渡。

662
01:02:12,699 --> 01:02:13,539
你必须有它们。

663
01:02:14,980 --> 01:02:22,380
因此，我们并不是真的 - 我们必须找到一种分发这些前图像的方法。

664
01:02:22,559 --> 01:02:35,440
为此，我们研究了几个步骤，几种方法，但事实是

665
01:02:35,440 --> 01:02:47,239
Erdogan和REFF通过前图片存储数据，因此他们有能力生成文件

666
01:02:47,239 --> 01:02:48,599
然后可以分发。

667
01:02:48,599 --> 01:02:54,439
而且它并不像转换整个数据库那样糟糕

668
01:02:54,439 --> 01:02:56,879
因为整个数据库非常大。

669
01:02:57,599 --> 01:03:00,039
验证，如果您获得了前图，

670
01:03:00,119 --> 01:03:03,739
您可以浏览自己的数据库，并验证您是否拥有所有前图。

671
01:03:04,500 --> 01:03:08,679
因此，它便宜得多，而且更安全。

672
01:03:08,679 --> 01:03:18,559
但是结果是您不能立即开始扫荡。

673
01:03:18,839 --> 01:03:22,899
您需要有一些时间才能生成前图像，

674
01:03:24,379 --> 01:03:29,379
就像冻结的默克尔树的前图像一样。

675
01:03:29,379 --> 01:03:35,279
因此，我们会给自己一个月，对不起，不是一个月，一个星期，

676
01:03:35,280 --> 01:03:40,000
在此期间，人声将其写入

677
01:03:40,320 --> 01:03:41,580
但是没有发生转换。

678
01:03:41,680 --> 01:03:43,060
所以我们仍然有两棵树。

679
01:03:44,340 --> 01:03:48,480
当客户收到前图像时，

680
01:03:48,480 --> 01:03:51,560
它很容易验证

681
01:03:51,560 --> 01:03:53,420
它有所有需要的前图

682
01:03:53,420 --> 01:03:56,780
因为这只是冷冻声带的前图像。

683
01:03:57,700 --> 01:03:59,400
然后是扫星星。

684
01:03:59,540 --> 01:04:01,180
当然，如果我们发现

685
01:04:01,240 --> 01:04:04,880
图像前分布有问题，

686
01:04:04,880 --> 01:04:08,320
我们总是可以进行紧急发布。

687
01:04:08,380 --> 01:04:10,900
它不是很棒，但是是

688
01:04:11,700 --> 01:04:15,380
至少我们有办法处理这一点。

689
01:04:16,920 --> 01:04:19,559
但是，是的，这仍然是一个空旷的问题，

690
01:04:20,860 --> 01:04:24,760
但这不是一个，并不像个大。

691
01:04:24,840 --> 01:04:27,800
因此，我们不会因为这个人而失去睡眠。

692
01:04:29,079 --> 01:04:32,880
然后我打算谈论的最后一件事

693
01:04:32,880 --> 01:04:35,640
是我们同步的方式。

694
01:04:36,119 --> 01:04:39,380
所以目前，只有一个客户

695
01:04:39,380 --> 01:04:42,220
已经实施了同步

696
01:04:42,599 --> 01:04:44,640
这是Snapsync的Verkle版本。

697
01:04:44,640 --> 01:04:47,240
但是我想给你的是概述

698
01:04:47,240 --> 01:04:50,380
您可以用Verkle树做什么，

699
01:04:50,480 --> 01:04:52,360
Verkle树如何简化同步。

700
01:04:53,300 --> 01:04:57,900
这个想法是您已经有了树的一部分

701
01:04:57,900 --> 01:04:59,820
包装在每个街区。

702
01:04:59,820 --> 01:05:03,860
所以这个想法是利用这一事实

703
01:05:03,860 --> 01:05:07,780
解决同步的功能

704
01:05:07,780 --> 01:05:09,580
并使同步更简单

705
01:05:09,580 --> 01:05:11,580
因此，您将从块端开始

706
01:05:11,580 --> 01:05:13,220
您加入网络的块

707
01:05:13,220 --> 01:05:14,900
然后您无情地执行

708
01:05:14,900 --> 01:05:19,080
但是当你走时，你不断重建树木

709
01:05:19,080 --> 01:05:22,900
因此您实际上可以积累所有叶子

710
01:05:22,900 --> 01:05:26,580
而且您知道您有最新版本的叶子

711
01:05:26,580 --> 01:05:28,000
这始终是最大的问题

712
01:05:28,000 --> 01:05:31,920
使用同步是因为，是的，

713
01:05:32,000 --> 01:05:34,880
为您提供了树的最新视图。

714
01:05:34,980 --> 01:05:36,519
因此，如果叶子没有被触摸，

715
01:05:37,559 --> 01:05:40,519
这意味着您有最新版本。

716
01:05:40,659 --> 01:05:45,219
只是来自以前的块。

717
01:05:46,519 --> 01:05:47,920
然后您在后台做什么

718
01:05:47,920 --> 01:05:49,860
您是开始下载吗，

719
01:05:50,079 --> 01:05:51,480
您开始询问周围的节点，

720
01:05:51,599 --> 01:05:55,579
所有叶子周围的完整节点

721
01:05:55,579 --> 01:06:00,420
到目前为止，在无状态的观点中尚未看到。

722
01:06:01,119 --> 01:06:04,319
您可以非常非常轻松地验证它们

723
01:06:04,319 --> 01:06:05,539
因为只是

724
01:06:06,000 --> 01:06:09,420
每次只会是树的一小部分。

725
01:06:09,519 --> 01:06:12,279
因此，您可以非常非常快地重新计算根本承诺，

726
01:06:13,079 --> 01:06:14,420
至少快速

727
01:06:14,420 --> 01:06:19,119
并验证您所拥有的是当前状态，

728
01:06:19,500 --> 01:06:21,719
至少适合您当前的视图。

729
01:06:21,719 --> 01:06:24,659
再一次

730
01:06:24,659 --> 01:06:27,019
这个过程甚至都没关系

731
01:06:27,019 --> 01:06:29,199
持续，因为您可以继续执行块

732
01:06:29,199 --> 01:06:30,939
无国籍

733
01:06:30,939 --> 01:06:32,359
直到那时

734
01:06:32,359 --> 01:06:34,500
是的，那是

735
01:06:34,500 --> 01:06:36,559
我想的几乎

736
01:06:36,559 --> 01:06:38,199
是的

737
01:06:38,199 --> 01:06:40,519
伊格纳西奥，我让你得出结论

738
01:06:40,519 --> 01:06:46,359
是的

739
01:06:46,359 --> 01:06:47,679
你能听到我吗？

740
01:06:48,619 --> 01:06:49,859
是的，好吧

741
01:06:49,860 --> 01:06:51,980
因为我的麦克风有问题。

742
01:06:53,160 --> 01:06:55,660
是的，这是演讲的结尾。

743
01:06:56,620 --> 01:07:01,519
我在这里留下了一个图像，就像我们为什么使用大象

744
01:07:01,519 --> 01:07:03,960
对于处女座树，这可能令人惊讶

745
01:07:03,960 --> 01:07:05,160
或不是很明显。

746
01:07:05,840 --> 01:07:09,620
所以我从纪前学到了大象是已知的

747
01:07:09,620 --> 01:07:13,680
为了摧毁树木或连根拔起树的树枝，

748
01:07:13,940 --> 01:07:18,980
这确实与我们试图做的事情相关

749
01:07:18,980 --> 01:07:22,280
对于以太坊协议，更改Markupobsidia

750
01:07:22,280 --> 01:07:23,539
树与另一棵树。

751
01:07:23,539 --> 01:07:28,280
所以我认为这种大象是吉祥物

752
01:07:28,280 --> 01:07:31,740
我认为是一个很好的主意

753
01:07:31,740 --> 01:07:34,079
Devops团队的Guillaume和Pari。

754
01:07:34,079 --> 01:07:36,139
所以这完全是pari。

755
01:07:36,139 --> 01:07:39,400
好吧，是的，对他很棒。

756
01:07:39,400 --> 01:07:46,619
而且我认为也许Sosh想说其他话。

757
01:07:46,619 --> 01:07:48,480
是的，真的很快，谢谢

758
01:07:48,480 --> 01:07:55,199
uh Ignacio Guillaume这里的每个人UH Ignacio和Guillaume只是想强调

759
01:07:55,199 --> 01:08:00,719
他们已经在垂直方面做了很多繁重的工作，所以很高兴

760
01:08:00,719 --> 01:08:06,079
他们的工作以及许多在垂直工作的人，我在这里很高兴扮演一小部分

761
01:08:06,880 --> 01:08:14,079
对于任何感兴趣的人，我们都有每两周一次的垂直实施者打电话

762
01:08:14,079 --> 01:08:19,760
当然，如果您想扮演更积极的角色，请欢迎聆听

763
01:08:19,760 --> 01:08:26,159
在以太坊r d和不和谐中，应该有一个方便的链接，但是的，每两周打电话

764
01:08:26,159 --> 01:08:39,039
继续这类讨论，真是太好了，非常感谢，我认为我们可以

765
01:08:39,039 --> 01:08:45,199
结束演示文稿让我看看我们是否有任何疑问，然后我们撕毁嗯

766
01:08:45,199 --> 01:08:50,800
非常感谢你们这三个嗯，嗯，这真是太好了

767
01:08:51,359 --> 01:08:57,039
所有深处的摄影和uh guillaume玻璃价格与移民表示感谢

768
01:08:57,039 --> 01:09:03,760
太多了，这是很多要消化的，但是我相信这可能是一些问题

769
01:09:03,760 --> 01:09:13,480
以前询问的一件事是关于量子后的安全性，Verkl是否有所改善

770
01:09:13,480 --> 01:09:18,300
在这种情况下，是否会使将来更容易交换某物

771
01:09:18,300 --> 01:09:21,159
量子安全。

772
01:09:21,159 --> 01:09:29,520
是的，所以我们在聊天中讨论的现实是所有基于椭圆的核心

773
01:09:29,520 --> 01:09:38,360
对于量子计算机而言，加密并不是安全的。所以实际上我们有，我的意思是

774
01:09:38,360 --> 01:09:44,540
对于量子，垂直树密码学不是安全的，所以这是时期。但是我们也有

775
01:09:44,540 --> 01:09:49,080
在协议中进行所有类型的更改，例如我们用于交易的签名

776
01:09:49,080 --> 01:09:55,360
是基于椭圆曲线的，因此我们必须改变签名的工作方式。 KCG承诺

777
01:09:55,359 --> 01:10:00,699
您正在看到斑点，或者您说这将是基于曲线的密码学，所以

778
01:10:00,699 --> 01:10:02,319
也打破。

779
01:10:02,319 --> 01:10:11,039
因此，通常我们会以我们对密码学和这个问题的看法的计划是每个计划

780
01:10:11,039 --> 01:10:15,239
使用该协议的密码学应具有量子安全的候选者。

781
01:10:15,239 --> 01:10:22,699
现在我们计划使用或介绍的任何新密码学都应有替代方案

782
01:10:22,699 --> 01:10:26,699
我们将来可以改变。

783
01:10:26,699 --> 01:10:35,519
这样做的是，这个量子密码学通常是非常新的，至少与

784
01:10:35,519 --> 01:10:43,559
我们现在使用的更稳定的密码学，而且还要慢得多，并且还有其他权衡

785
01:10:43,559 --> 01:10:47,899
像更大的签名或类似的东西。

786
01:10:47,899 --> 01:10:54,259
因此，这并不是一个简单的选择，嘿，只需使用量子安全加密

787
01:10:54,259 --> 01:11:01,699
还有其他权衡会影响UX或具有其他效果的其他权衡

788
01:11:01,699 --> 01:11:03,539
很糟糕。

789
01:11:03,539 --> 01:11:13,199
因此，每当这种风险变得更接近实用时，假设我们，我们就会

790
01:11:13,199 --> 01:11:18,639
应该真正开始切换这种不安全的加密

791
01:11:18,639 --> 01:11:19,519
到其他方案。

792
01:11:21,760 --> 01:11:24,179
Alexandre Drouinias-对，但这是重点。

793
01:11:24,179 --> 01:11:28,420
我们现在所做的工作可能必须重做，

794
01:11:28,420 --> 01:11:30,599
但是至少我们会做一次，

795
01:11:30,599 --> 01:11:33,899
因此，我们将了解发生了什么。

796
01:11:33,899 --> 01:11:38,619
是的，目前完全有道理

797
01:11:38,619 --> 01:11:42,760
专注于椭圆曲线，因为首先，

798
01:11:42,760 --> 01:11:44,220
仍然有待证明

799
01:11:44,220 --> 01:11:46,760
该量子计算确实在拐角处。

800
01:11:47,699 --> 01:11:50,619
这更重要

801
01:11:50,619 --> 01:11:54,500
它们可以打破椭圆曲线密码学。

802
01:11:55,140 --> 01:11:57,260
但是当这种情况发生时

803
01:11:57,840 --> 01:11:59,460
我们将准备再次切换。

804
01:12:03,460 --> 01:12:04,280
是的，很棒。

805
01:12:04,460 --> 01:12:05,119
是的，这很有意义。

806
01:12:05,320 --> 01:12:07,480
我对你们俩都这么多。

807
01:12:07,479 --> 01:12:17,879
关于计算开销的问题，这里是两个问题，但也许我们可以

808
01:12:17,879 --> 01:12:19,239
合并他们。

809
01:12:19,239 --> 01:12:29,719
因此，MPT的分支系数为16，而受欢迎的树有256个基准，

810
01:12:29,719 --> 01:12:36,339
链接或对带宽计算的权衡分析。

811
01:12:36,340 --> 01:12:43,380
围绕计算的另一个问题是在节点过渡上的过渡

812
01:12:43,380 --> 01:12:50,560
对于Virchow树，这是多少重的机器？

813
01:12:50,560 --> 01:13:04,480
是的，关于分支因素问题，所以特殊，例如魔术发生的地方

814
01:13:04,479 --> 01:13:09,279
因为broca树是分支因素没有一个，对这些没有影响

815
01:13:09,279 --> 01:13:17,679
我们必须在每个节点或每个向量上进行的开口。那里仍然有一个权衡

816
01:13:17,679 --> 01:13:25,119
因为分支因素，因此在任何Broca参数中，证明大小和验证

817
01:13:25,119 --> 01:13:31,039
时间，验证时间是在向量的大小上线性的。所以我们真的不能简单地喜欢

818
01:13:31,039 --> 01:13:38,880
选择100万个分支系数，然后将所有内容存储在单个矢量中。

819
01:13:38,880 --> 01:13:45,680
因此，分支因素和做成本之间仍然必须保持平衡

820
01:13:45,680 --> 01:13:51,279
用于验证验证者开口的开口。

821
01:13:51,279 --> 01:13:53,279
是的。

822
01:13:53,279 --> 01:13:57,420
从另一个角度来看，增加分支因素使其更加阴影感。

823
01:13:57,420 --> 01:14:02,000
因此，这需要更少的证明元素。

824
01:14:02,000 --> 01:14:12,380
是的，您必须在验证证明时间和

825
01:14:12,380 --> 01:14:17,940
多少帮助树的深度以及类似的事物。

826
01:14:17,940 --> 01:14:18,940
是的。

827
01:14:18,940 --> 01:14:24,180
我不知道，也许还有关于状态conversion依的另一个问题。

828
01:14:24,180 --> 01:14:31,520
因此，也许Guillaume希望稍后再补充，但是我们已经做了一些基准

829
01:14:31,520 --> 01:14:38,400
通常的台式机和摇滚5B作为较低，最低的设置硬件。

830
01:14:38,400 --> 01:14:50,960
而且我认为我们对每个块迁移可能10k键值感到舒适，

831
01:14:50,960 --> 01:14:59,199
在岩石5e中，但是我们当时所做的基准不包括4844

832
01:14:59,199 --> 01:15:02,640
在主网中加载，因为它不存在。

833
01:15:02,640 --> 01:15:11,939
因此，也许我们必须进行一些新的基准，以真正了解当前的主网

834
01:15:11,939 --> 01:15:19,460
加载um多么喜欢性能性能或喜欢的资源

835
01:15:19,460 --> 01:15:26,099
添加此额外的工作来进行每个块uh的转换，甚至决定是否真的是岩石5B或这是否真的

836
01:15:26,099 --> 01:15:33,219
低设置机器真的是对鼻子的合理期望

837
01:15:33,219 --> 01:15:41,539
conversion依我不知道吉利亚姆是否想说更多的话

838
01:15:41,539 --> 01:15:44,439
我似乎已经知道这是一个带宽问题。

839
01:15:45,699 --> 01:15:49,960
所以关键是，是的，

840
01:15:50,100 --> 01:15:54,899
这是证明的平均大小为150千容器。

841
01:15:55,300 --> 01:15:59,019
因此，我们的情况比斑点更糟。

842
01:16:00,539 --> 01:16:02,859
所以我们不是真的，我的意思是

843
01:16:02,979 --> 01:16:06,359
我们还没有真正对此做任何基准，

844
01:16:06,579 --> 01:16:09,239
但这是因为我们不期望什么都没有。

845
01:16:09,239 --> 01:16:14,779
所以这不是真的，我们没有任何问题

846
01:16:14,779 --> 01:16:21,420
嗯，很有趣的嗯，谢谢你，我是我想知道它的样子

847
01:16:21,420 --> 01:16:24,920
在无国籍客户的设置中，他们宣布是否会喜欢

848
01:16:24,920 --> 01:16:34,399
网络的另一个开销，所以听到嗯很棒，也许嗯，这很有趣

849
01:16:34,399 --> 01:16:43,000
因此，关于当前任务的问题，哪些挑战是正确的

850
01:16:43,000 --> 01:16:48,279
现在，正在解决的问题，路线图是什么，也许还有一些部分

851
01:16:48,279 --> 01:16:53,199
人们可以研究，开始做出贡献。

852
01:16:53,199 --> 01:17:00,359
我的意思是，当前的路线图是同步和转换，几乎是分发的。

853
01:17:00,359 --> 01:17:06,920
嗯，捐款好，有几个领域

854
01:17:06,920 --> 01:17:13,559
我最喜欢的，从未引起注意的是，um是在其他客户中实施UH的垂直树

855
01:17:13,559 --> 01:17:23,079
因此，我们在UH Geth的UM中实施了非常完整的实施

856
01:17:23,079 --> 01:17:27,640
以太坊，但在拉特中没有实施的实施。

857
01:17:28,519 --> 01:17:35,159
在阿拉贡，这很新生，所以我敢肯定他们可以欣赏一些工作。

858
01:17:36,439 --> 01:17:38,659
并得到一个，贝斯。

859
01:17:38,720 --> 01:17:42,960
Besu正在路上，但我敢肯定，他们也会感谢您的帮助。

860
01:17:44,300 --> 01:17:48,399
否则，有什么贡献的领域？

861
01:17:48,840 --> 01:17:50,699
好吧，我们想建立无国籍客户，

862
01:17:50,699 --> 01:17:53,439
因此，无状态客户是一个选择。

863
01:17:55,500 --> 01:17:57,859
否则

864
01:17:57,859 --> 01:18:00,359
这也没有得到很多关注，

865
01:18:00,359 --> 01:18:03,559
它与核心协议无直接相关，

866
01:18:03,559 --> 01:18:08,559
但这就是L2，Dapps的发展，

867
01:18:08,699 --> 01:18:11,399
像编译器一样

868
01:18:11,399 --> 01:18:14,519
垂直树特异性，尤其是编译器。

869
01:18:14,519 --> 01:18:17,220
目前没有对编译器进行的工作。

870
01:18:17,220 --> 01:18:20,720
因此，这将是一个非常有用的贡献。

871
01:18:21,659 --> 01:18:28,320
然后，我的意思是，需要大量工具。

872
01:18:28,560 --> 01:18:31,780
我们在Block Explorers中确实没有很多支持。

873
01:18:34,619 --> 01:18:37,039
还有一些可以完成的工作，

874
01:18:37,140 --> 01:18:45,060
尽管这已经是去年EPF努力的主题。

875
01:18:45,060 --> 01:18:47,520
但是总有ZK的东西。

876
01:18:48,360 --> 01:18:51,020
我认为这还为时过早

877
01:18:51,020 --> 01:18:55,240
实际上有帮助，但这是一种选择。

878
01:18:56,160 --> 01:18:57,440
有州到期，

879
01:18:57,660 --> 01:19:00,140
去年Han完成的非常好的工作。

880
01:19:02,460 --> 01:19:05,060
是的，也许看看它的互动方式

881
01:19:05,060 --> 01:19:06,039
带有帐户抽象。

882
01:19:06,500 --> 01:19:07,940
如果您可以建立接力者，

883
01:19:08,340 --> 01:19:10,120
有很多事情要做。

884
01:19:10,300 --> 01:19:13,460
老实说，我不会说一个

885
01:19:13,460 --> 01:19:17,619
您知道，最重要的是，一切都很重要。也许Nessio有

886
01:19:17,619 --> 01:19:18,920
更多想法？

887
01:19:21,500 --> 01:19:25,420
不，我认为我同意所有清单。我的意思是，我们还有其他

888
01:19:25,420 --> 01:19:29,659
分发等等。我认为我们有更多的决定

889
01:19:29,659 --> 01:19:33,640
要比我们真正可执行的任务

890
01:19:33,640 --> 01:19:36,520
想从客户团队那里获得更多反馈，

891
01:19:36,520 --> 01:19:41,640
什么样的解决方案可能会使它们更舒适。但我认为

892
01:19:41,640 --> 01:19:45,300
这是人们可以贡献的事情的非常好的清单。

893
01:19:45,300 --> 01:19:55,860
是的，非常感谢，伙计们。嗯，我们是，我们几乎正在解决所有问题

894
01:19:55,860 --> 01:20:01,119
我相信。在不和谐中也有一些回答。太感谢了

895
01:20:01,119 --> 01:20:08,600
顺便说一句，加入不和谐，并回答他们真正的赞赏是一个学习小组。

896
01:20:08,600 --> 01:20:21,200
您提到了状态到期，这是我想问的事情，因为这曾经是更大的事情，这并不是太多了。

897
01:20:21,200 --> 01:20:36,600
您是否认为垂直树也打开了州到期的大门？垂直树木更可行吗？那里有什么好处？

898
01:20:36,600 --> 01:20:42,260
是的。因此，是的，这完全使其可行或至少更实用。

899
01:20:43,520 --> 01:20:44,920
你知道，

900
01:20:44,960 --> 01:20:48,360
垂直树的问题在于，它既是福音，又是祸根

901
01:20:48,360 --> 01:20:49,520
国家到期。

902
01:20:49,800 --> 01:20:51,700
这是一个福音，因为证据，

903
01:20:51,800 --> 01:20:54,000
证明系统使其变得更加实用，

904
01:20:54,000 --> 01:20:59,240
但这使其同时较少相关，因为国家的增长变得

905
01:20:59,240 --> 01:21:02,760
少问题。因此，如果国家的增长变得不那么问题，

906
01:21:03,039 --> 01:21:06,020
它不属于a，

907
01:21:06,020 --> 01:21:09,220
要求或至少紧急。

908
01:21:10,340 --> 01:21:12,480
但是有一些很好的工作

909
01:21:12,480 --> 01:21:15,340
去年。我想

910
01:21:15,340 --> 01:21:18,580
实际上，我需要回到他的话题上。

911
01:21:19,840 --> 01:21:21,660
我想我们有

912
01:21:21,660 --> 01:21:23,780
好

913
01:21:23,780 --> 01:21:27,580
流线型解决方案。所以没有

914
01:21:27,580 --> 01:21:30,460
实施目前，但至少有

915
01:21:30,460 --> 01:21:33,680
在理论层面上完成的好工作

916
01:21:33,680 --> 01:21:40,840
我认为继续挖掘这个话题会很有趣，

917
01:21:42,780 --> 01:21:46,280
不幸的是，再次知道这一点

918
01:21:46,980 --> 01:21:51,180
垂直树的可能在不久的将来采用的可能性较小

919
01:21:51,180 --> 01:21:52,680
因为这不太紧急，

920
01:21:53,560 --> 01:21:56,800
但这绝对是我们迟早需要面对的话题。

921
01:21:57,200 --> 01:22:01,740
因此，我认为这不会拼写为国家到期的厄运。

922
01:22:01,739 --> 01:22:05,139
只是它仍然

923
01:22:05,139 --> 01:22:08,319
目前没有人真正在乎

924
01:22:08,319 --> 01:22:10,420
那将是最大的问题

925
01:22:10,420 --> 01:22:14,679
我在乎

926
01:22:14,679 --> 01:22:16,319
我问你，因为

927
01:22:16,319 --> 01:22:18,119
我很兴奋

928
01:22:18,119 --> 01:22:21,619
我第一次遇到的建议

929
01:22:21,619 --> 01:22:23,679
因为有很多无用的东西

930
01:22:23,679 --> 01:22:25,880
在状态下，我的节点需要运行

931
01:22:25,880 --> 01:22:28,279
我有我珍贵的小机器

932
01:22:28,279 --> 01:22:29,439
我存储了很多

933
01:22:29,439 --> 01:22:30,739
那里不重要的事情

934
01:22:30,739 --> 01:22:33,719
希望能过期。

935
01:22:33,719 --> 01:22:35,300
甚至在无状态错误中，我

936
01:22:35,300 --> 01:22:37,719
将尽可能完整的节点运行。

937
01:22:37,719 --> 01:22:42,079
因此，拥有更多领先优势会很高兴。

938
01:22:42,079 --> 01:22:44,659
是的，但是在历史到期之间，

939
01:22:44,659 --> 01:22:48,300
因为大多数在磁盘上占用空间的东西

940
01:22:48,300 --> 01:22:50,539
实际上是街区，历史街区，

941
01:22:50,539 --> 01:22:53,159
收据，所有这些东西。

942
01:22:53,159 --> 01:22:55,699
因此，我们有历史到期，这是另一个大话题。

943
01:22:55,699 --> 01:22:57,239
我在这里并没有真正帮助我的案子，

944
01:22:57,239 --> 01:22:59,619
但这也是一个非常重要的话题。

945
01:23:02,619 --> 01:23:06,279
而且，这是我们现在甚至可以做的。

946
01:23:06,439 --> 01:23:08,199
就像，我们永远存储收据。

947
01:23:08,800 --> 01:23:09,579
我们需要吗？

948
01:23:09,800 --> 01:23:10,219
并不真地。

949
01:23:11,859 --> 01:23:14,139
我们知道，我的意思是，我们可以

950
01:23:14,199 --> 01:23:18,079
客人一直在努力摆脱历史街区，

951
01:23:18,079 --> 01:23:21,719
但是，您知道，其他客户可能会感兴趣

952
01:23:21,719 --> 01:23:23,579
在实施历史到期时。

953
01:23:23,760 --> 01:23:25,659
这也是一个非常有趣的话题

954
01:23:25,659 --> 01:23:28,079
因为您真的不需要硬叉。

955
01:23:28,199 --> 01:23:29,739
您只需要实施它。

956
01:23:29,899 --> 01:23:30,300
就是这样。

957
01:23:32,300 --> 01:23:34,380
有一些问题。

958
01:23:34,619 --> 01:23:36,880
好的，我将停止谈论历史到期，

959
01:23:37,539 --> 01:23:41,139
但这将产生重大影响。

960
01:23:41,239 --> 01:23:42,180
然后最重要的是

961
01:23:42,239 --> 01:23:44,139
垂直树将产生另一个重大影响

962
01:23:44,139 --> 01:23:45,340
因为树，

963
01:23:45,899 --> 01:23:47,579
我们找到了存储树的方法

964
01:23:47,579 --> 01:23:51,479
以这样的方式，它也将占用更少的空间

965
01:23:52,359 --> 01:23:53,300
至少理论上。

966
01:23:53,300 --> 01:24:01,300
因此，一旦有了这两件事，历史到期就不会成为问题。

967
01:24:01,300 --> 01:24:06,300
仍然是，您是对的，有很多完全毫无意义的东西。

968
01:24:06,300 --> 01:24:12,300
您知道，在50岁时，谁会关心您的隐脚式呢？

969
01:24:12,300 --> 01:24:16,300
大多数拥有Cryptokitties的人，好的，也许不是在50年，而是在100年内，

970
01:24:16,300 --> 01:24:21,300
最有可能每个拥有隐脚智能的人都会死。我们还需要它吗？不。

971
01:24:21,300 --> 01:24:26,420
更重要的是，我们将用尽关心隐脚动力学的人。

972
01:24:28,180 --> 01:24:37,360
因此，是的，从长远来看，这非常重要，但是实际上，在未来10年中，

973
01:24:37,360 --> 01:24:40,680
基本上，您将不需要状态到期。

974
01:24:43,199 --> 01:24:47,199
正确的。是的，非常感谢您将历史介绍到有效期的介绍，

975
01:24:47,199 --> 01:24:51,199
因为这是在研究小组后来进行对话的预告片。

976
01:24:51,199 --> 01:24:53,159
我们将让派珀谈论历史

977
01:24:53,159 --> 01:24:56,399
在完整的演讲中到期，因此我们也会深入研究。

978
01:24:56,399 --> 01:24:57,699
非常感谢您，纪物。

979
01:24:57,699 --> 01:25:03,539
是的，伙计们，我认为还有很多其他问题

980
01:25:03,539 --> 01:25:07,079
我们现在可以回答。

981
01:25:07,079 --> 01:25:09,619
我们可能还有几分钟。

982
01:25:09,619 --> 01:25:11,159
乔什，你有什么吗？

983
01:25:11,159 --> 01:25:15,399
嗯，我是。

984
01:25:15,720 --> 01:25:16,059
是的。

985
01:25:16,059 --> 01:25:23,199
因此，virkle被打算用于以下硬叉之后，嗯，之后

986
01:25:23,199 --> 01:25:28,019
下一个，有点像您看到的时间范围

987
01:25:28,019 --> 01:25:32,800
所有这些内容均在不同的客户中实施，并进行了基准测试和测试

988
01:25:32,800 --> 01:25:35,979
以及所有准备辛勤工作的事情。

989
01:25:41,159 --> 01:25:47,119
我希望将地板交给乔什。

990
01:25:47,119 --> 01:25:52,359
好吧，我只需快速更新。

991
01:25:52,359 --> 01:25:54,479
所以我非常乐观，对吧？

992
01:25:54,479 --> 01:25:56,539
我仍然相信我们可以在丹昆进行领先。

993
01:25:56,539 --> 01:26:00,880
所以这是告诉你我有多乐观。

994
01:26:00,880 --> 01:26:05,800
但是，从我所看到的，大多数问题已经解决。

995
01:26:05,800 --> 01:26:09,360
是的，仍然有一些公开问题，例如同步，

996
01:26:11,579 --> 01:26:15,140
像图像前分布一样

997
01:26:15,520 --> 01:26:17,220
但这确实是一个问题

998
01:26:17,220 --> 01:26:22,820
因为很多客户都看过其他事情

999
01:26:22,820 --> 01:26:24,739
而不是看垂直树，而是

1000
01:26:25,340 --> 01:26:29,520
但是客户取得了很多进展。

1001
01:26:29,840 --> 01:26:31,840
我们在Nethermind方面有很好的支持。

1002
01:26:31,940 --> 01:26:35,079
我们在以太坊中得到了很好的支持。

1003
01:26:35,079 --> 01:26:39,239
是的，besu正在进行中，他们也取得了进步。

1004
01:26:39,239 --> 01:26:43,640
我认为明年，一年是现实的。

1005
01:26:43,640 --> 01:26:49,619
也许更悲观的人会说一年半，两年

1006
01:26:49,619 --> 01:26:55,220
但这至少已经准备好了。

1007
01:26:58,619 --> 01:27:04,019
惊人的。好吧，恭喜这件事，祝您好运前跑丹·库恩（Dan Kuhn）。

1008
01:27:05,079 --> 01:27:06,760
谢谢。

1009
01:27:08,739 --> 01:27:09,800
是的，很棒。

1010
01:27:09,979 --> 01:27:10,859
非常感谢，伙计们。

1011
01:27:11,399 --> 01:27:12,880
非常感谢您的演讲，

1012
01:27:13,019 --> 01:27:15,359
但尤其是您所做的所有出色工作

1013
01:27:15,359 --> 01:27:17,920
在记录树上迁移

1014
01:27:17,920 --> 01:27:19,559
或整个概念。

1015
01:27:20,220 --> 01:27:21,779
很高兴向您学习。

1016
01:27:22,699 --> 01:27:25,920
是的，我们快90分钟了。

1017
01:27:26,059 --> 01:27:27,619
我认为我们可以在这里总结。

1018
01:27:28,260 --> 01:27:30,380
但是，再次，我们非常感谢您在这里。

1019
01:27:30,479 --> 01:27:32,180
我们感谢您在不和谐中

1020
01:27:32,180 --> 01:27:33,180
回答问题。

1021
01:27:33,359 --> 01:27:34,899
也许还有一些问题

1022
01:27:34,899 --> 01:27:42,179
来，请密切关注它。人们可能会用某种东西来ping你。我希望你们听这个

1023
01:27:42,179 --> 01:27:48,579
会学到很多东西，我们将在Wiki上提供更多文档

1024
01:27:49,139 --> 01:27:59,859
稍后。是的，很棒。伟大的。谢谢大家。我们将在下周一见到你

1025
01:27:59,859 --> 01:28:06,579
与Teku的Paul一起研究共识层架构师架构

1026
01:28:08,259 --> 01:28:24,500
再次感谢吉尔·伊格纳西奥·乔什（Gil Ignacio Josh）今天的时间，感谢你们再见

1027
01:28:29,859 --> 01:28:39,859
¶¶

1028
01:28:39,859 --> 01:28:49,859
¶¶

1029
01:28:49,859 --> 01:29:19,839
谢谢。

1030
01:29:19,859 --> 01:29:20,339
谢谢。

