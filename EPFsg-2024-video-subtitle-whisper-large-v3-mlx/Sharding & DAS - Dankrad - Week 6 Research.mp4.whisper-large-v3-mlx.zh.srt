1
00:00:30,000 --> 00:00:54,200
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:59,979
我爱你。

10
00:03:00,000 --> 00:03:29,979
谢谢。

11
00:03:30,000 --> 00:03:59,979
谢谢。

12
00:04:30,000 --> 00:04:59,980
谢谢。

13
00:05:00,000 --> 00:05:19,620
好的。

14
00:05:19,620 --> 00:05:25,720
欢迎回到以太坊协议研究小组。

15
00:05:25,720 --> 00:05:35,600
因此，今天我们在这里与Dankrad的研究轨道第一届会议一起在这里

16
00:05:35,600 --> 00:05:39,940
谈论一些碎片和一些数据可用性采样。

17
00:05:39,940 --> 00:05:46,560
所以，马里奥，我继续前进，让您为我们介绍Dankrad，然后您可以将其带走。

18
00:05:46,560 --> 00:05:51,780
如果您有幻灯片或屏幕共享，Dankrad，您可以使用“ Little Prander”按钮做到这一点

19
00:05:51,780 --> 00:05:52,780
在那里。

20
00:05:52,779 --> 00:05:56,939
很棒，欢迎，舞者，欢迎所有与会者。

21
00:05:56,939 --> 00:06:03,179
因此，为Dancred提供介绍是一项艰巨的任务，因为这是一个大多数人

22
00:06:03,179 --> 00:06:08,039
不需要介绍，但是我还是会尝试的。

23
00:06:08,039 --> 00:06:14,219
因此，Dancred今天加入我们，正如您可能知道的那样，他是以太坊基金会的研究员

24
00:06:14,219 --> 00:06:20,699
您可能不知道他也是他，他是理论物理学的背景

25
00:06:20,699 --> 00:06:22,759
剑桥，这是非常令人印象深刻的。

26
00:06:22,920 --> 00:06:28,860
而且他一直在加密和以太坊上做得很好，最著名的是dankshard

27
00:06:28,860 --> 00:06:35,319
Inc.和数据可用性采样，以及NPC友好的监护权证明，开发证明

28
00:06:35,319 --> 00:06:41,620
无国籍和相关协议已经大概五年了。

29
00:06:42,099 --> 00:06:45,399
丹克沙德（Dankshard），很高兴能在这里到这里。

30
00:06:45,399 --> 00:06:51,459
您加入我们的小学习小组是一种荣幸，我们会听到

31
00:06:51,459 --> 00:06:52,560
关于它

32
00:06:52,560 --> 00:06:56,739
感谢您来自Dunkard本人，这是真的很棒的男人，是的

33
00:06:56,739 --> 00:06:58,279
非常感谢您在这里

34
00:06:58,279 --> 00:07:04,199
是的，你能听到我们的声音，我可以听到你谢谢你

35
00:07:04,199 --> 00:07:09,219
唯一的事情是我现在看不到一个按钮

36
00:07:09,220 --> 00:07:17,780
因此，在视频下，在中间说出现，对吗？

37
00:07:17,780 --> 00:07:26,380
不，我没有现在的按钮，我有麦克风，凸轮，聊天，我没有在场。

38
00:07:26,380 --> 00:07:30,980
是是因为我是的，是的，这是一个问题吗？

39
00:07:30,980 --> 00:07:36,080
您可能需要一个桌面才能共享屏幕，但是如果您共享幻灯片，

40
00:07:36,080 --> 00:07:37,080
我可以。

41
00:07:37,079 --> 00:07:38,539
我会那样做，是的。

42
00:07:38,539 --> 00:07:39,359
是的。

43
00:07:39,359 --> 00:07:40,199
是的。

44
00:07:48,839 --> 00:07:51,300
好吧，我只会通过电报发送它们。

45
00:08:01,899 --> 00:08:05,560
好吧，请给我一秒钟。

46
00:08:37,080 --> 00:08:48,420
所以几乎这几乎是它的几乎是

47
00:08:48,420 --> 00:08:49,420
几乎是它几乎是它的几乎是

48
00:08:49,420 --> 00:08:50,420
几乎这几乎是它几乎很漂亮

49
00:08:50,420 --> 00:08:51,420
几乎这几乎是它几乎是

50
00:08:51,420 --> 00:08:52,420
几乎是它几乎是它的几乎是

51
00:08:52,420 --> 00:08:53,420
几乎这几乎是它几乎很漂亮

52
00:08:53,420 --> 00:08:54,420
几乎这几乎是它几乎是它的几乎是

53
00:08:54,420 --> 00:08:55,420
几乎这几乎是它几乎很漂亮

54
00:08:55,420 --> 00:08:56,420
几乎这几乎是它几乎是

55
00:08:56,419 --> 00:08:58,699
好的，完美。

56
00:08:58,699 --> 00:09:01,699
你可以移动它们还是...？

57
00:09:01,699 --> 00:09:04,979
是的，我可以看到他们。

58
00:09:04,979 --> 00:09:05,979
酷，很酷。

59
00:09:05,979 --> 00:09:09,479
很酷，所以移至下一个。

60
00:09:09,479 --> 00:09:18,799
是的，所以只是我今天所说的话，所以我想从区块链的可伸缩性开始

61
00:09:18,799 --> 00:09:22,860
介绍为什么我们必须关心数据可用性。

62
00:09:22,860 --> 00:09:29,379
我将继续解决数据可用性问题，以数据形式讨论解决方案

63
00:09:29,379 --> 00:09:35,580
将是某种东西，然后我们将更具体地进入坦克碎片结构

64
00:09:35,580 --> 00:09:41,659
还谈论几个星期在以太坊实施的EIP4844

65
00:09:41,659 --> 00:09:42,659
前。

66
00:09:42,659 --> 00:09:43,659
请下一个幻灯片。

67
00:09:43,659 --> 00:09:49,580
因此，当我们谈论区块链可伸缩性时。

68
00:09:49,580 --> 00:10:16,980
这么多年前，维塔利克提出了区块链可伸缩性三元素。

69
00:10:19,580 --> 00:10:44,740
它说的是很难设计一个块链。

70
00:10:44,740 --> 00:10:48,899
它

71
00:10:48,899 --> 00:10:51,460
它

72
00:10:51,460 --> 00:10:55,419
提供

73
00:10:55,419 --> 00:10:59,940
它

74
00:10:59,940 --> 00:11:00,560
它

75
00:11:00,560 --> 00:11:02,019
它

76
00:11:02,019 --> 00:11:04,759
它

77
00:11:04,759 --> 00:11:08,680
它

78
00:11:08,680 --> 00:11:09,180
它

79
00:11:14,740 --> 00:11:43,740
好的。

80
00:11:44,740 --> 00:11:50,580
你好？你好。好的。听起来更好。更好吗？好的。好的。我改变了互联网

81
00:11:50,580 --> 00:11:57,379
联系。希望这会更好。对此很抱歉。您能听到我的声音多远？

82
00:11:59,460 --> 00:12:05,460
我听到的最后一件事是，维塔利克提出了可伸缩性三元素。

83
00:12:05,460 --> 00:12:18,420
是的，因此，可伸缩性三元素说，很难设计一个可以同时提供可扩展性，安全性和权力下放的区块链。

84
00:12:19,200 --> 00:12:23,180
重要的是，它并不是说这是不可能的。

85
00:12:23,180 --> 00:12:33,060
就在维塔利克（Vitalik）提出这一点时，我们并没有真正拥有制造可扩展区块链所需的所有构造。

86
00:12:33,059 --> 00:12:39,199
但幸运的是，我们现在确实有它们，我今天将讨论该解决方案的重要组成部分之一。

87
00:12:40,339 --> 00:12:42,079
如果您可以去下一个幻灯片。

88
00:12:44,819 --> 00:12:53,099
因此，让我们谈谈国家三元组的部分，即权力下放。

89
00:12:53,100 --> 00:13:01,540
因此，当我们谈论权力下放时，我们的意思是，重要的是一件重要的事情

90
00:13:01,540 --> 00:13:07,560
我们想要的是，任何人运行节点都非常容易。

91
00:13:07,560 --> 00:13:11,399
这就是使权力下放的原因。

92
00:13:11,399 --> 00:13:18,080
所以，下一个幻灯片。

93
00:13:18,080 --> 00:13:24,759
如果我们在这里查看此节点，理想情况下，我们希望有人可以轻松地运行一个节点

94
00:13:24,759 --> 00:13:26,960
他们自己的家。

95
00:13:26,960 --> 00:13:30,620
重要的是，这意味着两个因素是有限的。

96
00:13:30,620 --> 00:13:32,400
一个是执行。

97
00:13:32,400 --> 00:13:38,160
这个任何人都可以购买理想的小盒子最多只有几百美元。

98
00:13:38,160 --> 00:13:40,320
它可以做多少。

99
00:13:40,320 --> 00:13:44,220
另外，我们希望用户可能仍然能够将其用于其他事项

100
00:13:44,220 --> 00:13:45,220
同时。

101
00:13:45,220 --> 00:13:48,879
因此，我们甚至不想全职使用CPU。

102
00:13:48,879 --> 00:13:50,500
第二件事是带宽。

103
00:13:50,500 --> 00:13:53,980
因此，就像一个人可以得到的互联网连接一样

104
00:13:55,720 --> 00:13:57,399
在他们家中通常有限

105
00:13:57,399 --> 00:13:58,420
取决于国家。

106
00:13:58,420 --> 00:14:03,420
因此，我们必须对我们能够到达那里的东西感到满意

107
00:14:04,139 --> 00:14:09,139
这进一步限制了一个节点可以执行多少。

108
00:14:14,120 --> 00:14:15,040
下一个幻灯片。

109
00:14:15,220 --> 00:14:24,540
因此，如果我们看一下区块链堆栈，就像我们的现代理解一样，我们会看到

110
00:14:24,540 --> 00:14:31,340
它具有四个不同的层，这些层是执行，结算，数据

111
00:14:31,340 --> 00:14:34,080
可用性和共识。

112
00:14:34,080 --> 00:14:42,080
因此，共识就像是基本上是如何知道我们哪一个是我们的链

113
00:14:42,080 --> 00:14:48,720
所有人都同意，例如我们如何就最新的区块和UM达成共识

114
00:14:48,720 --> 00:14:55,520
就像工作证明和证明清酒之类的事情在这里起作用数据可用性um是

115
00:14:55,520 --> 00:15:03,360
一个作为我今天所说的部分，就像嗯，我们怎么知道一切

116
00:15:04,639 --> 00:15:11,360
那是区块链的一部分，每个人都可以解决，um是该层是

117
00:15:11,360 --> 00:15:18,000
这是沉降层，这基本上意味着它是UM的根层

118
00:15:18,000 --> 00:15:22,960
例如，链上的资产，因此一切都可以恢复到的逻辑

119
00:15:22,960 --> 00:15:31,840
告诉你喜欢好的，这是这个um eth或erc20 soken现在属于的人，

120
00:15:31,840 --> 00:15:37,440
执行是确定哪些事务有效UM的一层，因此执行是

121
00:15:37,440 --> 00:15:42,880
是说，如果您执行此交易，

122
00:15:42,880 --> 00:15:45,780
然后帐户以这种方式更改，

123
00:15:45,780 --> 00:15:49,780
或者它们不会改变，因为这是一项无效的交易。

124
00:15:49,780 --> 00:15:58,300
如果我们去下一个幻灯片，那么其中两个层

125
00:15:58,300 --> 00:16:02,260
实际上是天生的解决和共识。

126
00:16:02,260 --> 00:16:05,140
他们并不真正取决于交易的数量

127
00:16:05,140 --> 00:16:07,380
我们的区块链必须处理。

128
00:16:07,379 --> 00:16:13,360
因此，共识不依赖于此，因为共识可以得出，我们可以达成共识

129
00:16:13,360 --> 00:16:15,039
关于哈希之类的东西。

130
00:16:15,139 --> 00:16:20,059
因此，我们可以高度压缩必须达成共识的数据量。

131
00:16:20,259 --> 00:16:25,659
因此，实际上并不真正在乎我们每秒进行一项交易还是

132
00:16:25,659 --> 00:16:25,939
百万。

133
00:16:27,259 --> 00:16:31,220
为了解决，这是类似的方式。

134
00:16:32,019 --> 00:16:35,779
我们并不总是需要立即解决每笔交易。

135
00:16:35,779 --> 00:16:40,319
我们基本上可以净数量的交易。

136
00:16:40,860 --> 00:16:46,360
因此，解决方案也不一定取决于交易的数量。

137
00:16:46,819 --> 00:16:51,199
但是，这两件事绝对取决于交易的数量是数据可用性和执行。

138
00:16:51,379 --> 00:16:59,559
数据可用性，因为我们需要为所有想要的人提供每笔可用的数据，

139
00:16:59,559 --> 00:17:02,859
或至少有人需要它知道是否

140
00:17:02,859 --> 00:17:04,460
无论它们取决于什么，例如

141
00:17:04,460 --> 00:17:06,539
他们帐户的余额有效。

142
00:17:06,539 --> 00:17:11,179
和执行一样，就像我们需要一样

143
00:17:12,500 --> 00:17:15,039
是的，例如，我们目前需要

144
00:17:15,039 --> 00:17:18,240
在以太坊上执行所有交易，

145
00:17:18,240 --> 00:17:21,480
因此，它也需要扩展

146
00:17:21,480 --> 00:17:23,079
与交易的数量。

147
00:17:24,379 --> 00:17:25,220
下一个幻灯片。

148
00:17:25,220 --> 00:17:36,200
因此，几年前，我们提出了所谓的卷起的想法。

149
00:17:36,200 --> 00:17:43,319
终于，就像以前一样，有许多不同的想法来扩展区块链

150
00:17:43,319 --> 00:17:49,860
例如，在比特币上实现的状态渠道，例如，称为闪电，

151
00:17:49,860 --> 00:17:51,519
等离子体和其他人。

152
00:17:51,519 --> 00:17:57,019
但是所有这些都对他们能做什么有很大的限制，而且他们并没有真正

153
00:17:57,019 --> 00:18:02,279
提供我们想要的所有内容，尤其是通用计算。

154
00:18:02,279 --> 00:18:12,220
但是随着汇总，我们终于提出了一种普遍扩展计算的方法。

155
00:18:12,220 --> 00:18:19,139
他们从欺诈证据或有效性证明中获得了可扩展性，也通俗地

156
00:18:19,140 --> 00:18:27,780
被称为ZK，这样他们就可以向所有节点证明交易是钱包

157
00:18:27,780 --> 00:18:32,259
有效而无需它们实际上必须验证每个单独的交易，所以这就是

158
00:18:32,259 --> 00:18:37,620
缩放来自我们需要以某种方式停止，就像每个节点必须执行所有交易一样

159
00:18:38,580 --> 00:18:46,980
下一个幻灯片，然后最后一部分是我们如何扩展数据可用性，这就是我

160
00:18:46,980 --> 00:18:50,740
今天要谈论的是数据可用性采样。

161
00:18:52,500 --> 00:19:00,180
好的，让我们谈谈数据可用性问题。因此

162
00:19:00,180 --> 00:19:06,660
数据将改善它意味着没有网络参与者，其中包括勾结

163
00:19:06,660 --> 00:19:16,660
超级全节点的超级节点具有扣留数据的能力。因此，重要的是

164
00:19:16,980 --> 00:19:19,259
这包括勾结的超级差。

165
00:19:19,259 --> 00:19:24,559
因此，如果例如，您说，数据可用性实际上相对容易解决

166
00:19:25,079 --> 00:19:30,860
哦，我愿意相信大多数以太坊验证者总是诚实的。

167
00:19:31,940 --> 00:19:35,940
在这种情况下，您可以简单地，就像使它们全部投票。

168
00:19:36,140 --> 00:19:38,339
如果他们投票赞成，那么数据可用。

169
00:19:38,759 --> 00:19:40,640
只要诚实，这总是正确的。

170
00:19:41,420 --> 00:19:45,279
但这还不足以像以太坊这样的区块链。

171
00:19:45,279 --> 00:19:51,460
我们希望不仅仅是信任大多数的安全性。

172
00:19:51,460 --> 00:19:57,559
我们希望可以独立验证链上所有交易的有效性之类的东西

173
00:19:57,559 --> 00:20:00,819
与验证者是否诚实无关。

174
00:20:00,980 --> 00:20:04,599
因此，以太坊中验证者的力量相当有限，

175
00:20:05,160 --> 00:20:08,339
这是我们要保留的重要财产。

176
00:20:09,480 --> 00:20:14,879
并且该数据可用性在当前区块链中解决。

177
00:20:15,279 --> 00:20:22,799
包括以太坊，到目前为止，只有一个例外，或两个例外

178
00:20:22,799 --> 00:20:29,599
下载所有数据的节点。因此，目前，以太坊节点，每当有新块时，

179
00:20:29,599 --> 00:20:34,720
所有节点都会收到新块，因此，他们知道该块可用，

180
00:20:34,720 --> 00:20:36,879
因为他们看过了。他们从字面上看了整个障碍。

181
00:20:39,359 --> 00:20:43,519
因此，问题是，我们如何使此扩展？因此可扩展意味着

182
00:20:43,519 --> 00:20:49,200
所需的工作应小于下载完整块。更具体地说，我们想要

183
00:20:49,200 --> 00:20:55,519
诸如常数或对数的工作量之类的东西，例如平方根倾向于

184
00:20:55,519 --> 00:21:05,119
已经很多了。这就是我们的目标。下一个幻灯片。所以我喜欢

185
00:21:05,119 --> 00:21:10,019
谈论数据可用性

186
00:21:10,019 --> 00:21:12,639
因为它经常感到困惑。

187
00:21:12,639 --> 00:21:15,739
因此，数据可用性，这意味着

188
00:21:15,739 --> 00:21:18,979
保证数据没有被删除。

189
00:21:18,979 --> 00:21:22,159
因此，这是发布数据的保证。

190
00:21:22,159 --> 00:21:24,219
这是重要的部分。

191
00:21:24,219 --> 00:21:25,059
下一个幻灯片。

192
00:21:26,419 --> 00:21:30,839
这不是什么意思，它不是数据可用性

193
00:21:30,839 --> 00:21:31,979
是数据存储。

194
00:21:31,980 --> 00:21:37,740
数据存储是10年后，您可以问，嘿，那是什么数据？

195
00:21:38,360 --> 00:21:44,380
这是您也可能想要的单独属性，但重要的是，这不是数据可用性。

196
00:21:45,279 --> 00:21:48,200
因此，这是数据存储或持续可用性。

197
00:21:48,200 --> 00:21:50,480
我不是在谈论这个。

198
00:21:50,579 --> 00:21:52,059
这也是您可能想要的。

199
00:21:52,539 --> 00:21:56,099
幸运的是，实现数据可用性实际上要容易得多。

200
00:21:56,099 --> 00:22:06,679
这不需要经常复杂的结构，因为一旦发布数据，您只需要世界上一个人来保存它。

201
00:22:07,659 --> 00:22:10,779
世界上的一个人足以始终获取数据。

202
00:22:11,319 --> 00:22:20,699
而如果首先发布数据，那么那个诚实的人就不会为您提供帮助，因为他们从未收到数据。

203
00:22:20,699 --> 00:22:25,879
这就是为什么数据可用性比数据存储更难实现的原因。

204
00:22:26,099 --> 00:22:35,599
好的，所以这个数据值的问题对许多人，当他们第一次听到它时，听起来像是

205
00:22:35,599 --> 00:22:37,439
一个不重要的细节。

206
00:22:37,439 --> 00:22:44,939
在许多扩展解决方案中，这只是一些令人讨厌的细节，我们实际上已经找到了很多次。

207
00:22:44,939 --> 00:22:51,480
人们经常想到，例如等离子体，很长一段时间以来，

208
00:22:51,480 --> 00:22:54,480
最终缩放解决方案。

209
00:22:54,480 --> 00:23:00,860
最后，结果发现它像大问题一样命中，这是其中的一部分

210
00:23:00,860 --> 00:23:02,640
具有数据可用性。

211
00:23:02,640 --> 00:23:04,660
那为什么这么重要呢？

212
00:23:04,660 --> 00:23:12,740
因此，我们有两个选择可以完全可扩展的通用执行。

213
00:23:12,740 --> 00:23:17,940
其中之一是使用欺诈证据的乐观卷起。

214
00:23:17,940 --> 00:23:27,840
因此，他们的工作方式是您发布批处理，并声称新的舞台路线是执行交易后正确的舞台路线。

215
00:23:28,519 --> 00:23:34,920
之后，任何人都可以提交欺诈证据，声称这不是正确的结果。

216
00:23:34,920 --> 00:23:42,519
然后他们玩了一个小游戏，该游戏的财产是，如果他们玩正确的策略，任何人都可以始终赢得比赛。

217
00:23:43,900 --> 00:23:46,720
这真的很酷。

218
00:23:46,720 --> 00:23:54,559
只有一个人只有一个人，如果谁犯了欺诈的人没有发布他们的数据

219
00:23:54,559 --> 00:23:59,000
设法以某种方式将状态扎根在链上，但没有发布数据

220
00:23:59,000 --> 00:24:05,920
好吧，现在您遇到了无法创建欺诈证据的问题，因为人们可能知道

221
00:24:05,920 --> 00:24:11,360
好吧，不，这不能是正确的结果，但是他们不能证明这一点，例如

222
00:24:11,360 --> 00:24:16,579
我在这里的例子是，那里可能会有一笔微小的交易，从字面上看

223
00:24:16,579 --> 00:24:22,899
为什么您甚至都不会错过一小部分数据，就像打印1万亿以太一样

224
00:24:24,500 --> 00:24:30,819
如果您不能像无法证明欺诈行为一样，那将发生在卷中

225
00:24:30,819 --> 00:24:35,699
显然，它不会真正影响以太坊本身，因为那仍然包含在该卷中

226
00:24:35,699 --> 00:24:41,220
嗯，但是就像滚动一样，这仍然是一个巨大的问题，就像其他所有人一样

227
00:24:41,220 --> 00:24:42,360
现在无法

228
00:24:42,360 --> 00:24:45,380
就像有人可以退出所有这些以太

229
00:24:45,380 --> 00:24:47,059
或多大的汇总已锁定

230
00:24:47,059 --> 00:24:50,059
其他所有人都不会得到任何东西。

231
00:24:50,059 --> 00:24:53,720
因此，我们实际上需要所有数据才能无条件可用，

232
00:24:53,720 --> 00:24:56,779
否则将无法构建欺诈证据。

233
00:24:56,779 --> 00:25:00,339
对于ZK滚动，它比这更微妙。

234
00:25:00,339 --> 00:25:01,920
像汇总一样，用于乐观主义者汇总

235
00:25:01,920 --> 00:25:04,579
这真的很明显。

236
00:25:04,579 --> 00:25:06,039
对于您可以问的ZK滚动，

237
00:25:06,039 --> 00:25:07,620
好吧，我的意思是，即使数据丢失，

238
00:25:07,620 --> 00:25:10,380
没有人真的可以完全

239
00:25:11,220 --> 00:25:15,039
进行欺诈交易，因为您始终必须证明正确性

240
00:25:15,039 --> 00:25:22,519
但是像您在帐户中有钱的时候基本上一样

241
00:25:22,519 --> 00:25:29,900
嗯，要访问它，您需要证明您有钱

242
00:25:29,900 --> 00:25:37,180
如果您没有证人，或者也许您甚至不知道如何

243
00:25:37,180 --> 00:25:41,160
这正是因为有人将灰尘交易纳入您的帐户。

244
00:25:41,700 --> 00:25:44,580
基本上，是的，您的钱在那里。

245
00:25:44,580 --> 00:25:49,140
可以这么说，就像没有人可以从您的帐户中偷走它，但是他们可以锁定

246
00:25:49,140 --> 00:25:51,160
它在那里，然后他们可以勒索您。

247
00:25:51,299 --> 00:25:54,779
显然，我可以说，好吧，我给你证人，但是你必须给我50％

248
00:25:54,779 --> 00:25:55,279
你的钱。

249
00:25:56,720 --> 00:26:03,820
因此，即使对于您永远无法在链上进行无效交易的ZK汇总，您实际上也

250
00:26:03,820 --> 00:26:04,600
需要数据可用性。

251
00:26:07,180 --> 00:26:10,920
这使我们可以进行数据可用性采样。

252
00:26:13,560 --> 00:26:15,960
因此数据可用性采样背后的想法

253
00:26:15,960 --> 00:26:18,340
如下。

254
00:26:18,340 --> 00:26:20,880
我们不像一样，在这里获取数据

255
00:26:20,880 --> 00:26:23,759
而且我喜欢基本上把它分解了

256
00:26:23,759 --> 00:26:27,519
进入这些D0到D9小块。

257
00:26:27,519 --> 00:26:30,860
这个想法是我们想做的

258
00:26:30,860 --> 00:26:33,019
而不是下载所有数据，而是

259
00:26:33,019 --> 00:26:35,320
我们只选择一些随机位

260
00:26:35,320 --> 00:26:36,600
然后下载这些。

261
00:26:37,180 --> 00:26:47,519
而且，我们可以希望，好吧，如果我们要求的所有这些都可以使用，那么所有数据都希望可以使用。

262
00:26:48,860 --> 00:26:51,039
正确的。但是，请下一个幻灯片。

263
00:26:51,720 --> 00:27:01,279
有一个小问题，那就是，如果缺少任何数据，我们碰巧没有采样，我们实际上不会检测到它。

264
00:27:01,279 --> 00:27:15,500
正如我们之前讨论的那样，问题在于，不幸的是，在区块链上，即使是一小部分数据丢失也可能完全是灾难性的，因为我们拥有这些重要的财务信息。

265
00:27:15,799 --> 00:27:20,259
是的，不幸的是，丢失的交易可能是打印1万亿以太。

266
00:27:20,440 --> 00:27:22,819
如果我们错过了那个，那我们就被操了。

267
00:27:23,700 --> 00:27:27,619
因此，我们甚至无法负担得起一点点数据。

268
00:27:28,099 --> 00:27:30,420
因此，这个简单的想法无法直接起作用。

269
00:27:30,420 --> 00:27:32,920
我们不能仅仅将数据分成块。

270
00:27:35,320 --> 00:27:36,720
所以这是一个例子。

271
00:27:37,300 --> 00:27:41,180
如果我们说我们的客户样本的数据的10％，

272
00:27:41,759 --> 00:27:43,220
这只是很多，对吧？

273
00:27:43,620 --> 00:27:48,279
然后，块生产商可以隐藏一个不可用的交易。

274
00:27:49,340 --> 00:27:52,560
现在，我们知道，抓住这项交易，

275
00:27:52,759 --> 00:27:54,380
概率为10％，

276
00:27:54,380 --> 00:27:55,920
因为那是我们采样的数据。

277
00:27:55,920 --> 00:28:00,920
但这不是一个伟大的，那不是很大的机会，

278
00:28:02,160 --> 00:28:05,140
像攻击者一样，只有10％

279
00:28:05,140 --> 00:28:07,259
谁试图隐藏一些重要的数据。

280
00:28:07,259 --> 00:28:10,640
而且我们已经喜欢对10％的数据进行采样。

281
00:28:10,640 --> 00:28:13,279
因此，这里的权衡实际上并不奏效。

282
00:28:16,620 --> 00:28:21,620
因此，这使我们想到了删除编码数据的想法。

283
00:28:22,300 --> 00:28:25,920
所以我们做的不仅仅是我们不只是

284
00:28:25,920 --> 00:28:28,039
获取原始数据。

285
00:28:28,039 --> 00:28:30,640
因此，像这里一样，我们现在有四个原始数据，

286
00:28:30,640 --> 00:28:35,640
D0至D3，但我们为其添加了一些额外的数据。

287
00:28:36,740 --> 00:28:41,300
我们喜欢添加所谓的擦除代码。

288
00:28:41,300 --> 00:28:44,500
在此示例中，它专门读取所罗门代码。

289
00:28:44,500 --> 00:28:47,259
这意味着我们采用原始数据，

290
00:28:48,539 --> 00:28:53,160
我们将数据解释为多项式上的点

291
00:28:53,160 --> 00:28:58,600
然后我们可以将其扩展，就像我们在多项式上有四个点一样，

292
00:28:59,180 --> 00:29:03,920
我们知道，我们总是可以将其插入第3度的独特多项式中。

293
00:29:04,759 --> 00:29:06,620
我们在另外四个点评估了这一点。

294
00:29:06,720 --> 00:29:08,019
这些是E0至E3。

295
00:29:09,620 --> 00:29:14,400
现在，我们拥有多项式的这种非常酷的属性

296
00:29:14,400 --> 00:29:20,880
如果您有任何D加1点D度多项式，则

297
00:29:20,880 --> 00:29:25,040
您总是可以插入多项式，并且它是唯一的。

298
00:29:26,420 --> 00:29:32,640
因此，这意味着，如果我有D0，D3，E1和E2，例如

299
00:29:33,260 --> 00:29:35,100
然后我可以重建它，

300
00:29:35,260 --> 00:29:37,300
我会回到所有相同的观点。

301
00:29:37,840 --> 00:29:40,420
无论我提到哪个子集。

302
00:29:42,280 --> 00:29:42,580
正确的。

303
00:29:43,060 --> 00:29:44,180
所以这真的很酷，

304
00:29:44,260 --> 00:29:48,880
因为现在这种采样的原始想法实际上变得有效。

305
00:29:48,880 --> 00:30:00,540
因此，例如，如果我们进行30个随机块，并且所有这些都可用，则概率

306
00:30:00,540 --> 00:30:07,440
50％的数据不可用的是减去30。

307
00:30:07,440 --> 00:30:08,480
那是十亿分之一。

308
00:30:08,480 --> 00:30:10,720
所以这很低。

309
00:30:10,720 --> 00:30:16,820
因此，这与我们以前拥有的巨大不同，对吗？

310
00:30:16,819 --> 00:30:22,259
现在，我们只是查询30个块，这是一个恒定的数字。

311
00:30:22,259 --> 00:30:23,259
所以没关系。

312
00:30:23,259 --> 00:30:25,279
不必是数据的10％。

313
00:30:25,279 --> 00:30:29,200
如果我们有3,000个块，则是数据的1％。

314
00:30:29,200 --> 00:30:32,500
如果我们有30,000个块，则是数据的0.1％。

315
00:30:32,500 --> 00:30:34,480
所以这是不变的。

316
00:30:34,480 --> 00:30:37,339
现在的概率确实很低，我们可以使其降低。

317
00:30:37,339 --> 00:30:39,700
如果我们做40，那么我们有100万亿美元。

318
00:30:39,700 --> 00:30:45,299
因此，它很快成为一个极低的统计事件。

319
00:30:45,299 --> 00:31:01,440
但是，有一个捕捉，也就是说，快速更正，这是正确的。

320
00:31:01,440 --> 00:31:04,639
这应该说三学位，而不是五位。

321
00:31:04,639 --> 00:31:06,039
但这很好。

322
00:31:06,039 --> 00:31:19,599
因此，基本上可能发生的是这些扩展点未正确计算，

323
00:31:19,599 --> 00:31:25,579
攻击者只是构成随机点或其他任何东西。

324
00:31:25,579 --> 00:31:30,859
现在发生的是，如果您有50％的要点，则可以插入它，

325
00:31:30,859 --> 00:31:33,759
但是这些插值中的每一个都会有所不同。

326
00:31:33,759 --> 00:31:39,039
这显然很糟糕，因为我的意思是，区块链最重要的特性总是

327
00:31:39,039 --> 00:31:41,879
每个人都同意同一件事。

328
00:31:41,879 --> 00:31:43,319
因此，我们负担不起。

329
00:31:43,319 --> 00:31:56,940
因此，我们需要一种确保块中的任何内容始终是正确的读所罗门的方法

330
00:31:56,940 --> 00:32:03,640
代码或换句话说，整个事情都是正确程度的正常。

331
00:32:03,640 --> 00:32:12,320
这就是我们使用真正酷的东西，即所谓的KCG承诺，

332
00:32:12,320 --> 00:32:15,600
这是一种多项式承诺。

333
00:32:15,600 --> 00:32:22,640
KCG承诺具有他们一直致力于多项式的财产，而您

334
00:32:22,640 --> 00:32:24,560
可以限制该多项式的程度。

335
00:32:24,560 --> 00:32:32,840
因此，您可以说，这根根必须是对三级多项式的承诺。

336
00:32:33,640 --> 00:32:46,300
这意味着我们会自动获得任何人的财产，无论是诚实的笔记还是攻击者，都承诺始终是给定学位的多项式。

337
00:32:47,240 --> 00:32:52,880
因此，不再可能致力于无效的根源。

338
00:32:52,880 --> 00:32:56,180
这就像这个数组巢发现

339
00:32:56,180 --> 00:32:57,440
几年前我们做了

340
00:32:57,440 --> 00:33:01,060
最终使实施成为可能。

341
00:33:01,060 --> 00:33:03,880
幸运的是，它变得非常有效

342
00:33:03,880 --> 00:33:05,120
在过去的几年中。

343
00:33:06,840 --> 00:33:07,680
凉爽的。

344
00:33:09,520 --> 00:33:12,060
因此，让我们进入DAG图表结构

345
00:33:12,060 --> 00:33:16,420
我想出了两年多前提出的。

346
00:33:16,420 --> 00:33:27,759
因此，让我们来谈谈碎片最初是什么样的，或者很多人想象的

347
00:33:27,759 --> 00:33:30,779
因为，在以太坊上会是什么样。

348
00:33:30,779 --> 00:33:37,580
所以想法是，所以我们总是像这款信标连锁链和后来一样，就像我们添加的那样

349
00:33:37,580 --> 00:33:39,920
执行阻塞。

350
00:33:39,920 --> 00:33:44,300
然后的想法是，与那条灯塔链并行，会有很多碎片，

351
00:33:44,299 --> 00:33:50,059
最初就像1024个不同的镜头，所有镜头都并行运行，类似于信标

352
00:33:50,059 --> 00:33:57,659
连锁他们每个人都有一个建议者，然后每个人都将有一个投票的委员会

353
00:33:58,460 --> 00:34:02,220
该提议者是否出现以及他们提出了什么障碍

354
00:34:04,220 --> 00:34:10,380
嗯，所以问题是为什么我们为什么需要所有这些都需要所有这些

355
00:34:10,380 --> 00:34:12,059
所有这些委员会在这里。

356
00:34:12,059 --> 00:34:14,320
虽然问题在于这些建议中的每一个

357
00:34:14,320 --> 00:34:15,360
可以做一些不好的事情。

358
00:34:15,360 --> 00:34:18,480
每个人都可以不发布他们的数据

359
00:34:18,480 --> 00:34:22,500
或他们每个人都可以

360
00:34:24,000 --> 00:34:26,440
他们每个人都可以发布两个不同的块

361
00:34:26,440 --> 00:34:27,280
同时。

362
00:34:28,960 --> 00:34:30,680
这有重要的后果

363
00:34:30,680 --> 00:34:33,260
因为现在下一个问题是

364
00:34:33,260 --> 00:34:35,099
这些委员会可以分解。

365
00:34:35,099 --> 00:34:37,460
喜欢，对不起，请保持同样的想法。

366
00:34:37,460 --> 00:34:40,300
这些委员会可能只有50-50。

367
00:34:41,619 --> 00:34:44,099
而且，那么，您有一个问题。

368
00:34:44,340 --> 00:34:47,179
那么您如何确定哪个是正确的？

369
00:34:47,800 --> 00:34:53,579
因此，这本质上意味着我们必须等待很长时间才能确认这些委员会。

370
00:34:53,940 --> 00:34:59,420
并且可能需要几个时期，直到您知道每个图表块的作用。

371
00:35:00,019 --> 00:35:06,659
而且，当您开始进行该设计时，您会注意到这带来了许多实际问题。

372
00:35:06,659 --> 00:35:17,599
例如，我的意思是，只要提到其中一个，想象一下您是一个卷起，您想发布自己的博客，但没有得到确认。

373
00:35:18,219 --> 00:35:26,639
现在你打算做什么？您要发布下一个博客吗？您是否要重新发布它，以防其确认等等？

374
00:35:26,639 --> 00:35:35,779
因此，实际上确实很困难。我认为直到最后，实际上并没有真正弄清楚如何以有效的方式实际使用它的方法。

375
00:35:36,659 --> 00:35:48,420
所以，我说的是，如果我们喜欢改变设计，该怎么办，对不起，下一个

376
00:35:48,420 --> 00:35:50,799
幻灯片，不，是的。

377
00:35:50,799 --> 00:35:57,659
我们让一个提议者创建所有这些碎片和信标块。

378
00:35:57,659 --> 00:36:04,039
然后，我们只有一个大委员会检查所有这些，是否有效

379
00:36:04,039 --> 00:36:05,339
或不。

380
00:36:05,340 --> 00:36:12,059
可以做到这一点，因为当您有一个Pro一个建议者um时，我们可以像我们一样

381
00:36:12,059 --> 00:36:17,579
一起查看它们，原因是，如果他们未能发布数据

382
00:36:17,579 --> 00:36:23,019
一个碎片之一，我们可以让障碍失败，这是他们的责任

383
00:36:23,019 --> 00:36:27,980
上升，而当您有许多不同的建议时，您不能那么苛刻，因为您不能

384
00:36:28,620 --> 00:36:35,260
如果枪击的提议者对两个枪手做得不好，但是当你你

385
00:36:35,260 --> 00:36:38,700
当您汇总这样的责任时，就可以做到。

386
00:36:40,300 --> 00:36:45,900
我们想知道我们这样做的重要原因是因为

387
00:36:49,260 --> 00:36:55,020
在研究MEV的过程中，我们注意到最终的平衡是

388
00:36:55,020 --> 00:37:03,180
无论如何那样。某些各方很可能会在集中建造街区，

389
00:37:03,179 --> 00:37:08,219
而且，我们的整个设计都将包含问题。

390
00:37:08,399 --> 00:37:14,339
因此，保持抵制审查制度并确保他们诚实等等，

391
00:37:14,519 --> 00:37:17,139
由于MEV，这已经在路线图上。

392
00:37:17,859 --> 00:37:23,839
因此，只要说，我们可以摆脱所有这些复杂性是很有意义的

393
00:37:23,839 --> 00:37:27,440
拥有所有这些建议，因为实际上它将是一个建议。

394
00:37:28,119 --> 00:37:33,079
而且，我们只需要包含来自其中的潜在集中量向量即可。

395
00:37:33,179 --> 00:37:38,179
是的，这就像延伸一样。

396
00:37:39,239 --> 00:37:44,239
因此，基本上发生的是世界上

397
00:37:44,279 --> 00:37:46,419
提案建设者分离，

398
00:37:46,419 --> 00:37:48,919
你总是会得到一个，

399
00:37:48,919 --> 00:37:51,659
抱歉，我们仍在上一个幻灯片上。

400
00:37:51,659 --> 00:37:54,639
您总是会首先获得提案块

401
00:37:54,639 --> 00:37:57,559
提案选择建筑商的地方

402
00:37:57,559 --> 00:38:00,259
这就像一个小验证器一样。

403
00:38:00,259 --> 00:38:03,159
他们不需要很多硬件来计算这一点，

404
00:38:03,159 --> 00:38:06,659
但是，然后主要块将由建筑商建造

405
00:38:06,659 --> 00:38:09,339
谁有更多的资源，并且能够构建

406
00:38:09,339 --> 00:38:12,339
信标块和所有碎片块同时。

407
00:38:15,940 --> 00:38:19,739
还有一种成分

408
00:38:19,739 --> 00:38:22,259
潮湿的设计，这就是想法

409
00:38:22,259 --> 00:38:26,019
具有二维多项式扩展。

410
00:38:26,019 --> 00:38:29,759
因此，这里的想法是我们可以

411
00:38:29,760 --> 00:38:39,720
因此，我们采取KZG对行的承诺，这些承诺本质上是碎片，或者喜欢

412
00:38:39,720 --> 00:38:46,220
我认为，在更现代的说话中，我们会说斑点，我们称它们为斑点，每一个

413
00:38:46,220 --> 00:38:52,520
它们像一些数据一样表示，但随后像我们之前讨论过。

414
00:38:52,520 --> 00:38:57,120
因此，每条线本质上都是一个多项式，并具有延伸。

415
00:38:57,119 --> 00:39:01,759
但是，我们还要做的事情还将它们扩展到垂直轴上。

416
00:39:01,759 --> 00:39:11,739
因此，这里的每个单元格也将延伸。

417
00:39:11,739 --> 00:39:17,000
KCG承诺的好处是因为它们是线性的，您可以计算

418
00:39:17,000 --> 00:39:23,259
额外的KCG承诺也仅使用非常普通的扩展名。

419
00:39:23,260 --> 00:39:28,540
这样做有一些重要的优势。

420
00:39:28,540 --> 00:39:40,820
因此，基本上，很酷的事情是，如果我们有

421
00:39:40,820 --> 00:39:43,140
整个广场的任何三个季度。

422
00:39:43,140 --> 00:39:47,880
哪一个都没关系，但是您也可以以分布式的方式进行操作。

423
00:39:47,880 --> 00:39:52,039
因此，我们基本上在这里有两层验证。

424
00:39:52,039 --> 00:39:58,119
首先是验证者将验证该原件。

425
00:39:59,640 --> 00:40:01,240
因此，您可以使用下一张幻灯片。

426
00:40:02,840 --> 00:40:07,480
使用验证者将验证建筑商的工作正确。

427
00:40:07,619 --> 00:40:12,840
他们只需下载两个行和两列即可通过下载来做到这一点。

428
00:40:12,840 --> 00:40:27,300
而且，如果他们这样做，那么如果块不可用，因此不到75％的数据可用，他们将永远无法获得超过16的验证者投票。

429
00:40:27,300 --> 00:40:33,680
因此，第1 16个证明，这意味着如果没有可用的话，基本上将重新忽略并忽略该块。

430
00:40:34,440 --> 00:40:42,460
因此，只要有诚实的多数，验证者就永远不会投票赞成该区块，这始终是一个好的财产。

431
00:40:42,840 --> 00:40:46,400
尽管我们不想依靠诚实的多数

432
00:40:46,400 --> 00:40:49,539
这是某人需要过去的第一步。

433
00:40:50,960 --> 00:40:51,900
下一个幻灯片。

434
00:40:54,980 --> 00:40:58,620
那是一个很好的附加属性

435
00:40:58,620 --> 00:41:02,039
是因为每行和每一列单独

436
00:41:02,039 --> 00:41:05,260
是芦苇 - 固体代码或多项式，

437
00:41:05,260 --> 00:41:07,360
它们可以单独重建。

438
00:41:07,360 --> 00:41:10,640
因此，一旦您拥有一行或一列的50％，

439
00:41:10,640 --> 00:41:12,660
您可以重建该行或列。

440
00:41:12,840 --> 00:41:19,160
因此，这可以完全分布的方式完全发生。

441
00:41:21,000 --> 00:41:25,320
必须没有超级节点或任何其他数据来重建所有数据。

442
00:41:25,320 --> 00:41:27,720
这可以以非常分布的方式发生。

443
00:41:31,079 --> 00:41:31,640
下一个幻灯片。

444
00:41:34,120 --> 00:41:41,800
然后，最后一步是，即使是恶意的多数，我们也希望安全。

445
00:41:42,840 --> 00:41:47,600
因此，使用数据将使用该方法进行采样。

446
00:41:47,600 --> 00:41:51,400
以及每个节点，每个节点都会执行

447
00:41:51,400 --> 00:41:56,400
他们会在广场中选择75个随机样品吗

448
00:41:57,660 --> 00:42:00,460
他们不会认识他们。

449
00:42:00,460 --> 00:42:03,600
只有当他们找到所有这些样本时，

450
00:42:03,600 --> 00:42:08,000
他们会说这是75

451
00:42:08,000 --> 00:42:12,480
因为我们实际上需要75％的样品

452
00:42:12,480 --> 00:42:13,940
为了重建数据，

453
00:42:13,940 --> 00:42:16,639
高于我们的一通阈值。

454
00:42:16,639 --> 00:42:20,659
因此，这再次确保了它可用。

455
00:42:21,719 --> 00:42:24,039
不可用的块通过的概率

456
00:42:24,039 --> 00:42:25,840
小于SINUS 30。

457
00:42:28,639 --> 00:42:29,840
凉爽的。

458
00:42:29,840 --> 00:42:33,119
因此，让我们快速谈论EIP-4844如何

459
00:42:33,119 --> 00:42:35,139
您希望听说过，

460
00:42:35,139 --> 00:42:36,740
几周前升级

461
00:42:36,740 --> 00:42:39,519
我认为这很有趣。

462
00:42:39,519 --> 00:42:41,900
因此，如果您查看以太坊的数据可用性，

463
00:42:42,480 --> 00:42:52,800
昨天卷起，就像以前一样，是的，以获取数据

464
00:42:52,800 --> 00:42:58,820
将通过呼叫数据，这真的很昂贵且非常烦人，并且

465
00:42:58,820 --> 00:43:09,079
自3月13日以来，我们在

466
00:43:09,079 --> 00:43:12,940
到现在可以使用的区块链

467
00:43:12,940 --> 00:43:16,940
为了获取以太坊上可用的廉价数据。

468
00:43:18,039 --> 00:43:20,759
然后将来，我们将进一步扩展这一点，

469
00:43:20,759 --> 00:43:23,239
因此可能会有一些扩展

470
00:43:23,239 --> 00:43:25,980
到今年年底，AP-44

471
00:43:25,980 --> 00:43:28,400
也许明年的某个时候

472
00:43:28,400 --> 00:43:32,059
然后希望在接下来的两年左右的时间内

473
00:43:32,059 --> 00:43:33,279
我们将获得完整的碎片

474
00:43:33,279 --> 00:43:36,319
具有以太坊的大量数据可用性。

475
00:43:39,079 --> 00:43:43,079
因此，EIP-4844设计非常简单。

476
00:43:43,079 --> 00:43:48,079
我们在每个块中添加了一些KCG对数据的承诺，

477
00:43:49,420 --> 00:43:53,159
以及这些KCG承诺的实际数据

478
00:43:53,159 --> 00:43:57,239
是块数据，这只是分开分布

479
00:43:57,239 --> 00:43:59,779
在网络上，这意味着我们可以

480
00:43:59,779 --> 00:44:02,940
效率更高，可以并行工作，

481
00:44:02,940 --> 00:44:04,639
但是每个人仍然可以获得所有数据。

482
00:44:04,639 --> 00:44:07,000
因此，它还不可扩展，就像有些

483
00:44:07,000 --> 00:44:09,219
踏板数据周围的效率提高，

484
00:44:09,219 --> 00:44:11,840
特别是它开始了一个新的数据市场。

485
00:44:16,019 --> 00:44:17,219
如此主要的是，

486
00:44:17,219 --> 00:44:19,980
他们现在的价格独立于执行。

487
00:44:19,980 --> 00:44:21,420
这是一种新的气体类型，很酷，

488
00:44:21,420 --> 00:44:25,739
因为到目前为止，Roabs总是必须竞争

489
00:44:25,739 --> 00:44:28,599
在第一层交易中，

490
00:44:28,599 --> 00:44:31,880
不幸的是，这常常使它变得非常昂贵，

491
00:44:31,880 --> 00:44:34,639
因为那些人​​的价格往往很高，所以

492
00:44:34,639 --> 00:44:36,920
而且汽油必须定价，

493
00:44:36,920 --> 00:44:41,920
抱歉，数据必须以非常悲观的方式定价。

494
00:44:42,039 --> 00:44:45,980
是的，我们非常有限。

495
00:44:45,980 --> 00:44:49,139
因此，您可以查看是否查看L2费用之类的东西，

496
00:44:49,139 --> 00:44:52,299
现在，我们已经大大降低了汇总的费用，

497
00:44:52,299 --> 00:44:54,000
这就像一个伟大的成就。

498
00:44:55,440 --> 00:44:57,980
从不需要斑点来计算状态更新。

499
00:44:57,980 --> 00:44:59,980
因此，为了看最新状态

500
00:44:59,980 --> 00:45:00,859
以太坊链是

501
00:45:00,859 --> 00:45:03,239
您不需要实际的斑点数据。

502
00:45:03,239 --> 00:45:06,539
只需要知道它们存在。

503
00:45:06,539 --> 00:45:11,599
因此，整个想法是我们设计了这个，以便我们可以进行所有未来的升级

504
00:45:11,599 --> 00:45:13,000
很容易。

505
00:45:13,000 --> 00:45:19,379
因此，特别是，我们已经使用KCG承诺，这意味着我们可以直接升级

506
00:45:19,379 --> 00:45:21,259
这是使用擦除编码。

507
00:45:21,259 --> 00:45:26,519
像现在一样，我们不以任何方式使用擦除编码，但很容易

508
00:45:26,519 --> 00:45:28,299
添加此。

509
00:45:28,299 --> 00:45:32,759
因此，我们几乎可以完成我们需要做的所有工作，而无需共识的改变。

510
00:45:32,760 --> 00:45:36,520
将来真正共识需要做的唯一的事情是更新

511
00:45:36,520 --> 00:45:39,200
我们可以支持的斑点。

512
00:45:39,200 --> 00:45:44,260
所以这真的很好，因为它确实使它脱离了，基本上我们可以开始

513
00:45:44,260 --> 00:45:48,880
在整个网络和DAS上工作等等，而无需做更多的事情

514
00:45:48,880 --> 00:45:51,560
升级到以太坊。

515
00:45:51,560 --> 00:45:56,180
最后一个很酷的事情是，汇总将不必再次升级才能受益。

516
00:45:56,180 --> 00:46:02,220
因此，通过所有分片升级，到4844的接口将完全保持不变。

517
00:46:02,219 --> 00:46:11,779
因此，如果他们现在开始使用斑点，那么希望从现在开始几年后，他们将从全层次碎片中获得大量数据可用性。

518
00:46:12,799 --> 00:46:13,379
好的。

519
00:46:14,899 --> 00:46:15,519
谢谢。

520
00:46:15,959 --> 00:46:17,859
是的，如果您有任何疑问，请告诉我。

521
00:46:21,579 --> 00:46:21,980
惊人的。

522
00:46:22,239 --> 00:46:23,419
非常感谢，Dankorat。

523
00:46:24,319 --> 00:46:24,719
惊人的。

524
00:46:27,039 --> 00:46:28,139
是的，很好。

525
00:46:28,759 --> 00:46:29,919
是的，非常感谢您的谈话。

526
00:46:30,219 --> 00:46:31,159
我真的很感激。

527
00:46:31,159 --> 00:46:38,440
这是非常有见地的。我相信我们学到了很多。伙计们，如果你有

528
00:46:38,440 --> 00:46:43,079
关于Dyncraft的问题，请将其写在Discord主题中，我们很快就会询问。

529
00:46:45,159 --> 00:46:52,119
是的，我想问，是的，有一个问题，您是否可以详细说明有关电流的更多信息

530
00:46:52,119 --> 00:46:57,960
声明，当前的步骤和挑战。所以你提到有一些升级可以完成

531
00:46:57,960 --> 00:47:03,800
因为它以前，就像平均记录一样，然后是通往完整碎片的路径。

532
00:47:03,800 --> 00:47:11,840
是的，有什么问题，现在解决的挑战是为了实现这一目标吗？

533
00:47:11,840 --> 00:47:18,940
因此，有了4844，我的意思是，我们想做一些事情。

534
00:47:18,940 --> 00:47:25,280
目前，我实际上还没有完全看待这些。

535
00:47:25,280 --> 00:47:29,100
我认为目前，我们主要看到一切工作原理。

536
00:47:29,100 --> 00:47:32,440
我认为有一些非常小的问题，

537
00:47:33,640 --> 00:47:37,000
但我认为这主要是观看它的想法

538
00:47:37,000 --> 00:47:38,660
明年，

539
00:47:38,660 --> 00:47:41,900
希望我们能增加其中的斑点数量。

540
00:47:43,780 --> 00:47:45,160
我认为在碎片方面

541
00:47:45,160 --> 00:47:49,720
肯定有一些很大的障碍

542
00:47:49,720 --> 00:47:50,660
我们仍然需要接受。

543
00:47:50,659 --> 00:47:55,659
因此，池Das基本上是一个偏离的

544
00:47:56,980 --> 00:48:00,259
当前所有区块链都使用的网络模型。

545
00:48:00,259 --> 00:48:04,879
目前，区块链通常在广播上运行。

546
00:48:05,960 --> 00:48:09,119
就像基本上一样，就像每个人都看到的一切一样，

547
00:48:09,119 --> 00:48:11,359
网络上的所有消息。

548
00:48:11,359 --> 00:48:14,299
使用DAS，我们想要一个更薄的网络。

549
00:48:14,299 --> 00:48:15,980
我们希望能够喜欢

550
00:48:15,980 --> 00:48:19,659
每个样品只有很少的节点存储。

551
00:48:20,659 --> 00:48:26,059
这防止了面对可能的攻击等等，这阻止了巨大的挑战。

552
00:48:26,119 --> 00:48:28,299
因此，就像可能的网络结构。

553
00:48:28,699 --> 00:48:35,500
我们确实有一些，就像如何获得相当数量的缩放率有关。

554
00:48:36,039 --> 00:48:41,980
因此，基本上，我们已经在研究了一种结构，称为Peerdas。

555
00:48:42,480 --> 00:48:47,659
因此，如果您将其扩展到几乎所有样本仍在您的网络附近的程度，则

556
00:48:47,659 --> 00:48:49,839
就像在您的节点的一个跳跃中一样

557
00:48:50,159 --> 00:48:52,379
那你仍然可以很安全

558
00:48:52,379 --> 00:48:55,079
一切都可以正常工作。

559
00:48:55,179 --> 00:48:56,000
所以很好。

560
00:48:56,699 --> 00:48:57,940
因此，这将是我们的第一步。

561
00:48:58,059 --> 00:49:00,399
而且我认为就像下一步进入完整的碎片一样，

562
00:49:00,719 --> 00:49:03,599
这仍然是一个更大的问题。

563
00:49:03,599 --> 00:49:07,639
好吧，我的意思是，您基本上是可以实现的

564
00:49:07,639 --> 00:49:12,059
如果您在其他安全性假设上

565
00:49:12,059 --> 00:49:14,639
您基本上说，嘿，我很高兴相信

566
00:49:14,639 --> 00:49:23,199
会有一些超级节点总是保留所有样本，只要一个

567
00:49:23,199 --> 00:49:26,879
那些超级节点是诚实的，一切都会好起来的。

568
00:49:26,879 --> 00:49:34,400
我认为这是一个相对可以的假设，但是许多人不太舒服

569
00:49:34,400 --> 00:49:35,400
与它。

570
00:49:35,400 --> 00:49:39,099
但是，是的，有了这个假设，您可以相对工作。

571
00:49:39,099 --> 00:49:41,960
这就是Celestia在做的事情。

572
00:49:41,960 --> 00:49:44,379
它对他们有用。

573
00:49:44,380 --> 00:49:48,420
我认为一旦您进入了一个完全分布式系统

574
00:49:48,420 --> 00:49:51,260
还有DHT，仍然有实际的研究

575
00:49:51,260 --> 00:49:52,720
目前要完成。

576
00:49:56,140 --> 00:49:58,119
有趣的是，非常感谢。

577
00:49:58,119 --> 00:49:59,180
惊人的。

578
00:49:59,180 --> 00:50:03,760
是的，关于2D KZG有一个问题。

579
00:50:03,760 --> 00:50:06,940
数字75％来自哪里，

580
00:50:06,940 --> 00:50:10,440
是否是多型重建数据的50％

581
00:50:10,440 --> 00:50:13,240
但是乘以两个，还是？

582
00:50:13,239 --> 00:50:21,000
不，如果您解决的话，它只是想让您希望75％的样本成为

583
00:50:21,000 --> 00:50:34,759
可用，因此您需要0.75的n功率为230，然后大致获得75。

584
00:50:34,760 --> 00:50:38,000
凉爽，凉爽，凉爽。

585
00:50:38,000 --> 00:50:46,100
是的，福克斯，如果您还有更多问题，请继续询问。

586
00:50:46,100 --> 00:50:57,880
从安全的角度或协议的角度来看，保险是否有任何缺点，

587
00:50:57,880 --> 00:51:03,700
您认为有任何权衡吗？

588
00:51:03,699 --> 00:51:09,659
使用条款，就卷起吗？对于协议

589
00:51:09,659 --> 00:51:15,039
像安全性一样，例如，与

590
00:51:15,039 --> 00:51:21,579
带宽。是的，是的，我的意思是，带宽有所增加，所以这是真的

591
00:51:21,579 --> 00:51:28,239
实际上，我认为这是一个有趣的问题，因为是的，

592
00:51:28,239 --> 00:51:31,019
还有Tenkuun的其他问题，就像在哪里

593
00:51:31,019 --> 00:51:37,259
客户软件中的错误由于完全不同的原因而增加带宽。

594
00:51:37,259 --> 00:51:43,420
因此，我认为许多验证者看到的带宽很高，实际上并非引起

595
00:51:43,420 --> 00:51:47,639
通过斑点，但通过证明聚集八卦。

596
00:51:50,380 --> 00:51:56,519
是的，我的意思是，我想，是的，这是带宽的增加。

597
00:51:56,519 --> 00:52:09,259
是的，在某种程度上，是的，我们需要弄清楚我们对什么感到满意。

598
00:52:09,400 --> 00:52:14,300
我认为，是的，总会有一个权衡，有人会说，现在对我来说太多了。

599
00:52:14,480 --> 00:52:21,079
我认为，我希望很快我们将拥有可以减少您需要的带宽的结构。

600
00:52:21,079 --> 00:52:28,179
但是，是的，有一些方法可以减少网络本身。

601
00:52:28,480 --> 00:52:31,079
因此，目前可以进行许多优化。

602
00:52:33,119 --> 00:52:34,500
酷，很酷。太感谢了。

603
00:52:35,400 --> 00:52:47,779
是的，关于数据可用性采样的问题，特别是用于识别节点是否诚实存储数据以及如何削减数据的机制。

604
00:52:47,780 --> 00:52:52,780
因此，如果我认为存在某种挑战，

605
00:52:54,420 --> 00:52:55,940
但是，如果节点是，例如

606
00:52:55,940 --> 00:52:58,640
离线和诚实行事，

607
00:52:58,640 --> 00:53:01,740
只是我们是否有一些机制，是的。

608
00:53:02,780 --> 00:53:06,080
是的，所以您不能砍伐节点，对吗？

609
00:53:06,080 --> 00:53:08,620
节点不是绑定的，所以没有什么

610
00:53:08,620 --> 00:53:09,540
你可以做。

611
00:53:10,440 --> 00:53:13,640
因此，节点可以存储数据是否存储。

612
00:53:14,780 --> 00:53:17,120
您可以，如果这是您的同行之一，

613
00:53:17,119 --> 00:53:20,420
因此，如果您有一个非常本地的系统，那就是优势之一

614
00:53:20,420 --> 00:53:24,639
它在VPS上，然后您可以降低它们。

615
00:53:24,639 --> 00:53:28,299
您可以说，如果您没有我认为您应该拥有的样本，

616
00:53:28,460 --> 00:53:30,319
那你不是一个很好的同伴。

617
00:53:30,480 --> 00:53:35,940
所以我可能会降低您的范围，如果您的分数太低，

618
00:53:35,980 --> 00:53:37,119
我将与您断开连接。

619
00:53:38,239 --> 00:53:46,159
因此，这是存储的可能性。

620
00:53:46,159 --> 00:53:52,219
因此，目前，我们真的没有任何专家存储机制。

621
00:53:52,679 --> 00:53:54,619
顺便说一下，这不是以太坊的变化。

622
00:53:54,759 --> 00:53:55,739
情况也是如此。

623
00:53:56,239 --> 00:54:02,519
没有人保证过去的以太坊块被保存为存储空间。

624
00:54:02,699 --> 00:54:04,839
恰好是默认节点实现。

625
00:54:06,199 --> 00:54:11,079
将来，我们将包括一种称为证明监护权的建筑。

626
00:54:11,079 --> 00:54:17,360
这基本上意味着验证者至少必须存储一段时间才能不被削减。

627
00:54:17,900 --> 00:54:19,079
这是未来的升级。

628
00:54:19,179 --> 00:54:24,219
从现在开始大概是几年了，因为目前还不是最高的优先事项。

629
00:54:25,759 --> 00:54:28,559
如果数据将进行采样，这将无法直接帮助。

630
00:54:28,900 --> 00:54:33,840
就像单个样本一样，因为，就像，您无法真正，喜欢，是的，

631
00:54:33,920 --> 00:54:36,699
以太坊并不真正想要真正短期的削减条件。

632
00:54:36,699 --> 00:54:39,599
就像您在10秒内不回答一样，您就会被砍掉。

633
00:54:39,819 --> 00:54:42,579
像那样的是反省。

634
00:54:44,159 --> 00:54:47,799
就像它真的没有用，因为例如

635
00:54:47,799 --> 00:54:51,939
验证者，我们希望您能够在家中运行它们。

636
00:54:52,039 --> 00:54:53,859
您可以拥有不良的互联网连接，依此类推。

637
00:54:54,119 --> 00:54:55,919
所以所有这些都是长期的

638
00:54:55,919 --> 00:54:57,779
而且不是真的很喜欢

639
00:54:57,859 --> 00:54:59,199
我现在可以获取样品吗？

640
00:54:59,299 --> 00:55:00,899
所以你真的需要，是的，

641
00:55:00,899 --> 00:55:03,899
这是您真正需要的困难之一

642
00:55:03,899 --> 00:55:05,719
经常依靠诚实的节点。

643
00:55:05,719 --> 00:55:09,879
这就是使抽样本身变得困难的原因。

644
00:55:12,879 --> 00:55:14,279
太棒了，这很有趣。

645
00:55:14,279 --> 00:55:16,819
我没有意识到你可以使用DAS

646
00:55:16,819 --> 00:55:18,480
为您的同龄人评分。

647
00:55:18,480 --> 00:55:21,019
那可能非常有效。

648
00:55:21,019 --> 00:55:23,559
是的，很有趣。

649
00:55:23,559 --> 00:55:26,279
是的，伙计们，请随时提出更多问题。

650
00:55:26,279 --> 00:55:28,119
我们和丹·克拉德（Dan Kradt）有更多时间

651
00:55:28,119 --> 00:55:32,619
因此，这是一个捡大脑的机会。

652
00:55:32,619 --> 00:55:35,319
我可能会问一些更笼统的事情

653
00:55:35,320 --> 00:55:37,600
在外面，甚至在碎片之外

654
00:55:37,600 --> 00:55:39,360
是一个非常非常令人兴奋的话题

655
00:55:39,480 --> 00:55:41,500
当然。还有其他域

656
00:55:41,500 --> 00:55:43,440
您发现有趣，令人兴奋的

657
00:55:43,440 --> 00:55:45,480
您最近一直在工作，甚至可能在外面

658
00:55:45,480 --> 00:55:45,960
以太坊？

659
00:55:48,260 --> 00:55:48,700
正确的。

660
00:55:49,539 --> 00:55:51,220
我的意思是，在以太坊内，

661
00:55:51,440 --> 00:55:53,559
我认为，大个子之一

662
00:55:53,559 --> 00:55:54,400
东西，

663
00:55:54,660 --> 00:55:57,640
是的，现在，目前

664
00:55:57,640 --> 00:55:59,440
我认为很多人正在考虑

665
00:55:59,440 --> 00:56:01,140
是经济学，所以

666
00:56:01,140 --> 00:56:03,800
这是一个非常重要的话题。

667
00:56:03,800 --> 00:56:04,580
我认为，就像

668
00:56:04,579 --> 00:56:08,519
每个人都试图缠绕着自己的头

669
00:56:08,519 --> 00:56:11,980
将来可能的样子。

670
00:56:12,920 --> 00:56:16,799
我认为不是

671
00:56:16,799 --> 00:56:20,699
似乎理想的所有股份都被液体含有代币抓住，所以我们正在尝试

672
00:56:20,699 --> 00:56:24,599
找出是否有任何方法

673
00:56:24,599 --> 00:56:25,739
事实并非如此。

674
00:56:28,119 --> 00:56:30,840
是的，对此有很多想法。

675
00:56:30,840 --> 00:56:33,280
否则

676
00:56:33,280 --> 00:56:35,200
是的，我的意思是

677
00:56:35,200 --> 00:56:37,720
不，我没有

678
00:56:37,720 --> 00:56:39,000
喜欢

679
00:56:39,000 --> 00:56:42,000
我的意思是，我的许多

680
00:56:42,000 --> 00:56:44,100
目前我的大部分研究

681
00:56:44,100 --> 00:56:45,059
试图得到

682
00:56:45,059 --> 00:56:48,240
分碎实施并围绕这些实施

683
00:56:48,240 --> 00:56:51,140
惊人的

684
00:56:51,140 --> 00:56:53,980
也许你有点

685
00:56:53,980 --> 00:56:56,180
提到那里的赌场，你有点

686
00:56:56,180 --> 00:56:57,820
在Staking Maximalism上

687
00:56:57,820 --> 00:56:59,320
液体存在最大主义

688
00:56:59,320 --> 00:57:01,600
也许如果您可以谈论一下。

689
00:57:01,600 --> 00:57:10,000
是的，我的意思是，我认为，所以这是我在Twitter上发布的，我认为去年的某个时候。

690
00:57:10,000 --> 00:57:22,320
我认为，这确实是一个非常蓝天的思考，我认为这不是一个好主意。

691
00:57:22,320 --> 00:57:29,800
但是我的想法是，我认为，尤其是在宇宙索拉纳生态系统中，

692
00:57:30,080 --> 00:57:37,240
很多人想到的是，对Stakers的发行并不是真的，并不是真的

693
00:57:37,240 --> 00:57:39,300
真正的发行，因为每个人都可以利用。

694
00:57:39,519 --> 00:57:44,160
因此，从本质上讲，您最终，它变成了每个人的赌注，然后

695
00:57:44,160 --> 00:57:45,519
每个人都为此得到回报。

696
00:57:45,539 --> 00:57:47,140
因此，这就像一个完整的零和游戏。

697
00:57:47,139 --> 00:57:50,299
显然

698
00:57:50,299 --> 00:57:52,519
像所有这些一样

699
00:57:52,519 --> 00:57:53,839
委托书证明

700
00:57:53,839 --> 00:57:56,539
我的意思是以某种方式

701
00:57:56,539 --> 00:57:58,259
思考就像一件吸引人的事情

702
00:57:58,259 --> 00:58:00,199
就像哦，也许可以解决所有

703
00:58:00,199 --> 00:58:01,859
如果我们能喜欢的话，我们的问题

704
00:58:01,859 --> 00:58:04,179
只是使委派成为主要

705
00:58:04,179 --> 00:58:05,379
赌注和

706
00:58:05,379 --> 00:58:11,900
我尝试考虑

707
00:58:11,900 --> 00:58:14,299
我想喜欢

708
00:58:14,299 --> 00:58:16,199
Vitalik首先像基本上一样

709
00:58:16,199 --> 00:58:20,239
最终结果总是喜欢，为什么？

710
00:58:20,239 --> 00:58:21,579
我们从中得到什么？

711
00:58:21,579 --> 00:58:24,679
像，这些stakers对我们有何帮助？

712
00:58:24,679 --> 00:58:27,539
而且还不清楚。

713
00:58:27,539 --> 00:58:30,739
不幸的是，这很难。

714
00:58:30,739 --> 00:58:34,219
在许多情况下，感觉就像是放在

715
00:58:34,219 --> 00:58:37,059
就像一个纯粹的钱游戏一样

716
00:58:37,059 --> 00:58:40,279
协议中没有什么实际上没有。

717
00:58:40,279 --> 00:58:43,919
那为什么我们甚至这样做呢？

718
00:58:43,919 --> 00:58:45,619
是的，目前。

719
00:58:46,199 --> 00:58:48,019
我不完全知道。

720
00:58:48,019 --> 00:58:52,500
我认为考虑所有这些建议很有趣。

721
00:58:53,480 --> 00:58:58,939
我目前并不是很靠任何方向倾斜。

722
00:58:59,259 --> 00:59:09,419
我认为这些天我的主要感觉是，我们需要继续保持更加有限。

723
00:59:09,420 --> 00:59:17,980
它。我认为这些天我看到的最危险的情况是，如果所有以太都被固定在上面。

724
00:59:17,980 --> 00:59:25,240
我觉得这很难逆转。我们最终进入了一个每个人突然突然的世界

725
00:59:25,240 --> 00:59:32,360
从字面上看，一个利益相关者，因此没有人希望他们的收入减少。显然，这会影响

726
00:59:32,360 --> 00:59:37,139
人们的决策。现在，所有以太坊治理都将是关于多少

727
00:59:37,139 --> 00:59:43,299
我在此上赚的百分比等等。因此，这似乎很危险和反乌托邦世界。所以

728
00:59:46,739 --> 00:59:52,659
我认为沿着这些线路，但是，不幸的是，我们还没有解决方案。

729
00:59:55,379 --> 01:00:00,259
谢谢。那很有趣。感谢您分享。

730
01:00:00,260 --> 01:00:07,600
它。是的，也许也是关于签名的话题，您对协议有什么感觉

731
01:00:07,600 --> 01:00:11,600
足够的经济安全？

732
01:00:11,600 --> 01:00:18,900
是的，我实际上是对经济安全的极简主义者。我不相信。

733
01:00:18,900 --> 01:00:25,380
老实说，我认为，一到100亿左右，这是所有的经济安全

734
01:00:25,380 --> 01:00:33,140
曾经需要。我认为我们的路超过了必要的。我不认为是攻击者，

735
01:00:33,140 --> 01:00:41,619
这基本上是前门。我认为前门，获得足够的股份来做某事

736
01:00:41,619 --> 01:00:48,579
对以太坊的不利已经是如此安全，以至于没有攻击者会尝试攻击它。如果我有十亿

737
01:00:48,579 --> 01:00:56,340
美元否则让我们说是的，就像假设以太坊的经济安全仅在

738
01:00:56,340 --> 01:01:03,699
报价标志着现在有100亿美元

739
01:01:03,699 --> 01:01:09,799
知道是说是三十亿美元还是五个，是说要获得三分之一，所以不是真的

740
01:01:09,799 --> 01:01:15,960
像这样，但就像说这不是在哪里使用50亿美元攻击的方式

741
01:01:15,960 --> 01:01:21,000
以太坊肯定，只是为了基本上执行一个双重命运。

742
01:01:23,000 --> 01:01:27,720
看来，我认为双重最终确定会造成太大的损害

743
01:01:28,760 --> 01:01:33,880
而且我也相信，还有其他潜在的向量更便宜。

744
01:01:35,400 --> 01:01:40,199
考虑一下您可以购买五百万美元的零天数。

745
01:01:40,199 --> 01:01:48,179
因此，我认为，是的，我认为我们远远超出了我们需要更多经济安全的地步。

746
01:01:48,179 --> 01:01:56,719
那真的很酷。是的，这是关于其他基本上其他瓶颈真的很棒的

747
01:01:56,719 --> 01:01:59,000
当经济安全增长时。

748
01:01:59,000 --> 01:02:02,000
那是一个很好的点。

749
01:02:03,399 --> 01:02:04,939
是的，非常感谢。

750
01:02:08,319 --> 01:02:09,319
好的。

751
01:02:11,439 --> 01:02:14,119
我很好奇您是否可以详细说明

752
01:02:14,119 --> 01:02:19,119
在一个全部固定的世界中，它的样子。

753
01:02:22,019 --> 01:02:23,000
什么？

754
01:02:23,000 --> 01:02:27,159
就像将其变成的条件是什么？

755
01:02:27,159 --> 01:02:28,159
正确的。

756
01:02:28,159 --> 01:02:29,159
所以，对。

757
01:02:29,159 --> 01:02:35,920
因此，基本上，我的意思是，主要的事情是如此，要理解我们必须思考

758
01:02:35,920 --> 01:02:39,280
关于液体含有令牌会发生什么，对吗？

759
01:02:39,280 --> 01:02:45,320
因此，因此人们喜欢原本人的股份，因为像他们想要的那样，嗯，一定数量

760
01:02:45,320 --> 01:02:50,380
就像他们获得了一定的回报，嗯，本质上是两件事，就像他们一样

761
01:02:50,380 --> 01:02:57,019
将他们的钱锁定为安全性，因此他们锁定以太币

762
01:02:57,900 --> 01:03:06,860
嗯，嗯，他们必须喜欢投票或其他东西，所以液体以类似

763
01:03:08,140 --> 01:03:12,140
嗯，在一定程度上摆脱了这一点，因此您不需要运行无效的

764
01:03:12,140 --> 01:03:14,860
再过，您获得的奖励少一些，其他人运行它

765
01:03:14,860 --> 01:03:23,099
它。它做了一些事情。因此，它摆脱了资本瓶颈。好吧，好吧。

766
01:03:23,099 --> 01:03:30,160
是的，它的另一件事是，它可以让您立即离开

767
01:03:30,160 --> 01:03:39,800
因为有足够的流动性。好吧，这是第三件事，就像您还可以，是的，

768
01:03:39,800 --> 01:03:44,780
这也是流动性的函数，但是，您也可以使用它。喜欢，

769
01:03:44,780 --> 01:03:53,660
示例在defi中您可以锁定去做其他事情，依此类推，可能发生的事情是

770
01:03:53,660 --> 01:04:01,560
在某个时刻，是否有足够的液体流动性在液体含有代币中

771
01:04:01,560 --> 01:04:08,860
他们可能会变得如此吸引人，以至于奖励几乎是无关紧要的，就像可以说

772
01:04:08,860 --> 01:04:10,920
丽托（Lido）固定了以太

773
01:04:10,920 --> 01:04:14,079
具有相同的功能

774
01:04:14,079 --> 01:04:15,240
作为以太坊本身。

775
01:04:15,620 --> 01:04:16,380
和人们字面上

776
01:04:16,380 --> 01:04:17,500
在交流上

777
01:04:17,500 --> 01:04:19,180
开始交易

778
01:04:19,180 --> 01:04:21,300
像LS Ether

779
01:04:21,300 --> 01:04:22,099
而不是以太。

780
01:04:22,820 --> 01:04:22,960
正确的？

781
01:04:23,539 --> 01:04:23,860
所以，

782
01:04:24,360 --> 01:04:25,640
对不起，史蒂夫。

783
01:04:26,360 --> 01:04:27,320
所以，

784
01:04:27,599 --> 01:04:29,500
现在有什么区别？

785
01:04:29,800 --> 01:04:30,880
好吧，区别在于

786
01:04:30,880 --> 01:04:32,980
像利多·汤匙的ether

787
01:04:32,980 --> 01:04:34,160
仍然有产量

788
01:04:34,160 --> 01:04:35,079
与以太坊相比。

789
01:04:35,079 --> 01:04:36,019
所以永远是

790
01:04:36,019 --> 01:04:37,620
就像其他一切

791
01:04:37,620 --> 01:04:38,099
是一样的，

792
01:04:38,099 --> 01:04:39,559
它将永远更具吸引力。

793
01:04:39,559 --> 01:04:45,960
如果奖励下降到1％或0.5％或更少，那就是事实。

794
01:04:47,159 --> 01:04:49,860
所以这里有一个潜在的失控场景

795
01:04:49,860 --> 01:04:52,139
即使产量极低，

796
01:04:52,819 --> 01:04:55,860
他们基本上可以吃掉一切。

797
01:04:56,400 --> 01:04:59,400
唯一仍然可以使用以太的东西

798
01:04:59,400 --> 01:05:02,360
将直接支付汽油。

799
01:05:02,559 --> 01:05:03,420
仍然是真的。

800
01:05:03,639 --> 01:05:07,880
您必须最终更改为以太才能支付汽油。

801
01:05:08,099 --> 01:05:19,099
但是，我的意思是，只要所有这些都分配给了DEX，您可能会储备几％，就像在需要时可以有效地购买它。

802
01:05:20,239 --> 01:05:24,239
所以，是的，这是一种场景，就像基本上所有的ETH都被粘住了。

803
01:05:24,599 --> 01:05:25,639
我们目前还没有。

804
01:05:25,679 --> 01:05:32,099
我们显然没有看到我们去年看到的极端压力。

805
01:05:32,239 --> 01:05:33,519
它在某个时候停止了。

806
01:05:33,519 --> 01:05:37,920
我认为我们再次看到更多的赌注，但是我们仍然没有处于失控的情况。

807
01:05:37,920 --> 01:05:43,139
因此，人们仍然希望将其固定的ETH产量约3％至4％。

808
01:05:43,460 --> 01:05:46,680
这是有道理的，因为现在主要的液体令牌仍然是以太。

809
01:05:47,220 --> 01:05:50,840
例如，例如，您正在考虑在牛市上兑现，

810
01:05:51,400 --> 01:05:54,380
您可能会考虑一下，在某个时候我想要以太。

811
01:05:54,940 --> 01:06:01,260
如果那时以折扣的是将以太交易的交易，该怎么办？

812
01:06:01,400 --> 01:06:03,019
那我将不得不享受折扣。

813
01:06:03,240 --> 01:06:04,940
那可能不值得冒险，对吗？

814
01:06:04,940 --> 01:06:14,360
因此，目前，我们仍然不在一个人的收益率很小的时候感到满意

815
01:06:14,500 --> 01:06:15,700
像小于1％。

816
01:06:15,700 --> 01:06:18,960
但是，是的，我可以看到它最终可能发生。

817
01:06:18,960 --> 01:06:21,960
我认为这就是我们非常害怕的。

818
01:06:28,480 --> 01:06:30,099
惊人的。谢谢。

819
01:06:30,920 --> 01:06:31,980
是的，谢谢。

820
01:06:31,980 --> 01:06:38,740
嗯，好吧，嗯，如果可以的话，如果我们可以再等你一分钟，也许还有更多

821
01:06:38,740 --> 01:06:39,260
问题。

822
01:06:39,260 --> 01:06:45,179
嗯，嗯，是的，关于碎片的常见误解是什么？

823
01:06:45,340 --> 01:06:51,860
您知道，某些人会是什么样的误会，人们经常，如果您愿意的话

824
01:06:51,860 --> 01:06:52,260
揭穿？

825
01:06:52,260 --> 01:07:07,520
因此，我认为一件有趣的事情是碎片，或者是我们现代版本的碎片，

826
01:07:07,520 --> 01:07:14,080
这是随着汇总的数据碎片，必然意味着将不再具有合成性。

827
01:07:14,080 --> 01:07:21,200
因此，一件很酷的事情是汇总，因此当我们设计执行碎片时，请返回

828
01:07:21,199 --> 01:07:24,439
是的，这是我们碎片遇到的巨大问题之一。

829
01:07:24,439 --> 01:07:28,359
好吧，我们想，每个碎片都是它自己的小生态系统。

830
01:07:28,359 --> 01:07:35,419
在碎片之间移动绝对不会同步。

831
01:07:35,419 --> 01:07:37,539
但是随着汇总，情况实际上有些不同

832
01:07:37,539 --> 01:07:40,000
因为您可以设计非常大的汇总。

833
01:07:40,000 --> 01:07:43,659
我的意思是，贝丝的杰西（Jesse）前几天发布，

834
01:07:43,659 --> 01:07:47,419
他们想扩大每秒1千兆气的比例，这很棒，

835
01:07:47,419 --> 01:07:49,879
这正是汇总应该做的。

836
01:07:49,880 --> 01:07:52,039
很酷的是，汇总可以做到这一点

837
01:07:52,039 --> 01:07:55,160
因为它们不必像基础层那样分散

838
01:07:55,160 --> 01:07:58,160
因为它们可以通过基层负责。

839
01:07:58,360 --> 01:08:00,300
就像，我们可以保持他们的安全

840
01:08:00,300 --> 01:08:02,760
并保持其审查制度，

841
01:08:03,019 --> 01:08:05,940
即使他们不正确，也可以正确地构建。

842
01:08:05,940 --> 01:08:08,880
就像，如果他们的智能合约有

843
01:08:09,300 --> 01:08:12,160
用机制的强制交易等。

844
01:08:13,420 --> 01:08:17,960
因此，真正很酷的是在此汇总中，

845
01:08:17,960 --> 01:08:21,619
您可以拥有内部的大规模生态系统

846
01:08:21,619 --> 01:08:23,260
具有完整的合成性。

847
01:08:24,520 --> 01:08:28,359
在某种程度上，如果您愿意整合

848
01:08:30,579 --> 01:08:32,279
与基础层建议，

849
01:08:32,279 --> 01:08:35,319
您甚至可以与基础层具有合成性

850
01:08:35,319 --> 01:08:36,420
老实说。

851
01:08:39,720 --> 01:08:42,779
对，太棒了，谢谢，谢谢。

852
01:08:42,779 --> 01:08:53,179
好的，我们已经有一个问题，所以如果您可以给我们一些更具体的问题

853
01:08:53,179 --> 01:09:02,159
一般而言，围绕数据可用性采样和数据开发的开放研发问题，

854
01:09:02,159 --> 01:09:06,319
也许，您知道，人们可以学习，开始为

855
01:09:06,319 --> 01:09:09,000
许多渴望的贡献者。

856
01:09:09,000 --> 01:09:20,340
是的，是的，具体地，最大的开放问题是如何构建一个强大的分布

857
01:09:20,340 --> 01:09:22,920
哈希表或DHT。

858
01:09:22,920 --> 01:09:28,880
因此，如果有人对此感兴趣，那就像一个非常有趣的

859
01:09:28,880 --> 01:09:29,880
很酷的话题。

860
01:09:29,880 --> 01:09:36,899
因此，DHT的最大问题之一就是传统上，对等网络没有

861
01:09:36,899 --> 01:09:38,920
谁可以加入节点的限制。

862
01:09:40,139 --> 01:09:45,379
这在某种程度上包含在我之前，我以前提到过

863
01:09:45,599 --> 01:09:52,279
对于我们通常的区块链，例如以太坊，比特币，一切都是广播。

864
01:09:52,879 --> 01:09:57,199
如果您依靠这一点，那么很酷的是您只需要假设

865
01:09:57,199 --> 01:09:59,279
您已连接到一个诚实的节点。

866
01:10:00,039 --> 01:10:02,859
这就是一个相当可接受的假设

867
01:10:02,859 --> 01:10:04,920
人们相对舒适。

868
01:10:04,920 --> 01:10:06,699
这很难

869
01:10:06,699 --> 01:10:09,619
即使您拥有这种免费的加入机制，

870
01:10:09,760 --> 01:10:10,460
任何人都可以加入。

871
01:10:11,859 --> 01:10:13,100
很难。

872
01:10:13,800 --> 01:10:17,159
您可能会欺骗新节点。

873
01:10:17,340 --> 01:10:19,380
很难欺骗节点

874
01:10:19,380 --> 01:10:21,260
在网络中已经有很好的联系。

875
01:10:23,920 --> 01:10:28,039
因此DHT的问题

876
01:10:28,039 --> 01:10:31,720
是他们的安全假设要困难得多，

877
01:10:31,720 --> 01:10:37,000
即使分数相对较小，它们即使分解

878
01:10:37,000 --> 01:10:40,280
恶意节点，我们无法真正保证

879
01:10:40,280 --> 01:10:42,560
因为攻击者实际上可以添加

880
01:10:42,560 --> 01:10:44,720
电影网络的一百万个恶意节点

881
01:10:44,720 --> 01:10:47,220
我们将无能为力。

882
01:10:48,220 --> 01:10:51,440
是的，这是我们目前遇到的问题。

883
01:10:52,300 --> 01:10:54,380
如果人们想为此努力

884
01:10:55,260 --> 01:10:58,560
没有人真的找到了一个很棒的设计

885
01:10:58,560 --> 01:10:59,960
在脸上起作用。

886
01:10:59,960 --> 01:11:04,119
它可以使用与当前P2P网络相似的假设。

887
01:11:04,119 --> 01:11:07,119
那很有趣。

888
01:11:07,119 --> 01:11:13,159
是的，我希望研究小组的一些人会研究一下。

889
01:11:13,159 --> 01:11:14,920
是的，我们的成绩为70分钟。

890
01:11:14,920 --> 01:11:17,359
我认为我们可以慢慢结束。

891
01:11:17,359 --> 01:11:20,659
乔什，我们还有其他问题吗？

892
01:11:20,659 --> 01:11:28,899
是的，我很好奇执行碎片是否是路线图上的东西

893
01:11:28,899 --> 01:11:33,420
要点及其与数据碎片的不同。

894
01:11:33,420 --> 01:11:39,159
是的，我认为如今我认为执行碎片的差异很大。

895
01:11:39,159 --> 01:11:47,059
我认为过去五年中的景观发生了很多事情，我会

896
01:11:47,059 --> 01:11:56,019
说出我看到某种形式的执行碎片回到以太坊的方式是我们开始

897
01:11:56,020 --> 01:12:04,500
增加执行层的气体限制。我们这样做的方式是通过执行

898
01:12:04,500 --> 01:12:14,900
将自己分层到我们的数据层上，并通过ZKV-EVM添加证明。我们会的

899
01:12:14,900 --> 01:12:21,940
基本上是基本层本身会成为一个滚动，因为完整节点不必验证它

900
01:12:21,939 --> 01:12:23,479
它了。

901
01:12:23,479 --> 01:12:26,739
到那时，我认为我们可以达到一定程度

902
01:12:26,739 --> 01:12:29,279
我们可以在哪里开始缩放它。

903
01:12:29,279 --> 01:12:32,619
这可能不会像卷起一样积极。

904
01:12:32,619 --> 01:12:36,279
我们可能会更加保守。

905
01:12:36,279 --> 01:12:42,539
但是我可以看到我们最终可以得到100或1,000 x

906
01:12:42,539 --> 01:12:43,879
也不在基层。

907
01:12:48,719 --> 01:12:49,219
伟大的。

908
01:12:49,220 --> 01:12:52,199
是的，很酷的事情是它将保持完全综合

909
01:12:52,199 --> 01:12:56,060
因为它仍然像一个逻辑图表。

910
01:13:03,300 --> 01:13:06,520
好吧，是的，我认为这就是所有问题

911
01:13:06,520 --> 01:13:08,760
我在这里看到的。

912
01:13:11,340 --> 01:13:14,780
是的，是的，我认为我们已经是问题了

913
01:13:14,780 --> 01:13:18,980
我们已经超过70分钟了。

914
01:13:18,979 --> 01:13:22,419
是的，丹克拉特（Dankrat）就足够了。

915
01:13:22,419 --> 01:13:23,259
我知道这很宝贵，

916
01:13:23,259 --> 01:13:25,559
我们非常感谢您在这里。

917
01:13:25,559 --> 01:13:27,739
这是一种荣誉。

918
01:13:27,739 --> 01:13:29,199
是的，很高兴。

919
01:13:29,199 --> 01:13:30,319
是的。

920
01:13:30,319 --> 01:13:32,359
谢谢你有我。

921
01:13:32,359 --> 01:13:33,939
非常感谢，Dankrat。

922
01:13:33,939 --> 01:13:35,859
是的，我们感谢您加入研究小组。

923
01:13:35,859 --> 01:13:36,699
我们学到了很多，

924
01:13:36,699 --> 01:13:40,059
我希望有些人会写一份很棒的文件

925
01:13:40,059 --> 01:13:42,519
在我们的Wiki上开始说话

926
01:13:42,519 --> 01:13:45,579
进入数据可用性采样

927
01:13:45,579 --> 01:13:47,219
是的，是的。

928
01:13:47,220 --> 01:13:50,460
是的，很好，谢谢

929
01:13:50,460 --> 01:13:53,820
是的，这是我的一天

930
01:13:53,820 --> 01:13:57,360
再见是的，你们，但每个人都

931
01:13:57,360 --> 01:13:58,640
我们星期一见

932
01:13:58,640 --> 01:14:02,920
好吧，是的，星期一见

933
01:14:02,920 --> 01:14:05,600
另一个开发轨道课程

934
01:14:05,600 --> 01:14:10,199
龙我相信看执行

935
01:14:10,199 --> 01:14:15,119
客户深度潜水是我们将看到的

936
01:14:15,119 --> 01:14:22,399
如果我没有错，请让开发人员，开发人员，红色的首席开发人员解释体系结构

937
01:14:22,399 --> 01:14:27,680
红色移入数据库。如果有人对Rust感兴趣，对执行客户

938
01:14:27,680 --> 01:14:34,399
具体来说，这对您来说将是一个很好的学习机会。是的。惊人的。

939
01:14:34,399 --> 01:14:39,760
然后见。凉爽的。谢谢大家。再见。

