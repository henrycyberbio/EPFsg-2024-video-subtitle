1
00:00:00,000 --> 00:00:13,380
好的，每个人，感谢您加入我们，欢迎回到以太坊协议研究金研究小组。

2
00:00:13,960 --> 00:00:24,780
这是第10周的第二周，今天我们将与核心开发人员Lightclient谈论执行层。

3
00:00:24,780 --> 00:00:31,420
因此，我将继续前进，让Mario为我们介绍Matt，我们将在这里滚动。

4
00:00:33,039 --> 00:00:36,600
嘿，大家。嘿，马特。非常感谢您加入。非常感谢您的到来。

5
00:00:37,380 --> 00:00:39,620
你能听到我吗？

6
00:00:40,240 --> 00:00:41,159
我听到你的声音。

7
00:00:42,380 --> 00:00:45,079
是的，非常感谢您在这里，伙计。真的很感激。

8
00:00:45,520 --> 00:00:50,900
对于任何不认识Matt或Lightplan的人来说，他是，不仅是核心开发人员，

9
00:00:50,899 --> 00:00:57,619
他是Go Ethereum Tier团队的一员，不仅仅是Go Ethereum嗯，嗯

10
00:00:57,619 --> 00:01:04,180
测试IP编辑并通常会杀死轻杀，这是您可以去的人

11
00:01:04,180 --> 00:01:11,299
您想了解协议的所有复杂性如何混合在一起

12
00:01:11,299 --> 00:01:17,299
我相信他对协议的许多部分都有强烈的意见，嗯，他一直在

13
00:01:17,299 --> 00:01:22,979
还在处理诸如帐户障碍之类的东西多年，今天他将给予

14
00:01:22,979 --> 00:01:28,899
我们深入研究了执行层理论，他致力于在Go Ethereum中实施该理论

15
00:01:29,620 --> 00:01:36,099
如果您有任何疑问

16
00:01:36,099 --> 00:01:42,420
那是我们在过去一周中已经提出了一些问题，所以如果您准备好了

17
00:01:42,420 --> 00:01:46,019
可以随意将它们发布在相应的不和谐线程中。

18
00:01:46,460 --> 00:01:48,400
当有一个空间时，

19
00:01:48,439 --> 00:01:49,159
我们会问。

20
00:01:49,519 --> 00:01:51,240
我们会问马特。

21
00:01:51,840 --> 00:01:52,219
是的。

22
00:01:52,820 --> 00:01:54,180
再次感谢您在这里，伙计。

23
00:01:54,299 --> 00:01:55,180
我真的很感激。

24
00:01:55,299 --> 00:01:56,379
地板是你的。

25
00:01:58,379 --> 00:01:58,819
凉爽的。

26
00:01:59,000 --> 00:02:00,040
你们能听到我的声音吗？

27
00:02:01,840 --> 00:02:02,280
甜的。

28
00:02:03,140 --> 00:02:04,659
如果我问问题，

29
00:02:05,240 --> 00:02:08,480
人们将它们交给您的最佳方法是什么？

30
00:02:08,520 --> 00:02:10,180
是通过不和谐的，您会问他们吗？

31
00:02:10,900 --> 00:02:11,500
凉爽的。

32
00:02:12,419 --> 00:02:18,179
惊人的。非常感谢您拥有我。我很高兴与所有人谈论执行层。

33
00:02:18,239 --> 00:02:19,699
是的，我们会通过和不和谐做到。

34
00:02:20,479 --> 00:02:30,379
是的。因此，我有一些笔记准备以某种简单的术语概述执行层的概述。

35
00:02:31,019 --> 00:02:34,099
但是，如果您有疑问，请随时将其发布在Discord上。

36
00:02:34,659 --> 00:02:37,519
乔什（Josh）和马里奥（Mario），随时打扰我。

37
00:02:37,519 --> 00:02:40,859
我想确保我们都在同一页面上。

38
00:02:42,419 --> 00:02:47,819
这样，让我分享我的屏幕，我们可以继续开始并开始。

39
00:02:53,759 --> 00:03:00,599
所以我想出了一些轮廓，让我们有一点结构

40
00:03:00,599 --> 00:03:01,019
讨论。

41
00:03:02,299 --> 00:03:07,139
我想做的第一件事就是对主要部分的概述

42
00:03:07,139 --> 00:03:12,339
我看到执行层具有，然后我们可以更深入地深入了解其中的每个

43
00:03:12,340 --> 00:03:19,159
具体元素。因此，让我们开始。假设这是第二周的演讲。

44
00:03:24,099 --> 00:03:27,900
我想谈论的第一件事是我想谈谈

45
00:03:27,900 --> 00:03:31,240
执行层的块验证方面。

46
00:03:34,000 --> 00:03:39,980
通过合并，我们已经改变了执行层在以太坊中的作用

47
00:03:39,979 --> 00:03:45,959
在有些无所不包之前，您知道链的共识是

48
00:03:45,959 --> 00:03:52,120
确保链的完整性，您知道确保订购块

49
00:03:52,120 --> 00:03:56,879
以正确的方式正确地发生了重新发生的方式以及所有这些类型的

50
00:03:56,879 --> 00:04:04,019
合并后，所有这些都将所有这些都外包给了共识层，此时角色

51
00:04:04,019 --> 00:04:09,319
在执行层中已经变得更加简化，所以我喜欢将其视为

52
00:04:09,319 --> 00:04:12,159
它只是执行状态过渡功能。

53
00:04:12,159 --> 00:04:14,180
我们会谈论它的外观，

54
00:04:14,180 --> 00:04:18,800
但是只是为了具体阐明这一点，

55
00:04:18,800 --> 00:04:22,199
我们实际上可以在共识规范中看到

56
00:04:22,199 --> 00:04:26,839
共识层如何考虑执行层。

57
00:04:26,839 --> 00:04:29,139
因此，如果我们去共识规格

58
00:04:29,139 --> 00:04:33,600
我们看Deneb Beaton Chain，

59
00:04:33,600 --> 00:04:38,159
实际上，我们可以直接看一下，看看

60
00:04:38,160 --> 00:04:47,200
它已验证已通知的有效负载UH实际执行有效负载，因此有一个称为过程的函数

61
00:04:47,200 --> 00:04:55,200
执行有效载荷由信标链执行时，它正在通过所有其他

62
00:04:56,000 --> 00:05:01,120
验证验证块需要执行的验证是有效的，并将共识层移动向前移动

63
00:05:01,120 --> 00:05:08,399
因此，在此处，执行层实际上已经被此功能所体现。

64
00:05:08,399 --> 00:05:15,340
并且如何交流这些东西有很多不同的复杂性。

65
00:05:15,340 --> 00:05:18,139
您可以使用此执行引擎概念来看到这一点。

66
00:05:18,139 --> 00:05:23,740
这就是我们从共识层与执行层通信的方式。

67
00:05:23,740 --> 00:05:28,740
但实际上，您能想到的是我们进行一些高级检查，请确保有些事情

68
00:05:28,740 --> 00:05:33,699
就像父母的哈希是正确的一样，这是链的下一个块，验证一些诸如

69
00:05:33,699 --> 00:05:40,579
时间戳，其他一些，您知道，轻量级验证。然后我们将有效载荷发送到

70
00:05:40,579 --> 00:05:48,660
执行层并验证块。我们实际上可以看到最低级别的功能

71
00:05:48,660 --> 00:05:53,420
在与执行层与通知新有效载荷相互作用的信标链中。

72
00:05:53,420 --> 00:05:55,920
因此，通知新有效载荷。

73
00:05:56,580 --> 00:06:00,000
共识层的规格中没有实现

74
00:06:00,000 --> 00:06:03,180
因为它的作用只是发送执行有效载荷

75
00:06:03,180 --> 00:06:07,020
执行引擎，这是您的执行客户端。

76
00:06:07,640 --> 00:06:11,040
然后执行客户端执行状态过渡功能。

77
00:06:11,180 --> 00:06:14,540
它验证了块标头的校正，

78
00:06:14,720 --> 00:06:18,580
验证交易正确地应用于状态，

79
00:06:18,580 --> 00:06:20,740
它将返回对还是错。

80
00:06:20,740 --> 00:06:26,639
因此，就共识层如何看待执行层而言，这确实很简单。

81
00:06:28,019 --> 00:06:33,500
因此，从共识层的角度来看，这就是块验证。

82
00:06:34,040 --> 00:06:40,379
让我们看一下从实际执行层高级别的块验证的外观。

83
00:06:40,879 --> 00:06:42,160
所以我要在旅途中写这篇文章。

84
00:06:42,340 --> 00:06:44,000
这将是超级直接的。

85
00:06:44,460 --> 00:06:46,720
真的没有特别的事情。

86
00:06:46,720 --> 00:06:50,760
但是，如果您对某些语法的含义有疑问，请随时跳入。

87
00:06:51,440 --> 00:06:54,540
但基本上，您可以想到阶段过渡功能，我将简化

88
00:06:54,540 --> 00:06:58,220
它是sTF的一些参数。

89
00:06:58,220 --> 00:07:03,960
对于执行层所采用的确切条件并不是完美的。

90
00:07:04,200 --> 00:07:08,360
但是出于说明性目的，我认为这是考虑它的最简单方法。

91
00:07:08,700 --> 00:07:12,760
这样我们就会占据父母块，因为我们将不得不验证一些

92
00:07:12,759 --> 00:07:18,819
从父母到当前区块的过渡逻辑。然后，我们将接收当前的块。

93
00:07:20,519 --> 00:07:29,779
我们将接受状态数据库。因此，状态数据库是，基本上只是存储所有的

94
00:07:29,779 --> 00:07:35,180
关于当前的状态数据，或者我猜这是对父块的状态数据。就是这样

95
00:07:35,180 --> 00:07:40,459
最后一个已知的有效状态。我们要回来的是我们将返回另一个州数据库

96
00:07:40,459 --> 00:07:44,699
因为这将是更新的状态和错误。

97
00:07:44,979 --> 00:07:47,099
因此，如果此功能失败，

98
00:07:47,319 --> 00:07:50,359
我们希望返回错误，而不是更新状态数据库。

99
00:07:55,959 --> 00:07:56,399
好的。

100
00:07:57,259 --> 00:07:59,500
所以我们要做的第一件事

101
00:07:59,500 --> 00:08:00,699
我们必须验证标题吗？

102
00:08:01,019 --> 00:08:02,500
我们将近一点看

103
00:08:02,500 --> 00:08:05,099
当我们实际上经过Goethereum的实现时。

104
00:08:05,620 --> 00:08:08,599
但是我只是在这里说，如果有错误

105
00:08:08,600 --> 00:08:10,879
当我们验证标题时

106
00:08:10,879 --> 00:08:14,700
我们经过父母和街区，

107
00:08:15,480 --> 00:08:22,680
那么我们只想返回不更新的状态

108
00:08:22,680 --> 00:08:23,760
我们将返回错误。

109
00:08:24,720 --> 00:08:26,800
基本上这是什么意思

110
00:08:26,800 --> 00:08:32,879
检测到标题错误。

111
00:08:33,420 --> 00:08:36,879
因此，一个会失败的例子

112
00:08:36,879 --> 00:08:38,060
关于标题

113
00:08:38,059 --> 00:08:44,959
我猜一个有趣的例子是有很多历史相关性的是气体限制。所以今天，

114
00:08:44,959 --> 00:08:49,679
我们的气体限制约为3000万，气体限制实际上不是

115
00:08:49,679 --> 00:08:55,519
在任何地方的执行层中硬化和硬编码，有一种机制可以阻止生产者

116
00:08:55,519 --> 00:09:01,079
可以用来改变气体限制。因此，他们实际上有能力将气体限制更改

117
00:09:01,080 --> 00:09:08,379
A，您知道，一个10，10 24。因此，如果气体限制为3000万，您可以将其增加

118
00:09:08,379 --> 00:09:14,620
那一部分。因此，如果您将气体限制从3000万块增加到4000万，则

119
00:09:15,160 --> 00:09:19,460
您知道，在一个块中，标题验证将失败，

120
00:09:19,680 --> 00:09:24,180
因为您将超过10次超过10个分数更新。

121
00:09:25,280 --> 00:09:30,280
出现问题的另一个可能性是您可以拥有块数字

122
00:09:31,080 --> 00:09:32,900
不是顺序的

123
00:09:32,900 --> 00:09:35,240
这可能应该抓住

124
00:09:35,240 --> 00:09:37,180
信标连锁层也可能

125
00:09:37,180 --> 00:09:39,259
也发生

126
00:09:39,259 --> 00:09:40,040
验证标题

127
00:09:40,040 --> 00:09:43,220
1559的基本费用将

128
00:09:43,220 --> 00:09:45,000
需要根据

129
00:09:45,000 --> 00:09:47,139
最后使用的气体与

130
00:09:47,139 --> 00:09:49,100
气体限制，因此其中一堆

131
00:09:49,100 --> 00:09:50,180
那里发生的事情正在发生

132
00:09:50,180 --> 00:09:53,139
抱着我的猫正在吃我的

133
00:09:53,139 --> 00:09:54,139
脚现在

134
00:09:54,139 --> 00:09:55,520
没有

135
00:09:55,520 --> 00:09:58,840
嘿，伙计

136
00:09:58,840 --> 00:09:59,840
好的。

137
00:09:59,840 --> 00:10:00,840
你能听到我吗？

138
00:10:00,840 --> 00:10:04,800
仅一秒钟，您可以放大IDE，以便我们在屏幕上更清楚地看到吗？

139
00:10:04,800 --> 00:10:05,800
是的。

140
00:10:05,800 --> 00:10:06,800
有点小。

141
00:10:06,800 --> 00:10:07,800
那怎么样？

142
00:10:07,800 --> 00:10:10,180
更好，谢谢。

143
00:10:10,180 --> 00:10:12,320
好的。

144
00:10:12,320 --> 00:10:13,840
这就是验证标题。

145
00:10:13,840 --> 00:10:19,100
一旦我们验证了标头，我们将假设标题是正确的，并且环境

146
00:10:19,100 --> 00:10:25,060
标题指定是交易应运行的环境。

147
00:10:25,059 --> 00:10:28,579
因此，从那里您真的要应用交易

148
00:10:29,539 --> 00:10:35,859
所以我想在这里做的是在块交易上说范围

149
00:10:40,819 --> 00:10:45,779
因此，这只会使我们对块中的每笔交易进行循环

150
00:10:45,779 --> 00:10:49,219
对于每笔交易，我们需要执行它，所以我们会说

151
00:10:49,220 --> 00:10:55,200
我们将通过虚拟机（即EVM）运行它。

152
00:10:58,320 --> 00:11:02,519
所以我要给它一个块标头，因为在EVM中，您需要知道

153
00:11:02,519 --> 00:11:10,519
该块所在的上下文是因为有硬币基础或气体限制或

154
00:11:10,519 --> 00:11:15,759
时间戳。而且，您需要在执行该交易时需要知道这些值是什么。

155
00:11:15,759 --> 00:11:38,360
因此，我们将通过标头传递，然后将其提供给交易，然后将其给予状态。我们会说，如果此功能失败，我们只需要再次返回错误即可。在这种情况下，问题是交易实际上是无效的。因此，块无效。

156
00:11:38,360 --> 00:11:47,639
在执行层中，不可能在块内进行无效的事务

157
00:11:47,639 --> 00:11:52,000
如果块中有一些无效的毒药

158
00:11:52,000 --> 00:11:53,460
并使它无效

159
00:11:53,460 --> 00:12:04,320
如果该交易正确

160
00:12:04,320 --> 00:12:09,280
如果我们真的通过

161
00:12:09,280 --> 00:12:15,920
整个交易列表，我们可以返回具有所有的最终累积状态

162
00:12:15,920 --> 00:12:22,960
没有错误的交易，然后是信标链，您知道您可能会

163
00:12:22,960 --> 00:12:27,840
周围有一些包装器，您可能会在此周围具有一些包装器功能

164
00:12:27,840 --> 00:12:34,160
该执行有效载荷。

165
00:12:39,600 --> 00:12:41,540
这将归还我们的布尔。

166
00:12:43,540 --> 00:12:45,560
这会将我们的布尔归还给信标连锁店，

167
00:12:45,660 --> 00:12:48,759
它将调用其中的状态过渡功能。

168
00:12:49,300 --> 00:12:50,540
所以我不会把整个事情写出来。

169
00:12:50,660 --> 00:12:52,340
但基本上，我会说，

170
00:12:52,340 --> 00:13:03,500
如果没有错误，如果有错误返回false，否则对不起，否则返回true

171
00:13:03,500 --> 00:13:15,320
好的，因此BEACON链本质上是在调用一些功能新的有效负载。

172
00:13:15,320 --> 00:13:21,139
执行有效负载，然后我们在执行方面呼叫我们的状态过渡功能

173
00:13:21,139 --> 00:13:24,120
使用执行有效载荷中的信息。

174
00:13:24,799 --> 00:13:27,340
如果状态过渡函数没有错误，

175
00:13:27,559 --> 00:13:28,899
我们将返回真实。

176
00:13:29,059 --> 00:13:30,460
如果确实错误，我们返回false

177
00:13:30,460 --> 00:13:31,500
因为块无效。

178
00:13:32,899 --> 00:13:37,879
关于此块验证概述有什么问题吗？

179
00:13:42,899 --> 00:13:45,500
我们有几个问题。

180
00:13:45,500 --> 00:13:49,059
发生了什么？

181
00:13:52,659 --> 00:13:55,000
你为什么通过块标头

182
00:13:55,000 --> 00:13:56,360
进入vm.run？

183
00:13:58,559 --> 00:14:00,759
在块标题内

184
00:14:00,759 --> 00:14:01,960
都是所有信息。

185
00:14:02,399 --> 00:14:04,659
有两个背景

186
00:14:04,659 --> 00:14:06,419
执行交易时需要。

187
00:14:06,419 --> 00:14:08,179
第一个显然是状态

188
00:14:08,179 --> 00:14:09,840
因为国家有类似的东西

189
00:14:09,840 --> 00:14:12,279
您将要执行的合同代码

190
00:14:12,279 --> 00:14:14,620
其中的存储

191
00:14:14,620 --> 00:14:20,759
帐户可能正在操纵或阅读，但您也需要上下文，块上下文

192
00:14:20,759 --> 00:14:27,679
交易正在执行。因此，我提到了几个例子，但是还有几个

193
00:14:28,580 --> 00:14:35,000
您可能需要访问以前的randow值或块哈希。这是给你的

194
00:14:35,000 --> 00:14:42,080
虚拟机中某种类似的随机性，您可能需要访问基础

195
00:14:42,080 --> 00:14:46,620
基本费用，基本费用在块标头内，在交易执行范围内，

196
00:14:46,620 --> 00:14:48,139
您可以调用基本费用OPODE。

197
00:14:48,280 --> 00:14:50,960
因此，该价值将需要以某种方式填充。

198
00:14:51,040 --> 00:14:54,820
因此，我之所以传递标头的原因是填充这些环境价值。

199
00:14:56,620 --> 00:14:57,060
正确的。

200
00:14:57,160 --> 00:14:57,420
谢谢。

201
00:14:57,420 --> 00:15:07,160
因此，说的过渡函数由共识层调用，并返回是否返回

202
00:15:07,160 --> 00:15:07,720
这是有效的。

203
00:15:07,720 --> 00:15:13,000
这是无效的，CL会发生什么？

204
00:15:13,000 --> 00:15:19,060
因此，如果它在CL上无效，则该块将被拒绝。

205
00:15:19,060 --> 00:15:29,259
我们也许可以非常迅速地看待这一点。

206
00:15:29,259 --> 00:15:37,259
这是过程执行有效载荷。

207
00:15:37,720 --> 00:15:56,100
因此，就在这里，信标规格的作品的方式是使用断言来验证

208
00:15:56,100 --> 00:15:59,779
某些属性是他们所期望的。

209
00:15:59,779 --> 00:16:04,820
而且因为我们说此功能验证并通知新的有效载荷回报是一个布尔值，所以

210
00:16:04,820 --> 00:16:09,780
它试图断言该价值将是真实的，

211
00:16:09,940 --> 00:16:11,860
这意味着我们在状态过渡功能中

212
00:16:11,860 --> 00:16:13,160
正确验证了块。

213
00:16:13,700 --> 00:16:17,820
如果是错误的，并且您在信标规范中失败了，

214
00:16:17,940 --> 00:16:19,820
这基本上意味着拒绝块。

215
00:16:20,379 --> 00:16:23,720
可能不太清楚该机械的工作原理

216
00:16:23,720 --> 00:16:24,440
只是从规格中

217
00:16:24,580 --> 00:16:27,680
但这就是他们通常在这种情况下使用断言的方式。

218
00:16:32,060 --> 00:16:33,000
太棒了，谢谢。

219
00:16:33,000 --> 00:16:36,159
是的，我认为我们可以继续前进。

220
00:16:36,159 --> 00:16:41,559
有些问题慢慢出现，但随时可以进来。

221
00:16:41,559 --> 00:16:42,659
凉爽的。

222
00:16:42,659 --> 00:16:44,820
这就是块验证。

223
00:16:44,820 --> 00:16:51,240
我想提及的另一个高级主题，相对于执行客户端

224
00:16:51,240 --> 00:16:57,700
它在生态系统中的另一个主要角色是建立执行有效载荷，构建

225
00:16:57,700 --> 00:17:04,340
它包含状态转换的块，所有有趣的交易，

226
00:17:04,340 --> 00:17:04,980
有用的事情。

227
00:17:04,980 --> 00:17:12,620
因此，我们可以快速查看它的外观，从

228
00:17:12,620 --> 00:17:13,380
执行客户端。

229
00:17:16,000 --> 00:17:20,980
当我们到达点对点部分时，我将更多地谈论这个问题，但本质上是节点

230
00:17:20,980 --> 00:17:24,299
在此点对点方案上闲聊交易。

231
00:17:24,299 --> 00:17:31,180
这些是在块中尚未有效的交易

232
00:17:31,180 --> 00:17:37,279
在一个块中，但本身有效

233
00:17:37,279 --> 00:17:46,859
该帐户具有足够的uh价值来支付交易等，因此有时节点变成

234
00:17:46,859 --> 00:17:53,299
任务是创建一个由共识层随机共识层的块

235
00:17:53,299 --> 00:17:57,740
确定每个走的时代都像哪个验证者将要建立一个块，以及

236
00:17:57,740 --> 00:18:02,579
您的验证器恰好被选为构建该块，您会告诉您的共识客户

237
00:18:02,579 --> 00:18:08,599
嘿，您应该构建一个块，这是应该构建块的某些上下文

238
00:18:08,599 --> 00:18:13,980
因此，我们可以像我们在上面一样再次嘲笑它作为一个函数，然后去

239
00:18:13,980 --> 00:18:17,419
那看起来有点像

240
00:18:17,420 --> 00:18:23,380
我们将称为构建功能，它将在环境中采用

241
00:18:23,820 --> 00:18:30,880
我将无法完全定义，我们将稍后再定义它。但是环境正在发展

242
00:18:30,880 --> 00:18:35,539
要拥有所有信息，就像标题一样，它将拥有信息，

243
00:18:35,660 --> 00:18:40,480
就像时间戳是什么？什么是块号？以前的基本费用是多少，

244
00:18:40,960 --> 00:18:45,380
所有需要发生在街区中的提款，来自

245
00:18:45,380 --> 00:18:51,620
共识层。在这种情况下，共识层是大脑，这是

246
00:18:51,620 --> 00:18:56,800
信息，应该构建块的上下文。因此，只需在其中构建块

247
00:18:56,800 --> 00:19:02,600
语境。这就是环境。我们将进入一个池，这是一个交易池。

248
00:19:04,540 --> 00:19:11,840
该池正在维护交易列表。我们只是为了简单而假设

249
00:19:11,839 --> 00:19:17,279
抱歉，它将维护有序交易列表

250
00:19:17,279 --> 00:19:24,679
按其价值订购。因此，这将帮助我们建立最有利可图的障碍

251
00:19:24,679 --> 00:19:31,299
执行客户端给定我们在网络上看到的交易。

252
00:19:31,980 --> 00:19:38,699
我们还将采用州DBN，因为我们必须对此进行更新。以及我们需要返回的东西

253
00:19:38,700 --> 00:19:42,180
是一个块，一个状态数据库，

254
00:19:42,860 --> 00:19:45,019
因为我们已经更新了

255
00:19:45,019 --> 00:19:47,559
与该块中的累积交易

256
00:19:47,559 --> 00:19:49,940
可能是错误。

257
00:19:52,920 --> 00:19:53,319
好的。

258
00:19:53,319 --> 00:19:53,420
好的。

259
00:19:58,240 --> 00:19:59,259
内部构建，

260
00:19:59,819 --> 00:20:03,620
我们会跟踪几件事。

261
00:20:04,660 --> 00:20:06,740
我们应该跟踪使用的气体。

262
00:20:08,700 --> 00:20:13,759
因为我们只能使用有限的气体。

263
00:20:15,860 --> 00:20:20,039
我将不考虑事实

264
00:20:20,039 --> 00:20:21,759
我们实际上可以更改气体限制。

265
00:20:21,860 --> 00:20:23,960
我只是说这将是一些固定价值。

266
00:20:24,580 --> 00:20:25,860
因此，这是一个简单的例子。

267
00:20:26,319 --> 00:20:28,299
但是通常在建造街区时，

268
00:20:28,580 --> 00:20:31,180
您需要观看使用多少汽油

269
00:20:31,180 --> 00:20:32,819
并停止建造块

270
00:20:32,819 --> 00:20:36,160
一旦达到交易限制。

271
00:20:36,860 --> 00:20:37,980
可以包括。

272
00:20:38,700 --> 00:20:44,400
而且，我们还将存储所有将要进入块的交易。

273
00:20:46,220 --> 00:20:52,720
因此，让我们确保我们继续添加交易，直到使用的气体更大

274
00:20:52,720 --> 00:20:58,740
超过3000万。这大约是当今主网上的气体限制。

275
00:21:00,940 --> 00:21:06,220
因此，要获得我们的第一笔交易或进行任何交易，我们必须询问交易池，

276
00:21:06,220 --> 00:21:13,100
再说一次，黑拳击说它将保留有序的交易列表

277
00:21:13,100 --> 00:21:18,620
对于我们来说，我们总是得到最好的下一笔交易。我们可以说的只是

278
00:21:18,620 --> 00:21:23,980
为了启动交易，我们将其视为某种类型的列表，使我们能够弹出，

279
00:21:24,779 --> 00:21:32,940
我们将弹出该交易，然后我们将执行它。让我们称之为您知道的气体，

280
00:21:32,940 --> 00:21:42,240
它已经命名为um，我们称其为气体和错误，我们将运行交易

281
00:21:42,240 --> 00:21:54,059
再次像我们上面一样

282
00:21:54,059 --> 00:21:58,240
因此，我将在环境中通过它，只是您知道运行是

283
00:21:58,240 --> 00:22:02,400
它需要一些阻止和环境满足的接口。

284
00:22:03,140 --> 00:22:06,000
因此，我们将在环境中通过它，我们将通过该交易，

285
00:22:06,000 --> 00:22:07,220
然后我们将通过该州。

286
00:22:07,359 --> 00:22:11,720
因此，它将再次在这种情况下运行交易

287
00:22:11,720 --> 00:22:15,460
环境正在定义，它将返回我们

288
00:22:15,460 --> 00:22:20,700
更新的状态实际积累了交易。

289
00:22:21,299 --> 00:22:25,759
因此，如果那不成功，则意味着运行返回错误，

290
00:22:25,759 --> 00:22:32,759
实际上，我们只是要继续这里，所以这意味着交易无效

291
00:22:32,759 --> 00:22:42,019
而且因为我们仍然有更多的气体可以在块内消耗

292
00:22:42,339 --> 00:22:49,900
我们不想返回一个区域，因为UM没有发生的错误

293
00:22:49,900 --> 00:22:57,080
呃，确实没有错误的错误，但很有可能

294
00:22:57,080 --> 00:23:02,500
我们有无效的交易，因为它在执行时做得不好

295
00:23:02,500 --> 00:23:07,920
但是，或者也许交易池变得有些过时

296
00:23:07,920 --> 00:23:12,700
我们在这里做的就是让自己继续

297
00:23:12,700 --> 00:23:19,000
并尝试将下一个从池中的交易进入此块。

298
00:23:19,799 --> 00:23:23,380
因此，一旦我们验证了运行该事务的错误，

299
00:23:23,380 --> 00:23:27,759
实际上，我们可以将这种气体添加到使用的气体中。

300
00:23:28,000 --> 00:23:30,380
因此，我们只会添加。

301
00:23:30,580 --> 00:23:34,259
因此，现在假设我们进行了一项简单转让的交易。

302
00:23:34,539 --> 00:23:39,140
简单的传输仅花费21,000天气。

303
00:23:39,140 --> 00:23:45,160
现在，我们使用的汽油从零到21,000。

304
00:23:45,460 --> 00:23:47,360
因此，我们将继续这样做

305
00:23:47,360 --> 00:23:52,200
直到我们达到3000万，我可能应该说，

306
00:23:52,200 --> 00:23:54,500
或游泳池是空的。

307
00:23:58,140 --> 00:23:59,540
游泳池不是空的。

308
00:24:00,900 --> 00:24:04,520
所以我们要么完全填充块

309
00:24:04,520 --> 00:24:07,620
或者我们用完了潜在的交易。

310
00:24:07,619 --> 00:24:13,579
一旦我们做到了，我们需要做的就是要完成整个

311
00:24:13,579 --> 00:24:22,919
过渡并返回我们的状态数据库和我们的错误，我只会将其外包

312
00:24:22,919 --> 00:24:27,159
对于我们在以太坊中的另一个功能，就像这样最终确定了

313
00:24:27,159 --> 00:24:33,399
最终确定的是需要大量交易和一些有关

314
00:24:33,400 --> 00:24:41,540
块并产生一个完全组装的块。我们这样做的原因是有一些

315
00:24:41,540 --> 00:24:47,940
需要在块末尾完成的计算。我在这里有点掩饰。出色地

316
00:24:47,940 --> 00:24:53,400
查看何时查看过程功能。但基本上，在标题中，您有类似的东西

317
00:24:53,400 --> 00:25:01,280
交易路线，收据路线，提款路线。这些是您需要的值

318
00:25:01,279 --> 00:25:03,480
通过merkle-wibs列表来计算。

319
00:25:04,079 --> 00:25:06,680
因此，我们可以想象的是最终的功能

320
00:25:06,680 --> 00:25:07,559
要这样做。

321
00:25:07,700 --> 00:25:10,940
因此，我们可以，我忘了实际上附加这些交易。

322
00:25:10,940 --> 00:25:15,139
因此，我们不得不说附加。

323
00:25:16,779 --> 00:25:19,000
因此，现在我们有了交易列表。

324
00:25:20,079 --> 00:25:20,559
糟糕。

325
00:25:22,019 --> 00:25:26,619
因此，我将最终确定我们正在建造的块

326
00:25:26,619 --> 00:25:30,359
与环境，交易和国家。

327
00:25:31,279 --> 00:25:36,559
我只是说最终确定也将返回这三个值。

328
00:25:36,559 --> 00:25:39,839
因此，它将组装块，它将返回状态

329
00:25:39,839 --> 00:25:45,819
正确更新后，也许有一些提款或其他东西。

330
00:25:45,819 --> 00:25:51,160
而且，如果在最终确定过程中出现问题，它将返回错误。

331
00:25:51,160 --> 00:25:58,319
因此，这是构建块的超级简化方法。

332
00:25:58,319 --> 00:26:05,240
因此，希望这种对您的执行层如何思考建立块的方式。

333
00:26:05,939 --> 00:26:10,700
我不知道此示例是否有任何问题。

334
00:26:18,039 --> 00:26:21,899
是的，看来我们在这里的聊天中有一些问题。

335
00:26:25,559 --> 00:26:26,599
让我们来看看。

336
00:26:28,319 --> 00:26:32,960
保罗问，交易池是否以任何方式订购？

337
00:26:33,119 --> 00:26:36,659
如果不是，使用poop.pop时，我们如何确保最大利润？

338
00:26:37,619 --> 00:26:38,139
是的，到底是。

339
00:26:38,279 --> 00:26:42,439
因此，交易池是，我们在这种情况下假设

340
00:26:42,599 --> 00:26:47,939
它基本上是气价订购的。

341
00:26:48,200 --> 00:26:52,460
有了1559年，它有些复杂，因为我们有这个小费的概念，

342
00:26:52,460 --> 00:26:56,079
但从本质上讲，它是由向建筑商的最高付款交易订购的。

343
00:26:56,079 --> 00:27:02,839
因此，每次打电话给POP时，您都会获得为您提供最大价值的交易。

344
00:27:05,240 --> 00:27:07,419
太好了，谢谢。

345
00:27:11,339 --> 00:27:18,720
721 Orbit在构建块时询问执行层在将其发送到共识层之前是否拒绝任何交易？

346
00:27:18,720 --> 00:27:26,380
因此，您唯一拒绝交易的时间是，如果某些交易无效

347
00:27:26,380 --> 00:27:34,279
原因，您可以看到在这种情况下，事务池本身通常是

348
00:27:34,279 --> 00:27:40,339
进行一些验证，因此我们或多或少验证交易有效

349
00:27:40,339 --> 00:27:46,100
有时可能会有一些种族条件，泳池还没有完全更新，但是块状

350
00:27:46,099 --> 00:27:55,319
已更新，或者可能是一项交易。总的来说，我的意思是，总的来说

351
00:27:55,399 --> 00:28:00,919
交易池应真正验证交易有效。所以这不是真的

352
00:28:00,919 --> 00:28:06,139
发生太多。但是，您不会看交易并出于任何其他原因拒绝交易，

353
00:28:06,139 --> 00:28:12,279
然后它无法付款。因为如果交易可以付款，那么任何报价毫不Quote，无效的交易

354
00:28:12,279 --> 00:28:15,379
在执行过程中确实是一项恢复交易，

355
00:28:15,619 --> 00:28:18,119
从共识的角度来看，这是有效的。

356
00:28:18,480 --> 00:28:22,859
它可能没有有效改变状态

357
00:28:22,859 --> 00:28:24,740
除了支付使用的汽油费用。

358
00:28:28,700 --> 00:28:30,460
另一个问题是，

359
00:28:30,579 --> 00:28:33,259
有一些关于加密的备忘录的讨论。

360
00:28:33,759 --> 00:28:35,440
一，那有多可行？

361
00:28:35,500 --> 00:28:38,660
二，由于块交易是通过气体排序的

362
00:28:38,660 --> 00:28:41,000
在这样的设计中，气体未加密吗？

363
00:28:42,279 --> 00:28:48,240
是的，我的意思是，这是一个非常具有挑战性的问题，我认为很多人已经看过这个问题

364
00:28:48,240 --> 00:28:55,740
关于如何做的想法不同，我认为我主要在其他连锁店上看到的建议

365
00:28:55,740 --> 00:29:03,359
加密的Mempools的宇宙已经有诸如AS诸如AS的东西之类的东西，因为当您的时候您

366
00:29:03,359 --> 00:29:08,899
构建块您不知道交易是什么

367
00:29:08,900 --> 00:29:10,700
到一个块的有序列表

368
00:29:10,700 --> 00:29:13,500
因此，您需要有一个主意

369
00:29:13,500 --> 00:29:15,460
该块使用多少气体。

370
00:29:16,300 --> 00:29:19,700
我认为，我也看到了一些建议

371
00:29:19,700 --> 00:29:22,540
发件人也未加密的地方

372
00:29:22,540 --> 00:29:26,720
这只是目标和数据

373
00:29:26,720 --> 00:29:28,160
他们正在做的是加密的。

374
00:29:28,780 --> 00:29:31,140
这样，他们可以以某种方式验证。

375
00:29:31,140 --> 00:29:33,980
我想他们可以做一个非常简单的验证

376
00:29:33,980 --> 00:29:36,900
发件人可以为未加密的天然气付费。

377
00:29:38,900 --> 00:29:45,680
因此，这些显然会带有缺点，因为如果您想加密

378
00:29:45,680 --> 00:29:51,540
mempool，您正在尝试拥有私人交易流，您正在泄漏很多

379
00:29:51,540 --> 00:29:58,980
即使只是说使用的汽油，如果您有发件人地址，则信息。

380
00:30:00,660 --> 00:30:06,900
因此，从以太坊的角度来看，我认为这可能是

381
00:30:06,900 --> 00:30:11,900
将来更远的东西我们可能想要一个完整的解决方案，而不是一些东西

382
00:30:11,900 --> 00:30:19,660
那只是在做大多数事情，我可以是我可以在这里有点不在

383
00:30:19,660 --> 00:30:24,300
我有一段时间没有看的东西，但这通常是我的理解

384
00:30:24,300 --> 00:30:30,120
似乎我们没有找到一种完全以有效的方式进行加密的备忘录的方法

385
00:30:30,120 --> 00:30:33,160
因此，我们正在等待破解

386
00:30:33,160 --> 00:30:37,200
太棒了，谢谢

387
00:30:37,200 --> 00:30:40,060
您使用的条件

388
00:30:40,060 --> 00:30:42,460
对于汽油少于3000万

389
00:30:42,460 --> 00:30:44,300
但是您也提到它不是硬编码的

390
00:30:44,300 --> 00:30:46,519
所以这只是一个例子

391
00:30:46,519 --> 00:30:48,160
通过的参数

392
00:30:48,160 --> 00:30:50,060
是的，我的意思是

393
00:30:50,060 --> 00:30:51,800
我们可以说气体限制

394
00:30:51,800 --> 00:30:54,160
我认为我们拥有的功能是

395
00:30:54,160 --> 00:30:58,660
我的意思是，我们真的可以说

396
00:30:58,660 --> 00:31:00,259
我们可以说这在环境中吗

397
00:31:00,259 --> 00:31:02,500
但基本上

398
00:31:02,500 --> 00:31:10,980
每当您构建一个块时，您的节点都具有我所说的那种能力

399
00:31:10,980 --> 00:31:20,920
将气体限制控制超过1024，以便我可以在任一端进行操纵

400
00:31:20,920 --> 00:31:27,660
我可以使它加上或减去该价值，所以您在客户上说的话您可能会通过

401
00:31:27,660 --> 00:31:33,880
类似于气体目标。我忘记了，我忘记了这个标志的叫什么。这是气体限制目标

402
00:31:33,880 --> 00:31:43,820
或类似的东西。嗯，也许您可​​能会说4000万。因此，如果您的气体限制目标是

403
00:31:43,820 --> 00:31:51,740
在父块上方，气体限制，然后是环境文档，例如气体限制

404
00:31:51,740 --> 00:31:56,759
在某个时候试图弄清楚我们能与目标有多近的地方进行计算？

405
00:31:56,759 --> 00:32:07,339
基本上，它只是将它试图做一个超过1024的目标，即

406
00:32:07,339 --> 00:32:13,119
如果目标不是目标，我们是否超越了目标，如果它超出了目标

407
00:32:13,119 --> 00:32:19,500
可以减少它，少于1024超过1024，而您完全知道我们的目标

408
00:32:19,500 --> 00:32:25,539
因此，在这种情况下，如果我们的目标是4000万，最后一个价值为3000万，那将是

409
00:32:25,539 --> 00:32:28,559
3000万次

410
00:32:28,559 --> 00:32:30,339
我的意思是1025

411
00:32:30,339 --> 00:32:31,240
超过1024

412
00:32:31,240 --> 00:32:32,639
本质上

413
00:32:32,639 --> 00:32:38,240
所以你的节点

414
00:32:38,240 --> 00:32:40,259
对气体限制有一点控制

415
00:32:40,259 --> 00:32:42,180
是这个示例，我不是真的

416
00:32:42,180 --> 00:32:43,960
对它的状态非常深入

417
00:32:43,960 --> 00:32:46,399
计算但我们可以

418
00:32:46,399 --> 00:32:48,359
在短短一秒钟内，除非还有更多问题

419
00:32:48,359 --> 00:33:01,139
是的，他们有点不断进来，但我只是想吧，这是一个更重要的我

420
00:33:01,139 --> 00:33:07,379
猜猜是的有趣的问题是，这里是否有任何种族条件要担心

421
00:33:07,379 --> 00:33:13,179
嗯，像MEM的交易一样，他们将被包括在街区中

422
00:33:13,180 --> 00:33:19,500
在您构建另一本书之前已删除，是的，我的意思是我们试图避免种族条件

423
00:33:19,500 --> 00:33:24,240
我的意思是，这就像一个玩具示例一样，所以它并没有真正解决任何问题

424
00:33:24,240 --> 00:33:29,160
这是一种像诚信可能会丢失的地方，应该在交易池

425
00:33:29,160 --> 00:33:34,460
一旦您到达交易应该有效的，很多交易验证通常

426
00:33:34,460 --> 00:33:42,259
但是有时候，您知道游泳池并不总是完全同步的池，并且可能正在更新

427
00:33:42,259 --> 00:33:45,420
或喜欢浏览其交易列表

428
00:33:45,420 --> 00:33:49,460
并尝试更新有效的交易。

429
00:33:49,539 --> 00:33:50,579
所以你可能会得到一些东西

430
00:33:50,579 --> 00:33:52,879
目前的头部尚未更新。

431
00:33:52,879 --> 00:33:55,259
因此，交易可能无效。

432
00:33:56,160 --> 00:33:57,220
这就像一个例子。

433
00:33:59,279 --> 00:34:01,879
但是我们的交易，

434
00:34:03,059 --> 00:34:05,019
我们的街区建筑要复杂得多

435
00:34:05,019 --> 00:34:09,639
而且有些事情必须避免。

436
00:34:12,260 --> 00:34:18,580
惊人的。是的。人们不确定res变量是什么意思

437
00:34:18,580 --> 00:34:19,580
新状态。

438
00:34:19,580 --> 00:34:26,800
抱歉，这是新状态。我想我忘了，是的，我忘了积累

439
00:34:26,800 --> 00:34:34,180
它。因此，基本上是RES是将交易应用于其的状态。那我是什么

440
00:34:34,180 --> 00:34:41,260
这样做是，如果该交易有效，那么我只是将状态变量更新到res。所以

441
00:34:41,260 --> 00:34:45,700
但是随后，状态成为将交易适用于其的下一个状态。

442
00:34:46,800 --> 00:34:47,240
正确的。

443
00:34:48,520 --> 00:34:49,260
好吧，很棒。

444
00:34:49,580 --> 00:34:50,480
是的，非常感谢，马特。

445
00:34:50,560 --> 00:34:52,020
我认为我们可以前进。

446
00:34:52,820 --> 00:34:53,180
甜的。

447
00:34:54,260 --> 00:34:58,840
因此，您知道，我们已经结束了一半，但是现在我们已经完成了概述。

448
00:34:59,720 --> 00:35:04,260
因此，让我们跳进去，看看状态过渡功能。

449
00:35:04,260 --> 00:35:10,400
所以我给了你一个非常高的概述

450
00:35:10,400 --> 00:35:16,500
状态过渡功能看起来像，但我想真正带我们穿越

451
00:35:16,500 --> 00:35:24,820
在Go Ethereum中发生的事情可能有点困难，因为你们不能取消静音

452
00:35:24,820 --> 00:35:31,040
提出问题，但我只是要经历这个问题，希望这是您分类的一种方式

453
00:35:31,039 --> 00:35:36,659
查看此代码的现存位置，这些事物的形状是什么，也许是在您自己的时间上，

454
00:35:37,000 --> 00:35:42,920
深入浏览它，并尝试真正了解流程和每一行

455
00:35:42,920 --> 00:35:47,279
那正在发生。但是，我们将在这里很快进行。因为我确实有一对

456
00:35:47,279 --> 00:35:57,259
其他要谈论的事情。好的，所以如果我进入以太坊，我们实际上可以看一下该功能，

457
00:35:57,260 --> 00:36:02,600
通知新有效载荷功能，信标链正在调用

458
00:36:02,600 --> 00:36:04,720
与执行层交互。

459
00:36:05,620 --> 00:36:08,680
为此，我们会去催化剂，

460
00:36:09,020 --> 00:36:13,840
这是我们的引擎API的名字。

461
00:36:14,200 --> 00:36:19,760
引擎API是连接共识层的接口

462
00:36:19,760 --> 00:36:20,800
到执行层。

463
00:36:21,360 --> 00:36:23,160
我们将前往API.GO。

464
00:36:23,159 --> 00:36:27,199
有一个称为新有效载荷的函数。

465
00:36:30,679 --> 00:36:36,559
因此，新的有效载荷是信标连锁店所呼唤的。

466
00:36:37,059 --> 00:36:39,779
因此，它吸收了很多价值观，

467
00:36:40,019 --> 00:36:42,259
主要是我在谈论的价值观，

468
00:36:42,539 --> 00:36:45,480
块数据在此可执行数据中。

469
00:36:45,859 --> 00:36:48,819
这看起来很像一个街区。

470
00:36:49,119 --> 00:36:52,420
它有父母哈希，状态根，收据root，

471
00:36:52,420 --> 00:36:58,400
数量，气体限制，使用的气体，您的交易，提款，一堆其他

472
00:36:58,400 --> 00:37:03,460
东西。我不会太深入4844件事，因为那只是使东西成为

473
00:37:03,460 --> 00:37:10,599
更复杂。但是发生的是共识层有一个块。它想问

474
00:37:10,599 --> 00:37:18,599
执行层，该块有效吗？执行层进行一堆验证

475
00:37:18,599 --> 00:37:20,119
关于该块信息。

476
00:37:20,420 --> 00:37:23,199
因此，这将执行一些完整性检查。

477
00:37:23,960 --> 00:37:27,699
就像，如果我掌握了您给我的所有数据，

478
00:37:27,819 --> 00:37:30,299
它会等于您也给我的块哈希吗？

479
00:37:30,639 --> 00:37:35,239
这是经常会捕获小小的错误的东西。

480
00:37:37,759 --> 00:37:41,440
最终，它只是通过并验证了一些

481
00:37:41,719 --> 00:37:43,360
它只是进行了一堆完整性检查，

482
00:37:43,360 --> 00:37:50,900
关于信标链之间的通信和

483
00:37:50,900 --> 00:37:56,460
共识层。但是最终，我们掌握了此功能，插入没有设定头的块。

484
00:37:57,099 --> 00:38:02,300
因此，在这里，我们实际上开始尝试将该障碍物放入我们的链条中，

485
00:38:02,519 --> 00:38:08,700
我们验证了一堆我们想要存在的不变性，然后才开始将该块放入

486
00:38:08,699 --> 00:38:13,319
连锁

487
00:38:13,319 --> 00:38:20,579
非常复杂，他们知道他们有很多我认为我们可以看的东西

488
00:38:20,579 --> 00:38:27,299
现在删除信标连锁店正在做很多重组和连锁管理

489
00:38:27,299 --> 00:38:32,939
我们，但这是我们过去必须自己做的事实的一种事实

490
00:38:32,939 --> 00:38:38,559
在我们有股份证明之前，插入链将调用我们谈论的一些事情

491
00:38:38,559 --> 00:38:44,299
关于。有一个称为验证标头的函数。并且验证标头是一个函数

492
00:38:44,299 --> 00:38:53,440
界面。界面在共识中定义，这是我们所在的地方，但是有一个共识

493
00:38:53,440 --> 00:38:59,880
信标链的引擎，其功能验证标头。它能做的就是

494
00:38:59,880 --> 00:39:11,220
它将执行与此类共识相关的标题验证。

495
00:39:11,220 --> 00:39:16,240
它要做的第一件事是查看终端总困难吗？

496
00:39:16,240 --> 00:39:24,519
这就是我们确定链条是否是工作证明或股份证明的方式。

497
00:39:24,519 --> 00:39:30,920
指点总是您知道到达报价unquote，因为难度不再有更新

498
00:39:31,480 --> 00:39:40,920
合并已经发生了，所以我们一直在跳过ETH1标头验证和

499
00:39:40,920 --> 00:39:46,440
我们只是在进行Beacon标题验证

500
00:39:47,800 --> 00:39:52,920
在很多方面都相同

501
00:39:54,519 --> 00:39:58,179
个人约束。

502
00:39:58,679 --> 00:40:00,300
我会提到一些有趣的。

503
00:40:00,840 --> 00:40:03,380
首先，为了证明股份

504
00:40:03,480 --> 00:40:05,099
没有更多的叔叔概念。

505
00:40:05,719 --> 00:40:09,300
叔叔是相同块高度的重复块。

506
00:40:09,579 --> 00:40:10,960
我们有工作证明

507
00:40:10,960 --> 00:40:14,019
因为有时如果您有很多分布式矿工

508
00:40:14,019 --> 00:40:14,840
世界各地，

509
00:40:15,219 --> 00:40:18,300
两个矿工可能会大约同时找到一个街区

510
00:40:18,300 --> 00:40:20,480
在他们与对方交流之前

511
00:40:20,480 --> 00:40:21,519
他们找到了一个街区。

512
00:40:22,039 --> 00:40:24,340
因此，现在您在同一块号上有两个块

513
00:40:24,340 --> 00:40:28,760
而且您仍然想奖励这两个矿工

514
00:40:28,760 --> 00:40:30,980
因为他们把作品放进去，他们找到了一个障碍，所以

515
00:40:31,160 --> 00:40:34,700
但是，其中只有一个可以成为规范化的块，

516
00:40:34,920 --> 00:40:39,000
这意味着它是规范链的一部分。

517
00:40:39,820 --> 00:40:43,380
为了证明股份，我们不再有这个概念了。

518
00:40:43,380 --> 00:40:45,280
因此，在执行层中，

519
00:40:45,420 --> 00:40:48,559
我们强迫叔叔哈希永远成为一个空的叔叔哈希，

520
00:40:48,980 --> 00:40:51,360
这只是一个空列表的默克尔根。

521
00:40:51,360 --> 00:40:56,420
因此，如果不是这样，那么我们只需要返回错误，因为那不是有效的销售证明块。

522
00:40:57,059 --> 00:40:59,660
同样，在困难方面，我们没有工作证明。

523
00:41:00,079 --> 00:41:02,180
标题难度总是必须为零。

524
00:41:06,620 --> 00:41:07,340
让我们来看看。

525
00:41:07,720 --> 00:41:12,160
好的，所以我们谈论了1559年，我们谈论了气体限制。

526
00:41:12,420 --> 00:41:14,220
这是发生此检查的地方。

527
00:41:14,219 --> 00:41:21,019
因此，我们必须验证气体限制是否停留在允许的装订范围内。

528
00:41:21,739 --> 00:41:24,019
我认为这正在这里发生。

529
00:41:24,019 --> 00:41:27,279
因此，我们将其给予一定价值的母体气体限制。

530
00:41:27,699 --> 00:41:30,839
这是现在的当前标头的气体限制。

531
00:41:31,239 --> 00:41:37,839
而且我们必须确保它仍在可以接受的范围内。

532
00:41:37,840 --> 00:41:53,260
因此，基本上，我们只是计算出气体限制的分隔线，而我们只是确保差异不大于或小于限制。

533
00:41:53,740 --> 00:41:56,059
这就是1024号。

534
00:41:56,140 --> 00:42:03,140
我们只是将以前的气体限制除外，并确保差异并不大于此。

535
00:42:03,940 --> 00:42:05,900
这就是验证气体限制。

536
00:42:05,900 --> 00:42:10,940
它。然后是1559逻辑，我们计算基本费用。我们确保

537
00:42:10,940 --> 00:42:16,220
标题基本费用等于我们期望的基本费用。所以我们本质上要去

538
00:42:16,220 --> 00:42:22,559
通过标头中的每个字段，并确保所有这些字段都是正确的。

539
00:42:23,920 --> 00:42:29,720
因此，这主要是标题验证。一旦验证了标头，我们实际上可以去

540
00:42:29,719 --> 00:42:34,039
我们可以执行块或处理块。

541
00:42:34,239 --> 00:42:35,899
我只是跳回去。

542
00:42:36,239 --> 00:42:39,379
因此，现在我们又回到了该功能，插入块，

543
00:42:39,719 --> 00:42:41,059
插入无固定头的块。

544
00:42:41,539 --> 00:42:43,099
因此，如果我们继续下降，

545
00:42:43,199 --> 00:42:46,879
还有许多其他逻辑可以处理重新修饰，

546
00:42:47,319 --> 00:42:50,899
我们已经知道的障碍是我们已经知道的障碍。

547
00:42:51,659 --> 00:42:55,419
但是最终，如果我们过去了所有这些，

548
00:42:55,419 --> 00:42:58,099
应该调用称为过程的函数。

549
00:42:59,719 --> 00:43:08,279
我想，我通过了它。

550
00:43:08,279 --> 00:43:09,279
没有。

551
00:43:09,279 --> 00:43:13,939
在这里，在这里，就在这里。

552
00:43:13,939 --> 00:43:14,939
好的。

553
00:43:14,939 --> 00:43:21,959
因此，在我们经历了一大堆重要但无关的事情之后

554
00:43:21,959 --> 00:43:26,939
要插入一个块，我们最终可以进入此功能过程，这就是我写的

555
00:43:26,940 --> 00:43:28,000
在大纲中。

556
00:43:29,220 --> 00:43:32,139
这是我试图说明的功能

557
00:43:32,139 --> 00:43:33,920
在概述中为您有点。

558
00:43:34,700 --> 00:43:36,220
因此，如您所见，

559
00:43:36,280 --> 00:43:38,760
与我们展示的类似的东西

560
00:43:38,760 --> 00:43:39,380
在该概述中。

561
00:43:39,519 --> 00:43:41,480
它占据了一个障碍，它正在使用状态数据库。

562
00:43:42,579 --> 00:43:45,280
我想我也通过了父母

563
00:43:45,539 --> 00:43:48,539
但是我们可以访问我们。

564
00:43:48,840 --> 00:43:51,079
抱歉，我们真的不需要

565
00:43:51,079 --> 00:43:54,480
因为将父信息放入VM配置中。

566
00:43:54,480 --> 00:43:57,039
这就像执行的环境一样。

567
00:43:57,920 --> 00:43:59,699
因此，它在那里调用一个接口。

568
00:43:59,760 --> 00:44:04,440
我可以在国家处理器中访问它。

569
00:44:05,059 --> 00:44:09,679
因此，此功能的实际实现在这里。

570
00:44:10,460 --> 00:44:11,599
StateProcessor.go。

571
00:44:12,780 --> 00:44:19,400
因此，这就是我们真正在以太坊中进行国家过渡的地方。

572
00:44:24,480 --> 00:44:33,579
这里比我们在示例中谈论的要多得多，但是您基本上可以看到一个非常相似的结构。

573
00:44:33,699 --> 00:44:38,980
因此，在这里，我们只是创建一堆值，这些值将在整个块的执行过程中维护。

574
00:44:39,440 --> 00:44:40,480
这是二手气。

575
00:44:40,719 --> 00:44:45,240
最后，我们要确保我们使用的气体等于标题中使用的气体所说的气体。

576
00:44:45,539 --> 00:44:49,420
这是验证所有执行正确的重要检查。

577
00:44:50,440 --> 00:44:52,240
然后我们有循环。

578
00:44:52,239 --> 00:44:55,679
因此，我们只是通过块中的所有交易

579
00:44:55,679 --> 00:44:59,279
我们应用交易。

580
00:45:00,219 --> 00:45:04,919
申请交易确实像我们谈论的

581
00:45:04,919 --> 00:45:08,439
或者最终我们到达这里，我们称为VM。

582
00:45:08,979 --> 00:45:11,179
我们必须经过此功能过渡DB。

583
00:45:12,119 --> 00:45:16,899
Transition DB进行了一堆事务级验证。

584
00:45:17,199 --> 00:45:18,659
因此它具有预检查功能。

585
00:45:18,659 --> 00:45:21,899
这在验证交易的nonce是正确的。

586
00:45:22,239 --> 00:45:31,519
交易的平衡是正确的

587
00:45:33,439 --> 00:45:41,919
大约1559会检查很多费用验证，最终在这里完成

588
00:45:44,559 --> 00:45:49,279
我们验证您知道，必须发生很多小的验证

589
00:45:49,280 --> 00:45:52,440
但是最终，我们到达可以执行该交易的时候。

590
00:45:55,120 --> 00:46:00,620
就是说，我通过了它。

591
00:46:06,680 --> 00:46:07,380
啊，在这里。

592
00:46:07,380 --> 00:46:12,980
好的，在这里我们说执行的实例是两种类型。

593
00:46:13,540 --> 00:46:18,620
要么要执行合同创建，要么要执行呼叫。

594
00:46:19,280 --> 00:46:24,780
而且我们已经做到了，以便我们创建和调用这些功能。

595
00:46:25,600 --> 00:46:29,820
因此，在这里您可以查看交易是否会创建某些东西，

596
00:46:29,920 --> 00:46:33,700
我们将调用创建功能，并可以执行创建。

597
00:46:34,240 --> 00:46:36,800
而且，如果我们不是创建，那么我们必须更新NONCE。

598
00:46:36,800 --> 00:46:38,840
在创建中，NONCE已经更新。

599
00:46:39,000 --> 00:46:46,060
所以不是，这在代码的这个分支中不存在，

600
00:46:46,059 --> 00:46:50,320
但是我们更新了NONCE，然后执行呼叫。

601
00:46:50,860 --> 00:46:53,719
因此，我将跳过呼叫的实施

602
00:46:53,719 --> 00:46:56,779
因为当我们查看EVM时，我们会稍微看一下。

603
00:46:57,259 --> 00:47:00,119
但这本质上是在踢出EVM

604
00:47:00,119 --> 00:47:05,059
并说我想用它作为我的消息发件人执行EVM。

605
00:47:05,900 --> 00:47:06,960
这是目的地。

606
00:47:07,179 --> 00:47:09,119
因此，在该目的地加载代码

607
00:47:09,119 --> 00:47:13,019
然后将此数据作为呼叫数据传递到该目的地。

608
00:47:13,019 --> 00:47:27,400
因此，流程，我们获得了回报值，我们将获得剩余的气体，如果您从传递的气体中减去燃气，您将获得所用的气体数量以及执行过程中发生的任何错误。

609
00:47:27,400 --> 00:47:37,800
如果我们支付的重置存储空间退款，我们会将一些汽油退还给用户

610
00:47:37,800 --> 00:47:45,400
共同基础向用户收取的费用以执行该交易，然后我们

611
00:47:45,400 --> 00:47:50,760
返回该执行结果，因此，如果我们反弹，我们又回来应用消息

612
00:47:50,760 --> 00:47:54,760
我们只是积累了使用的气体。

613
00:47:55,280 --> 00:47:58,860
我们将此收据累积到我们的收据列表中。

614
00:48:01,340 --> 00:48:04,220
进入我们那里的收据列表，日志累积了。

615
00:48:05,460 --> 00:48:08,580
最终，我们进行了所有这些交易。

616
00:48:08,580 --> 00:48:10,560
我们完成此交易循环

617
00:48:10,560 --> 00:48:13,000
我们以前提到过这个功能，

618
00:48:13,180 --> 00:48:16,400
最终确定，这将仅适用

619
00:48:16,400 --> 00:48:18,840
一些特定的共识。

620
00:48:18,840 --> 00:48:39,900
因此，我们为信标链所拥有的一个有趣的链条即将到来，我们实际上应用了提款，因为这是一个共识层原始的，我想您可以说，这确实与交易无关。

621
00:48:39,900 --> 00:48:46,860
这是关于我们正在运行一个信标链的事实，例如，请单击，例如

622
00:48:46,960 --> 00:48:52,440
以太坊的另一种共识通常没有提款。

623
00:48:52,559 --> 00:48:56,800
因此，您需要有一个区分它的地方。这就是此功能最终确定的地方

624
00:48:56,800 --> 00:49:01,160
发挥作用。它使我们可以区分我们可能拥有的不同共识引擎。

625
00:49:01,740 --> 00:49:07,320
因此，最终确定将经历从信标连锁店发生的每个提款

626
00:49:07,320 --> 00:49:09,600
信标连锁告诉我们发生了什么

627
00:49:09,600 --> 00:49:11,720
在这个块中，它只是执行它们。

628
00:49:11,940 --> 00:49:15,340
因此，它增加了稀薄的空气。

629
00:49:16,000 --> 00:49:18,140
基本上只是服用一些以太

630
00:49:18,140 --> 00:49:20,120
那是在那个灯塔链上

631
00:49:20,120 --> 00:49:21,940
并将其放在执行层上。

632
00:49:23,420 --> 00:49:25,800
因此，一旦完成了，一旦完成，

633
00:49:25,800 --> 00:49:27,200
我们可以退还收据。

634
00:49:28,620 --> 00:49:32,340
让我们看看我是否可以反弹回到所谓的位置。

635
00:49:32,340 --> 00:49:39,440
所以我们正在研究这个功能

636
00:49:39,440 --> 00:49:40,519
应用交易

637
00:49:40,519 --> 00:49:42,059
所有这些交易

638
00:49:42,059 --> 00:49:44,160
哦，对不起，我们正在研究过程

639
00:49:44,160 --> 00:49:47,260
所以一旦完成

640
00:49:47,260 --> 00:49:48,059
我们在区块链中

641
00:49:48,059 --> 00:49:50,880
现在，区块链基本上是

642
00:49:50,880 --> 00:49:52,600
处理了

643
00:49:52,600 --> 00:49:55,360
所以它将做更多的事情

644
00:49:55,360 --> 00:49:56,539
更新一些指标

645
00:49:56,539 --> 00:49:59,300
最终我们将写那个块

646
00:49:59,300 --> 00:50:00,480
这是一种

647
00:50:00,480 --> 00:50:06,179
当一切都解决到磁盘或内存中时。

648
00:50:06,940 --> 00:50:10,179
因此，在这一点上，我们正在插入块。

649
00:50:10,240 --> 00:50:11,099
块是有效的。

650
00:50:11,820 --> 00:50:19,320
而且我们还有更多的指标和小事。

651
00:50:19,320 --> 00:50:23,639
但基本上，最后，我们返回块数

652
00:50:23,639 --> 00:50:27,240
写在磁盘上。

653
00:50:27,440 --> 00:50:28,760
如果有任何错误，我们返回。

654
00:50:28,760 --> 00:50:33,280
由于没有错误，我们成功地写了这个障碍，我们只是说，

655
00:50:33,740 --> 00:50:39,160
在这种情况下，写了一个块。如果我们一直回到催化剂API，

656
00:50:40,320 --> 00:50:46,640
因此，这实际上扔掉了写的块数，它只是检查是否错误，

657
00:50:46,940 --> 00:50:54,140
没有错误，我们会在没有设置头的情况下从插入块中恢复错误零错误，

658
00:50:54,139 --> 00:51:01,420
跳过所有这些UH，最终我们将返回有效载荷状态状态引擎有效

659
00:51:01,420 --> 00:51:08,460
还有一个新的最新哈希，这是刚刚插入的块，这就是完整的块插入

660
00:51:08,460 --> 00:51:13,519
每当共识层得到一个块并将其发送到执行时，就会发生的管道

661
00:51:13,519 --> 00:51:18,859
我知道这是很多我不想像一堆问题一样挂断的，但是

662
00:51:18,859 --> 00:51:22,460
如果有一些像高水平的事情，我可以在谈论一些之前很快回答

663
00:51:22,460 --> 00:51:25,139
其他东西，我对此很开放。

664
00:51:28,780 --> 00:51:30,139
太感谢了。

665
00:51:30,559 --> 00:51:31,659
我们将其具有更高的水平。

666
00:51:31,780 --> 00:51:35,500
如果您可以再次解释什么是收据。

667
00:51:37,000 --> 00:51:37,559
是的。

668
00:51:37,679 --> 00:51:51,619
因此收据是有关交易的信息，该信息只能在

669
00:51:51,619 --> 00:51:59,139
执行交易，因此，如果我们查看收据的共识定义，则有东西

670
00:51:59,139 --> 00:52:06,699
就像这些是共识字段，这些是实际上收据中的东西

671
00:52:06,699 --> 00:52:12,619
其他东西是一些没有收据中的以太坊东西，但是您有类型的东西

672
00:52:12,619 --> 00:52:17,539
说您知道此收据与

673
00:52:17,539 --> 00:52:30,420
基本上，这被用作歧视者，因此您可以解释不同类型的交易是否具有不同类型的不同类型的收据，我认为他们目前并不是这样。

674
00:52:31,759 --> 00:52:39,019
我认为，在州后，这是在拜占庭的，但已被贬低了一段时间。

675
00:52:39,019 --> 00:52:43,960
因此，您确实拥有这些，您有状态，这将说明是否交易

676
00:52:43,960 --> 00:52:50,320
恢复，您将使用汽油，累积气体，这说明了该交易多少

677
00:52:50,320 --> 00:52:52,119
使用了Bloom过滤器。

678
00:52:52,619 --> 00:52:55,759
我会，如果您不熟悉Bloom过滤器是什么，我会检查一下

679
00:52:55,759 --> 00:52:56,179
在维基百科。

680
00:52:56,380 --> 00:53:02,960
基本上，这是确定是否可能的快速方法，您正在寻找的日志发生

681
00:53:02,960 --> 00:53:04,179
在该交易中。

682
00:53:04,400 --> 00:53:08,440
然后，您只有所有日志的列表，并且您可以编写日志

683
00:53:08,440 --> 00:53:15,059
从智能合同中，智能合约地址将在这里。而且您可以有帮助的主题

684
00:53:15,059 --> 00:53:21,059
您可以通过Bloom过滤器快速找到它。然后您有数据。所以一个日志的示例可能是

685
00:53:21,059 --> 00:53:29,320
如果您发送ERC-20，ERC-20可能会列出一个日志，该日志显示了一定的ERC-20已发送

686
00:53:29,320 --> 00:53:35,220
从一个地址到另一个地址。因此，您可以从末端的块中读取

687
00:53:35,219 --> 00:53:41,059
交易并查看特定令牌发生的所有ERC-20转移。

688
00:53:41,059 --> 00:53:52,379
惊人的。非常感谢，马特。另一个问题是关于多个的环境

689
00:53:52,379 --> 00:53:57,779
导致多项其他交易的交易，例如致电其他交易

690
00:53:57,779 --> 00:54:02,459
合同等。您在概述中使用的上下文，如何

691
00:54:02,460 --> 00:54:15,519
变量如何获取它，好的，让我看看我是否可以非常快速地显示我想

692
00:54:15,519 --> 00:54:23,519
去国有处理器，所以我们认为有两种环境

693
00:54:23,519 --> 00:54:34,320
认为这是合适的

694
00:54:34,320 --> 00:54:40,000
级别上下文和块级别上下文，因此块级别是我提到的coinbase as gas

695
00:54:40,000 --> 00:54:46,159
限制块编号时间难度基本费用随机所有这些东西，这是不变的东西

696
00:54:46,159 --> 00:54:52,639
交易交易已固定在整个块上，然后我们有交易上下文

697
00:54:52,639 --> 00:54:55,879
起源，汽油价格，斑点的东西。

698
00:54:55,879 --> 00:54:59,239
这些都是整个交易中真实的事情，

699
00:54:59,980 --> 00:55:02,199
但是可能在块内发生变化

700
00:55:02,199 --> 00:55:03,739
因为有不同的交易。

701
00:55:04,319 --> 00:55:06,119
因此，这是两种类型的环境

702
00:55:06,119 --> 00:55:08,920
在执行过程中可以访问

703
00:55:09,319 --> 00:55:13,059
但通常是为交易的全部执行而修复。

704
00:55:13,920 --> 00:55:17,019
然后在口译员中也有

705
00:55:17,019 --> 00:55:22,820
evo，不，是吗？

706
00:55:30,980 --> 00:55:34,460
好的，在口译员内，您有一些东西。

707
00:55:35,199 --> 00:55:38,199
而且，您有一个范围上下文

708
00:55:38,199 --> 00:55:39,980
我们将在此处浏览一下，

709
00:55:40,239 --> 00:55:43,259
这与您所处的当前范围有关。

710
00:55:43,340 --> 00:55:46,300
因此，如果您要访问当前范围中的堆栈

711
00:55:46,300 --> 00:55:47,760
或当前范围中的内存

712
00:55:47,760 --> 00:55:51,100
或通过当前范围中的合同存储。

713
00:55:51,640 --> 00:55:56,620
这些都是可以访问的东西，

714
00:55:57,060 --> 00:56:00,440
该交易框架内的变化。

715
00:56:00,519 --> 00:56:04,320
每当您调用一些添加新呼叫框架的东西时，

716
00:56:04,760 --> 00:56:07,519
诸如呼叫，委托呼叫，创建，创建诸如

717
00:56:07,860 --> 00:56:09,580
这将创建新的范围。

718
00:56:10,560 --> 00:56:12,420
然后合同也是一个有趣的合同

719
00:56:12,420 --> 00:56:14,240
因为它有发件人。

720
00:56:14,239 --> 00:56:18,779
因此，呼叫者是消息。Sender如果您写一些坚固性。

721
00:56:19,619 --> 00:56:23,359
因此，这是在交易中发生变化的环境环境。

722
00:56:24,379 --> 00:56:31,319
这就是EVM（解释器）将用来填写指令请求。

723
00:56:31,319 --> 00:56:32,759
就像，呼叫者是什么？

724
00:56:32,939 --> 00:56:34,719
谁称这份合同？

725
00:56:35,319 --> 00:56:40,979
或者在这里这段记忆的价值是什么？

726
00:56:40,980 --> 00:56:45,139
这些是可以通过此环境变量访问的东西。

727
00:56:45,139 --> 00:56:48,139
所以我有点简化了很多东西，但是

728
00:56:48,139 --> 00:56:50,639
如果您开始挖掘出来，它就是这样，

729
00:56:50,639 --> 00:56:54,039
在我们拥有的VM中的实际实现中。

730
00:56:58,380 --> 00:57:00,860
太棒了，感谢您在那里潜水。

731
00:57:00,860 --> 00:57:05,800
我一直在看到新问题，但是人们仍在打字，

732
00:57:05,800 --> 00:57:09,219
屏幕有轻微的延迟，所以 - 

733
00:57:09,219 --> 00:57:13,099
好的。好吧，让我们继续前进。

734
00:57:13,639 --> 00:57:21,399
在我们关闭之前，我还有其他几件事要谈论。

735
00:57:22,019 --> 00:57:23,599
这就是状态过渡函数。

736
00:57:23,759 --> 00:57:30,339
让我们更深入地研究以太坊虚拟机是什么。

737
00:57:32,039 --> 00:57:38,000
因此，为了说明这一点，我想快速图表。

738
00:57:39,219 --> 00:57:44,859
这样您就可以了解EVM内部发生的事情。

739
00:57:45,000 --> 00:57:47,359
我想我只是展示了很多东西

740
00:57:47,359 --> 00:57:50,299
关于EVM中存在的不同上下文，

741
00:57:50,779 --> 00:57:54,579
但是我倾向于发现人们更好地理解它

742
00:57:54,579 --> 00:57:56,079
如果他们有图片要看。

743
00:57:56,839 --> 00:57:59,399
因此，我们将其称为EVM。

744
00:57:59,639 --> 00:58:02,659
这是EVM框。

745
00:58:03,659 --> 00:58:06,819
这本质上是EVM呼叫框架。

746
00:58:06,820 --> 00:58:16,620
因此，就像我说的那样，呼叫框架在整个交易中都会发生变化，并且您只能访问与该呼叫框架相关的事物。

747
00:58:17,059 --> 00:58:21,000
因此，该呼叫框架中可访问的内容是代码。

748
00:58:21,780 --> 00:58:24,680
这是您当前正在执行的代码。

749
00:58:26,280 --> 00:58:30,720
除了该代码外，您还需要知道要执行的代码中的位置。

750
00:58:30,860 --> 00:58:33,039
因此，您有PC，这是程序计数器。

751
00:58:33,039 --> 00:58:39,340
如果您完全熟悉口译员，那么您将熟悉PC的工作原理

752
00:58:39,340 --> 00:58:45,239
但基本上只是在说解释器处理的方式是PC在

753
00:58:45,239 --> 00:58:51,719
为零，它将将指令加载为代码中的索引零，然后执行该指令，然后将其加载

754
00:58:51,719 --> 00:58:59,000
如果指令大于一个字节，则更新PC或可能更多的PC

755
00:58:59,000 --> 00:59:01,219
我们的大多数说明都是一个字节。

756
00:59:01,219 --> 00:59:04,960
因此，我们还有其他一些框架级别的东西。

757
00:59:04,960 --> 00:59:08,300
我们有堆栈，我们有记忆，

758
00:59:14,440 --> 00:59:16,679
我们还剩下气体。

759
00:59:22,960 --> 00:59:26,320
这些主要是我们拥有的东西

760
00:59:26,320 --> 00:59:29,980
关于这种执行框架。

761
00:59:29,980 --> 00:59:33,039
我们也有像我们看到的东西

762
00:59:33,039 --> 00:59:36,960
我们有我刚刚过去的块上下文

763
00:59:36,960 --> 00:59:38,760
我们有TX上下文。

764
00:59:38,760 --> 00:59:40,900
这些在框架内可访问。

765
00:59:41,820 --> 00:59:45,320
我们也有可访问的状态。

766
00:59:46,700 --> 00:59:48,160
所以有很多操作

767
00:59:48,160 --> 00:59:51,240
可以访问该州的一部分。

768
00:59:51,240 --> 00:59:56,200
XCode-Size Xcode-Hash之类的东西，

769
00:59:56,199 --> 00:59:59,019
意思是外部代码大小或外部代码哈希。

770
00:59:59,439 --> 01:00:02,519
这些是可以让您阅读州的内容的说明。

771
01:00:03,359 --> 01:00:06,379
诸如Coinbase之类的说明为您提供块上下文。

772
01:00:07,099 --> 01:00:10,359
诸如Origin之类的说明为您提供交易上下文。

773
01:00:13,139 --> 01:00:18,759
好的，这主要是VM的样子。

774
01:00:19,739 --> 01:00:24,759
要了解有关EVM的工作原理的更多信息，

775
01:00:24,760 --> 01:00:27,780
我们可以有一个快速示例程序。

776
01:00:29,280 --> 01:00:31,300
我们将在这里的操场上做。

777
01:00:32,160 --> 01:00:33,100
哦，他们已经有一个。

778
01:00:34,760 --> 01:00:35,740
是的，让我们使用这个。

779
01:00:36,440 --> 01:00:38,820
因此，堆栈机的工作方式是

780
01:00:38,820 --> 01:00:42,460
堆栈是您进行操作的工作场所。

781
01:00:42,900 --> 01:00:48,180
所有说明本质上都采用堆栈论点

782
01:00:48,180 --> 01:00:54,440
修改该特定指令的行为。

783
01:00:54,760 --> 01:01:02,660
因此，在此示例中，本质上，我们正在用Mstore写一些内容，然后我们将其归还给呼叫者。

784
01:01:03,360 --> 01:01:09,920
因此，如果我们看一下看起来，如果我们逐步逐步，我们将使用第一个指令。

785
01:01:10,140 --> 01:01:13,600
因此，如果我们在这里考虑这张照片，PC等于零。

786
01:01:13,960 --> 01:01:16,700
因此，在此示例中，我们的PC为零。

787
01:01:17,320 --> 01:01:20,420
我们的堆栈和记忆是空的。

788
01:01:20,420 --> 01:01:22,539
然后剩余的气体无关紧要，

789
01:01:23,019 --> 01:01:25,880
但是，让我们想象我们基本上还有无限的气体。

790
01:01:27,240 --> 01:01:30,820
如果我们一步一步，我们已经推动了一个价值，

791
01:01:30,880 --> 01:01:32,019
该值是42。

792
01:01:32,619 --> 01:01:35,200
所以现在我们的堆栈已经成长为一个元素，

793
01:01:35,300 --> 01:01:36,960
它的值为42。

794
01:01:38,099 --> 01:01:41,099
我们再次运行另一项指令，推一个。

795
01:01:41,360 --> 01:01:43,300
这将零推到堆栈上。

796
01:01:44,440 --> 01:01:46,000
现在我们在Mstore。

797
01:01:46,180 --> 01:01:48,700
因此，Mstore的工作方式是

798
01:01:48,699 --> 01:01:54,919
堆栈上的第一个元素使用该元素作为编写值的偏移，然后读取

799
01:01:54,919 --> 01:02:00,799
堆栈上的下一个项目，它将该值写入该偏移量，因此当我按下下一个按钮时

800
01:02:00,799 --> 01:02:05,119
会发生的事情是，我们将删除两个堆栈元素，然后再进行内存

801
01:02:05,119 --> 01:02:11,879
要写42个，这正是这里发生的事情，所以现在我们想

802
01:02:11,879 --> 01:02:17,179
返回此值，因此返回值的方式是您需要说退货值有多大

803
01:02:17,179 --> 01:02:22,759
是。您需要说从哪里开始阅读该回报值。以及这样做的方式

804
01:02:22,759 --> 01:02:31,460
这是我们推动十六进制值20，即十进制为32。然后我们将索引从开始，

805
01:02:31,559 --> 01:02:37,239
是零。因此，我们将从这里开始。我们将通过所有这些字节中的所有32个。所以，如果我们只是

806
01:02:37,239 --> 01:02:42,500
看看这些，我们将20个将堆放到堆上，然后将零推到堆栈上。然后我们将他们俩弹出

807
01:02:42,500 --> 01:02:50,820
退货。因此，现在我们获得了42个回报值。这真的很粗略

808
01:02:50,820 --> 01:02:58,099
堆栈机有效，如何思考EVM内的行为。我会提到

809
01:02:58,099 --> 01:03:03,320
在EVM中，有许多不同类型的说明。我们在那里看的东西

810
01:03:03,320 --> 01:03:11,380
是一些非常简单的东西。通常，您可以想到不同的类别。

811
01:03:11,380 --> 01:03:13,740
这是算术之类的东西吗？

812
01:03:16,280 --> 01:03:20,140
因此，算术正在增加，减法，凸起，

813
01:03:21,039 --> 01:03:24,480
做模特，这种类型的东西。

814
01:03:24,680 --> 01:03:27,019
有位函数用于位弯曲。

815
01:03:27,240 --> 01:03:29,660
如果您需要做一个X或AN，则

816
01:03:30,119 --> 01:03:31,400
这些功能存在。

817
01:03:32,400 --> 01:03:33,800
有环境功能，

818
01:03:33,800 --> 01:03:37,200
这使我们可以访问块上下文

819
01:03:37,200 --> 01:03:39,160
就像我提到的那样，TX上下文。

820
01:03:39,159 --> 01:03:47,339
并射击。

821
01:03:47,339 --> 01:03:51,039
我们还具有呼叫框架说明。

822
01:03:51,039 --> 01:03:59,259
每当我们查看过渡数据库方法时，我们都会看到一点

823
01:03:59,259 --> 01:04:04,579
创建时，我们致电EVM.在电话时致电，我们致电EVM.Call。

824
01:04:04,579 --> 01:04:07,940
这些都是EVM中也存在的指令类型。

825
01:04:07,940 --> 01:04:10,539
如果您需要创建一个新的呼叫框架，

826
01:04:10,539 --> 01:04:12,500
有控制流。

827
01:04:12,500 --> 01:04:15,220
因此，如果您想拥有更复杂的程序，

828
01:04:15,220 --> 01:04:17,380
分支的程序，

829
01:04:17,380 --> 01:04:20,559
通过分支，也许我可以显示的一个例子是，

830
01:04:23,460 --> 01:04:25,639
这是4788合同。

831
01:04:28,599 --> 01:04:32,679
所以有一个晚上，所以这是4788的合同，

832
01:04:32,679 --> 01:04:36,659
这将在下一个硬叉中使用，

833
01:04:36,659 --> 01:04:39,019
但是您可以在这里看到一个分支的示例。

834
01:04:39,500 --> 01:04:41,960
所以这是要分支机构的

835
01:04:41,960 --> 01:04:44,920
根据呼叫者是否等于这个大数字，

836
01:04:45,420 --> 01:04:47,119
这个数字是一个特殊的数字。

837
01:04:47,239 --> 01:04:48,839
这是系统地址。

838
01:04:49,539 --> 01:04:51,779
这就是4788的工作方式。

839
01:04:51,960 --> 01:04:55,460
该系统将使用此地址调用此合同。

840
01:04:55,460 --> 01:04:57,940
在这种情况下，我们知道这是一个特别的电话。

841
01:04:58,219 --> 01:05:00,879
因此，我们使用跳跃i来确定

842
01:05:00,880 --> 01:05:08,740
如果呼叫者的平等和该号码为真，

843
01:05:08,740 --> 01:05:11,519
我们会跳到一定的价值。

844
01:05:11,700 --> 01:05:13,619
如果不是这样，我们将跳到不同的价值。

845
01:05:14,119 --> 01:05:15,900
这就是让你的

846
01:05:15,900 --> 01:05:17,960
控制程序的流程。

847
01:05:19,800 --> 01:05:21,460
然后还有堆栈操作。

848
01:05:22,119 --> 01:05:24,539
因此，我们在该示例中看到了一些堆栈操作。

849
01:05:24,820 --> 01:05:25,579
有推动。

850
01:05:25,860 --> 01:05:28,380
还有流行和交换之类的东西。

851
01:05:28,380 --> 01:05:31,820
这样就可以让您以不同的方式操纵堆栈

852
01:05:31,820 --> 01:05:37,140
然后有一些系统类型的调用

853
01:05:37,140 --> 01:05:41,360
我想我可以把

854
01:05:41,360 --> 01:05:45,119
我们可以说呼叫作为系统呼叫的一部分

855
01:05:45,119 --> 01:05:46,440
所以我们可以说呼叫创建

856
01:05:46,440 --> 01:05:49,940
我们看到了这种返回值的系统调用类型

857
01:05:49,940 --> 01:05:54,160
是的

858
01:05:54,160 --> 01:05:56,960
也许是商店

859
01:05:56,960 --> 01:05:58,320
是的

860
01:05:58,320 --> 01:06:00,720
这写信给合同的存储。

861
01:06:01,760 --> 01:06:03,360
然后有一些内存操作。

862
01:06:03,700 --> 01:06:07,280
我们可以进行MLOAD，MSTORE，MSTORE8，

863
01:06:07,820 --> 01:06:09,660
存储一个单个字节。

864
01:06:10,539 --> 01:06:12,860
因此，这些是让我们操纵记忆的事情

865
01:06:12,860 --> 01:06:13,500
在框架内。

866
01:06:15,519 --> 01:06:18,160
好吧，那是一个超级快速的速成课程

867
01:06:18,160 --> 01:06:19,519
在与EVM相关的事物上。

868
01:06:19,600 --> 01:06:21,559
关于EVM有什么疑问吗？

869
01:06:21,559 --> 01:06:33,679
嗯，保罗·UH问一个问题，询问如何确定各种教学成本

870
01:06:33,679 --> 01:06:40,940
嗯，很久以前有

871
01:06:40,940 --> 01:06:51,119
做了一些基准测试，我忘记了目标气的目标是什么

872
01:06:51,119 --> 01:06:57,659
我们大概是针对的，我不知道我是否能找到我是否能很快找到

873
01:06:57,659 --> 01:07:03,940
嗯，基本上有每秒的气，我们想在特定上处理

874
01:07:03,940 --> 01:07:10,619
处理器架构，这是我们大致达到不同汽油价格的地方

875
01:07:10,619 --> 01:07:16,519
而且我不记得我头顶上每秒的气是什么，但我们会出现

876
01:07:16,519 --> 01:07:22,559
使用使用该指令的基准测试，我们将多次运行

877
01:07:22,559 --> 01:07:29,659
很多时候您可以每秒运行，然后向后工作以找出什么是

878
01:07:29,659 --> 01:07:35,440
像您知道此指令是否需要这么长时间，那么我们需要什么气

879
01:07:35,440 --> 01:07:42,599
每秒钟到达该气体。在这一点上，您知道，我们有很多说明。所以

880
01:07:42,599 --> 01:07:49,059
有时我们不会超级执行这种类型的基准测试。所以伦敦带来了基本费用

881
01:07:49,059 --> 01:07:53,619
坚硬的叉子，在该特定指令上并没有真正的基准测试，因为我们

882
01:07:53,619 --> 01:08:00,659
只是复制了与其他块上下文类型指令相同的气值。

883
01:08:00,659 --> 01:08:09,420
因此，如今许多这些事情只需使用其他类似类型的说明的气体成本即可。

884
01:08:09,759 --> 01:08:18,279
我们仍然要处理这种粗糙的气体，但我认为事情并不是一条完美的。

885
01:08:19,340 --> 01:08:22,760
我认为某些事情可能会被过多收费。

886
01:08:22,760 --> 01:08:28,300
太好了，谢谢

887
01:08:28,300 --> 01:08:30,039
很少有人

888
01:08:30,039 --> 01:08:31,560
现在打字，所以也许我们会给

889
01:08:31,560 --> 01:08:33,920
五秒钟

890
01:08:33,920 --> 01:08:35,760
如果有什么事，我们可以

891
01:08:35,760 --> 01:08:37,659
继续这里

892
01:08:37,659 --> 01:08:40,159
是的，我还有15分钟

893
01:08:40,159 --> 01:08:42,060
大概是我不知道这是否还可以的

894
01:08:42,060 --> 01:08:44,180
是的

895
01:08:44,180 --> 01:08:44,680
这很棒

896
01:08:44,680 --> 01:08:46,300
甜的

897
01:08:46,300 --> 01:08:50,020
酷让我们

898
01:08:50,020 --> 01:08:52,199
只要继续努力，然后我们就可以做

899
01:08:52,199 --> 01:08:53,939
最后一个问题。

900
01:08:54,479 --> 01:08:54,720
好的。

901
01:08:56,359 --> 01:08:59,059
好吧，我们谈到了块验证。

902
01:08:59,479 --> 01:09:01,739
我们谈论了建筑物，

903
01:09:02,099 --> 01:09:03,539
状态过渡函数，

904
01:09:04,539 --> 01:09:07,340
超级高级概述有关EVM的工作原理。

905
01:09:07,899 --> 01:09:11,319
现在我想谈论点对点层，

906
01:09:11,659 --> 01:09:14,519
我们提到了一点

907
01:09:14,519 --> 01:09:17,659
当我们谈论交易池

908
01:09:17,659 --> 01:09:19,279
以及如何构建块。

909
01:09:19,819 --> 01:09:21,199
但是我想挖掘更多

910
01:09:21,199 --> 01:09:26,500
关于点对点的外观如何，

911
01:09:26,659 --> 01:09:28,019
它的责任是什么。

912
01:09:28,960 --> 01:09:35,159
因此执行层运行

913
01:09:35,159 --> 01:09:41,500
在称为DEVP2P的P2P协议上。

914
01:09:42,319 --> 01:09:49,000
DevP2P是以太坊的定制协议。

915
01:09:49,000 --> 01:09:52,520
它从以太坊的开始就发展了

916
01:09:52,520 --> 01:09:55,859
我猜是一个有趣的复活节彩蛋

917
01:09:55,859 --> 01:09:57,880
DEVP2P今天

918
01:09:57,880 --> 01:09:58,699
如果你不熟悉

919
01:09:58,699 --> 01:10:00,859
我们调用DEVP2P协议

920
01:10:00,859 --> 01:10:02,380
像Eth68

921
01:10:02,380 --> 01:10:04,979
Eth69

922
01:10:04,979 --> 01:10:07,600
我认为我们现在正在使用Eth68

923
01:10:07,600 --> 01:10:09,420
在Eth69上工作

924
01:10:09,420 --> 01:10:11,439
但

925
01:10:11,439 --> 01:10:13,279
和

926
01:10:13,279 --> 01:10:16,039
我想我应该说这就像一个潜艇

927
01:10:16,039 --> 01:10:16,880
能力

928
01:10:16,880 --> 01:10:29,880
因此，Dev P2P下还有其他协议。

929
01:10:29,880 --> 01:10:36,000
我们有ETH，我们有快照。

930
01:10:36,000 --> 01:10:38,119
这些是今天的主要人物。

931
01:10:38,119 --> 01:10:41,140
曾经有诸如耳语之类的东西。

932
01:10:41,140 --> 01:10:49,700
嗯，还有其他我能想到的，我想我们可以看一下

933
01:10:49,700 --> 01:10:56,100
哦，是的，莱斯

934
01:10:56,100 --> 01:11:06,400
是的，有一些关于证人传播副能力的想法，这将使我们能够传播

935
01:11:06,399 --> 01:11:13,879
障碍的目击者就是那些东西是的，是的，耳语le leas的见证人很友善

936
01:11:13,879 --> 01:11:19,079
今天被贬低了

937
01:11:19,079 --> 01:11:26,139
ETH的复活节彩蛋是，您知道我们现在使用ETH 68 69我们没有68个ETH协议

938
01:11:26,139 --> 01:11:33,059
我想早期发生了什么是我们从ETH 1开始，然后我们去了ETH 2

939
01:11:33,060 --> 01:11:39,640
以太坊的早期，有很多非常快的迭代，我们有点

940
01:11:39,640 --> 01:11:47,340
在Eth6附近的某个地方，那时他们只是决定我认为他们开始尝试

941
01:11:47,340 --> 01:11:56,520
像Eth6.1 Eth6.2一样思考，所有这些协议都丢失了，您不会真正

942
01:11:56,520 --> 01:12:02,960
在客户端定义中找到这些类型的协议，因为这是您知道的

943
01:12:02,960 --> 01:12:09,279
启动前的UH非常早就发布了，所以我们最终得到了我不知道什么

944
01:12:09,279 --> 01:12:14,960
首先在这里提到的是嗯

945
01:12:20,159 --> 01:12:22,239
好的，因此当前版本是E68

946
01:12:22,239 --> 01:12:38,079
好吧，是的，您60，所以我们有一堆POC，所以有POC 1 2 3 4 5 6，然后终于

947
01:12:38,079 --> 01:12:47,559
他们说的是6，他们说我们不能继续这样做，让我们只做6.0 6.1等，所以2015年我们有

948
01:12:47,560 --> 01:12:57,960
ITH 61 UH ITH 62 63我认为64可能是您在客户中可能看到的最后一个，但是是的

949
01:12:57,960 --> 01:13:03,080
我们对这些协议进行了许多不同的更改，因此没有68

950
01:13:03,080 --> 01:13:11,080
青年协议有大约15个协议，这很有趣，但可以回到什么

951
01:13:11,079 --> 01:13:25,880
PDP为我们做吗？因此，我们需要能够访问历史数据的责任。

952
01:13:28,119 --> 01:13:32,279
我们还需要能够访问交易。

953
01:13:32,279 --> 01:13:43,439
我会说新的交易实际上汇总了交易。所以这些正在待处理。所以这些

954
01:13:43,439 --> 01:13:48,479
是试图传播以进入一个块的交易，它们尚未在一个街区中，

955
01:13:48,479 --> 01:13:58,439
然后说。因此，这是ETH协议DevP2P协议的三个主要部分，

956
01:13:58,439 --> 01:14:07,879
ETH协议试图给我们。因此，让我们看访问历史数据。

957
01:14:09,479 --> 01:14:17,879
这是通过两种不同的方法完成的，或多或少，获取标题，获取块标题，

958
01:14:17,880 --> 01:14:23,760
并获得块尸体。

959
01:14:24,060 --> 01:14:26,520
如果您考虑什么是历史数据，

960
01:14:27,440 --> 01:14:30,560
这两件事或多或少。

961
01:14:31,340 --> 01:14:32,500
还有，

962
01:14:32,840 --> 01:14:35,279
让我确保我有一个正确的。

963
01:14:36,619 --> 01:14:39,340
获取块，获取收据。

964
01:14:40,000 --> 01:14:40,119
是的。

965
01:14:40,859 --> 01:14:42,220
因此，也有收据。

966
01:14:44,480 --> 01:14:46,680
所以这三种方法

967
01:14:46,680 --> 01:14:48,840
这使我们能够获取所有历史数据

968
01:14:48,840 --> 01:14:49,760
与以太坊有关。

969
01:14:50,240 --> 01:14:52,280
如果您考虑什么是历史数据，

970
01:14:52,360 --> 01:14:55,880
这是不需要的数据

971
01:14:55,880 --> 01:14:59,380
用于积极验证状态过渡函数。

972
01:15:00,060 --> 01:15:01,780
如果我们回头，我们认为

973
01:15:01,780 --> 01:15:04,020
该状态过渡功能是什么，

974
01:15:05,480 --> 01:15:07,140
它正在带父块，

975
01:15:07,260 --> 01:15:09,440
我们只是假设客户可以在客户端可用。

976
01:15:10,220 --> 01:15:14,320
在客户端的热门内存中可以访问。

977
01:15:14,319 --> 01:15:19,039
我们试图验证的当前块，然后是状态。所以没有意义

978
01:15:19,039 --> 01:15:23,259
就像，让我访问以太坊的所有历史街区，或者，在该州

979
01:15:23,259 --> 01:15:28,319
过渡功能，我没有地方检查200个块的街区的标题

980
01:15:28,319 --> 01:15:33,559
前。因此，这就是为什么我们将其称为历史数据，链中发生的事情，

981
01:15:33,559 --> 01:15:36,880
但不一定要在验证的活动路径中。

982
01:15:36,880 --> 01:15:41,819
我们也有一些获得交易的方法。

983
01:15:42,420 --> 01:15:47,239
我们有方法交易，已经存在了一段时间。

984
01:15:47,340 --> 01:15:52,960
然后，我们有了一种新的方法，称为新的合并交易哈希。

985
01:15:53,520 --> 01:15:59,659
我认为，这种新的汇总交易哈希方法出现在66中。

986
01:15:59,659 --> 01:16:06,920
当时的理由是我们需要减少执行的带宽使用

987
01:16:06,920 --> 01:16:14,279
客户，甚至您甚至今天都知道，尤其是今天，一旦您的客户同步

988
01:16:14,279 --> 01:16:20,960
您几乎所有的交易或对不起的所有网络带宽都在进行

989
01:16:20,960 --> 01:16:29,279
迈向交易，因此在E66中，彼得想找出一种减少带宽负载的方法

990
01:16:29,279 --> 01:16:37,139
执行客户的加载，并提出了一个想法，即不是发送完整的交易

991
01:16:37,139 --> 01:16:42,719
当我们获得新的交易时，每一个同行都宣布

992
01:16:42,719 --> 01:16:47,819
交易给我们，或者我们在本地收到，而不是将其发送给我们的所有同行

993
01:16:47,819 --> 01:16:54,259
我们只会将其发送到一个平方根的同伴，我们所有的其他同龄人都会收到

994
01:16:54,260 --> 01:16:55,619
新的池交易。

995
01:16:56,480 --> 01:16:58,320
完整的交易是

996
01:16:58,320 --> 01:17:00,539
随机子集，随机子集

997
01:17:00,539 --> 01:17:02,180
平方根对等的子集。

998
01:17:02,739 --> 01:17:04,659
因此，这确实有助于减轻

999
01:17:04,659 --> 01:17:06,640
带宽的用法

1000
01:17:06,640 --> 01:17:08,800
我得到同样的交易的地方

1001
01:17:08,800 --> 01:17:10,840
一遍又一遍地与许多不同

1002
01:17:10,840 --> 01:17:14,020
节点。

1003
01:17:14,300 --> 01:17:16,320
现在我大部分

1004
01:17:16,320 --> 01:17:18,340
只需重复其他节点的哈希。

1005
01:17:18,820 --> 01:17:20,960
而且我只称呼此方法

1006
01:17:20,960 --> 01:17:23,460
我认为是

1007
01:17:23,460 --> 01:17:25,600
获得汇总交易。

1008
01:17:28,079 --> 01:17:31,579
因此，我只称此方法得到汇总的交易

1009
01:17:31,579 --> 01:17:35,300
如果我收到一些以前从未见过的哈希。

1010
01:17:37,539 --> 01:17:39,500
我们可以看的一件有趣的事情

1011
01:17:39,500 --> 01:17:42,819
我们实际上可以去准确查看代码线吗

1012
01:17:42,819 --> 01:17:47,960
以太坊进行平方根公告的地方。

1013
01:17:48,439 --> 01:17:50,619
那是在eth中。

1014
01:17:51,180 --> 01:17:52,579
我认为这是在处理者中。

1015
01:17:53,460 --> 01:18:00,500
因此，有一个功能广播交易。

1016
01:18:00,500 --> 01:18:07,300
只要有可以广播的交易，该方法就会称为。

1017
01:18:07,300 --> 01:18:13,340
它的作用是...

1018
01:18:13,340 --> 01:18:27,079
好的，所以对于每笔交易，我们确定该交易是否已通过该交易

1019
01:18:27,079 --> 01:18:33,100
其他客户，我们还确定我们有多少同龄人将直接接收到这一点，

1020
01:18:33,100 --> 01:18:35,420
正方形的根函数是。

1021
01:18:35,420 --> 01:18:39,300
因此，根据我们有多少同龄人，我们将其占据平方根，也就是说

1022
01:18:39,300 --> 01:18:51,539
直接同行的数量。我们在哪里使用？是的，好吧。所以我认为同龄人是一个随机的

1023
01:18:51,539 --> 01:19:01,760
同行名单。因此，我们在这里说，好吧，一直到Num Direct。所以你可以想象

1024
01:19:01,760 --> 01:19:03,820
这是一个很小的价值，说两个。

1025
01:19:05,000 --> 01:19:08,920
所以同行索引零，一个，

1026
01:19:08,920 --> 01:19:12,480
我们将无条件发送此交易。

1027
01:19:13,260 --> 01:19:14,360
对于其他所有人，

1028
01:19:14,860 --> 01:19:19,360
我们只是在这里使用列表切片。

1029
01:19:19,579 --> 01:19:22,320
我们将发送所有其他同龄人

1030
01:19:22,320 --> 01:19:23,239
只是一个公告。

1031
01:19:24,260 --> 01:19:28,079
这就是使用此公告清单

1032
01:19:28,079 --> 01:19:29,960
与TX集列表相比。

1033
01:19:29,960 --> 01:19:34,119
这就是在这个文件中，这是什么？

1034
01:19:34,199 --> 01:19:35,720
Eth Slash Handler.go。

1035
01:19:35,800 --> 01:19:39,100
您实际上可以看到这是这种行为的地方

1036
01:19:39,100 --> 01:19:42,800
从开发人员中，P2P层即将到来。

1037
01:19:44,800 --> 01:19:48,060
因此，如果我们快速查看不同的方法，

1038
01:19:48,199 --> 01:19:50,659
让我们看一下它们。

1039
01:19:52,520 --> 01:19:53,359
GIT块标题。

1040
01:19:54,420 --> 01:19:58,439
请求，我们使用此请求ID。

1041
01:19:58,439 --> 01:20:01,519
这也许是在eth 67中添加的

1042
01:20:01,519 --> 01:20:03,819
和请求ID

1043
01:20:03,819 --> 01:20:07,819
只是让我们更好地跟踪我们的要求

1044
01:20:07,819 --> 01:20:10,059
因此，当我们发送请求时

1045
01:20:10,059 --> 01:20:11,039
我们发送ID

1046
01:20:11,039 --> 01:20:12,659
然后回应又回来了

1047
01:20:12,659 --> 01:20:14,000
它给了我们相同的ID

1048
01:20:14,000 --> 01:20:16,739
只是帮助跟踪请求

1049
01:20:16,739 --> 01:20:18,319
跟踪飞行中的请求

1050
01:20:18,319 --> 01:20:21,679
我们说这是一个开始

1051
01:20:21,679 --> 01:20:25,419
所以这将是块值

1052
01:20:25,420 --> 01:20:31,800
我们想开始从

1053
01:20:32,520 --> 01:20:34,579
我们会说我们想要多少个街区，

1054
01:20:34,840 --> 01:20:36,060
然后我们有能力

1055
01:20:36,060 --> 01:20:38,180
还可以使它们有可能相反。

1056
01:20:38,960 --> 01:20:42,480
这很重要，因为在合并之前，

1057
01:20:42,600 --> 01:20:44,859
您同步节点的方式，

1058
01:20:45,239 --> 01:20:45,800
同步历史，

1059
01:20:45,940 --> 01:20:47,000
你会从创世纪开始吗

1060
01:20:47,000 --> 01:20:49,199
因为这是第一个

1061
01:20:49,199 --> 01:20:54,920
这是链的可信根，

1062
01:20:54,920 --> 01:20:57,000
我们只会同步。

1063
01:20:57,140 --> 01:20:58,699
我们将下载所有标题，

1064
01:20:59,440 --> 01:21:01,239
下载所有块尸体。

1065
01:21:01,800 --> 01:21:03,020
因此，我们将同步

1066
01:21:03,239 --> 01:21:05,060
我们会说开始块零，

1067
01:21:06,260 --> 01:21:09,239
从零下载20个块。

1068
01:21:09,600 --> 01:21:10,880
因此，我们将达到20。

1069
01:21:11,279 --> 01:21:14,159
通过合并，我们实际上是相反的。

1070
01:21:14,539 --> 01:21:16,220
因此，我们有一个值得信赖的检查站，

1071
01:21:16,699 --> 01:21:18,260
有点像创世纪。

1072
01:21:18,699 --> 01:21:21,140
但是现在值得信赖的检查站在某个地方，

1073
01:21:21,699 --> 01:21:24,100
您知道，链的非零部分过去的创世纪，

1074
01:21:24,100 --> 01:21:25,960
我们，我们想获取历史数据。

1075
01:21:26,380 --> 01:21:28,000
因此，如果我们的检查点就像块

1076
01:21:28,000 --> 01:21:29,840
n，我们会

1077
01:21:29,840 --> 01:21:31,140
说我想得到

1078
01:21:31,140 --> 01:21:33,820
n处的起始块，极限

1079
01:21:33,820 --> 01:21:35,900
也许20，然后将街区放入

1080
01:21:35,900 --> 01:21:38,060
撤销。所以我们会下载

1081
01:21:38,060 --> 01:21:40,000
N-1，N-2，所有

1082
01:21:40,000 --> 01:21:41,900
到达N-20的方式。所以

1083
01:21:41,900 --> 01:21:43,900
那会让我们向后下载

1084
01:21:43,900 --> 01:21:44,400
那些块。

1085
01:21:46,120 --> 01:21:47,700
基本上，同一件事

1086
01:21:47,700 --> 01:21:48,539
GetBlockbodies。

1087
01:21:51,200 --> 01:21:51,880
曾经

1088
01:21:51,880 --> 01:21:53,680
实际上，不，这个有些不同。

1089
01:21:54,100 --> 01:21:55,900
因此，如果我们已经获得了标题，

1090
01:21:56,840 --> 01:21:58,180
一旦我们已经获得了标题，

1091
01:21:58,260 --> 01:21:59,640
我们知道块是什么。

1092
01:21:59,640 --> 01:22:01,579
所以我们可以要求尸体

1093
01:22:01,579 --> 01:22:03,760
与那些特定的标题有关。

1094
01:22:04,180 --> 01:22:07,520
因此，我们将发送我们拥有的所有块哈希的列表

1095
01:22:07,520 --> 01:22:08,800
并为那些尸体。

1096
01:22:09,800 --> 01:22:12,520
而且我得到的收据与那相同。

1097
01:22:13,440 --> 01:22:15,220
是的，在收据同样的交易中，

1098
01:22:15,400 --> 01:22:16,600
我们有我们的链

1099
01:22:16,860 --> 01:22:19,060
我们通过GET Block标头收到了链条。

1100
01:22:19,360 --> 01:22:21,220
然后我们去，我们得到所有这些收据

1101
01:22:21,220 --> 01:22:24,060
通过要求块哈希收据。

1102
01:22:24,100 --> 01:22:28,420
因此，这是获取待处理交易的历史数据。

1103
01:22:30,700 --> 01:22:32,320
我们有一种方法。

1104
01:22:36,980 --> 01:22:37,780
交易。

1105
01:22:38,620 --> 01:22:44,180
因此，这可能没有任何类型的请求。

1106
01:22:44,400 --> 01:22:49,180
许多其他消息是获取块，获得交易等等。

1107
01:22:49,640 --> 01:22:52,680
这是您只会无条件发送给同伴的东西，

1108
01:22:52,680 --> 01:22:56,340
就像我们在广播功能中看到的广播交易一样，

1109
01:22:56,340 --> 01:22:59,900
这将直接将交易直接发送到您的同伴。

1110
01:23:00,900 --> 01:23:03,079
因此，它实际上只是发送交易列表。

1111
01:23:04,240 --> 01:23:08,560
另一个是新的池交易哈希。

1112
01:23:09,180 --> 01:23:10,960
这个更复杂，

1113
01:23:11,480 --> 01:23:16,940
但基本上只是发送交易类型的列表，

1114
01:23:16,940 --> 01:23:20,360
它们的大小以及交易的哈希。

1115
01:23:20,359 --> 01:23:28,119
因此，一旦收到了这些，您就可以查看这些是您以前从未见过的交易哈希。

1116
01:23:28,719 --> 01:23:42,380
如果它们是您以前从未见过的交易哈希，则可以调用获取池交易，将其传递给事务哈希，然后同行将以完整的事务值响应。

1117
01:23:42,920 --> 01:23:45,460
这是在泳池交易中返回的。

1118
01:23:45,460 --> 01:23:50,359
池交易看起来非常类似于交易消息。

1119
01:23:51,920 --> 01:23:55,279
好的，这是历史数据，等待数据。

1120
01:23:55,960 --> 01:24:02,279
我想在P2P上提及的最后责任是访问州。

1121
01:24:02,960 --> 01:24:06,880
因此，很多人可能听说过Snapsync。

1122
01:24:07,480 --> 01:24:10,920
我只想快速说出Snapsync的工作原理。

1123
01:24:10,920 --> 01:24:13,800
在高水平上，您可以考虑

1124
01:24:13,800 --> 01:24:15,100
snapsync as

1125
01:24:15,100 --> 01:24:17,239
两相协议

1126
01:24:17,239 --> 01:24:19,180
第一阶段是

1127
01:24:19,180 --> 01:24:21,739
我需要下载一堆

1128
01:24:21,739 --> 01:24:23,500
数据

1129
01:24:23,500 --> 01:24:25,880
连续的话，如果我们

1130
01:24:25,880 --> 01:24:28,319
糟糕

1131
01:24:28,319 --> 01:24:31,699
如果我们想

1132
01:24:31,699 --> 01:24:33,579
关于

1133
01:24:33,579 --> 01:24:34,699
尝试

1134
01:24:34,699 --> 01:24:37,260
作为

1135
01:24:37,260 --> 01:24:39,760
某种

1136
01:24:39,760 --> 01:24:41,659
默克尔树。

1137
01:24:43,420 --> 01:24:48,760
该图只是一棵二进制树，因为这真的很困难

1138
01:24:48,760 --> 01:24:49,560
画。

1139
01:24:50,159 --> 01:24:57,159
在文本中绘制十六进制阵列树真的很困难。

1140
01:24:57,940 --> 01:24:59,520
我确定它已经完成了。

1141
01:25:02,180 --> 01:25:02,820
好的。

1142
01:25:02,819 --> 01:25:12,099
所以这是B，C，D。

1143
01:25:12,979 --> 01:25:24,139
好的，所以Snapsync的工作方式是您首先要求树的叶子以某个根。

1144
01:25:24,880 --> 01:25:26,699
因此，假设这是根。

1145
01:25:31,099 --> 01:25:32,739
因此根正在改变。

1146
01:25:32,819 --> 01:25:42,899
这是一个很小的例子，但是显然，我不知道，也许是数百万，也许是我们必须访问的1亿个不同的叶子节点。

1147
01:25:43,319 --> 01:25:45,099
我们必须访问的2亿个叶子节点。

1148
01:25:45,920 --> 01:25:51,880
因此，当我们经历这一点时，我们可能会访问a和b。

1149
01:25:52,239 --> 01:25:58,359
然后扎根一个变化，因为节点不能保留所有历史状态。

1150
01:25:58,460 --> 01:26:01,679
他们只保留那种热状态，即活跃状态。

1151
01:26:01,680 --> 01:26:06,300
在Go Ethereum和许多客户中，这是最近128个州。

1152
01:26:06,800 --> 01:26:12,100
因此，如果root 1是用于块，则假设1，现在您需要访问，

1153
01:26:12,320 --> 01:26:14,280
现在，区块链已经继续前进。

1154
01:26:17,840 --> 01:26:25,940
区块链已经继续前进，现在是200。

1155
01:26:26,840 --> 01:26:29,560
这些将像完全不同的价值观。

1156
01:26:31,680 --> 01:26:38,440
假设我们下载了试用的这一部分。

1157
01:26:38,539 --> 01:26:40,180
我们下载了试验的左侧部分。

1158
01:26:40,240 --> 01:26:41,060
我们有一个和B。

1159
01:26:42,079 --> 01:26:43,360
现在我们处于200号块。

1160
01:26:43,720 --> 01:26:46,360
我们花很长时间才下载这些东西。

1161
01:26:46,640 --> 01:26:47,920
我们需要下载C和D。

1162
01:26:48,060 --> 01:26:49,480
C和D仍然没有改变。

1163
01:26:50,100 --> 01:26:51,740
我们可以下载这些。

1164
01:26:51,820 --> 01:26:56,840
因此，现在在当地我们拥有的是A，B，C，D。

1165
01:26:56,840 --> 01:27:07,480
我们可以在链上看到的是，A和B不符合该块200

1166
01:27:07,480 --> 01:27:12,640
因此，现在我们需要去，我们需要询问像这样的更新值是什么

1167
01:27:12,640 --> 01:27:19,079
因此，SNAP协议的第一部分只是UH

1168
01:27:19,079 --> 01:27:23,060
我不知道该说这个连续

1169
01:27:23,060 --> 01:27:26,440
国家检索。

1170
01:27:29,700 --> 01:27:34,480
因此，我们只是在进行，我们正在访问每个叶子以获取帐户。和

1171
01:27:34,480 --> 01:27:38,060
这就像超级简单。显然有帐户尝试，然后有存储尝试

1172
01:27:38,060 --> 01:27:42,780
在下面。但是您只会通过，您将启动最低的索引叶节点，

1173
01:27:43,320 --> 01:27:46,840
下载它，下载下一个，然后一直穿过，直到到达州的尽头。

1174
01:27:47,140 --> 01:27:50,580
一旦完成了州的尽头，您就会发现自己可能有些过时的东西。

1175
01:27:50,579 --> 01:27:57,319
因此C和D仍然有效，但是A和B不正确，因此您必须经历此操作

1176
01:27:57,319 --> 01:28:03,319
这个康复阶段，如果您运行Geth节点或进行SNAP同步的任何节点

1177
01:28:03,319 --> 01:28:08,239
阶段可能是最令人困惑的部分

1178
01:28:08,239 --> 01:28:14,859
树并试图让您知道恢复状态的完整性，以便您要进行绕行

1179
01:28:14,859 --> 01:28:23,479
路径查找。因此，您可能会问，好吧，让我完整的节点列表

1180
01:28:23,479 --> 01:28:32,399
root 200。让我们在这里放一个和两个。因此，这个康复阶段可能就像获得R200。

1181
01:28:33,599 --> 01:28:41,519
这将返回您的节点一和两个节点，这些节点在此处列出。下一部分是

1182
01:28:41,520 --> 01:28:45,120
得到一个。

1183
01:28:46,040 --> 01:28:50,080
因此，这将列出您和A。

1184
01:28:50,820 --> 01:28:54,880
现在您会注意到这条路完全相同。

1185
01:28:54,880 --> 01:28:58,100
如果您用二进制树考虑一下，

1186
01:28:58,620 --> 01:29:00,740
左节点可能为索引零。

1187
01:29:01,280 --> 01:29:03,900
左左节点为索引零。

1188
01:29:04,520 --> 01:29:08,060
左右节点就像索引零一个。

1189
01:29:08,340 --> 01:29:11,500
因此，这些是零零，一个零的路径。

1190
01:29:11,520 --> 01:29:15,520
现在您可以看到，对于0，0，您有A。

1191
01:29:16,040 --> 01:29:19,220
您已经有一个了，但是告诉您实际上是R。

1192
01:29:19,780 --> 01:29:23,400
因此您可以更新，我们现在可以更新我们的本地状态

1193
01:29:23,400 --> 01:29:26,360
成为r，a，c，D。

1194
01:29:27,200 --> 01:29:29,100
您将继续这个康复过程。

1195
01:29:29,340 --> 01:29:32,120
您会看到您必须更新它，

1196
01:29:32,500 --> 01:29:34,100
但是随后您下降到2。

1197
01:29:36,340 --> 01:29:37,740
你说得到2，

1198
01:29:37,739 --> 01:29:44,899
而且您会看到您已经拥有CND，这都是正确的，因此无需更新

1199
01:29:44,899 --> 01:29:52,000
像康复一样的观点，这可能很难概念化，因为它是这样的

1200
01:29:52,000 --> 01:29:57,659
小例子，但是如果您将其推断到数百万节点，呃，这可能会变成

1201
01:29:57,659 --> 01:30:04,479
一个非常缓慢的过程，有趣的是，这个过程的功能是

1202
01:30:04,479 --> 01:30:06,759
您可以下载多快，

1203
01:30:07,599 --> 01:30:10,059
您可以下载多快？

1204
01:30:10,679 --> 01:30:11,579
如果你能做到这一点，

1205
01:30:11,899 --> 01:30:14,939
想象您可以立即下载此连续下载

1206
01:30:14,939 --> 01:30:18,539
然后您下载了针对R1的所有内容。

1207
01:30:19,099 --> 01:30:20,399
因此，您可以下载所有内容

1208
01:30:20,399 --> 01:30:21,819
在R1枢转之前。

1209
01:30:21,979 --> 01:30:23,639
这意味着您不必进行任何康复

1210
01:30:23,639 --> 01:30:25,319
因为您已经下载了

1211
01:30:25,319 --> 01:30:30,319
一个完整的状态试图反对某个路线。

1212
01:30:31,059 --> 01:30:33,019
只需要康复

1213
01:30:33,020 --> 01:30:39,160
每当您无法完成相同路线的连续状态检索时。

1214
01:30:39,260 --> 01:30:44,700
因此，您下载了一些针对R1的下载，您下载了一些反对R200，有些针对R400，

1215
01:30:45,220 --> 01:30:46,240
然后继续。

1216
01:30:46,800 --> 01:30:51,280
因此，如果您的Internet连接非常缓慢，那么您需要很长时间才能完成

1217
01:30:51,280 --> 01:30:57,940
州检索，一旦进入康复阶段，您就会有大量出现的节点

1218
01:30:57,940 --> 01:30:58,320
日期。

1219
01:30:58,319 --> 01:31:09,659
因此，现在您必须经历一个非常缓慢的路径检索过程才能下载该数据。因此，这就是为什么有时人们会说我的节点会粘在治疗上的原因？

1220
01:31:09,659 --> 01:31:14,019
这通常就是正在发生的事情。

1221
01:31:14,460 --> 01:31:17,579
他们的节点试图治愈

1222
01:31:17,579 --> 01:31:21,319
一个极端变形的尝试。

1223
01:31:21,899 --> 01:31:26,279
因此，有时最好删除

1224
01:31:26,279 --> 01:31:28,559
完整的数据库，尝试重新开始

1225
01:31:28,559 --> 01:31:30,220
随着连续的状态检索。

1226
01:31:30,779 --> 01:31:32,880
而且，如果您的互联网有问题

1227
01:31:32,880 --> 01:31:35,359
也许您的节点很长一段时间脱机

1228
01:31:35,359 --> 01:31:38,000
它具有连续状态，

1229
01:31:38,099 --> 01:31:39,420
但是它必须进行康复，

1230
01:31:39,659 --> 01:31:45,579
有时最好只下载所有州，我们也不必去

1231
01:31:46,380 --> 01:31:53,340
深入介绍了不同的uh快照消息，但这一切都在这里

1232
01:31:55,340 --> 01:32:03,099
嗯，这个仓库在以太坊组织中，因此，如果您对

1233
01:32:03,099 --> 01:32:09,340
DEVPDP规格或想挖掘更多这些东西，有以太坊斜线DEVPDP repo

1234
01:32:09,340 --> 01:32:11,960
如果您想了解Snapsync的更多信息，

1235
01:32:12,020 --> 01:32:13,340
这是snapspec。

1236
01:32:13,819 --> 01:32:17,980
SNAPSPEC具有超级良好的概述和描述。

1237
01:32:19,000 --> 01:32:22,400
绝对是，我认为绝对值得一读

1238
01:32:22,400 --> 01:32:26,560
如果您仍然对Snapsync的工作方式感到困惑。

1239
01:32:28,140 --> 01:32:29,720
好吧，那是P2P。

1240
01:32:29,860 --> 01:32:32,880
有什么问题与P2P内容有关吗？

1241
01:32:32,880 --> 01:32:40,159
非常感谢，马特。那太棒了。

1242
01:32:42,400 --> 01:32:48,079
我们已经在聊天中回答了一些问题。大多数人问，

1243
01:32:48,079 --> 01:32:54,319
你怎么知道你没有下载错误的链条，例如

1244
01:32:54,319 --> 01:32:59,920
在引导节点上连接您的网络是恶意的吗？那会发生什么呢？

1245
01:32:59,920 --> 01:33:05,760
是的，在这种情况下，这些路线是经过身份验证的路线。

1246
01:33:06,520 --> 01:33:14,699
因此，您开始进行Snapsync的方式看起来像这样。

1247
01:33:20,060 --> 01:33:23,460
因此，基本上，您从弱主观性检查点开始。

1248
01:33:23,460 --> 01:33:35,220
您如何获得该价值观，您知道这取决于每个人，但是大多数人做的是

1249
01:33:35,220 --> 01:33:44,159
从某些检查点服务器获取一些弱主观性检查点，这为您提供了路线

1250
01:33:44,159 --> 01:33:55,979
让我们看看我们将其称为r，实际上这就像一个块哈希，然后你去

1251
01:33:55,979 --> 01:33:58,960
您得到与哈希相关联的块

1252
01:33:58,960 --> 01:34:11,319
与哈希相关联的块后，您就可以开始按照该块状态进行快照

1253
01:34:11,319 --> 01:34:17,599
所以我想在这里阐明的是您正在运行的状态根源

1254
01:34:17,599 --> 01:34:25,539
从您的意义上说，我们相信这种状态的根源是正确的，就像您一样

1255
01:34:25,539 --> 01:34:31,500
不验证到达该状态根的计算是否正确，您假设是

1256
01:34:31,500 --> 01:34:35,960
正确，您将下载与之相关的状态

1257
01:34:35,960 --> 01:34:42,380
您有点喜欢继续这样做，因为我们没有验证状态。

1258
01:34:42,460 --> 01:34:47,159
因此，您有点看到新块进来，您可以在其中进行验证。

1259
01:34:47,720 --> 01:34:51,560
如果标题正确，则只需假设这些状态路线是正确的。那就是那里

1260
01:34:51,560 --> 01:34:57,560
新路线进来。因此，您可能已经验证了一条路线，并具有弱主观性检查点，

1261
01:34:57,560 --> 01:35:04,319
您花了很长时间才下载此数据，最终您可以到达200。

1262
01:35:04,319 --> 01:35:09,380
您有不同的路线，但是每次我们都相信该路线是正确的。

1263
01:35:09,579 --> 01:35:12,939
然后，您要回来的数据将对这条路线进行见证。

1264
01:35:13,420 --> 01:35:21,519
因此，如果我要求所有帐户，所有叶子的所有叶子从零到一个，都会返回

1265
01:35:21,519 --> 01:35:26,139
证明R是200号公路的一部分证明，A是200号公路的一部分。

1266
01:35:27,299 --> 01:35:32,599
因此，在这种情况下，您将不会获取不是要下载路线的一部分的数据。

1267
01:35:32,600 --> 01:35:40,100
真的，唯一可能发生的事情是国家计算错误

1268
01:35:40,100 --> 01:35:47,440
而且您正在下载一些损坏的状态，即该连锁店已经接受了它非常非常

1269
01:35:47,440 --> 01:35:52,440
不太可能发生这种情况，因为您知道这是一个轻度的客户假设

1270
01:35:52,440 --> 01:35:59,120
如果您不想依靠经济

1271
01:35:59,119 --> 01:36:05,500
多数，如果您想从创世纪验证或合并状态是正确的，

1272
01:36:05,500 --> 01:36:11,500
您必须做一个完整的同步。因此，Snap与完全同步无关。完全是一个

1273
01:36:11,500 --> 01:36:16,059
单独的访问状态方式。这就是您从一开始就开始的地方

1274
01:36:16,059 --> 01:36:21,000
应用以太坊上发生过的每笔交易，最终到达

1275
01:36:21,000 --> 01:36:27,079
最新块并验证最新块的状态是否等于所有交易的状态

1276
01:36:27,079 --> 01:36:27,699
您申请了。

1277
01:36:33,399 --> 01:36:33,960
惊人的。

1278
01:36:35,420 --> 01:36:36,800
让我们看看，也许有

1279
01:36:36,800 --> 01:36:38,840
更多问题，但我们当时正在

1280
01:36:38,840 --> 01:36:40,460
我们应该结束。它已经

1281
01:36:40,460 --> 01:36:42,039
超过90分钟。

1282
01:36:42,380 --> 01:36:44,840
但是，是的，很棒

1283
01:36:44,840 --> 01:36:46,699
火，伙计。谢谢

1284
01:36:46,699 --> 01:36:47,319
很多。

1285
01:36:48,059 --> 01:36:50,180
里面真的很棒。

1286
01:36:51,159 --> 01:36:52,800
人们爱你

1287
01:36:52,800 --> 01:36:54,559
顺便说一句，VIM设置。

1288
01:36:54,640 --> 01:36:56,500
他们已经找到了您的.files仓库

1289
01:36:56,500 --> 01:36:57,479
复制它。

1290
01:37:00,159 --> 01:37:01,439
是的，这很好。

1291
01:37:08,539 --> 01:37:10,119
是的，非常感谢您拥有我。

1292
01:37:11,579 --> 01:37:12,640
那是大多数事情

1293
01:37:12,640 --> 01:37:13,560
我想谈谈。

1294
01:37:13,659 --> 01:37:14,460
我认为我们真的没有

1295
01:37:14,460 --> 01:37:15,560
时间太多

1296
01:37:15,560 --> 01:37:17,119
超级深入

1297
01:37:17,119 --> 01:37:17,899
进入这些东西。

1298
01:37:18,020 --> 01:37:19,359
希望你能看到

1299
01:37:19,359 --> 01:37:20,760
不同的存储库

1300
01:37:20,760 --> 01:37:22,340
我正在访问。

1301
01:37:23,279 --> 01:37:25,100
死去的P2P回购，

1302
01:37:25,100 --> 01:37:30,200
共识规格回购这些是我建议的非常好的信息

1303
01:37:30,200 --> 01:37:36,140
人们喜欢更深入地研究以太坊的回购，如果您是您的回购很多好的评论

1304
01:37:36,140 --> 01:37:40,079
好奇我描述的某些事情如何工作，您可以完全可以

1305
01:37:40,079 --> 01:37:47,060
浏览这些内容，然后看到一些文档，我唯一的另一件事

1306
01:37:47,060 --> 01:37:53,680
在想谈论的是JSON RPC，我会检查执行API的回购

1307
01:37:53,680 --> 01:37:58,159
描述执行层的接口。

1308
01:37:58,159 --> 01:38:00,960
当人们想到什么是以太坊时

1309
01:38:00,960 --> 01:38:02,980
JSON RPC是一种以太坊

1310
01:38:02,980 --> 01:38:06,920
用或多或少的绝对术语

1311
01:38:06,920 --> 01:38:08,940
因为那是人们的界面

1312
01:38:08,940 --> 01:38:12,659
访问以太坊。

1313
01:38:12,659 --> 01:38:17,159
因此，看看执行API库，

1314
01:38:17,159 --> 01:38:19,700
您可以看到所有可用的数据

1315
01:38:19,700 --> 01:38:21,320
查询以太坊。

1316
01:38:21,319 --> 01:38:29,880
太棒了，非常感谢。我只想问一件事，您能分享笔记吗？

1317
01:38:29,880 --> 01:38:36,279
您与我们一起创建的概述文档，将其发送给我们或将其编辑给回购？

1318
01:38:36,279 --> 01:38:38,719
是的，我可以做到。

1319
01:38:38,719 --> 01:38:49,799
再次，出色的工作，我自己学到了很多东西，看到您经历了所有重要的事情

1320
01:38:49,800 --> 01:38:56,440
很棒的是的，我认为人们有一点学习，呃，呃，呃，再次观看录音

1321
01:38:56,440 --> 01:39:03,860
是的，嗯，非常感谢，我真的很感激，是的，可以随时在EPS上标记我

1322
01:39:03,860 --> 01:39:08,539
不一致，所以如果您还有其他问题，请在像客户一样给我标记，我会尝试与您联系

1323
01:39:08,539 --> 01:39:15,180
伙计们，我非常感谢Matt感谢它，并为您的那些人

1324
01:39:15,180 --> 01:39:18,300
本周在丹佛（Denver）为ETH丹佛（Eth Denver）。

1325
01:39:18,680 --> 01:39:22,880
我们将在星期四举办聚会。

1326
01:39:23,740 --> 01:39:27,380
您可以在不和谐中查看该信息。

1327
01:39:29,400 --> 01:39:30,880
是的，再一次，非常感谢，马特，

1328
01:39:30,880 --> 01:39:34,840
下周我们会见所有共识层概述

1329
01:39:34,840 --> 01:39:35,880
与亚历克斯·斯托克斯（Alex Stokes）。

1330
01:39:36,619 --> 01:39:37,020
好的。

1331
01:39:38,000 --> 01:39:38,960
谢谢，伙计们。

1332
01:39:39,320 --> 01:39:39,860
别紧张。

1333
01:39:41,140 --> 01:39:41,320
再见。

1334
01:39:42,000 --> 01:39:42,500
再见。

