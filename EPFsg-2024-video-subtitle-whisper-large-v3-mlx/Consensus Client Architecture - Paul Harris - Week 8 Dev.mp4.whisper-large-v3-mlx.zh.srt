1
00:00:30,000 --> 00:00:54,260
谢谢。

2
00:01:00,000 --> 00:01:29,980
谢谢。

3
00:01:30,000 --> 00:01:40,000
¶¶

4
00:01:40,000 --> 00:01:50,000
¶¶

5
00:01:50,000 --> 00:02:00,000
¶¶

6
00:02:00,000 --> 00:02:10,000
¶¶

7
00:02:10,000 --> 00:02:20,000
¶¶

8
00:02:20,000 --> 00:02:30,000
¶¶

9
00:02:30,000 --> 00:02:59,979
我爱你。

10
00:03:00,000 --> 00:03:29,979
谢谢。

11
00:03:30,000 --> 00:03:59,979
谢谢。

12
00:04:00,000 --> 00:04:07,840
好的，欢迎回到以太坊协议研究小组。

13
00:04:08,479 --> 00:04:15,979
我们现在正在第八周，这是第八周的开发赛道。

14
00:04:15,979 --> 00:04:27,379
我们在这里与Tecku的Paul Harris交谈，Tecku将为我们深入了解以太坊共识客户架构。

15
00:04:27,379 --> 00:04:36,339
是的，我会把它传给马里奥，也许在这里给我们保罗的深度介绍，然后将其拉开。

16
00:04:37,959 --> 00:04:38,719
嘿，大家。

17
00:04:38,939 --> 00:04:41,800
首先，保罗，非常感谢您今天加入我们。

18
00:04:42,219 --> 00:04:45,120
关于保罗，您应该知道的一件事是他在澳大利亚。

19
00:04:45,560 --> 00:04:50,659
今天对他来说还很早，所以非常感谢您制作并在这里加入我们。

20
00:04:50,920 --> 00:04:55,659
因为我们非常渴望了解共识层和实际客户端体系结构。

21
00:04:55,660 --> 00:05:03,120
在过去的几周中，我们对亚历克斯·斯托克斯（Alex Stokes）的共识层有深入的了解。

22
00:05:04,020 --> 00:05:11,780
我们看到了执行层客户端，今天我们最终也深入研究了共识客户端的真实代码基础。

23
00:05:12,680 --> 00:05:23,220
特别是，保罗为我们准备了有关EIP或想法如何成为规范的一些演讲

24
00:05:23,220 --> 00:05:27,380
然后，它通过以前通过研究小组讨论的这一过程实施。

25
00:05:27,380 --> 00:05:31,140
是的，我们真的很高兴得知这一点。

26
00:05:31,140 --> 00:05:40,620
作为共识活动的一部分，保罗正在共识客户Teku。

27
00:05:40,620 --> 00:05:47,140
而且已经有一段时间了，我相信保罗已经在以太坊周围已经存在了几年。

28
00:05:47,139 --> 00:05:57,539
去年，他也一直在为协议奖学金做AMA，但这是

29
00:05:57,539 --> 00:05:58,539
非技术。

30
00:05:58,539 --> 00:06:02,439
我们在那里聊天非常好，但这不是真正的潜水，所以，是的，很兴奋

31
00:06:02,439 --> 00:06:04,539
有你。

32
00:06:04,539 --> 00:06:05,939
是的，舞台是你的。

33
00:06:05,939 --> 00:06:09,560
随时分享您的屏幕并通过它来完成它。

34
00:06:09,560 --> 00:06:11,959
非常感谢您在这里。

35
00:06:11,959 --> 00:06:12,959
惊人的。

36
00:06:12,959 --> 00:06:15,620
非常感谢您邀请我。

37
00:06:15,620 --> 00:06:17,079
我认为这听起来还不错。

38
00:06:19,340 --> 00:06:21,540
我只是在使用耳机，我确实倾向于

39
00:06:22,720 --> 00:06:24,319
有时会变得有趣，

40
00:06:24,319 --> 00:06:26,019
所以我以为我会检查它。

41
00:06:26,019 --> 00:06:27,240
嗯，听起来很棒。

42
00:06:28,360 --> 00:06:29,920
惊人的。

43
00:06:29,920 --> 00:06:32,519
所以，我将分享一个屏幕。

44
00:06:32,519 --> 00:06:33,639
对不起，背景。

45
00:06:33,639 --> 00:06:34,620
通常我有一个

46
00:06:35,879 --> 00:06:38,040
通常我隐藏了橱柜和一切。

47
00:06:41,000 --> 00:06:42,220
那是我的屏幕吗？

48
00:06:43,800 --> 00:06:45,500
我已经准备了一些幻灯片甲板。

49
00:06:45,620 --> 00:06:55,620
这不仅是我说话。正如已经说过的那样，我为

50
00:06:55,620 --> 00:07:01,740
一个名为tecku的客户端上的共识层，我必须说表达的观点

51
00:07:01,740 --> 00:07:08,980
是我的，它们不一定反映共识的观点。

52
00:07:08,980 --> 00:07:17,780
关于我的一点点，我是与共识的区块链协议工程师，该公司

53
00:07:17,780 --> 00:07:22,120
共识，我在Teku上工作。

54
00:07:22,120 --> 00:07:28,860
我还是几个REST API的维护者，这是Beacon API和密钥经理

55
00:07:28,860 --> 00:07:37,259
API，它们是共识层用来做不同事情的主要API。

56
00:07:37,259 --> 00:07:46,279
我的团队中有七位软件工程师，四位在技术人员中，对不起，四个

57
00:07:46,279 --> 00:07:56,300
在欧洲，三个在亚太地区，但我们是一个团队。

58
00:07:56,300 --> 00:08:02,079
我认为我会从高水平的共识层开始。

59
00:08:02,079 --> 00:08:07,539
显然，我们有很多事情可以驱动我们的日常工作。

60
00:08:08,839 --> 00:08:18,539
有共识规范，基本上是共识层的完整可执行规范。

61
00:08:19,439 --> 00:08:26,120
有一个执行API，这是我们与执行层客户端的接口。

62
00:08:26,339 --> 00:08:27,839
因此，这也很重要。

63
00:08:27,839 --> 00:08:39,179
就内部API而言，我们拥有Beacon API，它使我们能够执行诸如生产块并提交块之类的事情。

64
00:08:39,179 --> 00:08:46,839
然后是关键管理器API，这也很重要，但更重要的是涉及经过验证的密钥管理。

65
00:08:46,839 --> 00:08:53,339
因此，能够接受新密钥，能够删除我们正在运行的密钥。

66
00:08:53,340 --> 00:09:00,740
然后是构建器API，它围绕着构建执行层部分

67
00:09:00,740 --> 00:09:10,960
优先使用某些人的执行层的块。

68
00:09:10,960 --> 00:09:16,879
有些人违约回到本地执行层，但有些人使用

69
00:09:16,879 --> 00:09:21,720
建造者API要做MEV。

70
00:09:21,720 --> 00:09:29,000
驱动团队的另一件事显然是他们的实际团队指导。

71
00:09:29,000 --> 00:09:35,120
以Teco为例，我们目前不实施光线客户端，因此有部分

72
00:09:35,120 --> 00:09:47,860
我们理解的共识规范，但我们不一定实施。

73
00:09:47,860 --> 00:09:55,139
查看所有内容，基本上是共识层和执行层，都可以找到开放的规格。

74
00:09:55,940 --> 00:10:02,659
Prefus Dake本身基本上就像是一个非常大，复杂，分布式的游戏。

75
00:10:04,100 --> 00:10:09,940
像任何游戏一样，互动的定义很好，并且有一组规则。

76
00:10:09,940 --> 00:10:18,740
就像任何复杂的游戏一样，肯定有灰色区域，我们认为

77
00:10:18,740 --> 00:10:25,240
规则将得到充分定义，实际上并不是完美定义。

78
00:10:25,240 --> 00:10:29,960
因为共识层使用可执行的规格，所以这意味着我们可以在

79
00:10:29,960 --> 00:10:34,760
这些规格，然后我们可以与所有实现共享这些测试。

80
00:10:34,759 --> 00:10:41,919
因此，例如，Tecce可以下载所有这些测试并运行它们，然后排除

81
00:10:41,919 --> 00:10:55,360
那些我们不想像光线客户那样涵盖的人。

82
00:10:55,360 --> 00:11:01,580
看着tecce，所以我们的使命陈述（如果您愿意的话）是我们想成为客户

83
00:11:01,580 --> 00:11:03,860
适用于机构stakers的选择。

84
00:11:06,820 --> 00:11:08,259
我们是用爪哇写的

85
00:11:09,560 --> 00:11:13,200
所以希望人们能读一点爪哇，

86
00:11:13,200 --> 00:11:16,259
但这不会是今天的超级代码，

87
00:11:16,259 --> 00:11:17,360
所以应该很好。

88
00:11:18,740 --> 00:11:20,960
我们有很多广泛的指标

89
00:11:22,440 --> 00:11:24,000
那是通过普罗米修斯暴露的，

90
00:11:24,000 --> 00:11:27,720
所以有一个非常好的仪表板，

91
00:11:27,720 --> 00:11:29,259
我今天可能不会表现出来，

92
00:11:29,259 --> 00:11:32,419
但是我们确实有它，并且公开可供所有人使用

93
00:11:32,419 --> 00:11:34,840
使用。

94
00:11:34,840 --> 00:11:37,819
而且我们非常关注测试。

95
00:11:37,819 --> 00:11:40,819
如果有人以前看过测试三角形，

96
00:11:40,819 --> 00:11:46,059
因此，您将在单位测试级别进行大量测试。

97
00:11:46,059 --> 00:11:48,059
然后，当您上三角形时，

98
00:11:48,059 --> 00:11:49,659
在整合级别的少量，

99
00:11:49,659 --> 00:11:51,600
而且在系统级别上少了。

100
00:11:51,600 --> 00:11:54,600
但是覆盖所有级别通常是一个好主意

101
00:11:54,600 --> 00:11:57,439
这样您就可以获得所需的覆盖范围。

102
00:11:59,259 --> 00:12:02,500
我们非常专注于伐木。

103
00:12:02,500 --> 00:12:06,539
因此，我们使用基本的用户log4j。

104
00:12:06,539 --> 00:12:12,759
如果有人知道，几年前，我们受到了Log4J的影响。

105
00:12:12,759 --> 00:12:16,720
我认为大多数客户团队都是。

106
00:12:16,720 --> 00:12:18,819
我们运行一个代码流。

107
00:12:18,819 --> 00:12:26,179
因此，一些客户团队将使用分支机构开发，在不同的分支机构中进行功能

108
00:12:26,179 --> 00:12:29,739
然后将它们带入最后。

109
00:12:29,739 --> 00:12:30,739
我们不这样做。

110
00:12:30,739 --> 00:12:34,639
我们使用开发或大师开发。

111
00:12:34,639 --> 00:12:36,539
我们经常发布所有代码。

112
00:12:36,539 --> 00:12:43,979
因此，我们所做的任何事情都需要活跃或在功能标志后面。

113
00:12:43,979 --> 00:12:51,000
如果我们不希望代码在版本中，我们需要确保我们正在禁用

114
00:12:51,000 --> 00:12:52,000
它。

115
00:12:52,000 --> 00:12:55,960
有大量文档。

116
00:12:55,960 --> 00:13:00,779
该产品是开源的，我们确实支持不和谐

117
00:13:00,779 --> 00:13:04,379
通过共识不和谐以及

118
00:13:04,379 --> 00:13:07,679
我们确实在每个状态中都有存在，

119
00:13:07,679 --> 00:13:09,399
那里有一个TechU支持渠道。

120
00:13:12,019 --> 00:13:14,419
最后，我们是节点运算符。

121
00:13:14,419 --> 00:13:17,840
因此，我们在Mainnet上运行Techu，显然我们运行Techu

122
00:13:17,840 --> 00:13:20,480
在测试网上也是如此。

123
00:13:22,000 --> 00:13:24,279
有些人称自己吃自己的狗食，

124
00:13:24,279 --> 00:13:27,879
如果有人以前听说过。

125
00:13:31,059 --> 00:13:33,259
那是一种共识层的概述，

126
00:13:33,259 --> 00:13:38,259
和tecku，到目前为止有什么问题吗？

127
00:13:43,820 --> 00:13:46,259
只有一个问题，

128
00:13:46,259 --> 00:13:51,259
Tecku是否使用Gradle，我相信确实如此。

129
00:13:51,259 --> 00:13:58,419
我们确实使用Gradle，是的。 Gradle是我们的构建系统，我们目前发布到文物中。

130
00:13:58,419 --> 00:14:08,419
现在还有一个，TECO不实施持久的API的原因是什么？

131
00:14:08,419 --> 00:14:14,419
好问题。是的，肯定。

132
00:14:14,419 --> 00:14:21,399
基本上，这是没有很多资源的历史文物。

133
00:14:21,399 --> 00:14:29,379
当我们开始teku进入零阶段发布时，我们到了两个开发人员

134
00:14:29,379 --> 00:14:32,839
一段时间，所以没有能力。

135
00:14:32,839 --> 00:14:38,339
现在我们有七个

136
00:14:38,340 --> 00:14:42,860
更多的资源可以考虑进行全新的代码流。

137
00:14:43,780 --> 00:14:51,399
我们确实得到了一些协议奖学金人

138
00:14:51,399 --> 00:14:52,440
开始这样做。

139
00:14:52,560 --> 00:14:54,580
所以有一个开始，

140
00:14:54,759 --> 00:14:56,580
但是我们只是没有资源。

141
00:14:58,320 --> 00:15:01,340
这并不是人民的重点

142
00:15:01,340 --> 00:15:05,019
我们的业务声明的目的是

143
00:15:05,120 --> 00:15:07,800
因此，我们并没有发现这是一个巨大的问题。

144
00:15:07,799 --> 00:15:10,319
但是，也很高兴能完成规格。

145
00:15:11,959 --> 00:15:13,639
因此，只是竞争驱动程序。

146
00:15:14,620 --> 00:15:15,139
是的，明白了。

147
00:15:15,299 --> 00:15:15,740
谢谢保罗。

148
00:15:16,159 --> 00:15:17,240
是的，我认为您可以继续前进。

149
00:15:18,379 --> 00:15:18,799
凉爽的。

150
00:15:20,419 --> 00:15:22,599
我简要介绍了材料

151
00:15:22,599 --> 00:15:25,479
那是八个东西

152
00:15:25,479 --> 00:15:31,519
和阿德里安（Adrian）谈论所有模块

153
00:15:31,519 --> 00:15:33,500
已经在技术中

154
00:15:33,500 --> 00:15:35,039
实际上更加完整

155
00:15:35,039 --> 00:15:37,719
比我意识到的。

156
00:15:37,879 --> 00:15:39,939
所以我还没有详细介绍

157
00:15:39,939 --> 00:15:41,360
关于技术的布局。

158
00:15:41,360 --> 00:15:44,360
所以希望人们能看一下那个演讲，

159
00:15:45,039 --> 00:15:47,379
但是，如果没有，那不是一个大问题。

160
00:15:48,939 --> 00:15:51,379
我们只是今天不会涵盖

161
00:15:51,379 --> 00:15:54,120
因为毫无意义地讨论相同的事情。

162
00:15:55,120 --> 00:15:56,740
在很高的水平上

163
00:15:58,579 --> 00:16:02,819
我们以某种方式布置了模块

164
00:16:02,820 --> 00:16:07,640
它有点像层次结构。

165
00:16:08,100 --> 00:16:10,600
因此，我们在底层有基础架构。

166
00:16:11,379 --> 00:16:13,460
我们的以太坊高于此。

167
00:16:13,460 --> 00:16:19,700
基本上，基础设施无法从以太坊中汲取任何东西。

168
00:16:21,280 --> 00:16:25,060
它可以在同一级别上拉进去，但是在堆栈后不能吸入。

169
00:16:25,300 --> 00:16:29,260
这对于信标和验证器模块而言相同，

170
00:16:29,780 --> 00:16:31,060
技术人员也是如此。

171
00:16:31,059 --> 00:16:35,819
因此，它可以一直沿堆栈消耗，

172
00:16:36,039 --> 00:16:38,679
但是基础架构无法在堆栈上消耗任何地方，

173
00:16:38,779 --> 00:16:41,199
B无法消耗堆栈。

174
00:16:42,619 --> 00:16:45,679
有一些工具坐在侧面，

175
00:16:45,899 --> 00:16:47,739
而且我们确实有参考测试。

176
00:16:49,019 --> 00:16:53,079
但这是我们指导开发人员说的指导

177
00:16:53,479 --> 00:16:58,379
确保我们不会引起循环依赖性。

178
00:16:58,379 --> 00:17:08,579
可能发生的事情之一，因为Intellij相当宽容，我们可以介绍

179
00:17:08,579 --> 00:17:13,500
循环依赖性且不真正知道，因此有建造检查以确保我们是

180
00:17:13,500 --> 00:17:18,259
以良好的顺序食用事物，不会导致其他人问题。

181
00:17:18,259 --> 00:17:25,660
因为有时候人们将项目导入日食，尤其是引起问题

182
00:17:25,660 --> 00:17:34,220
在过去。大多数开发人员都使用Intellij，这并不重要，但是Eclipse非常

183
00:17:34,220 --> 00:17:43,259
自以为是。我要先深入研究API，因为那是一件事

184
00:17:43,259 --> 00:17:50,480
自阿德里安（Adrian）举行会谈以来发生了变化。无论如何，他们对API都很轻松，但是我们曾经

185
00:17:50,480 --> 00:17:54,259
使用带注释的对象进行我们的API，

186
00:17:54,259 --> 00:17:59,360
现在，我们已经更改为更有声明的风格。

187
00:17:59,360 --> 00:18:08,360
如果我们看一下API的位置以及它们的用途，

188
00:18:08,360 --> 00:18:11,240
就操作员而言，他们可能

189
00:18:11,240 --> 00:18:13,599
需要与信标节点互动，

190
00:18:13,599 --> 00:18:16,440
他们可能需要与验证器客户端进行互动

191
00:18:16,440 --> 00:18:19,480
出于两个不同的原因。

192
00:18:19,480 --> 00:18:24,920
获得了信标API，允许从信标访问实际数据

193
00:18:24,920 --> 00:18:31,599
节点。您可以获取状态数据，可以获取块数据，您可以

194
00:18:31,599 --> 00:18:41,440
产生并提交证明以及所有此类事物，这将

195
00:18:41,440 --> 00:18:47,680
直接进行，就像信标节点将其提交给网络一样。这

196
00:18:47,680 --> 00:18:51,720
验证者客户端本身是一个小客户

197
00:18:51,720 --> 00:18:54,560
那只是管理钥匙并制作

198
00:18:54,560 --> 00:18:56,840
确保完成职责。

199
00:18:56,840 --> 00:19:00,279
它可以使用信标API来做到这一点。

200
00:19:00,279 --> 00:19:03,060
但是从操作员的角度来看

201
00:19:03,060 --> 00:19:07,140
密钥管理器API允许操作员

202
00:19:07,140 --> 00:19:13,400
在运行时添加或删除验证器密钥。

203
00:19:13,400 --> 00:19:17,920
所以这是一种漂亮的API。

204
00:19:17,920 --> 00:19:20,220
确实需要更多的安全性。

205
00:19:20,220 --> 00:19:27,200
我认为在关键经理API中，我们建议仅使用SSL。

206
00:19:27,200 --> 00:19:29,680
我们还建议它受到密码保护，

207
00:19:29,680 --> 00:19:34,920
因为这类事情正在涉及私钥，所以

208
00:19:34,920 --> 00:19:38,700
它是超级敏感的。

209
00:19:38,700 --> 00:19:41,840
因此，如果您丢失了私钥，那将是不好的。

210
00:19:41,839 --> 00:19:43,299
希望我们都明白这一点。

211
00:19:43,299 --> 00:19:47,899
我很高兴参与其中，但这就是Keymanager API

212
00:19:47,899 --> 00:19:50,399
在附近。

213
00:19:50,399 --> 00:19:52,240
从信标节点的角度来看，

214
00:19:52,240 --> 00:19:55,879
它主要消耗的API是引擎API

215
00:19:55,879 --> 00:19:59,759
与执行层和构建器API交谈，

216
00:19:59,759 --> 00:20:03,279
我相信这被称为与建筑商互动

217
00:20:03,279 --> 00:20:08,099
并继电器与MEV互动。

218
00:20:08,099 --> 00:20:12,719
不需要使用构建器API。

219
00:20:12,719 --> 00:20:16,539
您只需连接一个信标节点

220
00:20:16,539 --> 00:20:20,199
执行层，这是我在家中的作品。

221
00:20:20,199 --> 00:20:24,719
它确实简化了设置，并且有情况

222
00:20:24,719 --> 00:20:28,799
信标节点可能需要关闭构建器API的位置

223
00:20:28,799 --> 00:20:31,719
这样我们就可以产生块，因为我们的第一

224
00:20:31,719 --> 00:20:36,579
重要的是网络的生计。

225
00:20:36,579 --> 00:20:40,519
我今天将不会全部了解的另一个API，

226
00:20:40,519 --> 00:20:45,679
除了Beacon API，我什么都不会涉及。

227
00:20:45,679 --> 00:20:50,259
有一个允许外部签名者的签名API。

228
00:20:50,259 --> 00:20:56,679
因此，如果您使用的是Dirk或Web3签名者，

229
00:20:56,679 --> 00:20:58,899
他们将实现签名API，

230
00:20:58,899 --> 00:21:01,220
验证器客户将通过他们去

231
00:21:01,220 --> 00:21:05,059
签名而不是签名。

232
00:21:06,579 --> 00:21:15,059
它允许分享签名者并确保所有事物都得到集中控制，

233
00:21:15,059 --> 00:21:21,059
这是一个更好的高价值解决方案，而不是拥有本地签名者

234
00:21:21,740 --> 00:21:24,500
并且必须自己做闪烁的保护。

235
00:21:31,399 --> 00:21:34,139
因此，这可能是显而易见的，但只是要陈述它，

236
00:21:34,140 --> 00:21:43,860
API是世界的界面，也是世界访问Beacon API的界面。

237
00:21:43,860 --> 00:21:51,840
默认情况下它是安全的，因此对我们来说，这意味着我们有一个访问列表，并且仅访问

238
00:21:51,840 --> 00:22:02,000
由Localhost，仅在127.0.0.1上访问。

239
00:22:02,000 --> 00:22:06,440
我们使用声明性接口，这是有趣的位。

240
00:22:06,440 --> 00:22:11,279
我们最终不得不写自己的书，这永远不是我的第一选择，但是在这种情况下

241
00:22:11,279 --> 00:22:15,119
这很有意义。

242
00:22:15,119 --> 00:22:20,099
它称为类型定义，我们将在一分钟内查看一些示例。

243
00:22:20,099 --> 00:22:27,539
类型定义使我们能够定义对象的一部分以暴露，以及部分

244
00:22:27,539 --> 00:22:30,339
没有明确的零件不暴露，

245
00:22:30,339 --> 00:22:33,079
但我们基本上可以说

246
00:22:33,079 --> 00:22:35,519
访问对象的这些属性，

247
00:22:35,519 --> 00:22:38,659
如果我们有一个对象，这非常有用

248
00:22:38,659 --> 00:22:40,319
那略有不同

249
00:22:40,319 --> 00:22:42,319
我们需要在网络上分享的内容。

250
00:22:44,700 --> 00:22:46,460
它们都是基于SSZ的。

251
00:22:46,460 --> 00:22:48,299
因此SSZ强烈键入

252
00:22:48,299 --> 00:22:50,460
它具有所有信息

253
00:22:50,460 --> 00:22:52,099
关于我们要分享的内容。

254
00:22:52,099 --> 00:22:54,399
我们希望它能够利用

255
00:22:54,399 --> 00:22:55,700
已经存在的数据

256
00:22:55,700 --> 00:22:59,360
因此，我们不必在API层上重新定义所有这些，

257
00:22:59,360 --> 00:23:01,240
这是我们在做的

258
00:23:01,240 --> 00:23:05,200
当我们创建旧对象时，

259
00:23:05,200 --> 00:23:07,200
我们也将在一分钟内完成。

260
00:23:13,940 --> 00:23:15,940
一个非常简单的类型def示例，

261
00:23:16,900 --> 00:23:20,860
我们有一个名为Post Sectestation的课程。

262
00:23:20,860 --> 00:23:23,860
那是信标节点

263
00:23:23,859 --> 00:23:28,659
实际上是在试图向信标节点提交签名证明。

264
00:23:28,659 --> 00:23:31,139
抱歉，验证器客户端尝试

265
00:23:31,139 --> 00:23:33,299
提交签名证明。

266
00:23:37,099 --> 00:23:43,740
这是物体本身体内的结构。

267
00:23:43,740 --> 00:23:47,079
但这是我们宣布要使用的内容的地方。

268
00:23:47,079 --> 00:23:52,899
因此，我们说的是，在请求正文中，我们有一个，我会停止点击，

269
00:23:52,900 --> 00:23:56,060
我们有一个可见的类型定义。

270
00:23:56,060 --> 00:24:01,860
因此，它将像JSON一样跨过电线。

271
00:24:01,860 --> 00:24:03,660
我们要消耗那个JSON

272
00:24:03,660 --> 00:24:06,100
并将其变成真实的对象。

273
00:24:06,100 --> 00:24:09,060
而且我们将使用证明模式。

274
00:24:09,060 --> 00:24:16,200
因此，每个SSZ对象都定义了其模式，

275
00:24:16,200 --> 00:24:20,780
我们将利用证明模式。

276
00:24:20,779 --> 00:24:24,559
我们将期待它为JSON。

277
00:24:24,559 --> 00:24:31,099
在回答方面，确定是一个很好的回应。

278
00:24:31,099 --> 00:24:37,359
对于喜欢HTTP代码的任何人来说，这是200。

279
00:24:37,359 --> 00:24:40,660
其他可能是不良请求代码的代码，即

280
00:24:40,660 --> 00:24:42,839
400。

281
00:24:42,839 --> 00:24:47,099
不良的请求代码也必须定义为JSON类型。

282
00:24:47,099 --> 00:24:51,939
所以我们告诉它，我们给它的类型

283
00:24:51,939 --> 00:24:55,439
我们向它声明它的样子

284
00:24:55,439 --> 00:24:56,759
作为有效对象。

285
00:24:57,919 --> 00:24:59,480
如果我们看，

286
00:25:02,399 --> 00:25:05,139
希望这种变化，没有。

287
00:25:07,279 --> 00:25:08,980
在任何地方都没有更改视图。

288
00:25:14,519 --> 00:25:16,519
我希望它能保持景色。

289
00:25:17,099 --> 00:25:18,099
出色的。

290
00:25:18,099 --> 00:25:34,379
所以，哦，我耗尽了房间。

291
00:25:34,379 --> 00:25:38,980
这是在构造函数中定义的。

292
00:25:38,980 --> 00:25:45,899
然后在句柄请求中，这是存在的预定义接口，我们基本上是

293
00:25:45,900 --> 00:25:57,320
获取请求主体。当我们内部致电提交站时，我们将获得未来。所以这是一种异步

294
00:25:57,320 --> 00:26:07,800
请求，我们可能会获取数据错误列表。然后基本上我们异步做出反应。

295
00:26:07,800 --> 00:26:14,380
我们需要排队回答，以说，一旦这个未来解决，我们就会去

296
00:26:14,380 --> 00:26:21,260
如果有实际，请仔细检查任何错误，并决定错误响应

297
00:26:21,260 --> 00:26:28,420
错误。

298
00:26:28,420 --> 00:26:29,420
我们有单位测试。

299
00:26:29,420 --> 00:26:34,260
哦，我将不得不停下来开始它。

300
00:26:34,260 --> 00:26:37,920
对此很抱歉。

301
00:26:37,920 --> 00:26:43,380
我应该只单击另一个链接。

302
00:26:44,380 --> 00:27:03,180
抱歉，我没有意识到它必须停下来开始。

303
00:27:03,180 --> 00:27:18,140
好吧，Junit中的单位测试是一个非常常见的框架。

304
00:27:18,140 --> 00:27:23,880
在单元测试中，我们不使用模拟服务器或任何复杂的东西。

305
00:27:23,880 --> 00:27:31,620
基本上，显然，我们要确保我们能够提交该类型的对象。

306
00:27:31,619 --> 00:27:38,899
因此，我们会提交认证类型，我们希望它能回来，并且

307
00:27:38,899 --> 00:27:43,959
响应主体应为无效。

308
00:27:43,959 --> 00:27:50,699
就何时有无效证明而言，我们希望能够恢复错误

309
00:27:50,699 --> 00:27:58,039
并得到它并获得不良的请求响应。

310
00:27:58,039 --> 00:28:01,279
然后我们参加了身体周围的其他测试。

311
00:28:01,279 --> 00:28:09,379
我将在短短一秒钟内看一下您的评论，Josh。

312
00:28:09,379 --> 00:28:12,259
这会更容易。

313
00:28:12,259 --> 00:28:17,920
让我们现在尝试一下。

314
00:28:17,920 --> 00:28:21,579
共享屏幕。

315
00:28:21,579 --> 00:28:30,139
哦，直到我们的屏幕。

316
00:28:30,139 --> 00:28:31,139
好的。

317
00:28:31,139 --> 00:28:32,139
你现在看到了吗？

318
00:28:32,139 --> 00:28:33,139
凉爽的。

319
00:28:33,139 --> 00:28:34,139
是的。

320
00:28:34,139 --> 00:28:35,139
好的。

321
00:28:35,139 --> 00:28:36,139
那更好。

322
00:28:36,139 --> 00:28:41,460
在我们的屏幕之前，我没有点击共享？

323
00:28:41,460 --> 00:28:50,019
显然，我没有共享整个屏幕的权限。

324
00:28:50,019 --> 00:28:51,860
对不起。

325
00:28:51,860 --> 00:28:55,680
解决此权限问题时，有什么问题吗？

326
00:28:55,680 --> 00:29:06,279
是的，关于您是否与Basu共享任何图书馆有一个大问题，

327
00:29:06,279 --> 00:29:09,440
那里将是一些合作的工作。

328
00:29:12,119 --> 00:29:13,960
实际上，这是一个很好的问题。

329
00:29:13,960 --> 00:29:22,920
我们确实分享了几个图书馆。

330
00:29:22,920 --> 00:29:27,559
主要的实际上是在普罗米修斯附近。

331
00:29:27,559 --> 00:29:31,180
因此，我们所有的指标都通过基本库，该图书馆

332
00:29:31,180 --> 00:29:36,279
安全是否必须实施任何指标

333
00:29:36,279 --> 00:29:37,639
自己。

334
00:29:37,639 --> 00:29:41,559
我们确实有快速的课程，可以让我们做自己的事情。

335
00:29:41,559 --> 00:29:47,619
我只需要重新

336
00:29:47,619 --> 00:29:50,500
好的，我们很快就会回来。

337
00:29:50,500 --> 00:29:56,519
是的，保罗正在做它，以便他可以分享他的整个屏幕。

338
00:29:56,519 --> 00:30:01,399
我认为他没有意识到他的浏览器正在进行这次会议。

339
00:30:01,399 --> 00:30:04,759
因此，我们将在这里稍后回来。

340
00:30:04,759 --> 00:30:08,000
同时，请随时提出任何问题。

341
00:30:08,000 --> 00:30:16,099
另外，如果您对以前与共识有关的谈话有任何疑问，请感觉到

342
00:30:16,099 --> 00:30:18,980
免费发布它们。

343
00:30:18,980 --> 00:30:19,980
嘿。

344
00:30:19,980 --> 00:30:20,980
嗨，布莱恩。

345
00:30:20,980 --> 00:30:23,559
你能把我放回去吗？

346
00:30:23,559 --> 00:30:29,579
显然，它无法重新打开Prime，这意味着它无法重新打开此问题。

347
00:30:29,579 --> 00:30:33,740
现在，她将能够共享整个屏幕。

348
00:30:33,740 --> 00:30:48,039
我只是说，我们确实共享基本库，这主要是围绕指标。

349
00:30:48,039 --> 00:30:54,399
因此，除此之外，我不这么认为。

350
00:30:54,400 --> 00:31:01,960
我知道Web3注册会吸引许多我们的REST API东西。

351
00:31:01,960 --> 00:31:06,800
我不认为他们，希望他们不再了，因为我们已经摆脱了大部分

352
00:31:06,800 --> 00:31:07,360
他们使用。

353
00:31:08,080 --> 00:31:11,380
这是我很快就必须追赶的事情。

354
00:31:13,140 --> 00:31:15,380
现在，我获得了登录所有内容的乐趣。

355
00:31:15,380 --> 00:31:32,780
是的，这很有意义，指标基本上可能是同一回事，但是其他部分非常

356
00:31:32,780 --> 00:31:35,260
EL和CL之间的不同。

357
00:31:35,260 --> 00:31:38,920
是的，当还有更多问题即将到来时，我们会告诉您。

358
00:31:38,920 --> 00:31:46,440
是的，我只是在登录，我们现在有很多身份验证要求，所以关闭

359
00:31:46,440 --> 00:31:50,259
浏览器实际上真的很糟糕，但是我得到了。

360
00:31:50,259 --> 00:31:53,140
总是这样。

361
00:31:53,140 --> 00:31:56,320
让我们再试一次。

362
00:31:56,320 --> 00:31:59,620
不，不是幻灯片。

363
00:32:29,619 --> 00:32:34,899
更好。

364
00:32:34,899 --> 00:32:38,500
现在，它实际上正在为您改变。

365
00:32:38,500 --> 00:32:48,659
我们注意到的一件事是当我们在实际上开发API时的差距

366
00:32:48,659 --> 00:32:52,839
当我们使用注释时，我们可以很容易地更改

367
00:32:52,839 --> 00:32:57,500
API，没有看到定义发生了变化。

368
00:32:57,500 --> 00:33:00,059
实际上真的很糟糕，尤其是在这个API上，

369
00:33:00,059 --> 00:33:03,200
因为定义确实非常重要

370
00:33:03,200 --> 00:33:05,259
做对。

371
00:33:05,259 --> 00:33:11,579
所以我们最终基本上倾倒了JSON模式

372
00:33:11,579 --> 00:33:14,660
因此测试可以参考JSON模式

373
00:33:14,660 --> 00:33:20,059
为了验证我们没有改变事物，

374
00:33:20,059 --> 00:33:23,759
或至少向我们展示我们何时改变了事情。

375
00:33:23,759 --> 00:33:28,079
这是一个非常低的技术解决方案，但非常有效

376
00:33:28,079 --> 00:33:34,240
我们最终将这些文件获取在这种情况下，我们正在查看

377
00:33:34,240 --> 00:33:39,359
邮政数据站，我们正在查看路线ETH V1

378
00:33:39,359 --> 00:33:42,879
信标泳池证明有两条路线

379
00:33:42,879 --> 00:33:47,759
有一个数据报，有一个帖子数据报

380
00:33:47,759 --> 00:33:52,000
在这里定义的get定义了，我们会向下滚动，因为我们正在查看帖子

381
00:33:52,000 --> 00:34:01,839
实施因此，就帖子而言，它具有几个标签，这是

382
00:34:01,839 --> 00:34:07,599
验证器所需的API，实际上知道任何验证器真的很重要

383
00:34:09,039 --> 00:34:12,960
这是实现REST API必须实现此帖子功能

384
00:34:15,840 --> 00:34:20,000
这是一个标签，是一个低技术解决方案，可以说您需要实施此功能

385
00:34:20,000 --> 00:34:25,280
事实证明它非常有效，然后我们基本上希望休息

386
00:34:25,280 --> 00:34:30,000
车站必须在车站

387
00:34:30,880 --> 00:34:39,039
我们得到的有效响应是200 400和500。500被神奇地添加了

388
00:34:39,039 --> 00:34:44,719
我们真的不想在每个界面中进行500个攻击

389
00:34:44,719 --> 00:34:48,960
因此，我们使其成为默认集的一部分，但是我们已经始终添加

390
00:34:48,960 --> 00:34:57,039
我们声明中的那个界面真的很方便

391
00:34:57,039 --> 00:35:02,320
键入定义，因为我们能够看到我们当时所缺少的

392
00:35:02,320 --> 00:35:07,519
更改界面重写整个库是一项艰巨的任务，如果您没有

393
00:35:08,720 --> 00:35:12,159
事先进行了足够的测试，您真的不会很有趣

394
00:35:15,280 --> 00:35:15,599
嗯

395
00:35:15,599 --> 00:35:23,279
哦，丑陋，这很丑陋。

396
00:35:23,279 --> 00:35:24,900
这是这个示例的大部分。

397
00:35:24,900 --> 00:35:29,819
有人对此有任何疑问吗？

398
00:35:29,819 --> 00:35:41,559
我认为这可能很有趣的原因是因为这是我们自己的

399
00:35:41,559 --> 00:35:53,559
因此，您无法在网上找到它可以找到它的参考文献，这是您真正需要遵循示例或询问Techie Devs的内容。

400
00:35:54,559 --> 00:35:59,559
很有趣。我们对这个示例没有特别的问题。

401
00:36:00,559 --> 00:36:06,559
但是还有另一个问题。您使用任何依赖注入框架吗？

402
00:36:06,559 --> 00:36:15,400
pen悔注射框架。

403
00:36:15,400 --> 00:36:18,599
没有人想到。

404
00:36:18,599 --> 00:36:25,179
我们做，不，没有想到。

405
00:36:25,179 --> 00:36:26,179
我们可能。

406
00:36:26,179 --> 00:36:29,119
我不这么认为。

407
00:36:29,119 --> 00:36:35,559
我们确实有人们用来模糊和东西的图书馆，但这并不是真正的

408
00:36:35,559 --> 00:36:41,719
问题是。我想那是注入模糊的数据，但是是的。

409
00:36:45,380 --> 00:36:47,320
是的，我说不，但我可能错了。

410
00:36:49,360 --> 00:36:52,579
好吧，现在。是的，谢谢保罗。我认为我们可以

411
00:36:52,719 --> 00:36:53,259
继续前进。

412
00:36:59,480 --> 00:37:05,480
下一个例子也是我爱我的鼠标轮。对不起。下一个

413
00:37:05,480 --> 00:37:14,679
我要输入的另一个示例也是使用类型定义。

414
00:37:14,679 --> 00:37:22,159
这个略有不同，因为我们最终要做的是我们带来一个对象

415
00:37:22,159 --> 00:37:28,159
不是我们自己的包装对象称为ObjectinMetadata。

416
00:37:28,159 --> 00:37:34,000
我们发现通常需要返回某种通用对象。

417
00:37:34,639 --> 00:37:36,500
在这种情况下，它是一个字节32。

418
00:37:36,500 --> 00:37:38,739
在某些情况下，这是整个块。

419
00:37:40,539 --> 00:37:51,379
但是有了这些数据，我们还需要它是否最终确定以及是否在合并后的世界中，

420
00:37:51,519 --> 00:37:53,440
有一种称为执行乐观的模式。

421
00:37:54,119 --> 00:37:56,799
因此，我们并没有真正拥有所有数据。

422
00:37:56,800 --> 00:37:59,920
我们认为这是有效的，但我们实际上没有EL的数据。

423
00:38:02,880 --> 00:38:08,880
因此，我们发现我们非常需要这种类型的定义，并为其创建了此容器。

424
00:38:10,560 --> 00:38:14,480
因此，我们可以将其传递到包含字节32的对象和元数据中。

425
00:38:16,320 --> 00:38:21,200
在这种情况下，尽管我们有这种结构，但我们需要一个不同的结构

426
00:38:21,200 --> 00:38:25,200
输出，这就是为什么这比最后一个更有趣的原因。

427
00:38:25,199 --> 00:38:35,319
我们已经有了，我们正在定义一个是数据的字段，并且要获取该数据字段实际上是

428
00:38:35,319 --> 00:38:42,699
根类型，因此它实际上是在这个定义中递归的，该定义具有一个字段

429
00:38:42,699 --> 00:38:46,619
根，是字节32。

430
00:38:46,619 --> 00:38:54,779
因此，这就是此GET块根功能的实际数据有效载荷。

431
00:38:54,780 --> 00:38:57,160
它也有执行的乐观标志，

432
00:38:57,160 --> 00:38:59,260
只是直接从物体上

433
00:38:59,260 --> 00:39:00,660
和最终标志，仅

434
00:39:00,660 --> 00:39:01,880
直接从物体上脱离。

435
00:39:05,360 --> 00:39:15,140
这是一个非常相似的测试。

436
00:39:15,140 --> 00:39:17,700
因此，它应该返回标头块信息。

437
00:39:17,700 --> 00:39:21,740
我们尝试使用主要有意义的测试名称。

438
00:39:21,739 --> 00:39:25,779
有时它们很长，

439
00:39:25,779 --> 00:39:28,979
但是我们确实尝试使它们相当描述。

440
00:39:28,979 --> 00:39:31,119
它是经过代码评论的评论的来源

441
00:39:31,119 --> 00:39:31,739
一直以来。

442
00:39:34,219 --> 00:39:39,099
同样，元数据与其他测试非常相似。

443
00:39:39,099 --> 00:39:40,819
我们在这里做的是验证

444
00:39:40,819 --> 00:39:46,699
该类型的定义具有我们需要的一切。

445
00:39:46,699 --> 00:39:51,039
因此，我们知道我们需要能够返回200个响应，

446
00:39:51,039 --> 00:39:54,340
而且我们知道我们需要能够将其转换为400。

447
00:39:54,340 --> 00:39:58,699
如果对象定义不包含这些，

448
00:39:58,699 --> 00:40:04,360
然后我们遇到了麻烦，因为它会变成400个响应

449
00:40:04,360 --> 00:40:07,699
进行500响应，而500是内部错误，这是

450
00:40:07,699 --> 00:40:14,579
仍然是一个错误，但这不是休息的很好的回应

451
00:40:14,579 --> 00:40:15,079
API。

452
00:40:15,079 --> 00:40:24,279
但是基本上，单位测试对该元数据定义更感兴趣

453
00:40:24,279 --> 00:40:31,460
并且集成测试实际上对您获得的实际情况更感兴趣

454
00:40:31,460 --> 00:40:35,199
在这种情况下，我猜对象定义本身

455
00:40:35,199 --> 00:40:40,639
这很容易，因为它主要是块根

456
00:40:40,639 --> 00:40:45,639
因此，它将其扔到另一个对象，我们不会看。

457
00:40:48,400 --> 00:40:50,500
获得块根并不大量使用。

458
00:40:52,400 --> 00:40:56,400
另一个是后证明，大量使用了。

459
00:40:57,059 --> 00:41:00,739
因此，每次我们运行验证器时，另一个都会进行测试

460
00:41:00,739 --> 00:41:01,879
那是偏远模式。

461
00:41:02,539 --> 00:41:05,900
它将使用该界面，我们很快就会知道它是否破裂。

462
00:41:10,639 --> 00:41:17,799
当我们查看API时，我们还有另一件事是这是我们自己的文档版本，

463
00:41:17,799 --> 00:41:20,719
但这也位于执事APIS存储库上。

464
00:41:21,039 --> 00:41:24,179
有一种方法可以查看对象定义。

465
00:41:25,599 --> 00:41:30,359
因此，这是我们在那时所寻找的界面。

466
00:41:33,579 --> 00:41:36,179
它具有路径参数，即块ID。

467
00:41:36,179 --> 00:41:56,099
我认为，有趣的是，您可以通过诸如头部之类的东西，或者可以通过块根，我认为这仅仅是因为块ID是标准的定义，但是能够有点奇怪通过块根，然后将块根返回。

468
00:41:57,480 --> 00:42:02,259
但这只是有时可能发生的怪异设计成果之一。

469
00:42:02,260 --> 00:42:10,580
因此，这是一个相对简单的示例，即类型定义的几个示例。

470
00:42:15,860 --> 00:42:23,060
我将在一秒钟内从API继续前进。在我们之前，还有其他关于API的问题吗

471
00:42:23,059 --> 00:42:34,400
目前，我没有看到有关API的具体内容。

472
00:42:34,400 --> 00:42:35,400
是的。

473
00:42:35,400 --> 00:42:36,400
凉爽的。

474
00:42:36,400 --> 00:42:42,659
我们将进入下一节。

475
00:42:42,659 --> 00:42:48,219
我聚集在一起，您已经看了ERP和EIP过程。

476
00:42:48,219 --> 00:42:53,500
我不在整个过程中，所以从开发人员的角度来看这一切

477
00:42:53,500 --> 00:42:58,799
谁从原型制作部分开始。

478
00:42:58,799 --> 00:43:06,339
因此，我可能会歪曲事情，但这是我对此的看法。

479
00:43:06,339 --> 00:43:14,399
因此，我们在EIP过程中达到了一个时间点，我们不再只是一个研究项目，

480
00:43:14,400 --> 00:43:19,680
我们想开始研究如何实施某些东西。

481
00:43:19,680 --> 00:43:23,680
因此，我们从这一轮原型制作开始

482
00:43:23,680 --> 00:43:29,599
这不再是研究。我们经常在不和谐上讨论这些事情，

483
00:43:29,599 --> 00:43:34,960
因此，ETH，研发，不和谐。对于某些更大的东西

484
00:43:34,960 --> 00:43:40,400
有专门的频道，有时它们在电报上，

485
00:43:40,400 --> 00:43:44,220
这仅取决于对话的开始。

486
00:43:44,220 --> 00:43:48,420
通常，它最终是两者之间的桥梁。

487
00:43:48,420 --> 00:43:51,960
这是一个相当有机和泥泞的过程。

488
00:43:51,960 --> 00:43:55,960
因此很难理解会发生什么

489
00:43:55,960 --> 00:43:59,139
因为它并不总是一样。

490
00:43:59,139 --> 00:44:01,559
当我们这样做时，我们正在查看更多

491
00:44:01,559 --> 00:44:04,480
工程心态。

492
00:44:04,480 --> 00:44:06,940
所以我们更整体地看待

493
00:44:06,940 --> 00:44:13,360
现在已经存在的系统，并试图用知识将某些东西安装到该系统中

494
00:44:13,360 --> 00:44:18,700
其余的。

495
00:44:18,700 --> 00:44:25,780
因此，这种情况是我们试图使EIP真正适合可执行

496
00:44:25,780 --> 00:44:33,539
规格并确保我们了解EL和CL如何相互作用。

497
00:44:33,539 --> 00:44:36,699
有时肯定会错过。

498
00:44:36,699 --> 00:44:40,940
在ERP被大多接受并锻炼之后

499
00:44:40,940 --> 00:44:45,619
细节是事情的发展很大。

500
00:44:45,619 --> 00:44:48,019
这都是非常模糊和手动的，

501
00:44:48,019 --> 00:44:50,820
我们将进入一个具体的例子，我可以解释

502
00:44:50,820 --> 00:44:52,039
更多我在说什么。

503
00:44:55,360 --> 00:45:00,639
ERP 7251在最大的有效余额附近

504
00:45:00,639 --> 00:45:02,480
增加。

505
00:45:02,480 --> 00:45:06,960
的确，我正在考虑这个，因为我目前正在实施它

506
00:45:07,599 --> 00:45:14,400
而且我觉得我基本上有一个合理的理解

507
00:45:15,599 --> 00:45:20,960
当发生削减事件时，我们正在查看最初的处罚

508
00:45:22,480 --> 00:45:30,000
嗯，削减的事件uh uh也变得昂贵，即使我们正在寻找一个验证者

509
00:45:30,000 --> 00:45:37,920
它是1E，是当前验证者之一如果他们将蒙受的最初罚款

510
00:45:37,920 --> 00:45:38,639
被砍了。

511
00:45:39,900 --> 00:45:48,539
只是要清楚，因为随时用多种不同的方式使用了削减

512
00:45:48,539 --> 00:45:52,820
有人在网络上受到罚款，我们只是将其称为罚款。

513
00:45:52,820 --> 00:45:57,539
如果有人做了故意不好的事情

514
00:45:57,539 --> 00:45:59,340
我们认为它足够糟糕

515
00:45:59,340 --> 00:46:02,240
他们应该停止参与网络，

516
00:46:02,400 --> 00:46:05,100
我们将其称为削减，只是削减了这一点。

517
00:46:07,780 --> 00:46:11,400
所以我所说的被削减的结果

518
00:46:11,400 --> 00:46:13,980
实际上是被启动了网络。

519
00:46:16,100 --> 00:46:19,260
小验证器的最初处罚还不错，

520
00:46:19,320 --> 00:46:21,680
但是，一旦我们将其扩展到Max EB，

521
00:46:21,679 --> 00:46:27,139
当今其余规则的最初罚款看起来像64 ETH。

522
00:46:29,079 --> 00:46:33,440
这是线性的缩放，所以在某些世界中，您可以说这是公平的

523
00:46:33,440 --> 00:46:40,579
但是现实是，如果我要在一个盒子上有64个验证器

524
00:46:40,579 --> 00:46:43,659
其中一个被证明削减了

525
00:46:43,659 --> 00:46:47,000
剩下的一段时间都很好

526
00:46:47,000 --> 00:46:49,239
取决于他们证明哪个插槽。

527
00:46:49,239 --> 00:46:56,839
因此，我可以关闭该节点，只为一个验证器或少量验证器而被削减。

528
00:46:57,419 --> 00:47:07,719
如果将所有这些合并到一个验证器中，那么我将只会产生少量的罚款时，我会产生100％的罚款。

529
00:47:08,859 --> 00:47:12,199
因此，从这个角度来看，这并不公平。

530
00:47:12,199 --> 00:47:25,319
因此，他们想要做的是最初的罚款，请确保最初的罚款对每个人都无效。

531
00:47:25,559 --> 00:47:28,399
这不是对机构的惩罚。

532
00:47:28,399 --> 00:47:30,019
这不是惩罚独奏的人。

533
00:47:30,019 --> 00:47:32,400
是。

534
00:47:32,400 --> 00:47:38,280
当我们看一下将其放入规格中时，

535
00:47:38,280 --> 00:47:43,000
举报人奖励的想法想到了。

536
00:47:43,000 --> 00:47:44,639
当您被砍伐时会发生什么

537
00:47:44,639 --> 00:47:47,780
是有人向报告获得奖励​​。

538
00:47:47,780 --> 00:47:50,900
实际上，这是块提议者。

539
00:47:50,900 --> 00:47:55,400
从理论上讲，它可能是产生的第三方

540
00:47:55,400 --> 00:47:57,139
这是所有数据

541
00:47:57,139 --> 00:48:02,319
并试图报告被禁止的人。

542
00:48:02,319 --> 00:48:07,900
在这种情况下，我们的2048 ETH验证器（最大）

543
00:48:07,900 --> 00:48:12,259
本来会创建4个ETH举报人奖，

544
00:48:12,259 --> 00:48:15,819
很棒，很多人会很高兴。

545
00:48:15,819 --> 00:48:21,059
但是问题是我们实际上是在铸造ETH。

546
00:48:21,059 --> 00:48:26,920
罚款不再支付该举报人奖，这是

547
00:48:27,139 --> 00:48:32,679
如果我们回到游戏理论，它是无限的资源产生，这是避免的。

548
00:48:33,460 --> 00:48:36,099
因此，最终，我们不想造成Eth。

549
00:48:38,699 --> 00:48:45,319
这样做的解决方案是至少必须涵盖举报人的奖励。

550
00:48:50,000 --> 00:48:56,239
这是一个有趣的案例，即EIP何时进入现实世界。

551
00:48:57,139 --> 00:49:01,659
我只是要读一个问题。

552
00:49:05,500 --> 00:49:10,839
我们在这里有一个问题有关此处的更改。

553
00:49:12,099 --> 00:49:14,400
它正在查看阶段0规格吗？

554
00:49:14,759 --> 00:49:16,759
这听起来像是阶段0规格。

555
00:49:21,259 --> 00:49:23,099
我必须在那个方面找你

556
00:49:23,099 --> 00:49:24,739
但是我很确定。

557
00:49:27,139 --> 00:49:32,139
我很确定，它在Bellatrix中变为1E。

558
00:49:36,299 --> 00:49:38,319
如果有人在研究共识规范，

559
00:49:38,319 --> 00:49:43,319
我们要做的另一件事是我们基本上创造了一个差异

560
00:49:45,139 --> 00:49:49,559
在上一个版本和下一个版本之间

561
00:49:49,559 --> 00:49:51,420
作为下一个版本的定义。

562
00:49:51,420 --> 00:49:54,460
因此，它可能会令人困惑，

563
00:49:54,460 --> 00:49:58,019
但是我可以追逐这个问题，马里乌斯。

564
00:49:58,019 --> 00:50:00,740
我现在无法回答。

565
00:50:00,740 --> 00:50:05,039
但是我很确定，在贝拉特里克斯（Bellatrix）中，它变为1e。

566
00:50:07,960 --> 00:50:11,240
基本上，奖励问题发生了变化。

567
00:50:11,240 --> 00:50:14,599
是的，我为Paul复制了这个问题，所以有点长了。

568
00:50:14,599 --> 00:50:17,720
但是我们在不和谐中进行了讨论

569
00:50:17,720 --> 00:50:20,420
因此，也许如果您会加入我们的不和谐

570
00:50:20,420 --> 00:50:27,700
是的，好吧。您想为此射击我一个DM链接吗？

571
00:50:27,700 --> 00:50:32,820
是的，我会的。惊人的。否则我会肯定的是。

572
00:50:35,860 --> 00:50:41,059
无论如何，当我们指出最初的罚款将被罚款64时，没有其他人

573
00:50:41,059 --> 00:50:45,380
在那个小组中，我可能是对的，但我可以确认这一点。

574
00:50:47,539 --> 00:50:48,659
嗯，

575
00:50:50,420 --> 00:51:00,280
因此，基本上所有功能，所有ERP都进入共识规范时的功能

576
00:51:00,280 --> 00:51:08,320
进入此下划线功能文件夹。

577
00:51:08,320 --> 00:51:12,300
在这种情况下，我们现在也更改了有效。

578
00:51:12,300 --> 00:51:16,960
我们只更换了信标链和叉子，但是看来我们现在改变了另一个

579
00:51:16,960 --> 00:51:19,980
文件。

580
00:51:19,980 --> 00:51:28,099
这些是规格上的不同，所以当他们说，我们将跳跃

581
00:51:28,099 --> 00:51:34,199
我认为，具体来说，我们将去标准州。

582
00:51:34,199 --> 00:51:41,740
好吧，信标国家并非如此。

583
00:51:41,740 --> 00:51:49,900
因此，这些重新定义了对象，然后在某个时候我们开始恢复新手，我们知道

584
00:51:49,900 --> 00:51:53,559
我们正在寻找7、2、5、1。

585
00:51:53,559 --> 00:51:56,400
实际上，我们添加了大量新领域

586
00:51:56,400 --> 00:52:00,519
进入比特币状态7、2、5、1。

587
00:52:00,519 --> 00:52:03,579
这就是所有这些。

588
00:52:03,579 --> 00:52:05,720
其中一些是列表，

589
00:52:05,720 --> 00:52:06,880
要证明很有趣。

590
00:52:06,880 --> 00:52:10,380
前几天有人注意到这个

591
00:52:10,380 --> 00:52:11,920
是我们第一次

592
00:52:11,920 --> 00:52:13,440
将有剪接列表。

593
00:52:16,820 --> 00:52:18,680
这将是我们的痛苦点

594
00:52:18,680 --> 00:52:19,840
尚未完成。

595
00:52:19,840 --> 00:52:24,640
但实际上，通常，当我们向国家添加东西时，

596
00:52:24,780 --> 00:52:27,240
我们添加一个或两个字段，而不是八个字段。

597
00:52:28,180 --> 00:52:31,600
所以，是的，这会变得有趣。

598
00:52:32,900 --> 00:52:34,600
我要展示的是...

599
00:52:36,720 --> 00:52:38,579
我实际上可能会跳到我的想法。

600
00:52:38,579 --> 00:52:49,559
当我们将东西添加到我们的

601
00:52:49,559 --> 00:52:58,119
嗯，我们的代码基础是因为事物如何发展的历史

602
00:52:58,119 --> 00:53:05,960
我们在实际版本领域的UM中确实有变化

603
00:53:05,960 --> 00:53:13,119
但是我们在API区域API模式中进行了整个变化。

604
00:53:15,260 --> 00:53:18,059
这些是我们过去使用的旧注释对象。

605
00:53:18,340 --> 00:53:21,800
不，那不是我点击的内容。

606
00:53:23,780 --> 00:53:24,260
这是？

607
00:53:26,099 --> 00:53:27,460
不，那是Json。

608
00:53:29,900 --> 00:53:31,340
和余额存款。

609
00:53:31,519 --> 00:53:32,360
好的，看起来更好。

610
00:53:32,360 --> 00:53:42,940
因此，有了我们的带注释的对象，我们必须将它们称为pojos，普通的旧爪哇对象，

611
00:53:42,940 --> 00:53:47,920
但是基本上，我们必须在添加的每个字段上注释，我们必须放置

612
00:53:47,920 --> 00:53:52,620
注释构造函数。

613
00:53:52,620 --> 00:53:59,140
我们还需要创建一个构造函数，使我们可以采用真实对象，版本

614
00:53:59,139 --> 00:54:09,219
对象并产生此对象，以便我们可以转换这两种方式，以便我们需要能够去

615
00:54:09,219 --> 00:54:17,139
到架构对象和架构对象，取决于场景上的对象，这基本上是

616
00:54:17,139 --> 00:54:22,900
整个文件夹基本上是技术债务，因为我们不再使用它

617
00:54:22,900 --> 00:54:29,780
方案，但仍然需要定义，因为它正在改变状态和旧状态

618
00:54:29,780 --> 00:54:39,300
API仍然引用此。我们将它们用于某些验证器API，对某​​些

619
00:54:39,860 --> 00:54:48,420
验证者客户端与信标节点的交互，但不需要状态，而是

620
00:54:48,420 --> 00:54:52,280
但是我们还没有完全删除该代码路径，

621
00:54:52,460 --> 00:54:54,599
因此，我们仍然维护这些对象，

622
00:54:54,740 --> 00:54:55,700
有点不幸。

623
00:54:59,000 --> 00:55:01,720
话虽如此，这是一个很小的变化

624
00:55:01,720 --> 00:55:04,320
与其他东西相比

625
00:55:04,380 --> 00:55:05,880
无论如何都必须存在。

626
00:55:08,300 --> 00:55:10,740
如果我们只是看json对象，

627
00:55:12,680 --> 00:55:15,200
所有新领域都将在那里。

628
00:55:15,199 --> 00:55:24,699
它们也在这里定义了，所以这在Json Land中的外观

629
00:55:24,699 --> 00:55:32,839
这些测试相当方便的地方是因为更改对象然后更改了类型

630
00:55:32,839 --> 00:55:40,019
对象使用并流过所有物体的定义

631
00:55:40,019 --> 00:55:45,280
集成测试，因此我们可以在不查看代码的情况下确切地看到发生了什么变化

632
00:55:45,280 --> 00:55:52,139
如果其中之一从UN64中变成了其他事物，则同样的事情

633
00:55:52,139 --> 00:55:55,599
这也会在这里反映，我们可以很容易地看到

634
00:55:55,599 --> 00:56:05,320
这是我们拥有建筑商的一整体，目前这只是我自己的分支

635
00:56:05,320 --> 00:56:10,200
在某些常数中被黑客入侵，我不会在达到真实代码时做到这一点

636
00:56:11,480 --> 00:56:14,200
但这是一种使它脱离地面的简单方法。

637
00:56:17,240 --> 00:56:22,120
我假设每个人都看过建筑商的模式，所以我不会跳入建造者

638
00:56:22,120 --> 00:56:29,960
图案。我要说的主要内容是有很多东西只是改变

639
00:56:29,960 --> 00:56:36,840
对于那八个领域

640
00:56:41,320 --> 00:56:45,880
该集成测试是令人讨厌的测试，它基本上显示了我们错过了什么

641
00:56:50,519 --> 00:56:53,159
这是我们使用分支开发的几次

642
00:56:53,159 --> 00:56:58,139
通常，我们会做的是我们只是将事情放在功能切换后面

643
00:56:58,139 --> 00:57:05,619
嗯，目前我们已经接受了一些功能已被接受

644
00:57:05,619 --> 00:57:13,399
伊莱克特拉和有些仍在制定中，而7251是已经解决的一项，所以

645
00:57:13,399 --> 00:57:22,379
一直还没有被完全接受，而且还没有更改为是的，它肯定是在

646
00:57:22,380 --> 00:57:29,059
伊莱克因此，我将其保留在分支上，以免感染其他东西，因为一旦我添加

647
00:57:29,059 --> 00:57:38,320
这些对象进入状态，然后我们与之交谈的任何其他客户都需要成为

648
00:57:38,320 --> 00:57:41,380
处理同一状态，否则将获得不同的路线，

649
00:57:42,000 --> 00:57:43,320
而且我们将无法互相交谈。

650
00:57:43,320 --> 00:57:58,400
嗯，来自7251的另一个示例一个看似简单的一个um是符合激活队列的条件

651
00:57:58,400 --> 00:58:06,860
因此，这是一个可以查看验证器对象并确定的函数

652
00:58:06,860 --> 00:58:12,559
它是否需要进入激活队列以成为活跃

653
00:58:12,559 --> 00:58:14,579
文件编辑器。

654
00:58:14,579 --> 00:58:19,320
在Python中，一切都是蛇案。

655
00:58:19,320 --> 00:58:22,880
在Java，拥有

656
00:58:22,880 --> 00:58:25,699
混合有些事情是蛇案的混合案例

657
00:58:25,699 --> 00:58:28,059
有些事情是骆驼盒。

658
00:58:28,059 --> 00:58:32,759
所有主要的Java编码标准都是骆驼壳。

659
00:58:32,759 --> 00:58:34,179
所以我们已经使用了骆驼盒。

660
00:58:34,179 --> 00:58:40,159
如果我们翻译了这一点，我们将符合激活队列的资格

661
00:58:40,159 --> 00:58:43,599
更像是这样。

662
00:58:43,599 --> 00:58:45,379
当我们这样做时，应该找到其中之一

663
00:58:45,379 --> 00:58:48,139
通过代码进行搜索。

664
00:58:48,139 --> 00:58:52,379
因此，我们将在一秒钟内查看代码。

665
00:58:52,379 --> 00:58:57,559
它是在抽象的时期处理器中，这很好。

666
00:58:57,559 --> 00:59:03,279
然后我们可以看一下如何定义

667
00:59:03,279 --> 00:59:09,579
它是否有资格获得electra的激活队列

668
00:59:09,579 --> 00:59:12,019
必须更改该功能。

669
00:59:12,019 --> 00:59:17,259
因此，如果我跳回去，则更改要小得多。

670
00:59:22,579 --> 00:59:27,880
摘要，您将processr放置。

671
00:59:34,400 --> 00:59:37,719
有趣的是，它是内联的，没关系。

672
00:59:39,579 --> 00:59:43,699
我们有一个评论，提到它有资格参加激活队列。

673
00:59:45,079 --> 00:59:48,799
如果我们回顾规格，它基本上是在做同样的事情。

674
00:59:48,880 --> 00:59:50,079
有点不同。

675
00:59:52,759 --> 00:59:59,579
但这听起来好像我们只是在试图确保我们不必阅读整个验证器对象，以便我们可以做出确定。

676
01:00:02,139 --> 01:00:06,119
因此，在不更改该逻辑的情况下，我只是将其分为一个函数。

677
01:00:06,119 --> 01:00:14,759
基本上，当我们看时，我只能覆盖该功能。

678
01:00:16,119 --> 01:00:17,460
我去了错误的文件。

679
01:00:17,460 --> 01:00:22,460
如此摘要等级。

680
01:00:25,119 --> 01:00:31,019
因此，符合激活队列的条件现在取决于最小激活平衡，

681
01:00:31,099 --> 01:00:35,699
这是一个在7.2.5.1中发挥作用的新领域。

682
01:00:36,119 --> 01:00:44,380
随之而来的是，还有许多其他功能需要定义。

683
01:00:45,679 --> 01:00:50,019
由于复利的提款证书正在加剧撤回凭证。

684
01:00:50,659 --> 01:00:56,960
我不知道这使得通过撤回凭证变得容易得多。

685
01:00:57,099 --> 01:00:58,699
我假设这是为了测试。

686
01:00:58,699 --> 01:01:07,419
这是我不太在意的开销，但这并不是一个大问题，所以我

687
01:01:07,419 --> 01:01:14,379
刚刚按照规格进行操作的方式，然后有一个get max效应验证max

688
01:01:14,379 --> 01:01:21,119
有意义的有效平衡，因为我们必须检查提款凭证前缀

689
01:01:21,119 --> 01:01:24,119
如果有人看着

690
01:01:24,119 --> 01:01:28,719
肮脏的细节

691
01:01:28,719 --> 01:01:30,079
验证器。

692
01:01:31,400 --> 01:01:34,259
我们有一个前缀为0x00。

693
01:01:35,679 --> 01:01:37,980
当戒断活动在Capella时，

694
01:01:38,339 --> 01:01:40,639
实际上，在此之前，

695
01:01:41,279 --> 01:01:42,719
这是ETH1撤离

696
01:01:42,719 --> 01:01:46,619
基本上是0x01

697
01:01:46,619 --> 01:01:48,679
然后一堆零

698
01:01:48,679 --> 01:01:50,559
然后是ETH地址。

699
01:01:50,559 --> 01:01:57,059
我们将利用这一点，并将其制作为0x02进行复合。

700
01:01:58,460 --> 01:02:04,320
目前，我不建议任何人观看此事更改他们的用户0x02。

701
01:02:04,440 --> 01:02:08,380
没有什么阻止你的，但这可能不是很好

702
01:02:08,380 --> 01:02:11,119
直到我们确定要更改为的所有细节。

703
01:02:13,679 --> 01:02:18,139
无论如何，0x01是您现在在主网上看到的最常见的

704
01:02:18,139 --> 01:02:25,239
这意味着取款基本上是在循环中进行的

705
01:02:25,239 --> 01:02:28,699
在几天的时间里，

706
01:02:29,159 --> 01:02:31,199
每个人都处理了部分提款。

707
01:02:32,980 --> 01:02:35,420
新的复合将会改变一点

708
01:02:35,420 --> 01:02:38,500
细节尚未确定

709
01:02:38,500 --> 01:02:41,139
至于那将是什么样子。

710
01:02:41,139 --> 01:02:53,460
我们有一堆预设可以更改以添加一些新字段。

711
01:02:53,460 --> 01:02:55,359
我们有不同的网络配置。

712
01:02:55,359 --> 01:03:00,619
因此，显然，主网是大多数人所知道的。

713
01:03:00,619 --> 01:03:07,359
最小值是一个方便的网络配置，可以在开发过程中运行，因为它不需要

714
01:03:07,359 --> 01:03:10,559
很多事情，但它确实从零阶段开始。

715
01:03:11,139 --> 01:03:13,940
Swift是我们实际上仅用于测试的一种。

716
01:03:14,879 --> 01:03:18,059
这是非常非常短的时期时间，

717
01:03:18,239 --> 01:03:21,440
因此，它使我们能够进行诸如运行接受测试之类的事情

718
01:03:21,440 --> 01:03:26,400
以一种非常快速的方式进行最终确定

719
01:03:26,400 --> 01:03:29,299
不必等待几分钟。

720
01:03:30,259 --> 01:03:32,579
但是它们都需要更新Electra。

721
01:03:33,859 --> 01:03:35,199
所以这就是经历。

722
01:03:35,199 --> 01:03:45,960
然后，我们在测试中有这些对象，这些对象基本上只是定义了一些默认值

723
01:03:45,960 --> 01:03:53,500
它们是相当任意的，所以我还没有完美地定义每个值，但它们给了我们一个

724
01:03:53,500 --> 01:03:56,960
代表写作测试秒

725
01:03:56,960 --> 01:04:08,960
因此，更改要小得多，但它也只针对一个功能，我们已经

726
01:04:08,960 --> 01:04:16,840
最终实施了三到四个，因为我们正在研究该最小激活平衡。

727
01:04:16,840 --> 01:04:24,480
因此，当您原型阐明功能时，这就是您经历的事情。

728
01:04:24,480 --> 01:04:31,360
显然，涉及测试，我们必须添加一个框架。

729
01:04:31,360 --> 01:04:39,619
因此，当将参考测试添加到规格中时，我们将能够致电其中一些人

730
01:04:39,619 --> 01:04:44,079
功能以验证他们正在做我们认为正在做的事情。

731
01:04:44,079 --> 01:04:53,860
但是目前，我们还没有这些，所以我们只是在实施代码本身。

732
01:04:53,860 --> 01:04:55,099
那是随机的。

733
01:04:55,099 --> 01:04:56,700
有什么问题吗？

734
01:05:04,059 --> 01:05:05,820
对此没有问题，

735
01:05:08,079 --> 01:05:09,320
也许以后

736
01:05:09,320 --> 01:05:12,780
但是一些未拖累的问题。

737
01:05:12,780 --> 01:05:15,420
什么是数据库，

738
01:05:15,420 --> 01:05:17,579
TECO使用的数据库引擎是什么？

739
01:05:19,160 --> 01:05:20,680
显然我们有两个。

740
01:05:20,679 --> 01:05:25,779
当我们从创世纪开始时，我们仅使用rockSDB。

741
01:05:27,000 --> 01:05:32,019
有时我们能够升级RocksDB时遇到问题，

742
01:05:32,019 --> 01:05:36,480
他们确实有很多错误的开始

743
01:05:36,480 --> 01:05:39,279
随着他们的一些释放，突然的事情会回归。

744
01:05:40,219 --> 01:05:41,799
因此，我们确实切换到LevelDB。

745
01:05:43,099 --> 01:05:48,659
我们发现LevelDB现在并不是真正积极地维护的。

746
01:05:48,659 --> 01:05:52,139
因此，我们正在考虑切换回RockSDB。

747
01:05:53,940 --> 01:05:55,699
巴苏显然使用rocksdb，

748
01:05:55,879 --> 01:05:59,799
大团队中的那个领域有很多专业知识。

749
01:06:01,659 --> 01:06:04,839
对于任何好奇的人

750
01:06:05,199 --> 01:06:08,639
共识确实经营着一大批人

751
01:06:08,639 --> 01:06:10,819
也维持超级巴苏。

752
01:06:11,519 --> 01:06:16,039
这就是为什么巴苏有时是对泰克的考虑

753
01:06:16,039 --> 01:06:19,480
在我们的发展方面

754
01:06:19,480 --> 01:06:21,340
因为我们确实有很多专业知识

755
01:06:21,340 --> 01:06:24,440
在我们自己的小组内

756
01:06:24,440 --> 01:06:27,380
对于很多基本的东西。

757
01:06:29,719 --> 01:06:30,739
好的，谢谢。

758
01:06:31,000 --> 01:06:32,199
很有趣，是的，

759
01:06:32,279 --> 01:06:35,079
因为这是从级别的DB转移到踏板

760
01:06:35,079 --> 01:06:39,960
有趣的是，您可以回到DB级。

761
01:06:40,679 --> 01:06:41,880
谢谢。

762
01:06:42,579 --> 01:06:45,039
还有另一个问题

763
01:06:45,039 --> 01:06:49,199
您在技术开发中发现最具挑战性的是什么，

764
01:06:49,199 --> 01:06:52,380
代码库的哪一部分最难维护

765
01:06:52,380 --> 01:06:54,940
从事质量功能？

766
01:06:55,940 --> 01:06:57,920
存储肯定是最难的。

767
01:07:02,199 --> 01:07:05,380
数据库存储的变化很少。

768
01:07:05,380 --> 01:07:09,579
因此，您得到的基本上是测试

769
01:07:09,579 --> 01:07:13,440
有时对

770
01:07:13,440 --> 01:07:16,940
他们通常是由离开团队的人写的

771
01:07:16,940 --> 01:07:21,519
因为我们需要更改它们并不普遍。

772
01:07:21,920 --> 01:07:26,039
因此，一旦我们最终潜入改变任何东西

773
01:07:26,039 --> 01:07:29,559
在存储层中，它往往有点开销。

774
01:07:32,360 --> 01:07:36,139
欧洲有一位绅士在这里

775
01:07:36,139 --> 01:07:38,820
比我少一点，但是有一段时间。

776
01:07:39,400 --> 01:07:42,960
所以通常它落在我们一个人身上

777
01:07:42,960 --> 01:07:44,980
要关注任何存储更改。

778
01:07:48,500 --> 01:07:50,300
并且有代码的各个部分。

779
01:07:51,519 --> 01:07:54,920
因此，当我们查看我们可以运行的两种方式时，

780
01:07:55,240 --> 01:07:57,500
我们可以作为组合的信标节点运行

781
01:07:57,500 --> 01:08:04,039
能够在相同的过程中运行Val编辑器键。

782
01:08:04,860 --> 01:08:08,019
或者我们可以使用分解的Val编辑器客户端运行。

783
01:08:08,019 --> 01:08:13,559
因此，在这两种模式中，每个人都有一个父母班级。

784
01:08:13,559 --> 01:08:19,359
有一个信标连锁控制器，并且有一个经过验证的客户服务，我相信这是

785
01:08:19,359 --> 01:08:21,500
从我的头顶上。

786
01:08:21,500 --> 01:08:26,819
这两个就像父母所建造的父母。

787
01:08:26,819 --> 01:08:32,140
但是，如果您需要添加诸如密钥管理器API之类的内容，则可以在其中运行

788
01:08:32,140 --> 01:08:36,699
合并过程，也可以在经过验证的客户服务中运行，您确实需要

789
01:08:36,699 --> 01:08:42,239
了解您的国旗将在哪里活跃。

790
01:08:42,239 --> 01:08:45,760
我们使用pico-cli进行类似命令的标志参数

791
01:08:45,760 --> 01:08:46,599
处理内容。

792
01:08:49,300 --> 01:08:49,960
正确的。

793
01:08:49,960 --> 01:08:50,460
有趣的。

794
01:08:50,460 --> 01:08:53,859
因此，您有两个截然不同的标准节点

795
01:08:53,859 --> 01:08:55,979
和验证器。

796
01:08:55,979 --> 01:08:58,840
我们对验证器代码有一个疑问，

797
01:08:58,840 --> 01:09:00,699
但是我认为我们稍后可以进入

798
01:09:00,699 --> 01:09:04,880
您可以继续前进并完成演示文稿

799
01:09:04,880 --> 01:09:10,800
我们现在有一个多小时，所以呃，肯定会继续下去

800
01:09:12,480 --> 01:09:14,880
我还有其他几张幻灯片，但是

801
01:09:15,680 --> 01:09:22,400
他们真的是，以防万一我没时间，但这就是这样包裹的

802
01:09:22,400 --> 01:09:26,880
我们正在研究的一种事情

803
01:09:26,880 --> 01:09:34,079
我们的团队的运作方式，我们将分配一个所有者

804
01:09:34,079 --> 01:09:36,260
到个人EIP。

805
01:09:36,260 --> 01:09:40,619
因此，例如，有些人会有EIP7002，

806
01:09:40,619 --> 01:09:45,420
这是一个由Electra确认的EIP，而且很小。

807
01:09:45,420 --> 01:09:48,900
有些人，像我一样，都获得了超长

808
01:09:48,900 --> 01:09:50,420
大得多。

809
01:09:52,880 --> 01:09:55,060
拥有它的人显然会

810
01:09:55,060 --> 01:09:59,680
将该项目分成门票，或者我说的是

811
01:09:59,680 --> 01:10:04,060
在这里，但基本上是在Github上发出的。

812
01:10:04,060 --> 01:10:06,400
理想情况下，我们将向团队介绍

813
01:10:06,400 --> 01:10:11,880
使人们了解变化涉及的内容

814
01:10:11,880 --> 01:10:14,940
并对所有内容有一点概述。

815
01:10:14,940 --> 01:10:19,340
然后那个人将成为

816
01:10:19,340 --> 01:10:21,840
有点在钩子上确保

817
01:10:21,840 --> 01:10:23,300
这些东西是交付的。

818
01:10:23,300 --> 01:10:28,300
因此，只要确保测试网就是

819
01:10:29,060 --> 01:10:33,699
我们正在加入他们，我们没有任何问题，

820
01:10:33,699 --> 01:10:36,980
如果规格改变了，请跟上这些发展。

821
01:10:38,440 --> 01:10:41,980
并取决于功能本身，

822
01:10:41,980 --> 01:10:44,960
7.0.0.2很小

823
01:10:44,960 --> 01:10:47,260
它很容易由一个人实施，

824
01:10:47,260 --> 01:10:50,300
但是Max-eb看起来像

825
01:10:50,300 --> 01:10:52,239
这将是一个很大的功能。

826
01:10:53,300 --> 01:10:55,800
例如，斑点是一个非常大的功能，

827
01:10:55,800 --> 01:10:58,760
而且我们有一半的团队在斑点上。

828
01:10:58,760 --> 01:11:01,159
因此，您可能不会实现整个功能

829
01:11:01,159 --> 01:11:02,060
取决于这个大小。

830
01:11:04,760 --> 01:11:09,779
取款是另一个很好的例子，是卡佩拉。

831
01:11:09,779 --> 01:11:14,539
我拥有该功能，我负责确保

832
01:11:14,539 --> 01:11:16,360
一切正常。

833
01:11:16,360 --> 01:11:18,119
但是团队中还有另一个人

834
01:11:18,119 --> 01:11:21,480
这帮助我完成了一些事情，

835
01:11:21,479 --> 01:11:24,919
只是为了使我们可以准时进行测试网。

836
01:11:30,599 --> 01:11:32,599
从团队方面就这就是关于这一点。

837
01:11:32,599 --> 01:11:35,000
目前，我们目前没有产品所有者。

838
01:11:35,519 --> 01:11:38,239
我们主要只是在开发团队中进行管理。

839
01:11:41,599 --> 01:11:44,159
我们确实有，因为我们有欧洲的存在，

840
01:11:44,719 --> 01:11:47,319
他们倾向于去所有核心开发学校

841
01:11:47,319 --> 01:11:51,340
当时我倾向于在床上睡觉

842
01:11:51,340 --> 01:11:52,719
因为现在是凌晨2点。

843
01:11:57,719 --> 01:11:59,539
这就是我要看的

844
01:11:59,539 --> 01:12:04,880
从EIP的角度来看，

845
01:12:05,500 --> 01:12:08,519
我希望人们发现这有用。

846
01:12:09,979 --> 01:12:11,179
如果没有其他问题，

847
01:12:11,259 --> 01:12:14,599
我确实有一个可以经历的快速性能

848
01:12:14,599 --> 01:12:15,799
或者我们可以将其包裹在那里。

849
01:12:15,920 --> 01:12:16,920
无论哪种方式，我都很容易。

850
01:12:17,319 --> 01:12:24,079
保罗，非常感谢。

851
01:12:24,079 --> 01:12:27,319
看到它在团队中的工作方式也很有趣。

852
01:12:27,319 --> 01:12:28,659
这是一个有趣的见解。

853
01:12:28,659 --> 01:12:36,119
让我们看看是否对AAP过程有任何疑问。

854
01:12:36,119 --> 01:12:42,139
到目前为止，我们没有。

855
01:12:42,139 --> 01:12:43,139
但这很有趣。

856
01:12:43,140 --> 01:12:49,539
这么多，因为我们一直在使用它来说明如何更改实现

857
01:12:49,539 --> 01:12:54,020
在以太坊中，有一些EIP想法经历了一些

858
01:12:54,020 --> 01:12:58,820
研究过程已经实施，很高兴深入研究

859
01:12:59,700 --> 01:13:07,780
放大它实际发生的方式，所以它确实很有帮助，让我们看看是否是否

860
01:13:07,779 --> 01:13:13,779
嗯，我们有任何相关问题，否则我很高兴能继续为您提供更多

861
01:13:13,779 --> 01:13:20,420
空间，我们大概剩下20分钟，您一开始就可以了，所以我们可以使用

862
01:13:20,420 --> 01:13:27,219
那个时候有人打字了，所以我只想看看是否有一个相关的问题，是的

863
01:13:27,220 --> 01:13:40,900
问题好吧，嗯

864
01:13:40,900 --> 01:13:47,780
实施或与EPB有关的任何研究在技术上可能类似于EPB

865
01:13:49,300 --> 01:13:56,100
嗯，我正在尝试关注EPB上的对话，这很长，是的，如果有人有兴趣

866
01:13:56,100 --> 01:13:59,120
EPB有一个ETH R＆D频道。

867
01:14:03,700 --> 01:14:06,880
看到它目前如何抛弃会很有趣。

868
01:14:06,980 --> 01:14:09,200
我认为它看起来不会在伊莱克特拉（Electra）。

869
01:14:11,060 --> 01:14:14,160
但是要有很多考虑。

870
01:14:17,160 --> 01:14:19,280
是的，很有趣。谢谢。

871
01:14:19,280 --> 01:14:23,140
还有其他问题吗？

872
01:14:26,100 --> 01:14:37,440
好吧，我认为我们可以继续。

873
01:14:37,440 --> 01:14:52,060
如果您有更多内容，请随时继续。

874
01:14:52,060 --> 01:14:52,680
好的。

875
01:14:54,900 --> 01:14:58,039
我只提到一个快速的性能示例。

876
01:14:58,039 --> 01:15:01,900
我确定这是特定于语言的，

877
01:15:02,420 --> 01:15:05,120
很抱歉任何不看爪哇的人，

878
01:15:05,320 --> 01:15:10,020
但是Java具有同步功能，

879
01:15:10,800 --> 01:15:17,960
并同步函数基本上作为一个过程运行，

880
01:15:18,280 --> 01:15:20,200
因此，只有一个人可以一直运行。

881
01:15:22,060 --> 01:15:29,660
当我在霍尔斯基（Holsky）上查看表演时，我所做的一件事就是试图扩大规模

882
01:15:32,460 --> 01:15:36,300
机器在霍尔斯基（Holsky）上所做的事情，直到它开始破裂为止。

883
01:15:37,260 --> 01:15:44,780
当事情开始呈阴性时，它可能是性能的有用指标。所以我

884
01:15:44,779 --> 01:15:48,279
我从10,000个钥匙开始，这很好。

885
01:15:49,019 --> 01:15:52,179
我将其提高到15,000至20,000。

886
01:15:52,699 --> 01:15:55,519
20,000件事开始有点南方

887
01:15:56,119 --> 01:15:57,859
但是我对此不满意。

888
01:15:57,979 --> 01:16:01,719
我将其提高到一个节点以运行30,000个键，

889
01:16:02,599 --> 01:16:05,439
这不是理想的

890
01:16:06,079 --> 01:16:09,059
但这确实显示了一个有趣的模式

891
01:16:09,060 --> 01:16:15,020
当我们在当地进行削减保护时，

892
01:16:15,500 --> 01:16:18,000
我们需要运行这些功能

893
01:16:18,000 --> 01:16:22,160
维护削减保护数据

894
01:16:22,160 --> 01:16:23,680
为了确保我们不能被削减。

895
01:16:24,700 --> 01:16:26,580
这些功能实际上是同步的。

896
01:16:27,020 --> 01:16:30,000
因此，我们开始打瓶颈，

897
01:16:30,240 --> 01:16:32,980
在梅森街区不多，

898
01:16:33,320 --> 01:16:36,440
关于证明的更多

899
01:16:36,439 --> 01:16:40,659
因为您的验证器平均

900
01:16:41,719 --> 01:16:45,679
您可以查看验证者的第32个

901
01:16:45,679 --> 01:16:49,779
您正在运行的是在每个插槽中测试。

902
01:16:50,659 --> 01:16:52,819
因此，如果我正在运行30,000个验证者，

903
01:16:52,899 --> 01:16:54,699
那是很多验证者

904
01:16:54,699 --> 01:16:56,159
最终测试了每个插槽。

905
01:16:56,359 --> 01:17:00,879
他们每个人都必须为文件写一个更新，

906
01:17:01,259 --> 01:17:02,679
很好。

907
01:17:02,759 --> 01:17:04,139
这是很少的数据。

908
01:17:04,860 --> 01:17:12,700
但是，如果是一个函数，基本上是锁定的功能

909
01:17:12,700 --> 01:17:20,539
30,000个验证器我只能检查一个电梯，它变成了很大的资源约束

910
01:17:22,220 --> 01:17:26,140
因此，有一个很小的功能有点可怕

911
01:17:26,140 --> 01:17:29,440
基本上要删除该同步。

912
01:17:32,460 --> 01:17:37,640
如果您看一下，它基本上不是一个新解决方案。

913
01:17:37,900 --> 01:17:41,060
如果您查看数据库，关系数据库，则

914
01:17:41,400 --> 01:17:44,760
他们最初是从桌级锁定方案开始的

915
01:17:44,760 --> 01:17:47,740
他们最终确定

916
01:17:47,740 --> 01:17:49,420
该排级别的锁定要聪明很多。

917
01:17:50,579 --> 01:17:52,640
基本上，这类似于

918
01:17:52,640 --> 01:17:56,280
因为我要锁定一个验证器。

919
01:17:57,160 --> 01:17:59,700
因此可以一次访问多个验证器

920
01:17:59,700 --> 01:18:00,780
为了削减保护，

921
01:18:01,800 --> 01:18:04,980
但是只能更新一个验证器

922
01:18:04,980 --> 01:18:08,380
就像单个序列一样。

923
01:18:09,460 --> 01:18:11,380
因此，您最终需要大量锁定数据

924
01:18:11,380 --> 01:18:16,920
围绕该电源数据。

925
01:18:17,460 --> 01:18:22,240
所以我实际上有很多记录

926
01:18:22,239 --> 01:18:25,179
和当地的飞溅保护记录

927
01:18:25,179 --> 01:18:28,639
最终有自己的锁。

928
01:18:30,800 --> 01:18:32,639
但是最终结果

929
01:18:32,639 --> 01:18:36,979
大约增加了15％

930
01:18:36,979 --> 01:18:39,800
在我们对其他电台的有效性。

931
01:18:40,699 --> 01:18:43,179
所以很有趣

932
01:18:43,179 --> 01:18:46,880
有时一个小设计决定，

933
01:18:46,880 --> 01:18:49,939
在低水平上还可以，

934
01:18:49,939 --> 01:18:52,739
当事情扩大时，这是不好的。

935
01:18:53,599 --> 01:19:00,679
所以我认为这可能只是一个相当简单的表演

936
01:19:00,679 --> 01:19:03,479
有时我们会看。

937
01:19:03,619 --> 01:19:06,960
我在幻灯片上没有的另一个例子是

938
01:19:06,960 --> 01:19:11,960
UN64是TECU中的一个成熟对象。

939
01:19:12,500 --> 01:19:15,179
因此，当我查看减少内存大小时，

940
01:19:15,899 --> 01:19:17,919
我尝试了数周和几周的事情，

941
01:19:17,920 --> 01:19:27,079
然后我看了我们的内存分析仪，

942
01:19:27,340 --> 01:19:30,340
事实证明，我们有数百万个物体

943
01:19:30,340 --> 01:19:35,840
都说32e，那就是这个Uint64。

944
01:19:36,220 --> 01:19:39,000
所以我可以节省数百兆

945
01:19:39,000 --> 01:19:43,739
仅通过使单个静态变量具有32e值，in

946
01:19:45,000 --> 01:19:47,739
当我今天考虑时，这仍然让我震惊。

947
01:19:47,920 --> 01:19:55,020
因此，当您的背景中会发生一些有趣的表演事物

948
01:19:55,020 --> 01:19:56,020
做发展。

949
01:19:56,020 --> 01:20:11,140
我唯一的另一个幻灯片，可能是一个及时的问题，我如何成为科尔迪夫？

950
01:20:11,140 --> 01:20:17,039
始终为我回答这个问题的第一件事是参与其中。

951
01:20:17,039 --> 01:20:22,880
假设您不在一个可以提供帮助的地方，因为很多人可以

952
01:20:22,880 --> 01:20:32,159
帮助他们比他们意识到的更多，所以我的建议是选择一个好榜样的人

953
01:20:32,159 --> 01:20:40,479
Potus基本上是因为他实施了一项他想要的功能

954
01:20:40,479 --> 01:20:48,319
否则想实施它，所以他自学了如何做，现在就在一个亲切的团队中

955
01:20:49,919 --> 01:20:57,839
但是选择一个项目尝试使用它，并熟悉自己熟悉，如果您选择了

956
01:20:57,839 --> 01:21:04,879
显然，我们已经达成了共识的不和谐，因为我们甚至创建了两个渠道

957
01:21:04,880 --> 01:21:07,900
技术人员贡献者频道。

958
01:21:07,900 --> 01:21:12,000
如果您

959
01:21:12,000 --> 01:21:14,119
想要参与，这是一个频道

960
01:21:14,119 --> 01:21:17,760
如果您需要帮助找到东西，您可能会谈论

961
01:21:17,760 --> 01:21:20,920
或者，如果您需要帮助了解代码。

962
01:21:20,920 --> 01:21:25,460
我们确实有开发人员在那里看。

963
01:21:25,460 --> 01:21:28,920
甚至ETH研发也是一个非常好的地方。

964
01:21:28,920 --> 01:21:30,840
之前提到过EPB，那里

965
01:21:30,840 --> 01:21:33,440
是专门针对EPB的渠道。

966
01:21:33,439 --> 01:21:40,719
因此，如果您对此感兴趣，我将加入该频道，并试图让您围绕事情的运作方式。

967
01:21:43,699 --> 01:21:47,179
而且，许多团队都有招聘页面。

968
01:21:47,859 --> 01:21:51,379
共识雇用页面始终在那里。

969
01:21:52,039 --> 01:21:56,000
而且我认为我们目前正在招聘Cordevs。

970
01:21:56,000 --> 01:22:03,399
这只是我的，因为有时候我是我最大的敌人

971
01:22:03,399 --> 01:22:06,979
不要让自己怀疑任何使您退缩的事情

972
01:22:06,979 --> 01:22:11,000
那就是我所拥有的一切

973
01:22:11,000 --> 01:22:15,100
非常感谢保罗

974
01:22:15,100 --> 01:22:19,020
是的，对于那些仍在听的人

975
01:22:19,020 --> 01:22:21,960
是的，加入像这个研究小组这样的程序

976
01:22:21,960 --> 01:22:25,000
以及协议奖学金也是一个很好的方法

977
01:22:25,000 --> 01:22:31,439
通过进入核心发展的旅程，获得更多的结构和指导，

978
01:22:31,579 --> 01:22:37,960
如果那是您想走的道路。这是一个很好的观点。协议奖学金是

979
01:22:37,960 --> 01:22:44,640
真的，真的很好。我们也与那里的人一起度过了很多良好的经验。所以

980
01:22:44,640 --> 01:22:50,899
绝对值得一提。是的，实际上，我想问一下。

981
01:22:50,899 --> 01:22:55,059
也许，如果您可以给人们一些有关他们的首次捐款的提示。

982
01:22:55,420 --> 01:23:00,319
您以前与EPF的家伙有良好的经验，

983
01:23:00,319 --> 01:23:04,420
所以也许您喜欢他们的互动的某些事情

984
01:23:04,420 --> 01:23:07,379
或它对人的工作原理。

985
01:23:08,920 --> 01:23:13,719
我认为我实际上并不需要做很多事情来指定该项目

986
01:23:13,719 --> 01:23:19,719
从那以前是这样做的，因为它已经是预定义的，

987
01:23:19,720 --> 01:23:22,880
我认为，做了改变的绅士，但是

988
01:23:24,760 --> 01:23:27,720
他们对

989
01:23:27,720 --> 01:23:31,260
诉状基本上是想为Teku实施诉讼。

990
01:23:32,920 --> 01:23:36,480
我建议这样做正确而不是这样做

991
01:23:36,480 --> 01:23:40,960
作为浅水潜水，整个过程将是一个更好的选择。

992
01:23:41,560 --> 01:23:44,680
所以我们最终发展了

993
01:23:45,680 --> 01:23:49,020
实际上，他可能是最近进入存储层的人之一

994
01:23:49,020 --> 01:23:50,700
因为他必须改变这一点

995
01:23:50,700 --> 01:23:54,860
并能够为客户生成一些终点。

996
01:23:55,340 --> 01:23:58,740
但是，由于我们已经对其进行了充分的测试和产品准备就绪，所以

997
01:23:59,420 --> 01:24:00,960
我们没有一路跨过它。

998
01:24:01,180 --> 01:24:02,640
所以有一天我们会重新审视它，

999
01:24:03,240 --> 01:24:06,620
我认为这对每个人都是一个很好的结果。

1000
01:24:09,160 --> 01:24:11,160
我认为他从中得到了很多。

1001
01:24:12,560 --> 01:24:13,540
是的，很棒。

1002
01:24:14,400 --> 01:24:18,140
也许您提到了一个很好的第一个问题。

1003
01:24:18,140 --> 01:24:23,880
也许人们可以为其他人做出贡献或类似活跃的事情

1004
01:24:23,880 --> 01:24:33,100
您知道的研究开发领域，Tecubesu或其他港口可能需要帮助？

1005
01:24:33,100 --> 01:24:43,640
就ERP而言，他们显然在经历时被记录下来

1006
01:24:43,640 --> 01:24:45,920
这些东西是免费的。

1007
01:24:45,920 --> 01:24:49,520
因此，如果人们认为他们可以为ERP做出贡献，

1008
01:24:49,700 --> 01:24:50,880
他们绝对应该参与其中，

1009
01:24:51,400 --> 01:24:54,760
与那些拥护它的人接触

1010
01:24:54,760 --> 01:24:57,220
并尝试成为过程的一部分。

1011
01:25:00,460 --> 01:25:04,740
很多信息一直在流动，

1012
01:25:04,820 --> 01:25:09,860
因此，最大的挑战是找到您需要生命的信息。

1013
01:25:10,720 --> 01:25:12,900
ETH R＆D是为此的绝佳资源。

1014
01:25:13,640 --> 01:25:19,660
有一个共识DEV频道，并且有一个全核Devs频道。

1015
01:25:21,160 --> 01:25:25,260
相当接受被考虑的问题。

1016
01:25:25,460 --> 01:25:32,900
我不会垃圾邮件，但我绝对不会害怕问一个问题。

1017
01:25:36,860 --> 01:25:38,800
他们总体上是一个相当开放的一堆。

1018
01:25:38,800 --> 01:25:48,020
嗯，这显然与尴尬的腹肌保持相符

1019
01:25:48,020 --> 01:25:56,060
呃，就像您可以在YouTube上看到他们的电话一样，一个人的贡献是

1020
01:25:56,060 --> 01:26:02,980
在很大程度上总结了这些电话，所以我知道Um Ben Edgington有一段时间加入了他们

1021
01:26:02,979 --> 01:26:08,500
就像这些电话的子弹点摘要一样，

1022
01:26:08,559 --> 01:26:11,839
我以前非常感谢，因为我可以读

1023
01:26:11,839 --> 01:26:14,799
而不是看一个半小时，因为我从未见过。

1024
01:26:16,719 --> 01:26:18,719
因此，人们以不同的方式做出贡献。

1025
01:26:19,839 --> 01:26:23,339
显然，它的另一面是人们的贡献

1026
01:26:23,339 --> 01:26:29,199
更多地是关于空光耕种的，这不是很好，但是是的。

1027
01:26:29,899 --> 01:26:30,979
是的，这很有趣。

1028
01:26:30,979 --> 01:26:38,259
世界还好，您是否得到了一些垃圾邮件UH PR或类似的东西，因为

1029
01:26:38,259 --> 01:26:44,099
它是信标API是怪异的信标API频道似乎比我要获得的垃圾邮件要多得多。

1030
01:26:44,099 --> 01:26:54,819
期待，嗯，我是那个主要的管理员之一，所以我看到它可能比有时更重要

1031
01:26:54,819 --> 01:26:59,699
但是，就像人们评论或关闭PR和其他东西之类的东西，我不知道会有什么

1032
01:27:00,979 --> 01:27:05,779
它必须给您一些东西，因为人们会做很多事情，是的，这很耗时

1033
01:27:05,779 --> 01:27:12,739
那些已经有很少时间的开发团队，所以我不建议这样做很好，是的

1034
01:27:12,739 --> 01:27:19,299
我在您所说的某些内容中注意到了它，例如旧PRS问题，只是随机评论，然后喜欢

1035
01:27:19,299 --> 01:27:24,339
在GitHub上也有点烦人来阻止它们，因为您需要提交整个报告，并且

1036
01:27:24,339 --> 01:27:29,539
是的，是的，是的，是的，是的，谢谢，保罗嗯

1037
01:27:30,979 --> 01:27:38,139
我们有一些更困难的问题，我对Java并不那么熟悉，但我认为

1038
01:27:38,139 --> 01:27:44,239
这就像使用虚拟线程在Java 21中的新功能，也许是谁使用它们

1039
01:27:44,239 --> 01:27:47,399
还是您是否利用最新功能。

1040
01:27:47,399 --> 01:27:55,799
目前，我们进入Java 17，因此我们没有使用Java中的任何新功能

1041
01:27:55,799 --> 01:27:56,799
21。

1042
01:27:56,800 --> 01:28:04,079
我真的真的想使用记录，我相信这是Java 17，但问题是

1043
01:28:04,079 --> 01:28:13,220
我们如何做事与记录如何完成的现实对使用并不是很干扰

1044
01:28:13,220 --> 01:28:14,220
他们要么。

1045
01:28:14,220 --> 01:28:23,420
因此，有时我们会使用新功能，但这仅取决于我们使用事物的方式。

1046
01:28:23,420 --> 01:28:29,119
就像Java 17中的新开关语法一样，我们已经开始使用它，但是其他

1047
01:28:29,119 --> 01:28:31,980
像唱片之类的功能，我们并没有真正触摸。

1048
01:28:31,980 --> 01:28:41,079
希望很快我们将开始搬到Java 21，但我们还需要对

1049
01:28:41,079 --> 01:28:43,300
使人们只是为了搬家。

1050
01:28:43,300 --> 01:28:49,380
因此，添加Docker图像通常首先更改，因为这很容易提升。

1051
01:28:49,380 --> 01:28:56,659
是的，它可能会破坏许多人的环境，这是一大步。

1052
01:28:56,659 --> 01:29:00,720
是的，它被列为打破变化。

1053
01:29:00,720 --> 01:29:10,500
是的，人们其他任何问题都可以问，我们还有一些

1054
01:29:10,500 --> 01:29:11,500
最后一个问题左右。

1055
01:29:11,500 --> 01:29:15,659
我不确定，乔什，你在这里有什么吗？

1056
01:29:15,659 --> 01:29:20,060
我认为我们已经没有问题池了。

1057
01:29:20,060 --> 01:29:23,000
是的，我不这么认为。

1058
01:29:23,000 --> 01:29:29,000
保罗，只要感谢您，带我们浏览了Teku并给我们一个很好的概述

1059
01:29:29,000 --> 01:29:33,739
该代码库及其工作原理。

1060
01:29:33,739 --> 01:29:35,039
您非常欢迎。

1061
01:29:35,039 --> 01:29:37,460
是的，非常感谢。

1062
01:29:37,460 --> 01:29:39,020
是的，我很感激。

1063
01:29:39,020 --> 01:29:40,520
看到真是太好了

1064
01:29:40,520 --> 01:29:42,680
特别是这样

1065
01:29:42,680 --> 01:29:44,680
我会说有点热有趣

1066
01:29:44,680 --> 01:29:46,120
EIP为Maxeb

1067
01:29:46,120 --> 01:29:48,780
非常讨论

1068
01:29:48,780 --> 01:29:50,360
人们有意见

1069
01:29:50,360 --> 01:29:52,580
想包括它，所以真的很棒

1070
01:29:52,580 --> 01:29:53,560
实际看到它在行动中

1071
01:29:53,560 --> 01:29:56,420
是的，非常感谢保罗，再次

1072
01:29:56,420 --> 01:29:57,480
非常感谢

1073
01:29:57,480 --> 01:30:00,740
为我们接我们

1074
01:30:00,740 --> 01:30:01,000
和

1075
01:30:01,000 --> 01:30:03,960
希望大家今天休息

1076
01:30:03,960 --> 01:30:04,740
祝你有美好的一天

1077
01:30:04,740 --> 01:30:08,280
不用担心非常感谢您的时间

1078
01:30:08,279 --> 01:30:13,559
是的，非常感谢Paul，我们将与您见面。

1079
01:30:13,559 --> 01:30:15,559
保罗·克鲁格曼（Paul Krugman），好吧，谢谢保罗。

1080
01:30:15,559 --> 01:30:16,559
保罗·克鲁格曼（Paul Krugman），好吧，大家都有美好的一天。

1081
01:30:16,559 --> 01:30:22,099
保罗·克鲁格曼（Paul Krugman），在研究小组的其他成员中，我们将在一对夫妇中见到大家

1082
01:30:22,099 --> 01:30:30,039
星期三的几天与Barnum，Bay和Manon聊天，并在MEB和审查制度上聊天。

1083
01:30:30,039 --> 01:30:31,819
保罗·克鲁格曼（Paul Krugman），很棒。

1084
01:30:31,819 --> 01:30:34,239
保罗·克鲁格曼（Paul Krugman），好吧，谢谢。

1085
01:30:34,239 --> 01:30:36,759
保罗·克鲁格曼（Paul Krugman），非常感谢您关注所有人。

1086
01:30:36,760 --> 01:30:37,820
谢谢，保罗。再见。

1087
01:31:06,760 --> 01:31:36,739
谢谢。

1088
01:31:36,760 --> 01:31:41,760
。

